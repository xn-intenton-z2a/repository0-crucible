Hydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.\nThis entire document is a work in progress and several
    sections are incomplete, missing, or outdated. All open issues and decisions
    are documented in our
    issue tracker.
    If you have questions, please don't hesitate to
    join the Hydra W3C Community Group and post to the mailing list.\njoin the Hydra W3C Community Group and post to the mailing list.\nThis specification was published by the
    Hydra W3C Community Group. It is
    not a W3C Standard nor is it on the W3C Standards Track. Please note that under the
    W3C Community Contributor License Agreement (CLA)
    there is a limited opt-out and other conditions apply. Learn more about
    W3C Community and Business Groups.\nHydra W3C Community Group\nW3C Community Contributor License Agreement (CLA)\nW3C Community and Business Groups\nTo participate in the development of this specification, please join the
    Hydra W3C Community Group. If
    you have questions, want to suggest a feature, or raise an issue, please send a mail to the
    public-hydra@w3.org mailing list.\nHydra W3C Community Group\npublic-hydra@w3.org mailing list\nCoping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.\nThe combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.\nThis specification describes the conformance criteria for
    Hydra API documentations
    and Hydra clients. These criteria are
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.\nConformance for Hydra clients should probably not be
    specified in this document.\nAdd normative statements\nThe key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].\nThe basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.\nThe namespace of the Hydra core vocabulary is
    http://www.w3.org/ns/hydra/core#, and the suggested prefix
    is hydra. The figure below illustrates the vocabulary (the
    figure’s goal is to show how Hydra is used rather than its precise
    definition).\nIs this illustration clear enough or is it confusing?
    Feedback would be much appreciated.\nThe Hydra core vocabulary\nThe Hydra core vocabulary\nAdd ranges for Operation "members"\nAn alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.\nThe used prefixes should be documented somewhere.\nThroughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.\nAdding Affordances to Representations\nThe exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.\nThe simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type—a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.\nIn Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.\nGenerally, a client decides whether to follow a link or not based on
      the link relation (or property in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every link
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <a> tag) are
      followed but most references in link elements (the
      <link> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      if a property represents a link intended to be
      dereferenced or solely an identifier. Hydra's
      Link class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can be used to define a property
      linking issues to their comments:\nIn the example above, a property identified with the URL
      http://api.example.com/vocab#comments is defined to be
      of the type Link. This is enough information for a client
      understanding Hydra to know that the value of the
      comments property in the following example is intended
      to be dereferenced.\nIt is recommended to dereference resources that are
      within an API's domain. This may prevent possible issues with cross-site
      scripting or obtaining resources which might have no meaning
      to the client or such that the client would be unable to interpret.
      Still, there is no formal prohibition of dereferencing resources
      linked with well-known properties, e.g. rdf:seeAlso.\nIn the example above, the value of the comments
      property is a JSON object with an @id member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:\nWhile links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      Operation represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      Operation is its HTTP method. Optionally, it is
      also possible to describe what information the server expects
      or returns, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.\nThe following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them.\nThe example above references Hydra's context to map properties such
      as operation and method and values like
      Operation to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.\nIt is worth mentioning that due to the fact that Hydra is built on
      RDF, which is a graph, it may happen that a related resource
      (an object of the relation) may not be fully described in the
      resource's payload. In several circumstances (i.e. payload terms
      defined in API documentation sa described in
      Documenting a Web API
      or IriTemplate expected as a related resource as described in
      Templated Links) client may
      discover no additional statements describing it. These rules should
      be considered by the client in following scenarios:\nDocumenting a Web API\nin case of an object expected to be a hypermedia resource does not have all
        the necessary statements for which it is a subject, the client SHOULD look in the
        API documentation for more details\nin case the mentioned object, after consulting an API documentation, still
        does not have all the necessary statements for which it is a subject and both
        mentioned object's Url and Url of the initially obtained resource has the
        same scheme and authority (by means of [[!RFC3986]] sections 3.1 and 3.2), the client
        SHOULD de-reference that Url. If the resource does not have the same scheme and
        authority the client MAY choose to de-reference it (for example if the resource
        originates from another API well-known to the client)\nin case the mentioned object still does not have all the necessary
        statements for which it is a subject (i.e. de-referencing it failed
        or statements are missing), the client SHOULD either ignore the whole
        statement (i.e. for display purposes) or throw an exception (i.e. an
        IriTemplate is about to be resolved and de-referenced)\nExample of each of the situations are as follows:\nresource http://api.example.com/people should have an IriTemplate available
        as there is a complete definition of the template available at http://api.example.com/doc/.\nresource http://api.example.com/events should not have an Iri template exposed as there
        are no additional details available, neither in the initial resources' payload nor in the API documentation.\nKeep in mind that any resource described by any hypermedia control
      may fail at runtime due to various reasons. Operation details
      such as returns or possibleStatus may also vary at runtime,
      which means client SHOULD always verify received payloads at runtime.\nDocumenting a Web API\nIn Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.\nHydra's ApiDocumentation class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.\nIn Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.\nThese differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.\nMention that Hydra classes are dereferenceable
      resources.\nSince Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      supportedProperty references an intermediate data structure,
      namely instances of the SupportedProperty class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.\nAll instances of a specific class typically support the same
      operations. Hydra therefore features a supportedOperation
      property which defines the operations supported by all instances of
      a class.\nThe same feature can be used to describe the operations supported
      by values of a Link property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.\nExample shown below describes the operation's expected and returned
      value as a dereferencable resource (an RDF resource of a given class),
      but the vocabulary is not limited to only those originating
      from RDF and is enabled to other types of resources.
      Please note that in case of multiple either returned or expected types
      provided, client SHOULD assume the set includes any of the types,
      but not limited to those types and client SHOULD interpret received
      payload at runtime for possible discrepancies.\nIn addition to expected/returned resources, it is also possible to
      express similar features for headers with returnsHeader and
      expectsHeader predicates which provides a simple set of header
      names. Client SHOULD apply respective header semantics when creating
      or receiving a request natural for the protocol in use.\nThe example above enable an HTTP client to prepare a proper cross-site
      pre-flight request so the server exposes enlisted headers for the client.
      The client is also aware of the user authentication requirement necessary
      for the operation invocation.\nFor more complex scenarios it is also possible to expand selected header
      specification with both name and possible values, i.e. when defining
      expected Content-Type values of resources that can be uploaded.
      In case multiple possible values are provided, client SHOULD assume
      that the set includes any of the values, but not limited to those values.
      In order to change that default behavior it is possible to use closedSet
      predicate on the header specification indicating that the set of provided
      values is, well, closed and no other values are available. In both case the client
      SHOULD interpret received payload at runtime for possible discrepancies.\nTo wrap up everything altogether, it is also possible to attach atomic
      operations supported by, well, supported property itself. This might
      come in handy for scenarios, when resource can be partially modified.
      It can be achieved with two approaches, both having advantages and
      disadvantages.\nFirst approach would involve adding a supportedOperation to the
      intermediate structure of SupportedProperty.
      This way prevents from leaking API specific features from the API itself
      to i.e. externally defined properties. Data aggregators won't assume that
      each instance with a given property could have such an operation.\nAnother approach would require the API to elevate a specific property
      to Link, which can accept a supportedOperation. This
      is more intuitive in APIs operating with internally used vocabularies
      where assumption that every instance with that very specific property
      has the operation attached available.\nDirect usage of supportedOperation on rdf:Property
      without elevating it to the Link SHOULD NOT be implemented as clients
      may not discover such a construct correctly.\nThese are the simple example scenarios and possible usages are not
      limited to those described above.\nDue to the fact an ApiDocumentation as all other resources may fail
      at runtime, it is important to take countermeasures.
      A simple strategy to try to recover from such a situation would be to reload
      the ApiDocumentation and redo all pre-computations that were
      based on the ApiDocumentation (or at least those that lead
      to the current failure). Another, simpler approach would require
      an application to show an error message with option to return
      to a previous or home screen.\nDescribe the various properties of an operation.\nHydra also allows enriching both ApiDocumentation and
      hypermedia controls with human-readable descriptions by applying
      title and description (as shown in the examples above).
      The former states a name of such a decorated element that could
      be displayed as a label. The latter provides its description
      to be presented i.e. as a hint.\nAforementioned title and description SHOULD take precedence
      over standard rdfs:label and rdfs:comment.\nThere is one more feature related to how Linked Data works. Consider the
      example below written in turtle syntax:\nand how it could be transformed with JSON-LD framing process:\nAs you can see, additional details about ex:SomeType went
      missing, while this shouldn't happen. The fact that the IRI mentioned
      is an rdfs:Class may be meaningful for a correct interpretation
      of the received payload and this is a sole reason of why a Client
      SHOULD NOT disregard other parts of the payload that are not directly
      related to the API documentation or other hypermedia controls.\nDiscovering a Hydra-powered Web API\nThe first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look for a Link Header with a relation type
      http://www.w3.org/ns/hydra/core#apiDocumentation (this is
      the IRI identifying the hydra:apiDocumentation property).\nIn the following example, a Hydra client simply accesses the
      homepage of an API publisher (http://www.example.com)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.\nThe response in the example above contains an HTTP Link Header
      pointing to http://api.example.com/doc/.
      Retrieving that resource, the client would obtain a
      Hydra API documentation defining the API's main entry
      point:\nHydra API documentation\nPlease note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.\nIn another scenario the ApiDocumentation would be discovered from
      a bookmarked resource's representation. Api implementation SHOULD emit
      the HTTP Link header on every Api response, making
      the ApiDocumentation (and entry points it defines) discoverable
      all the time.\nIt is common to provide a separate API address after a breaking changes
      update. This prevents current clients not to get broken as these may not
      support these changes.\nWith hypermedia provided in each response payload, it may be unnecessary
      to provide such an alternative API. This is due to fact the client follows
      what the server provides and with proper margin for errors implemented
      within that client, even breaking changes can be published on the fly.\nStill, Hydra does neither have any special support for API versions, nor
      prevents them. It's fully an implementers decision on if and how
      to provide the API features.\nDescribe Hydra's Resource class? Or should that better be
    described somewhere in the beginning?\nIn many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes hydra:Collection and
      hydra:PartialCollectionView.\nA hydra:Collection can be used to reference a set of resources
      as follows:\nAs shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.\nSince collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a hydra:PartialCollectionView. It describes a specific
      view on the collection which represents only a subset of the collection's
      members. A PartialCollectionView may contain links to the
      first, next, previous, and last
      PartialCollectionView which allows a client to find all members
      of a Collection.\nSay that all these properties are optional? What about
      first and, perhaps more interestingly, last?\nA memberAssertion is a way to declare additional, implicit statements about
      members of a collection. Statements which may otherwise
      be missing from the respective member resources inlined in a collection's
      representation.\nIn the above example, adding a memberAssertion node to the collection instructs the
      client that every member of this collection is linked to the subject
      by the property. It could be written as a SPARQL triple pattern below, where
      ?m would be substituted by each member of the collection.\nA memberAssertion MUST use two and only two of the subject, property
      and object predicates. There memberAssertion predicate MAY have more than one
      such blocks, each expressing different relations between the collection members and other resources.\nIt's important to point out that the subject, property
      and object predicates are defined within the Hydra namespace and are not
      rdf terms.\nSometimes, it is impossible for a server to construct a URL because
      the URL depends on information only known by the client. A typical
      use case are URLs which enable a client to query the server. In such
      a case, the server cannot construct the URL because it does not know
      the query the client is interested in. What the server can do however,
      is to give the client a template to construct such a URL at runtime.
      In Hydra, the IriTemplate class is used to do so.\nAn IriTemplate consists of a template literal and a set
      of mappings. Each IriTemplateMapping maps a
      variable used in the template to a property and may
      optionally specify whether that variable is required or not.
      The syntax of the template literal is specified by its datatype and
      defaults to the [[!RFC6570]] URI Template syntax, which can be
      explicitly indicated by hydra:Rfc6570Template.\nThe example above maps the variable q to Hydra's
      freetextQuery property and marks it as required.
      As its name suggests, the freetextQuery property can be used
      for free text queries.\nA template syntax only details how to fill out simple string values,
      but not how to derive such string values from typed values,
      language-tagged strings, or IRIs. Hydra addresses this by
      specifying how such values are to be serialized as strings. The
      serialization of an IriTemplate's variables can be described
      by setting the variableRepresentation property to
      BasicRepresentation or ExplicitRepresentation. The
      BasicRepresentation represents values by their lexical form. It
      omits type and language information and does not differentiate between
      IRIs and literals. The ExplicitRepresentation, on the other
      hand, includes type and language information and differentiates
      between IRIs and literals by serializing values as follows:\nIRIs are represented as-is.\nLiterals, i.e., (typed) values and language-tagged strings are
        represented by their lexical form, surrounded by a single pair of
        doubles quotes (").\nIf a literal has a language, a single @ symbol is
        appended after the double-quoted lexical form, followed by a
        non-empty [[BCP47]] language code.\nIf a literal has a type, two caret symbols
        (^^) are appended after the double-quoted literal,
        followed by the full datatype IRI.\nIn both representations characters MUST NOT be escaped. In case the
      representation format is not explicitly described, clients SHOULD
      use the BasicRepresentation by default.\nAlthough ExplicitRepresentation use of
      @ and ^^ is similar, it is not the
      same as the [[Turtle]] representation for literals. Turtle literals
      require escaping of special characters, surround datatype IRIs with
      angular brackets (< and >), and also
      allow single quotes (') to indicate literals.
      ExplicitRepresentation values must not be escaped, IRIs must
      not be surrounded by any character, and only double quotes can
      indicate literals.\nBelow are some example values serialized in the different
      representations as well as the result of expanding the IRI template
      http://example.com/find/{value} with the respective
      value.\nSimilar to how Hydra's Link class allows the definition of
      properties that represent hyperlinks as described in
      ,
      the TemplatedLink class allows the definition of properties
      whose value are IRI templates. Hydra predefines one such property,
      namely the search property which can be used to document
      available search interfaces.\nIRI expansion should be performed with respect to the specification
      behind the IRI template type (RFC 6570 by default), and the product
      of this process SHOULD be an IRI. When the produced IRI is relative,
      the client SHOULD stick to RFC 3986 sections 5.1.3 and 5.1.4 to be compatible
      with most RDF serializations that support relative IRIs. Still, it may be
      preferred to use another base URI for the expansion process, which
      makes the resolveRelativeTo term useful. It allows to switch the
      IRI template expansion algorithm so the base URI is established using
      current link context, which is a subject of the relation pointing to an
      IriTemplate instance. In case that subject is a relative URI,
      default behavior SHOULD be used as fallback.\nThe example below allows to make the product of an IRI template
      expansion relative to the http://api.example.com/an-issue/ resource
      by using it as its base URI, which further enables the some:operation to
      be moved to i.e. API documentation level rather to inline it.\nWhen constructed, the IRI would effectively become similar to http://api.example.com/an-issue/1234,
      with the relative part {id} appended to the link context URL.\nIRI template operations\nThere are circumstances in which client would like to perform an operation
      not knowing the final IRI of the resource to be called. This case is especially
      in force when working with collections - client may want to add a new
      collection member, or it may need to provide more details while searching
      with other protocol's method (i.e. POST instead of GET in case of an HTTP).\nThis is achievable by attaching a supportedOperation to the property
      that connects a subject of that relation with its IRI template
      as described in the previous part of this document. Please note that
      client is still allowed to use the defined link and custom operation's
      method is optional.\nThe example above allows client to either invoke an HTTP GET or POST
      call on http://api.example.com/issues?search=search_string resource.\nThe example above allows client to invoke only an HTTP POST
      call on http://api.example.com/issues?find=search_string resource as
      the described relation of find is not a Link.\nSupported property data source\nThere are circumstances in which an API would like to inform a client on
      when to obtain values to feed data structures with details. Having all the
      necessary components like supported property, collection and IRI templates,
      it is possible to drive the client and direct it with links and operations
      to the data sources.\nIt is doable by attaching either a collection or search
      predicate to instance of supportedProperty or to property.
      In such case client SHOULD use assume that the relation leads to
      the collection of values compatible with the supported property's range
      and can be used to feed data structures with the supported property.
      It is recommended (but not mandatory) to use freetextQuery
      variable mapping in case of the search predicate as it has a
      well defined semantics and takes the burden of interpretation from
      the client.\nWhile it is possible to provide such links in both API documentation
      and within the received payload, client SHOULD use the latter link first
      if applicable. This is due to fact the the server may want to put additional
      context to narrow the collection of viable values. Redefinition does not
      make the more general one obsolete though and and can be used as a fallback.\nThe example above instructs a client that every resource of type
      schema:Event can have a relation of schema:actor, the objects of which the
      client can obtain using the search link provided.\nDescription of HTTP Status Codes and Errors\nHTTP status codes have well defined semantics and can be used to
      signal the outcome of an operation. Unfortunately, however, HTTP
      status codes by themselves are often not specific enough, making it
      difficult to understand the real cause of an error. For
      instance, a 429 Too Many Requests response is rarely
      informative enough by itself. To address this issue, Hydra defines
      a Status class which allows additional
      information to be associated with an HTTP status code.\nAn ApiDocumentation or an Operation may document the
      status codes that might be returned by the server using the
      possibleStatus property as described in
      . This allows
      a developer to understand what to expect when invoking an operation.
      It has, however, not to be considered as an extensive list of all
      potentially returned status codes; it is merely a hint. Developers
      should expect to encounter other HTTP status codes as well.\nA server may also return a Status directly in
      a response. When doing so, it often makes sense to subclass the
      Status to make its semantics more explicit.
      Hydra defines just one such subclass, namely the Error class.
      This provides an extensible framework to communicate error details to
      a client.\nFurthermore, a Status or Error returned by the server can also
      be given an identifier. When dereferenced, the Error resource can provide
      more detailed information or possible ways to resolve the problem, if applicable.\nFinally, the server SHOULD provide error descriptions using an [[!RFC7807]] standard
      by using an application/problem+json response. When doing so, the server also MUST provide
      an additional header pointing to either the built-in Hydra http://www.w3.org/ns/hydra/error
      context or any JSON-LD context that maps the terms type, title, detail,
      status and instance the same way as the standard one.\nWhile the built-in context makes the response fully compatible with the mentioned specification,
      properties not defined in the standard Hydra's error context won't be visible for Hydra aware processors.
      To overcome this, it is possible to declare a custom context pointed the same way, that would combine standard
      Hydra's standard error context and an additional JSON-LD context with either the @vocab
      or custom property mappings telling the processor on how to interpret those custom error properties.\nResources provided may have an additional hint pointing to an Error type like in the example
      above, but it is not mandatory to do so as all resources described with application/problem+json
      are considered hydra:Error.\nIt is worth to mention that it may happen (i.e. due to proxy behavior) the value of the status property
      will differ to the one received from the protocol layer.\nClient initiated pagination\nThere are situations when a client would like to provide a specific
      collection limitations, i.e. by providing query-language like member
      offset and limit or some specific page index and number of members
      per page. This is doable with offset/limit or
      pageIndex/limit predicates.\nWith those, it is possible to bind a template variables mapped
      with externally obtained values (i.e. user interaction) the same way
      as with other mappings.\nWhile the predicates enlisted above accepts non-negative integer
      numbers, there is also a possibility of providing a custom page
      reference expressed via pageReference predicate. It is possible
      to provide a custom page identifier (i.e. a GUID or a letter)
      instead of a number.\nWhile Hydra Core Vocabulary allows addressing many usage scenarios,
      not every aspect of API behavior can be covered. This
      applies especially to querying, resource projection or data structure
      description. This is due to fact that Hydra is meant to be as light
      as possible forcing to drop some of the features out of its scope.\nThat is why there is a possibility of hinting a client on what kind
      of extensions may be found or used in the received payloads.
      After discovering an extension predicate in the API documentation,
      client can assume additional details are available described with
      complementary vocabularies.\nIt is up to the used vocabulary to define how these additional details should be
      interpreted. In case client does not recognize these extensions,
      additional details should be ignored and base Hydra interpretation
      should be in force.\nServer SHOULD NOT use extensions to add statements that are in
      contradiction to base Hydra interpretation so the client is not confused.
      Server SHOULD also keep multiple extensions describing adequate
      knowledge in line regarding their description (i.e. data structure
      descriptions in various vocabularies should not cause differences).\nClient can express its preferences through the Prefer HTTP header
      by pointing the preferred extensions via IRIs as on the example below.
      The client SHOULD use the Prefer HTTP header [[!RFC7240]] with
      the hydra.extension preference as an iri attribute having
      the IRI of the extension as value to hint the server about the extension
      it supports. Multiple preferences can be expressed by providing multiple
      Prefer header values.\nServer MUST implement Prefer header handling according to
      the [[!RFC7240]] and implementers should proceed with caution.\nThe authors would like to thank the following individuals for contributing
    their ideas and providing feedback for writing this specification:
    Arnau Siches, elf Pavlik, Karol Szczepański, Mark Baker, Martijn Faassen,
    Matthias Lehmann, Ruben Verborgh, Ryan J. McDonough, Sam Goto,
    Thomas Hoppe, Tomasz Pluskiewicz, @wasabiwimp (on GitHub).\nThe Hydra Core Vocabulary in JSON-LD\n\n\nHydra simplifies the development of interoperable, hypermedia-driven Web APIs

              Building Web APIs seems still more an art than a science. How can we build APIs such that generic clients can easily use them? And how do we build those clients? Current APIs heavily rely on out-of-band information such as human-readable documentation and API-specific SDKs. However, this only allows for very simple and brittle clients that are hardcoded against specific APIs. Hydra, in contrast, is a set of technologies that allow to design APIs in a different manner, in a way that enables smarter clients.
          
      

      
          
              Hydra Core Vocabulary

              Essential building blocks for machine-accessible Hypermedia APIs

              Read the specification

              There also exists a demo Web API featuring a simple issue tracker which allows you to play with Hydra directly in your web browser.

          
          
              Linked Data Fragments

              API and client designs to publish and query Linked Data at Web-scale

              Get familiar with Linked Data Fragments or read the triple pattern fragments specification

              Various LDF data sources are already available. Query them.
          
          
              Join the Working Group
              Wanna help? Then join the Hydra W3C Community Group. Here's how:

              
                Get a free W3C account (it may take a while to get approved).
                Join the Hydra W3C Community Group.
                Bonus points: Send an email to introduce yourself to the group.
              
          
      

      
          
              Tools/Libraries/​Applications

              
                HydraConsole: a generic API console
                  for Hydra-powered Web APIs
                HydraBundle: a bundle for
                  Symfony2 to create Web APIs based on Hydra
                  (demo application)
                API Platform: a PHP framework to build Web APIs
                  with JSON-LD, Schema.org and Hydra
                hydra-java: annotate your Java beans
                  and serialize them as JSON-LD with Hydra
                URSA: a framework written in C# to create
                  Hydra-powered Web APIs
                hydrus: a set of Python based tools to create
                  Hydra-powered Web APIs
                Levanzo: Clojure library to build hypermedia driven RESTful APIs
                Argolis: Hydra hypermedia controls for .NET web applications written in Nancy
                hydra-core: a JavaScript library to work
                  with Hydra-enabled Web APIs
                SmallHydra: a small Hydra library for the ESP8266 and Arduino platform
                hydra-py: a Hydra library for Python
                  (including a Triple Patterns Fragments client)
                Alcaeus: a Hydra client library written in TypeScript
                HydraClient: a PHP client library to
                  access Hydra-powered Web APIs
                api-doc-parser: a JavaScript library to parse Hydra API documentations
                JsonLD: a JSON-LD processor implemented in PHP
                Linked Data Fragments Server: serve triple pattern fragments
                  (JavaScript,
                  Java,
                  NetKernel)
                Linked Data Fragments Client: query a Linked Data Fragments API
                  (JavaScript,
                  browser,
                  Java)
              
          
      

      
          
              Publications/​Presentations

              
                M. Lanthaler,
                  “The Web Is Changing — From Strings to Things,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                M. Lanthaler,
                  “Why and How to Optimize Your Data Architecture for an Integrated Future,”
                  presented at Presented at APIcon UK 2014 in London, England.
                  [video].
                T. Hoppe,
                  “REST APIs Today and Tomorrow - an Essay,”
                  presented at several Meetups.
                M. Lanthaler,
                  “Creating Awesome Web APIs is a Breeze,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                T. Pluskiewicz,
                  “JSON-LD and Hydra - Hypermedia API alternatively,”
                  presented at Meet.js Wrocław 2014.
                M. Lanthaler,
                  “A Deep Dive into JSON-LD and Hydra,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “Stop Reinventing the Wheel! Use Linked Data to Build Better APIs,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “The Web 3.0 is just around the corner. Be prepared!,”
                  presented at APIdays Berlin, 2014.
                R. Verborgh,
                  “The Lonesome LOD Cloud,”
                  presented at the 4th USEWOD Workshop on Usage Analysis and the Web of Data, 2014.
                R. Verborgh, M. Vander Sande, P. Colpaert,
                  S. Coppens, E. Mannens, and R. Van de Walle,
                  “Web-Scale Querying through Linked Data Fragments,”
                  in Proceedings of the 7th Workshop on Linked Data on the Web (LDOW2014) at the 23nd International
                  World Wide Web Conference (WWW2014), 2014 [slides].
                M. Lanthaler,
                  “Full-on Hypermedia APIs with Hydra,”
                  presented at the API Strategy & Practice Conference, 2014 [video].
                R. Verborgh,
                  “Hypermedia cannot be the engine,”
                  presented at the API Strategy & Practice Conference, 2014.
                C. Pautasso, E. Wilde, and R. Alarcon (editors),
                  “REST: Advanced Research Topics and Practical Applications,”
                  Springer New York, 2014.
                L. Richardson, M. Amundsen, and S. Ruby,
                  “RESTful Web APIs,” O’Reilly Media, 2013.
                M. Lanthaler,
                  “Building Next-Generation Web APIs with JSON-LD and Hydra,”
                  presented at Symfony Live Portland 2013 [slides]
                  [video].
                M. Lanthaler and C. Gütl,
                  “Hydra: A Vocabulary for Hypermedia-Driven Web APIs,”
                  in Proceedings of the 6th Workshop on Linked Data on the Web (LDOW2013) at the 22nd International
                  World Wide Web Conference (WWW2013), 2013 [slides].
                M. Lanthaler, “Creating 3rd Generation Web APIs with Hydra,”
                  in Proceedings of the 22nd International World Wide Web Conference (WWW2013), 2013, pp. 35–37
                  [slides].
                M. Lanthaler and C. Gütl,
                  “Model Your Application Domain, Not Your JSON Structures,”
                  in Proceedings of the 4th International Workshop on RESTful Design (WS-REST 2013) at the
                  22nd International World Wide Web Conference (WWW2013), 2013, pp. 1415–1420
                  [slides].\n\n\n\nHydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.\nThis entire document is a work in progress and several
    sections are incomplete, missing, or outdated. All open issues and decisions
    are documented in our
    issue tracker.
    If you have questions, please don't hesitate to
    join the Hydra W3C Community Group and post to the mailing list.\njoin the Hydra W3C Community Group and post to the mailing list.\nThis specification was published by the
    Hydra W3C Community Group. It is
    not a W3C Standard nor is it on the W3C Standards Track. Please note that under the
    W3C Community Contributor License Agreement (CLA)
    there is a limited opt-out and other conditions apply. Learn more about
    W3C Community and Business Groups.\nHydra W3C Community Group\nW3C Community Contributor License Agreement (CLA)\nW3C Community and Business Groups\nTo participate in the development of this specification, please join the
    Hydra W3C Community Group. If
    you have questions, want to suggest a feature, or raise an issue, please send a mail to the
    public-hydra@w3.org mailing list.\nHydra W3C Community Group\npublic-hydra@w3.org mailing list\nCoping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.\nThe combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.\nThis specification describes the conformance criteria for
    Hydra API documentations
    and Hydra clients. These criteria are
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.\nConformance for Hydra clients should probably not be
    specified in this document.\nAdd normative statements\nThe key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].\nThe basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.\nThe namespace of the Hydra core vocabulary is
    http://www.w3.org/ns/hydra/core#, and the suggested prefix
    is hydra. The figure below illustrates the vocabulary (the
    figure’s goal is to show how Hydra is used rather than its precise
    definition).\nIs this illustration clear enough or is it confusing?
    Feedback would be much appreciated.\nThe Hydra core vocabulary\nThe Hydra core vocabulary\nAdd ranges for Operation "members"\nAn alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.\nThe used prefixes should be documented somewhere.\nThroughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.\nAdding Affordances to Representations\nThe exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.\nThe simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type—a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.\nIn Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.\nGenerally, a client decides whether to follow a link or not based on
      the link relation (or property in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every link
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <a> tag) are
      followed but most references in link elements (the
      <link> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      if a property represents a link intended to be
      dereferenced or solely an identifier. Hydra's
      Link class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can be used to define a property
      linking issues to their comments:\nIn the example above, a property identified with the URL
      http://api.example.com/vocab#comments is defined to be
      of the type Link. This is enough information for a client
      understanding Hydra to know that the value of the
      comments property in the following example is intended
      to be dereferenced.\nIt is recommended to dereference resources that are
      within an API's domain. This may prevent possible issues with cross-site
      scripting or obtaining resources which might have no meaning
      to the client or such that the client would be unable to interpret.
      Still, there is no formal prohibition of dereferencing resources
      linked with well-known properties, e.g. rdf:seeAlso.\nIn the example above, the value of the comments
      property is a JSON object with an @id member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:\nWhile links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      Operation represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      Operation is its HTTP method. Optionally, it is
      also possible to describe what information the server expects
      or returns, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.\nThe following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them.\nThe example above references Hydra's context to map properties such
      as operation and method and values like
      Operation to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.\nIt is worth mentioning that due to the fact that Hydra is built on
      RDF, which is a graph, it may happen that a related resource
      (an object of the relation) may not be fully described in the
      resource's payload. In several circumstances (i.e. payload terms
      defined in API documentation sa described in
      Documenting a Web API
      or IriTemplate expected as a related resource as described in
      Templated Links) client may
      discover no additional statements describing it. These rules should
      be considered by the client in following scenarios:\nDocumenting a Web API\nin case of an object expected to be a hypermedia resource does not have all
        the necessary statements for which it is a subject, the client SHOULD look in the
        API documentation for more details\nin case the mentioned object, after consulting an API documentation, still
        does not have all the necessary statements for which it is a subject and both
        mentioned object's Url and Url of the initially obtained resource has the
        same scheme and authority (by means of [[!RFC3986]] sections 3.1 and 3.2), the client
        SHOULD de-reference that Url. If the resource does not have the same scheme and
        authority the client MAY choose to de-reference it (for example if the resource
        originates from another API well-known to the client)\nin case the mentioned object still does not have all the necessary
        statements for which it is a subject (i.e. de-referencing it failed
        or statements are missing), the client SHOULD either ignore the whole
        statement (i.e. for display purposes) or throw an exception (i.e. an
        IriTemplate is about to be resolved and de-referenced)\nExample of each of the situations are as follows:\nresource http://api.example.com/people should have an IriTemplate available
        as there is a complete definition of the template available at http://api.example.com/doc/.\nresource http://api.example.com/events should not have an Iri template exposed as there
        are no additional details available, neither in the initial resources' payload nor in the API documentation.\nKeep in mind that any resource described by any hypermedia control
      may fail at runtime due to various reasons. Operation details
      such as returns or possibleStatus may also vary at runtime,
      which means client SHOULD always verify received payloads at runtime.\nDocumenting a Web API\nIn Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.\nHydra's ApiDocumentation class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.\nIn Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.\nThese differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.\nMention that Hydra classes are dereferenceable
      resources.\nSince Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      supportedProperty references an intermediate data structure,
      namely instances of the SupportedProperty class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.\nAll instances of a specific class typically support the same
      operations. Hydra therefore features a supportedOperation
      property which defines the operations supported by all instances of
      a class.\nThe same feature can be used to describe the operations supported
      by values of a Link property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.\nExample shown below describes the operation's expected and returned
      value as a dereferencable resource (an RDF resource of a given class),
      but the vocabulary is not limited to only those originating
      from RDF and is enabled to other types of resources.
      Please note that in case of multiple either returned or expected types
      provided, client SHOULD assume the set includes any of the types,
      but not limited to those types and client SHOULD interpret received
      payload at runtime for possible discrepancies.\nIn addition to expected/returned resources, it is also possible to
      express similar features for headers with returnsHeader and
      expectsHeader predicates which provides a simple set of header
      names. Client SHOULD apply respective header semantics when creating
      or receiving a request natural for the protocol in use.\nThe example above enable an HTTP client to prepare a proper cross-site
      pre-flight request so the server exposes enlisted headers for the client.
      The client is also aware of the user authentication requirement necessary
      for the operation invocation.\nFor more complex scenarios it is also possible to expand selected header
      specification with both name and possible values, i.e. when defining
      expected Content-Type values of resources that can be uploaded.
      In case multiple possible values are provided, client SHOULD assume
      that the set includes any of the values, but not limited to those values.
      In order to change that default behavior it is possible to use closedSet
      predicate on the header specification indicating that the set of provided
      values is, well, closed and no other values are available. In both case the client
      SHOULD interpret received payload at runtime for possible discrepancies.\nTo wrap up everything altogether, it is also possible to attach atomic
      operations supported by, well, supported property itself. This might
      come in handy for scenarios, when resource can be partially modified.
      It can be achieved with two approaches, both having advantages and
      disadvantages.\nFirst approach would involve adding a supportedOperation to the
      intermediate structure of SupportedProperty.
      This way prevents from leaking API specific features from the API itself
      to i.e. externally defined properties. Data aggregators won't assume that
      each instance with a given property could have such an operation.\nAnother approach would require the API to elevate a specific property
      to Link, which can accept a supportedOperation. This
      is more intuitive in APIs operating with internally used vocabularies
      where assumption that every instance with that very specific property
      has the operation attached available.\nDirect usage of supportedOperation on rdf:Property
      without elevating it to the Link SHOULD NOT be implemented as clients
      may not discover such a construct correctly.\nThese are the simple example scenarios and possible usages are not
      limited to those described above.\nDue to the fact an ApiDocumentation as all other resources may fail
      at runtime, it is important to take countermeasures.
      A simple strategy to try to recover from such a situation would be to reload
      the ApiDocumentation and redo all pre-computations that were
      based on the ApiDocumentation (or at least those that lead
      to the current failure). Another, simpler approach would require
      an application to show an error message with option to return
      to a previous or home screen.\nDescribe the various properties of an operation.\nHydra also allows enriching both ApiDocumentation and
      hypermedia controls with human-readable descriptions by applying
      title and description (as shown in the examples above).
      The former states a name of such a decorated element that could
      be displayed as a label. The latter provides its description
      to be presented i.e. as a hint.\nAforementioned title and description SHOULD take precedence
      over standard rdfs:label and rdfs:comment.\nThere is one more feature related to how Linked Data works. Consider the
      example below written in turtle syntax:\nand how it could be transformed with JSON-LD framing process:\nAs you can see, additional details about ex:SomeType went
      missing, while this shouldn't happen. The fact that the IRI mentioned
      is an rdfs:Class may be meaningful for a correct interpretation
      of the received payload and this is a sole reason of why a Client
      SHOULD NOT disregard other parts of the payload that are not directly
      related to the API documentation or other hypermedia controls.\nDiscovering a Hydra-powered Web API\nThe first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look for a Link Header with a relation type
      http://www.w3.org/ns/hydra/core#apiDocumentation (this is
      the IRI identifying the hydra:apiDocumentation property).\nIn the following example, a Hydra client simply accesses the
      homepage of an API publisher (http://www.example.com)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.\nThe response in the example above contains an HTTP Link Header
      pointing to http://api.example.com/doc/.
      Retrieving that resource, the client would obtain a
      Hydra API documentation defining the API's main entry
      point:\nHydra API documentation\nPlease note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.\nIn another scenario the ApiDocumentation would be discovered from
      a bookmarked resource's representation. Api implementation SHOULD emit
      the HTTP Link header on every Api response, making
      the ApiDocumentation (and entry points it defines) discoverable
      all the time.\nIt is common to provide a separate API address after a breaking changes
      update. This prevents current clients not to get broken as these may not
      support these changes.\nWith hypermedia provided in each response payload, it may be unnecessary
      to provide such an alternative API. This is due to fact the client follows
      what the server provides and with proper margin for errors implemented
      within that client, even breaking changes can be published on the fly.\nStill, Hydra does neither have any special support for API versions, nor
      prevents them. It's fully an implementers decision on if and how
      to provide the API features.\nDescribe Hydra's Resource class? Or should that better be
    described somewhere in the beginning?\nIn many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes hydra:Collection and
      hydra:PartialCollectionView.\nA hydra:Collection can be used to reference a set of resources
      as follows:\nAs shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.\nSince collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a hydra:PartialCollectionView. It describes a specific
      view on the collection which represents only a subset of the collection's
      members. A PartialCollectionView may contain links to the
      first, next, previous, and last
      PartialCollectionView which allows a client to find all members
      of a Collection.\nSay that all these properties are optional? What about
      first and, perhaps more interestingly, last?\nA memberAssertion is a way to declare additional, implicit statements about
      members of a collection. Statements which may otherwise
      be missing from the respective member resources inlined in a collection's
      representation.\nIn the above example, adding a memberAssertion node to the collection instructs the
      client that every member of this collection is linked to the subject
      by the property. It could be written as a SPARQL triple pattern below, where
      ?m would be substituted by each member of the collection.\nA memberAssertion MUST use two and only two of the subject, property
      and object predicates. There memberAssertion predicate MAY have more than one
      such blocks, each expressing different relations between the collection members and other resources.\nIt's important to point out that the subject, property
      and object predicates are defined within the Hydra namespace and are not
      rdf terms.\nSometimes, it is impossible for a server to construct a URL because
      the URL depends on information only known by the client. A typical
      use case are URLs which enable a client to query the server. In such
      a case, the server cannot construct the URL because it does not know
      the query the client is interested in. What the server can do however,
      is to give the client a template to construct such a URL at runtime.
      In Hydra, the IriTemplate class is used to do so.\nAn IriTemplate consists of a template literal and a set
      of mappings. Each IriTemplateMapping maps a
      variable used in the template to a property and may
      optionally specify whether that variable is required or not.
      The syntax of the template literal is specified by its datatype and
      defaults to the [[!RFC6570]] URI Template syntax, which can be
      explicitly indicated by hydra:Rfc6570Template.\nThe example above maps the variable q to Hydra's
      freetextQuery property and marks it as required.
      As its name suggests, the freetextQuery property can be used
      for free text queries.\nA template syntax only details how to fill out simple string values,
      but not how to derive such string values from typed values,
      language-tagged strings, or IRIs. Hydra addresses this by
      specifying how such values are to be serialized as strings. The
      serialization of an IriTemplate's variables can be described
      by setting the variableRepresentation property to
      BasicRepresentation or ExplicitRepresentation. The
      BasicRepresentation represents values by their lexical form. It
      omits type and language information and does not differentiate between
      IRIs and literals. The ExplicitRepresentation, on the other
      hand, includes type and language information and differentiates
      between IRIs and literals by serializing values as follows:\nIRIs are represented as-is.\nLiterals, i.e., (typed) values and language-tagged strings are
        represented by their lexical form, surrounded by a single pair of
        doubles quotes (").\nIf a literal has a language, a single @ symbol is
        appended after the double-quoted lexical form, followed by a
        non-empty [[BCP47]] language code.\nIf a literal has a type, two caret symbols
        (^^) are appended after the double-quoted literal,
        followed by the full datatype IRI.\nIn both representations characters MUST NOT be escaped. In case the
      representation format is not explicitly described, clients SHOULD
      use the BasicRepresentation by default.\nAlthough ExplicitRepresentation use of
      @ and ^^ is similar, it is not the
      same as the [[Turtle]] representation for literals. Turtle literals
      require escaping of special characters, surround datatype IRIs with
      angular brackets (< and >), and also
      allow single quotes (') to indicate literals.
      ExplicitRepresentation values must not be escaped, IRIs must
      not be surrounded by any character, and only double quotes can
      indicate literals.\nBelow are some example values serialized in the different
      representations as well as the result of expanding the IRI template
      http://example.com/find/{value} with the respective
      value.\nSimilar to how Hydra's Link class allows the definition of
      properties that represent hyperlinks as described in
      ,
      the TemplatedLink class allows the definition of properties
      whose value are IRI templates. Hydra predefines one such property,
      namely the search property which can be used to document
      available search interfaces.\nIRI expansion should be performed with respect to the specification
      behind the IRI template type (RFC 6570 by default), and the product
      of this process SHOULD be an IRI. When the produced IRI is relative,
      the client SHOULD stick to RFC 3986 sections 5.1.3 and 5.1.4 to be compatible
      with most RDF serializations that support relative IRIs. Still, it may be
      preferred to use another base URI for the expansion process, which
      makes the resolveRelativeTo term useful. It allows to switch the
      IRI template expansion algorithm so the base URI is established using
      current link context, which is a subject of the relation pointing to an
      IriTemplate instance. In case that subject is a relative URI,
      default behavior SHOULD be used as fallback.\nThe example below allows to make the product of an IRI template
      expansion relative to the http://api.example.com/an-issue/ resource
      by using it as its base URI, which further enables the some:operation to
      be moved to i.e. API documentation level rather to inline it.\nWhen constructed, the IRI would effectively become similar to http://api.example.com/an-issue/1234,
      with the relative part {id} appended to the link context URL.\nIRI template operations\nThere are circumstances in which client would like to perform an operation
      not knowing the final IRI of the resource to be called. This case is especially
      in force when working with collections - client may want to add a new
      collection member, or it may need to provide more details while searching
      with other protocol's method (i.e. POST instead of GET in case of an HTTP).\nThis is achievable by attaching a supportedOperation to the property
      that connects a subject of that relation with its IRI template
      as described in the previous part of this document. Please note that
      client is still allowed to use the defined link and custom operation's
      method is optional.\nThe example above allows client to either invoke an HTTP GET or POST
      call on http://api.example.com/issues?search=search_string resource.\nThe example above allows client to invoke only an HTTP POST
      call on http://api.example.com/issues?find=search_string resource as
      the described relation of find is not a Link.\nSupported property data source\nThere are circumstances in which an API would like to inform a client on
      when to obtain values to feed data structures with details. Having all the
      necessary components like supported property, collection and IRI templates,
      it is possible to drive the client and direct it with links and operations
      to the data sources.\nIt is doable by attaching either a collection or search
      predicate to instance of supportedProperty or to property.
      In such case client SHOULD use assume that the relation leads to
      the collection of values compatible with the supported property's range
      and can be used to feed data structures with the supported property.
      It is recommended (but not mandatory) to use freetextQuery
      variable mapping in case of the search predicate as it has a
      well defined semantics and takes the burden of interpretation from
      the client.\nWhile it is possible to provide such links in both API documentation
      and within the received payload, client SHOULD use the latter link first
      if applicable. This is due to fact the the server may want to put additional
      context to narrow the collection of viable values. Redefinition does not
      make the more general one obsolete though and and can be used as a fallback.\nThe example above instructs a client that every resource of type
      schema:Event can have a relation of schema:actor, the objects of which the
      client can obtain using the search link provided.\nDescription of HTTP Status Codes and Errors\nHTTP status codes have well defined semantics and can be used to
      signal the outcome of an operation. Unfortunately, however, HTTP
      status codes by themselves are often not specific enough, making it
      difficult to understand the real cause of an error. For
      instance, a 429 Too Many Requests response is rarely
      informative enough by itself. To address this issue, Hydra defines
      a Status class which allows additional
      information to be associated with an HTTP status code.\nAn ApiDocumentation or an Operation may document the
      status codes that might be returned by the server using the
      possibleStatus property as described in
      . This allows
      a developer to understand what to expect when invoking an operation.
      It has, however, not to be considered as an extensive list of all
      potentially returned status codes; it is merely a hint. Developers
      should expect to encounter other HTTP status codes as well.\nA server may also return a Status directly in
      a response. When doing so, it often makes sense to subclass the
      Status to make its semantics more explicit.
      Hydra defines just one such subclass, namely the Error class.
      This provides an extensible framework to communicate error details to
      a client.\nFurthermore, a Status or Error returned by the server can also
      be given an identifier. When dereferenced, the Error resource can provide
      more detailed information or possible ways to resolve the problem, if applicable.\nFinally, the server SHOULD provide error descriptions using an [[!RFC7807]] standard
      by using an application/problem+json response. When doing so, the server also MUST provide
      an additional header pointing to either the built-in Hydra http://www.w3.org/ns/hydra/error
      context or any JSON-LD context that maps the terms type, title, detail,
      status and instance the same way as the standard one.\nWhile the built-in context makes the response fully compatible with the mentioned specification,
      properties not defined in the standard Hydra's error context won't be visible for Hydra aware processors.
      To overcome this, it is possible to declare a custom context pointed the same way, that would combine standard
      Hydra's standard error context and an additional JSON-LD context with either the @vocab
      or custom property mappings telling the processor on how to interpret those custom error properties.\nResources provided may have an additional hint pointing to an Error type like in the example
      above, but it is not mandatory to do so as all resources described with application/problem+json
      are considered hydra:Error.\nIt is worth to mention that it may happen (i.e. due to proxy behavior) the value of the status property
      will differ to the one received from the protocol layer.\nClient initiated pagination\nThere are situations when a client would like to provide a specific
      collection limitations, i.e. by providing query-language like member
      offset and limit or some specific page index and number of members
      per page. This is doable with offset/limit or
      pageIndex/limit predicates.\nWith those, it is possible to bind a template variables mapped
      with externally obtained values (i.e. user interaction) the same way
      as with other mappings.\nWhile the predicates enlisted above accepts non-negative integer
      numbers, there is also a possibility of providing a custom page
      reference expressed via pageReference predicate. It is possible
      to provide a custom page identifier (i.e. a GUID or a letter)
      instead of a number.\nWhile Hydra Core Vocabulary allows addressing many usage scenarios,
      not every aspect of API behavior can be covered. This
      applies especially to querying, resource projection or data structure
      description. This is due to fact that Hydra is meant to be as light
      as possible forcing to drop some of the features out of its scope.\nThat is why there is a possibility of hinting a client on what kind
      of extensions may be found or used in the received payloads.
      After discovering an extension predicate in the API documentation,
      client can assume additional details are available described with
      complementary vocabularies.\nIt is up to the used vocabulary to define how these additional details should be
      interpreted. In case client does not recognize these extensions,
      additional details should be ignored and base Hydra interpretation
      should be in force.\nServer SHOULD NOT use extensions to add statements that are in
      contradiction to base Hydra interpretation so the client is not confused.
      Server SHOULD also keep multiple extensions describing adequate
      knowledge in line regarding their description (i.e. data structure
      descriptions in various vocabularies should not cause differences).\nClient can express its preferences through the Prefer HTTP header
      by pointing the preferred extensions via IRIs as on the example below.
      The client SHOULD use the Prefer HTTP header [[!RFC7240]] with
      the hydra.extension preference as an iri attribute having
      the IRI of the extension as value to hint the server about the extension
      it supports. Multiple preferences can be expressed by providing multiple
      Prefer header values.\nServer MUST implement Prefer header handling according to
      the [[!RFC7240]] and implementers should proceed with caution.\nThe authors would like to thank the following individuals for contributing
    their ideas and providing feedback for writing this specification:
    Arnau Siches, elf Pavlik, Karol Szczepański, Mark Baker, Martijn Faassen,
    Matthias Lehmann, Ruben Verborgh, Ryan J. McDonough, Sam Goto,
    Thomas Hoppe, Tomasz Pluskiewicz, @wasabiwimp (on GitHub).\nThe Hydra Core Vocabulary in JSON-LD\n\n\nHydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.\nThis entire document is a work in progress and several
    sections are incomplete, missing, or outdated. All open issues and decisions
    are documented in our
    issue tracker.
    If you have questions, please don't hesitate to
    join the Hydra W3C Community Group and post to the mailing list.\njoin the Hydra W3C Community Group and post to the mailing list.\nThis specification was published by the
    Hydra W3C Community Group. It is
    not a W3C Standard nor is it on the W3C Standards Track. Please note that under the
    W3C Community Contributor License Agreement (CLA)
    there is a limited opt-out and other conditions apply. Learn more about
    W3C Community and Business Groups.\nHydra W3C Community Group\nW3C Community Contributor License Agreement (CLA)\nW3C Community and Business Groups\nTo participate in the development of this specification, please join the
    Hydra W3C Community Group. If
    you have questions, want to suggest a feature, or raise an issue, please send a mail to the
    public-hydra@w3.org mailing list.\nHydra W3C Community Group\npublic-hydra@w3.org mailing list\nCoping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.\nThe combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.\nThis specification describes the conformance criteria for
    Hydra API documentations
    and Hydra clients. These criteria are
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.\nConformance for Hydra clients should probably not be
    specified in this document.\nAdd normative statements\nThe key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].\nThe basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.\nThe namespace of the Hydra core vocabulary is
    http://www.w3.org/ns/hydra/core#, and the suggested prefix
    is hydra. The figure below illustrates the vocabulary (the
    figure’s goal is to show how Hydra is used rather than its precise
    definition).\nIs this illustration clear enough or is it confusing?
    Feedback would be much appreciated.\nThe Hydra core vocabulary\nThe Hydra core vocabulary\nAdd ranges for Operation "members"\nAn alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.\nThe used prefixes should be documented somewhere.\nThroughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.\nAdding Affordances to Representations\nThe exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.\nThe simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type—a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.\nIn Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.\nGenerally, a client decides whether to follow a link or not based on
      the link relation (or property in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every link
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <a> tag) are
      followed but most references in link elements (the
      <link> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      if a property represents a link intended to be
      dereferenced or solely an identifier. Hydra's
      Link class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can be used to define a property
      linking issues to their comments:\nIn the example above, a property identified with the URL
      http://api.example.com/vocab#comments is defined to be
      of the type Link. This is enough information for a client
      understanding Hydra to know that the value of the
      comments property in the following example is intended
      to be dereferenced.\nIt is recommended to dereference resources that are
      within an API's domain. This may prevent possible issues with cross-site
      scripting or obtaining resources which might have no meaning
      to the client or such that the client would be unable to interpret.
      Still, there is no formal prohibition of dereferencing resources
      linked with well-known properties, e.g. rdf:seeAlso.\nIn the example above, the value of the comments
      property is a JSON object with an @id member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:\nWhile links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      Operation represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      Operation is its HTTP method. Optionally, it is
      also possible to describe what information the server expects
      or returns, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.\nThe following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them.\nThe example above references Hydra's context to map properties such
      as operation and method and values like
      Operation to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.\nIt is worth mentioning that due to the fact that Hydra is built on
      RDF, which is a graph, it may happen that a related resource
      (an object of the relation) may not be fully described in the
      resource's payload. In several circumstances (i.e. payload terms
      defined in API documentation sa described in
      Documenting a Web API
      or IriTemplate expected as a related resource as described in
      Templated Links) client may
      discover no additional statements describing it. These rules should
      be considered by the client in following scenarios:\nDocumenting a Web API\nin case of an object expected to be a hypermedia resource does not have all
        the necessary statements for which it is a subject, the client SHOULD look in the
        API documentation for more details\nin case the mentioned object, after consulting an API documentation, still
        does not have all the necessary statements for which it is a subject and both
        mentioned object's Url and Url of the initially obtained resource has the
        same scheme and authority (by means of [[!RFC3986]] sections 3.1 and 3.2), the client
        SHOULD de-reference that Url. If the resource does not have the same scheme and
        authority the client MAY choose to de-reference it (for example if the resource
        originates from another API well-known to the client)\nin case the mentioned object still does not have all the necessary
        statements for which it is a subject (i.e. de-referencing it failed
        or statements are missing), the client SHOULD either ignore the whole
        statement (i.e. for display purposes) or throw an exception (i.e. an
        IriTemplate is about to be resolved and de-referenced)\nExample of each of the situations are as follows:\nresource http://api.example.com/people should have an IriTemplate available
        as there is a complete definition of the template available at http://api.example.com/doc/.\nresource http://api.example.com/events should not have an Iri template exposed as there
        are no additional details available, neither in the initial resources' payload nor in the API documentation.\nKeep in mind that any resource described by any hypermedia control
      may fail at runtime due to various reasons. Operation details
      such as returns or possibleStatus may also vary at runtime,
      which means client SHOULD always verify received payloads at runtime.\nDocumenting a Web API\nIn Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.\nHydra's ApiDocumentation class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.\nIn Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.\nThese differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.\nMention that Hydra classes are dereferenceable
      resources.\nSince Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      supportedProperty references an intermediate data structure,
      namely instances of the SupportedProperty class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.\nAll instances of a specific class typically support the same
      operations. Hydra therefore features a supportedOperation
      property which defines the operations supported by all instances of
      a class.\nThe same feature can be used to describe the operations supported
      by values of a Link property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.\nExample shown below describes the operation's expected and returned
      value as a dereferencable resource (an RDF resource of a given class),
      but the vocabulary is not limited to only those originating
      from RDF and is enabled to other types of resources.
      Please note that in case of multiple either returned or expected types
      provided, client SHOULD assume the set includes any of the types,
      but not limited to those types and client SHOULD interpret received
      payload at runtime for possible discrepancies.\nIn addition to expected/returned resources, it is also possible to
      express similar features for headers with returnsHeader and
      expectsHeader predicates which provides a simple set of header
      names. Client SHOULD apply respective header semantics when creating
      or receiving a request natural for the protocol in use.\nThe example above enable an HTTP client to prepare a proper cross-site
      pre-flight request so the server exposes enlisted headers for the client.
      The client is also aware of the user authentication requirement necessary
      for the operation invocation.\nFor more complex scenarios it is also possible to expand selected header
      specification with both name and possible values, i.e. when defining
      expected Content-Type values of resources that can be uploaded.
      In case multiple possible values are provided, client SHOULD assume
      that the set includes any of the values, but not limited to those values.
      In order to change that default behavior it is possible to use closedSet
      predicate on the header specification indicating that the set of provided
      values is, well, closed and no other values are available. In both case the client
      SHOULD interpret received payload at runtime for possible discrepancies.\nTo wrap up everything altogether, it is also possible to attach atomic
      operations supported by, well, supported property itself. This might
      come in handy for scenarios, when resource can be partially modified.
      It can be achieved with two approaches, both having advantages and
      disadvantages.\nFirst approach would involve adding a supportedOperation to the
      intermediate structure of SupportedProperty.
      This way prevents from leaking API specific features from the API itself
      to i.e. externally defined properties. Data aggregators won't assume that
      each instance with a given property could have such an operation.\nAnother approach would require the API to elevate a specific property
      to Link, which can accept a supportedOperation. This
      is more intuitive in APIs operating with internally used vocabularies
      where assumption that every instance with that very specific property
      has the operation attached available.\nDirect usage of supportedOperation on rdf:Property
      without elevating it to the Link SHOULD NOT be implemented as clients
      may not discover such a construct correctly.\nThese are the simple example scenarios and possible usages are not
      limited to those described above.\nDue to the fact an ApiDocumentation as all other resources may fail
      at runtime, it is important to take countermeasures.
      A simple strategy to try to recover from such a situation would be to reload
      the ApiDocumentation and redo all pre-computations that were
      based on the ApiDocumentation (or at least those that lead
      to the current failure). Another, simpler approach would require
      an application to show an error message with option to return
      to a previous or home screen.\nDescribe the various properties of an operation.\nHydra also allows enriching both ApiDocumentation and
      hypermedia controls with human-readable descriptions by applying
      title and description (as shown in the examples above).
      The former states a name of such a decorated element that could
      be displayed as a label. The latter provides its description
      to be presented i.e. as a hint.\nAforementioned title and description SHOULD take precedence
      over standard rdfs:label and rdfs:comment.\nThere is one more feature related to how Linked Data works. Consider the
      example below written in turtle syntax:\nand how it could be transformed with JSON-LD framing process:\nAs you can see, additional details about ex:SomeType went
      missing, while this shouldn't happen. The fact that the IRI mentioned
      is an rdfs:Class may be meaningful for a correct interpretation
      of the received payload and this is a sole reason of why a Client
      SHOULD NOT disregard other parts of the payload that are not directly
      related to the API documentation or other hypermedia controls.\nDiscovering a Hydra-powered Web API\nThe first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look for a Link Header with a relation type
      http://www.w3.org/ns/hydra/core#apiDocumentation (this is
      the IRI identifying the hydra:apiDocumentation property).\nIn the following example, a Hydra client simply accesses the
      homepage of an API publisher (http://www.example.com)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.\nThe response in the example above contains an HTTP Link Header
      pointing to http://api.example.com/doc/.
      Retrieving that resource, the client would obtain a
      Hydra API documentation defining the API's main entry
      point:\nHydra API documentation\nPlease note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.\nIn another scenario the ApiDocumentation would be discovered from
      a bookmarked resource's representation. Api implementation SHOULD emit
      the HTTP Link header on every Api response, making
      the ApiDocumentation (and entry points it defines) discoverable
      all the time.\nIt is common to provide a separate API address after a breaking changes
      update. This prevents current clients not to get broken as these may not
      support these changes.\nWith hypermedia provided in each response payload, it may be unnecessary
      to provide such an alternative API. This is due to fact the client follows
      what the server provides and with proper margin for errors implemented
      within that client, even breaking changes can be published on the fly.\nStill, Hydra does neither have any special support for API versions, nor
      prevents them. It's fully an implementers decision on if and how
      to provide the API features.\nDescribe Hydra's Resource class? Or should that better be
    described somewhere in the beginning?\nIn many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes hydra:Collection and
      hydra:PartialCollectionView.\nA hydra:Collection can be used to reference a set of resources
      as follows:\nAs shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.\nSince collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a hydra:PartialCollectionView. It describes a specific
      view on the collection which represents only a subset of the collection's
      members. A PartialCollectionView may contain links to the
      first, next, previous, and last
      PartialCollectionView which allows a client to find all members
      of a Collection.\nSay that all these properties are optional? What about
      first and, perhaps more interestingly, last?\nA memberAssertion is a way to declare additional, implicit statements about
      members of a collection. Statements which may otherwise
      be missing from the respective member resources inlined in a collection's
      representation.\nIn the above example, adding a memberAssertion node to the collection instructs the
      client that every member of this collection is linked to the subject
      by the property. It could be written as a SPARQL triple pattern below, where
      ?m would be substituted by each member of the collection.\nA memberAssertion MUST use two and only two of the subject, property
      and object predicates. There memberAssertion predicate MAY have more than one
      such blocks, each expressing different relations between the collection members and other resources.\nIt's important to point out that the subject, property
      and object predicates are defined within the Hydra namespace and are not
      rdf terms.\nSometimes, it is impossible for a server to construct a URL because
      the URL depends on information only known by the client. A typical
      use case are URLs which enable a client to query the server. In such
      a case, the server cannot construct the URL because it does not know
      the query the client is interested in. What the server can do however,
      is to give the client a template to construct such a URL at runtime.
      In Hydra, the IriTemplate class is used to do so.\nAn IriTemplate consists of a template literal and a set
      of mappings. Each IriTemplateMapping maps a
      variable used in the template to a property and may
      optionally specify whether that variable is required or not.
      The syntax of the template literal is specified by its datatype and
      defaults to the [[!RFC6570]] URI Template syntax, which can be
      explicitly indicated by hydra:Rfc6570Template.\nThe example above maps the variable q to Hydra's
      freetextQuery property and marks it as required.
      As its name suggests, the freetextQuery property can be used
      for free text queries.\nA template syntax only details how to fill out simple string values,
      but not how to derive such string values from typed values,
      language-tagged strings, or IRIs. Hydra addresses this by
      specifying how such values are to be serialized as strings. The
      serialization of an IriTemplate's variables can be described
      by setting the variableRepresentation property to
      BasicRepresentation or ExplicitRepresentation. The
      BasicRepresentation represents values by their lexical form. It
      omits type and language information and does not differentiate between
      IRIs and literals. The ExplicitRepresentation, on the other
      hand, includes type and language information and differentiates
      between IRIs and literals by serializing values as follows:\nIRIs are represented as-is.\nLiterals, i.e., (typed) values and language-tagged strings are
        represented by their lexical form, surrounded by a single pair of
        doubles quotes (").\nIf a literal has a language, a single @ symbol is
        appended after the double-quoted lexical form, followed by a
        non-empty [[BCP47]] language code.\nIf a literal has a type, two caret symbols
        (^^) are appended after the double-quoted literal,
        followed by the full datatype IRI.\nIn both representations characters MUST NOT be escaped. In case the
      representation format is not explicitly described, clients SHOULD
      use the BasicRepresentation by default.\nAlthough ExplicitRepresentation use of
      @ and ^^ is similar, it is not the
      same as the [[Turtle]] representation for literals. Turtle literals
      require escaping of special characters, surround datatype IRIs with
      angular brackets (< and >), and also
      allow single quotes (') to indicate literals.
      ExplicitRepresentation values must not be escaped, IRIs must
      not be surrounded by any character, and only double quotes can
      indicate literals.\nBelow are some example values serialized in the different
      representations as well as the result of expanding the IRI template
      http://example.com/find/{value} with the respective
      value.\nSimilar to how Hydra's Link class allows the definition of
      properties that represent hyperlinks as described in
      ,
      the TemplatedLink class allows the definition of properties
      whose value are IRI templates. Hydra predefines one such property,
      namely the search property which can be used to document
      available search interfaces.\nIRI expansion should be performed with respect to the specification
      behind the IRI template type (RFC 6570 by default), and the product
      of this process SHOULD be an IRI. When the produced IRI is relative,
      the client SHOULD stick to RFC 3986 sections 5.1.3 and 5.1.4 to be compatible
      with most RDF serializations that support relative IRIs. Still, it may be
      preferred to use another base URI for the expansion process, which
      makes the resolveRelativeTo term useful. It allows to switch the
      IRI template expansion algorithm so the base URI is established using
      current link context, which is a subject of the relation pointing to an
      IriTemplate instance. In case that subject is a relative URI,
      default behavior SHOULD be used as fallback.\nThe example below allows to make the product of an IRI template
      expansion relative to the http://api.example.com/an-issue/ resource
      by using it as its base URI, which further enables the some:operation to
      be moved to i.e. API documentation level rather to inline it.\nWhen constructed, the IRI would effectively become similar to http://api.example.com/an-issue/1234,
      with the relative part {id} appended to the link context URL.\nIRI template operations\nThere are circumstances in which client would like to perform an operation
      not knowing the final IRI of the resource to be called. This case is especially
      in force when working with collections - client may want to add a new
      collection member, or it may need to provide more details while searching
      with other protocol's method (i.e. POST instead of GET in case of an HTTP).\nThis is achievable by attaching a supportedOperation to the property
      that connects a subject of that relation with its IRI template
      as described in the previous part of this document. Please note that
      client is still allowed to use the defined link and custom operation's
      method is optional.\nThe example above allows client to either invoke an HTTP GET or POST
      call on http://api.example.com/issues?search=search_string resource.\nThe example above allows client to invoke only an HTTP POST
      call on http://api.example.com/issues?find=search_string resource as
      the described relation of find is not a Link.\nSupported property data source\nThere are circumstances in which an API would like to inform a client on
      when to obtain values to feed data structures with details. Having all the
      necessary components like supported property, collection and IRI templates,
      it is possible to drive the client and direct it with links and operations
      to the data sources.\nIt is doable by attaching either a collection or search
      predicate to instance of supportedProperty or to property.
      In such case client SHOULD use assume that the relation leads to
      the collection of values compatible with the supported property's range
      and can be used to feed data structures with the supported property.
      It is recommended (but not mandatory) to use freetextQuery
      variable mapping in case of the search predicate as it has a
      well defined semantics and takes the burden of interpretation from
      the client.\nWhile it is possible to provide such links in both API documentation
      and within the received payload, client SHOULD use the latter link first
      if applicable. This is due to fact the the server may want to put additional
      context to narrow the collection of viable values. Redefinition does not
      make the more general one obsolete though and and can be used as a fallback.\nThe example above instructs a client that every resource of type
      schema:Event can have a relation of schema:actor, the objects of which the
      client can obtain using the search link provided.\nDescription of HTTP Status Codes and Errors\nHTTP status codes have well defined semantics and can be used to
      signal the outcome of an operation. Unfortunately, however, HTTP
      status codes by themselves are often not specific enough, making it
      difficult to understand the real cause of an error. For
      instance, a 429 Too Many Requests response is rarely
      informative enough by itself. To address this issue, Hydra defines
      a Status class which allows additional
      information to be associated with an HTTP status code.\nAn ApiDocumentation or an Operation may document the
      status codes that might be returned by the server using the
      possibleStatus property as described in
      . This allows
      a developer to understand what to expect when invoking an operation.
      It has, however, not to be considered as an extensive list of all
      potentially returned status codes; it is merely a hint. Developers
      should expect to encounter other HTTP status codes as well.\nA server may also return a Status directly in
      a response. When doing so, it often makes sense to subclass the
      Status to make its semantics more explicit.
      Hydra defines just one such subclass, namely the Error class.
      This provides an extensible framework to communicate error details to
      a client.\nFurthermore, a Status or Error returned by the server can also
      be given an identifier. When dereferenced, the Error resource can provide
      more detailed information or possible ways to resolve the problem, if applicable.\nFinally, the server SHOULD provide error descriptions using an [[!RFC7807]] standard
      by using an application/problem+json response. When doing so, the server also MUST provide
      an additional header pointing to either the built-in Hydra http://www.w3.org/ns/hydra/error
      context or any JSON-LD context that maps the terms type, title, detail,
      status and instance the same way as the standard one.\nWhile the built-in context makes the response fully compatible with the mentioned specification,
      properties not defined in the standard Hydra's error context won't be visible for Hydra aware processors.
      To overcome this, it is possible to declare a custom context pointed the same way, that would combine standard
      Hydra's standard error context and an additional JSON-LD context with either the @vocab
      or custom property mappings telling the processor on how to interpret those custom error properties.\nResources provided may have an additional hint pointing to an Error type like in the example
      above, but it is not mandatory to do so as all resources described with application/problem+json
      are considered hydra:Error.\nIt is worth to mention that it may happen (i.e. due to proxy behavior) the value of the status property
      will differ to the one received from the protocol layer.\nClient initiated pagination\nThere are situations when a client would like to provide a specific
      collection limitations, i.e. by providing query-language like member
      offset and limit or some specific page index and number of members
      per page. This is doable with offset/limit or
      pageIndex/limit predicates.\nWith those, it is possible to bind a template variables mapped
      with externally obtained values (i.e. user interaction) the same way
      as with other mappings.\nWhile the predicates enlisted above accepts non-negative integer
      numbers, there is also a possibility of providing a custom page
      reference expressed via pageReference predicate. It is possible
      to provide a custom page identifier (i.e. a GUID or a letter)
      instead of a number.\nWhile Hydra Core Vocabulary allows addressing many usage scenarios,
      not every aspect of API behavior can be covered. This
      applies especially to querying, resource projection or data structure
      description. This is due to fact that Hydra is meant to be as light
      as possible forcing to drop some of the features out of its scope.\nThat is why there is a possibility of hinting a client on what kind
      of extensions may be found or used in the received payloads.
      After discovering an extension predicate in the API documentation,
      client can assume additional details are available described with
      complementary vocabularies.\nIt is up to the used vocabulary to define how these additional details should be
      interpreted. In case client does not recognize these extensions,
      additional details should be ignored and base Hydra interpretation
      should be in force.\nServer SHOULD NOT use extensions to add statements that are in
      contradiction to base Hydra interpretation so the client is not confused.
      Server SHOULD also keep multiple extensions describing adequate
      knowledge in line regarding their description (i.e. data structure
      descriptions in various vocabularies should not cause differences).\nClient can express its preferences through the Prefer HTTP header
      by pointing the preferred extensions via IRIs as on the example below.
      The client SHOULD use the Prefer HTTP header [[!RFC7240]] with
      the hydra.extension preference as an iri attribute having
      the IRI of the extension as value to hint the server about the extension
      it supports. Multiple preferences can be expressed by providing multiple
      Prefer header values.\nServer MUST implement Prefer header handling according to
      the [[!RFC7240]] and implementers should proceed with caution.\nThe authors would like to thank the following individuals for contributing
    their ideas and providing feedback for writing this specification:
    Arnau Siches, elf Pavlik, Karol Szczepański, Mark Baker, Martijn Faassen,
    Matthias Lehmann, Ruben Verborgh, Ryan J. McDonough, Sam Goto,
    Thomas Hoppe, Tomasz Pluskiewicz, @wasabiwimp (on GitHub).\nThe Hydra Core Vocabulary in JSON-LD\n\n\nHydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.\nThis entire document is a work in progress and several
    sections are incomplete, missing, or outdated. All open issues and decisions
    are documented in our
    issue tracker.
    If you have questions, please don't hesitate to
    join the Hydra W3C Community Group and post to the mailing list.\njoin the Hydra W3C Community Group and post to the mailing list.\nThis specification was published by the
    Hydra W3C Community Group. It is
    not a W3C Standard nor is it on the W3C Standards Track. Please note that under the
    W3C Community Contributor License Agreement (CLA)
    there is a limited opt-out and other conditions apply. Learn more about
    W3C Community and Business Groups.\nHydra W3C Community Group\nW3C Community Contributor License Agreement (CLA)\nW3C Community and Business Groups\nTo participate in the development of this specification, please join the
    Hydra W3C Community Group. If
    you have questions, want to suggest a feature, or raise an issue, please send a mail to the
    public-hydra@w3.org mailing list.\nHydra W3C Community Group\npublic-hydra@w3.org mailing list\nCoping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.\nThe combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.\nThis specification describes the conformance criteria for
    Hydra API documentations
    and Hydra clients. These criteria are
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.\nConformance for Hydra clients should probably not be
    specified in this document.\nAdd normative statements\nThe key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].\nThe basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.\nThe namespace of the Hydra core vocabulary is
    http://www.w3.org/ns/hydra/core#, and the suggested prefix
    is hydra. The figure below illustrates the vocabulary (the
    figure’s goal is to show how Hydra is used rather than its precise
    definition).\nIs this illustration clear enough or is it confusing?
    Feedback would be much appreciated.\nThe Hydra core vocabulary\nThe Hydra core vocabulary\nAdd ranges for Operation "members"\nAn alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.\nThe used prefixes should be documented somewhere.\nThroughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.\nAdding Affordances to Representations\nThe exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.\nThe simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type—a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.\nIn Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.\nGenerally, a client decides whether to follow a link or not based on
      the link relation (or property in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every link
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <a> tag) are
      followed but most references in link elements (the
      <link> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      if a property represents a link intended to be
      dereferenced or solely an identifier. Hydra's
      Link class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can be used to define a property
      linking issues to their comments:\nIn the example above, a property identified with the URL
      http://api.example.com/vocab#comments is defined to be
      of the type Link. This is enough information for a client
      understanding Hydra to know that the value of the
      comments property in the following example is intended
      to be dereferenced.\nIt is recommended to dereference resources that are
      within an API's domain. This may prevent possible issues with cross-site
      scripting or obtaining resources which might have no meaning
      to the client or such that the client would be unable to interpret.
      Still, there is no formal prohibition of dereferencing resources
      linked with well-known properties, e.g. rdf:seeAlso.\nIn the example above, the value of the comments
      property is a JSON object with an @id member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:\nWhile links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      Operation represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      Operation is its HTTP method. Optionally, it is
      also possible to describe what information the server expects
      or returns, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.\nThe following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them.\nThe example above references Hydra's context to map properties such
      as operation and method and values like
      Operation to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.\nIt is worth mentioning that due to the fact that Hydra is built on
      RDF, which is a graph, it may happen that a related resource
      (an object of the relation) may not be fully described in the
      resource's payload. In several circumstances (i.e. payload terms
      defined in API documentation sa described in
      Documenting a Web API
      or IriTemplate expected as a related resource as described in
      Templated Links) client may
      discover no additional statements describing it. These rules should
      be considered by the client in following scenarios:\nDocumenting a Web API\nin case of an object expected to be a hypermedia resource does not have all
        the necessary statements for which it is a subject, the client SHOULD look in the
        API documentation for more details\nin case the mentioned object, after consulting an API documentation, still
        does not have all the necessary statements for which it is a subject and both
        mentioned object's Url and Url of the initially obtained resource has the
        same scheme and authority (by means of [[!RFC3986]] sections 3.1 and 3.2), the client
        SHOULD de-reference that Url. If the resource does not have the same scheme and
        authority the client MAY choose to de-reference it (for example if the resource
        originates from another API well-known to the client)\nin case the mentioned object still does not have all the necessary
        statements for which it is a subject (i.e. de-referencing it failed
        or statements are missing), the client SHOULD either ignore the whole
        statement (i.e. for display purposes) or throw an exception (i.e. an
        IriTemplate is about to be resolved and de-referenced)\nExample of each of the situations are as follows:\nresource http://api.example.com/people should have an IriTemplate available
        as there is a complete definition of the template available at http://api.example.com/doc/.\nresource http://api.example.com/events should not have an Iri template exposed as there
        are no additional details available, neither in the initial resources' payload nor in the API documentation.\nKeep in mind that any resource described by any hypermedia control
      may fail at runtime due to various reasons. Operation details
      such as returns or possibleStatus may also vary at runtime,
      which means client SHOULD always verify received payloads at runtime.\nDocumenting a Web API\nIn Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.\nHydra's ApiDocumentation class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.\nIn Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.\nThese differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.\nMention that Hydra classes are dereferenceable
      resources.\nSince Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      supportedProperty references an intermediate data structure,
      namely instances of the SupportedProperty class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.\nAll instances of a specific class typically support the same
      operations. Hydra therefore features a supportedOperation
      property which defines the operations supported by all instances of
      a class.\nThe same feature can be used to describe the operations supported
      by values of a Link property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.\nExample shown below describes the operation's expected and returned
      value as a dereferencable resource (an RDF resource of a given class),
      but the vocabulary is not limited to only those originating
      from RDF and is enabled to other types of resources.
      Please note that in case of multiple either returned or expected types
      provided, client SHOULD assume the set includes any of the types,
      but not limited to those types and client SHOULD interpret received
      payload at runtime for possible discrepancies.\nIn addition to expected/returned resources, it is also possible to
      express similar features for headers with returnsHeader and
      expectsHeader predicates which provides a simple set of header
      names. Client SHOULD apply respective header semantics when creating
      or receiving a request natural for the protocol in use.\nThe example above enable an HTTP client to prepare a proper cross-site
      pre-flight request so the server exposes enlisted headers for the client.
      The client is also aware of the user authentication requirement necessary
      for the operation invocation.\nFor more complex scenarios it is also possible to expand selected header
      specification with both name and possible values, i.e. when defining
      expected Content-Type values of resources that can be uploaded.
      In case multiple possible values are provided, client SHOULD assume
      that the set includes any of the values, but not limited to those values.
      In order to change that default behavior it is possible to use closedSet
      predicate on the header specification indicating that the set of provided
      values is, well, closed and no other values are available. In both case the client
      SHOULD interpret received payload at runtime for possible discrepancies.\nTo wrap up everything altogether, it is also possible to attach atomic
      operations supported by, well, supported property itself. This might
      come in handy for scenarios, when resource can be partially modified.
      It can be achieved with two approaches, both having advantages and
      disadvantages.\nFirst approach would involve adding a supportedOperation to the
      intermediate structure of SupportedProperty.
      This way prevents from leaking API specific features from the API itself
      to i.e. externally defined properties. Data aggregators won't assume that
      each instance with a given property could have such an operation.\nAnother approach would require the API to elevate a specific property
      to Link, which can accept a supportedOperation. This
      is more intuitive in APIs operating with internally used vocabularies
      where assumption that every instance with that very specific property
      has the operation attached available.\nDirect usage of supportedOperation on rdf:Property
      without elevating it to the Link SHOULD NOT be implemented as clients
      may not discover such a construct correctly.\nThese are the simple example scenarios and possible usages are not
      limited to those described above.\nDue to the fact an ApiDocumentation as all other resources may fail
      at runtime, it is important to take countermeasures.
      A simple strategy to try to recover from such a situation would be to reload
      the ApiDocumentation and redo all pre-computations that were
      based on the ApiDocumentation (or at least those that lead
      to the current failure). Another, simpler approach would require
      an application to show an error message with option to return
      to a previous or home screen.\nDescribe the various properties of an operation.\nHydra also allows enriching both ApiDocumentation and
      hypermedia controls with human-readable descriptions by applying
      title and description (as shown in the examples above).
      The former states a name of such a decorated element that could
      be displayed as a label. The latter provides its description
      to be presented i.e. as a hint.\nAforementioned title and description SHOULD take precedence
      over standard rdfs:label and rdfs:comment.\nThere is one more feature related to how Linked Data works. Consider the
      example below written in turtle syntax:\nand how it could be transformed with JSON-LD framing process:\nAs you can see, additional details about ex:SomeType went
      missing, while this shouldn't happen. The fact that the IRI mentioned
      is an rdfs:Class may be meaningful for a correct interpretation
      of the received payload and this is a sole reason of why a Client
      SHOULD NOT disregard other parts of the payload that are not directly
      related to the API documentation or other hypermedia controls.\nDiscovering a Hydra-powered Web API\nThe first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look for a Link Header with a relation type
      http://www.w3.org/ns/hydra/core#apiDocumentation (this is
      the IRI identifying the hydra:apiDocumentation property).\nIn the following example, a Hydra client simply accesses the
      homepage of an API publisher (http://www.example.com)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.\nThe response in the example above contains an HTTP Link Header
      pointing to http://api.example.com/doc/.
      Retrieving that resource, the client would obtain a
      Hydra API documentation defining the API's main entry
      point:\nHydra API documentation\nPlease note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.\nIn another scenario the ApiDocumentation would be discovered from
      a bookmarked resource's representation. Api implementation SHOULD emit
      the HTTP Link header on every Api response, making
      the ApiDocumentation (and entry points it defines) discoverable
      all the time.\nIt is common to provide a separate API address after a breaking changes
      update. This prevents current clients not to get broken as these may not
      support these changes.\nWith hypermedia provided in each response payload, it may be unnecessary
      to provide such an alternative API. This is due to fact the client follows
      what the server provides and with proper margin for errors implemented
      within that client, even breaking changes can be published on the fly.\nStill, Hydra does neither have any special support for API versions, nor
      prevents them. It's fully an implementers decision on if and how
      to provide the API features.\nDescribe Hydra's Resource class? Or should that better be
    described somewhere in the beginning?\nIn many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes hydra:Collection and
      hydra:PartialCollectionView.\nA hydra:Collection can be used to reference a set of resources
      as follows:\nAs shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.\nSince collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a hydra:PartialCollectionView. It describes a specific
      view on the collection which represents only a subset of the collection's
      members. A PartialCollectionView may contain links to the
      first, next, previous, and last
      PartialCollectionView which allows a client to find all members
      of a Collection.\nSay that all these properties are optional? What about
      first and, perhaps more interestingly, last?\nA memberAssertion is a way to declare additional, implicit statements about
      members of a collection. Statements which may otherwise
      be missing from the respective member resources inlined in a collection's
      representation.\nIn the above example, adding a memberAssertion node to the collection instructs the
      client that every member of this collection is linked to the subject
      by the property. It could be written as a SPARQL triple pattern below, where
      ?m would be substituted by each member of the collection.\nA memberAssertion MUST use two and only two of the subject, property
      and object predicates. There memberAssertion predicate MAY have more than one
      such blocks, each expressing different relations between the collection members and other resources.\nIt's important to point out that the subject, property
      and object predicates are defined within the Hydra namespace and are not
      rdf terms.\nSometimes, it is impossible for a server to construct a URL because
      the URL depends on information only known by the client. A typical
      use case are URLs which enable a client to query the server. In such
      a case, the server cannot construct the URL because it does not know
      the query the client is interested in. What the server can do however,
      is to give the client a template to construct such a URL at runtime.
      In Hydra, the IriTemplate class is used to do so.\nAn IriTemplate consists of a template literal and a set
      of mappings. Each IriTemplateMapping maps a
      variable used in the template to a property and may
      optionally specify whether that variable is required or not.
      The syntax of the template literal is specified by its datatype and
      defaults to the [[!RFC6570]] URI Template syntax, which can be
      explicitly indicated by hydra:Rfc6570Template.\nThe example above maps the variable q to Hydra's
      freetextQuery property and marks it as required.
      As its name suggests, the freetextQuery property can be used
      for free text queries.\nA template syntax only details how to fill out simple string values,
      but not how to derive such string values from typed values,
      language-tagged strings, or IRIs. Hydra addresses this by
      specifying how such values are to be serialized as strings. The
      serialization of an IriTemplate's variables can be described
      by setting the variableRepresentation property to
      BasicRepresentation or ExplicitRepresentation. The
      BasicRepresentation represents values by their lexical form. It
      omits type and language information and does not differentiate between
      IRIs and literals. The ExplicitRepresentation, on the other
      hand, includes type and language information and differentiates
      between IRIs and literals by serializing values as follows:\nIRIs are represented as-is.\nLiterals, i.e., (typed) values and language-tagged strings are
        represented by their lexical form, surrounded by a single pair of
        doubles quotes (").\nIf a literal has a language, a single @ symbol is
        appended after the double-quoted lexical form, followed by a
        non-empty [[BCP47]] language code.\nIf a literal has a type, two caret symbols
        (^^) are appended after the double-quoted literal,
        followed by the full datatype IRI.\nIn both representations characters MUST NOT be escaped. In case the
      representation format is not explicitly described, clients SHOULD
      use the BasicRepresentation by default.\nAlthough ExplicitRepresentation use of
      @ and ^^ is similar, it is not the
      same as the [[Turtle]] representation for literals. Turtle literals
      require escaping of special characters, surround datatype IRIs with
      angular brackets (< and >), and also
      allow single quotes (') to indicate literals.
      ExplicitRepresentation values must not be escaped, IRIs must
      not be surrounded by any character, and only double quotes can
      indicate literals.\nBelow are some example values serialized in the different
      representations as well as the result of expanding the IRI template
      http://example.com/find/{value} with the respective
      value.\nSimilar to how Hydra's Link class allows the definition of
      properties that represent hyperlinks as described in
      ,
      the TemplatedLink class allows the definition of properties
      whose value are IRI templates. Hydra predefines one such property,
      namely the search property which can be used to document
      available search interfaces.\nIRI expansion should be performed with respect to the specification
      behind the IRI template type (RFC 6570 by default), and the product
      of this process SHOULD be an IRI. When the produced IRI is relative,
      the client SHOULD stick to RFC 3986 sections 5.1.3 and 5.1.4 to be compatible
      with most RDF serializations that support relative IRIs. Still, it may be
      preferred to use another base URI for the expansion process, which
      makes the resolveRelativeTo term useful. It allows to switch the
      IRI template expansion algorithm so the base URI is established using
      current link context, which is a subject of the relation pointing to an
      IriTemplate instance. In case that subject is a relative URI,
      default behavior SHOULD be used as fallback.\nThe example below allows to make the product of an IRI template
      expansion relative to the http://api.example.com/an-issue/ resource
      by using it as its base URI, which further enables the some:operation to
      be moved to i.e. API documentation level rather to inline it.\nWhen constructed, the IRI would effectively become similar to http://api.example.com/an-issue/1234,
      with the relative part {id} appended to the link context URL.\nIRI template operations\nThere are circumstances in which client would like to perform an operation
      not knowing the final IRI of the resource to be called. This case is especially
      in force when working with collections - client may want to add a new
      collection member, or it may need to provide more details while searching
      with other protocol's method (i.e. POST instead of GET in case of an HTTP).\nThis is achievable by attaching a supportedOperation to the property
      that connects a subject of that relation with its IRI template
      as described in the previous part of this document. Please note that
      client is still allowed to use the defined link and custom operation's
      method is optional.\nThe example above allows client to either invoke an HTTP GET or POST
      call on http://api.example.com/issues?search=search_string resource.\nThe example above allows client to invoke only an HTTP POST
      call on http://api.example.com/issues?find=search_string resource as
      the described relation of find is not a Link.\nSupported property data source\nThere are circumstances in which an API would like to inform a client on
      when to obtain values to feed data structures with details. Having all the
      necessary components like supported property, collection and IRI templates,
      it is possible to drive the client and direct it with links and operations
      to the data sources.\nIt is doable by attaching either a collection or search
      predicate to instance of supportedProperty or to property.
      In such case client SHOULD use assume that the relation leads to
      the collection of values compatible with the supported property's range
      and can be used to feed data structures with the supported property.
      It is recommended (but not mandatory) to use freetextQuery
      variable mapping in case of the search predicate as it has a
      well defined semantics and takes the burden of interpretation from
      the client.\nWhile it is possible to provide such links in both API documentation
      and within the received payload, client SHOULD use the latter link first
      if applicable. This is due to fact the the server may want to put additional
      context to narrow the collection of viable values. Redefinition does not
      make the more general one obsolete though and and can be used as a fallback.\nThe example above instructs a client that every resource of type
      schema:Event can have a relation of schema:actor, the objects of which the
      client can obtain using the search link provided.\nDescription of HTTP Status Codes and Errors\nHTTP status codes have well defined semantics and can be used to
      signal the outcome of an operation. Unfortunately, however, HTTP
      status codes by themselves are often not specific enough, making it
      difficult to understand the real cause of an error. For
      instance, a 429 Too Many Requests response is rarely
      informative enough by itself. To address this issue, Hydra defines
      a Status class which allows additional
      information to be associated with an HTTP status code.\nAn ApiDocumentation or an Operation may document the
      status codes that might be returned by the server using the
      possibleStatus property as described in
      . This allows
      a developer to understand what to expect when invoking an operation.
      It has, however, not to be considered as an extensive list of all
      potentially returned status codes; it is merely a hint. Developers
      should expect to encounter other HTTP status codes as well.\nA server may also return a Status directly in
      a response. When doing so, it often makes sense to subclass the
      Status to make its semantics more explicit.
      Hydra defines just one such subclass, namely the Error class.
      This provides an extensible framework to communicate error details to
      a client.\nFurthermore, a Status or Error returned by the server can also
      be given an identifier. When dereferenced, the Error resource can provide
      more detailed information or possible ways to resolve the problem, if applicable.\nFinally, the server SHOULD provide error descriptions using an [[!RFC7807]] standard
      by using an application/problem+json response. When doing so, the server also MUST provide
      an additional header pointing to either the built-in Hydra http://www.w3.org/ns/hydra/error
      context or any JSON-LD context that maps the terms type, title, detail,
      status and instance the same way as the standard one.\nWhile the built-in context makes the response fully compatible with the mentioned specification,
      properties not defined in the standard Hydra's error context won't be visible for Hydra aware processors.
      To overcome this, it is possible to declare a custom context pointed the same way, that would combine standard
      Hydra's standard error context and an additional JSON-LD context with either the @vocab
      or custom property mappings telling the processor on how to interpret those custom error properties.\nResources provided may have an additional hint pointing to an Error type like in the example
      above, but it is not mandatory to do so as all resources described with application/problem+json
      are considered hydra:Error.\nIt is worth to mention that it may happen (i.e. due to proxy behavior) the value of the status property
      will differ to the one received from the protocol layer.\nClient initiated pagination\nThere are situations when a client would like to provide a specific
      collection limitations, i.e. by providing query-language like member
      offset and limit or some specific page index and number of members
      per page. This is doable with offset/limit or
      pageIndex/limit predicates.\nWith those, it is possible to bind a template variables mapped
      with externally obtained values (i.e. user interaction) the same way
      as with other mappings.\nWhile the predicates enlisted above accepts non-negative integer
      numbers, there is also a possibility of providing a custom page
      reference expressed via pageReference predicate. It is possible
      to provide a custom page identifier (i.e. a GUID or a letter)
      instead of a number.\nWhile Hydra Core Vocabulary allows addressing many usage scenarios,
      not every aspect of API behavior can be covered. This
      applies especially to querying, resource projection or data structure
      description. This is due to fact that Hydra is meant to be as light
      as possible forcing to drop some of the features out of its scope.\nThat is why there is a possibility of hinting a client on what kind
      of extensions may be found or used in the received payloads.
      After discovering an extension predicate in the API documentation,
      client can assume additional details are available described with
      complementary vocabularies.\nIt is up to the used vocabulary to define how these additional details should be
      interpreted. In case client does not recognize these extensions,
      additional details should be ignored and base Hydra interpretation
      should be in force.\nServer SHOULD NOT use extensions to add statements that are in
      contradiction to base Hydra interpretation so the client is not confused.
      Server SHOULD also keep multiple extensions describing adequate
      knowledge in line regarding their description (i.e. data structure
      descriptions in various vocabularies should not cause differences).\nClient can express its preferences through the Prefer HTTP header
      by pointing the preferred extensions via IRIs as on the example below.
      The client SHOULD use the Prefer HTTP header [[!RFC7240]] with
      the hydra.extension preference as an iri attribute having
      the IRI of the extension as value to hint the server about the extension
      it supports. Multiple preferences can be expressed by providing multiple
      Prefer header values.\nServer MUST implement Prefer header handling according to
      the [[!RFC7240]] and implementers should proceed with caution.\nThe authors would like to thank the following individuals for contributing
    their ideas and providing feedback for writing this specification:
    Arnau Siches, elf Pavlik, Karol Szczepański, Mark Baker, Martijn Faassen,
    Matthias Lehmann, Ruben Verborgh, Ryan J. McDonough, Sam Goto,
    Thomas Hoppe, Tomasz Pluskiewicz, @wasabiwimp (on GitHub).\nThe Hydra Core Vocabulary in JSON-LD\n\n\nHydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.\nThis entire document is a work in progress and several
    sections are incomplete, missing, or outdated. All open issues and decisions
    are documented in our
    issue tracker.
    If you have questions, please don't hesitate to
    join the Hydra W3C Community Group and post to the mailing list.\njoin the Hydra W3C Community Group and post to the mailing list.\nThis specification was published by the
    Hydra W3C Community Group. It is
    not a W3C Standard nor is it on the W3C Standards Track. Please note that under the
    W3C Community Contributor License Agreement (CLA)
    there is a limited opt-out and other conditions apply. Learn more about
    W3C Community and Business Groups.\nHydra W3C Community Group\nW3C Community Contributor License Agreement (CLA)\nW3C Community and Business Groups\nTo participate in the development of this specification, please join the
    Hydra W3C Community Group. If
    you have questions, want to suggest a feature, or raise an issue, please send a mail to the
    public-hydra@w3.org mailing list.\nHydra W3C Community Group\npublic-hydra@w3.org mailing list\nCoping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.\nThe combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.\nThis specification describes the conformance criteria for
    Hydra API documentations
    and Hydra clients. These criteria are
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.\nConformance for Hydra clients should probably not be
    specified in this document.\nAdd normative statements\nThe key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].\nThe basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.\nThe namespace of the Hydra core vocabulary is
    http://www.w3.org/ns/hydra/core#, and the suggested prefix
    is hydra. The figure below illustrates the vocabulary (the
    figure’s goal is to show how Hydra is used rather than its precise
    definition).\nIs this illustration clear enough or is it confusing?
    Feedback would be much appreciated.\nThe Hydra core vocabulary\nThe Hydra core vocabulary\nAdd ranges for Operation "members"\nAn alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.\nThe used prefixes should be documented somewhere.\nThroughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.\nAdding Affordances to Representations\nThe exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.\nThe simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type—a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.\nIn Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.\nGenerally, a client decides whether to follow a link or not based on
      the link relation (or property in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every link
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <a> tag) are
      followed but most references in link elements (the
      <link> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      if a property represents a link intended to be
      dereferenced or solely an identifier. Hydra's
      Link class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can be used to define a property
      linking issues to their comments:\nIn the example above, a property identified with the URL
      http://api.example.com/vocab#comments is defined to be
      of the type Link. This is enough information for a client
      understanding Hydra to know that the value of the
      comments property in the following example is intended
      to be dereferenced.\nIt is recommended to dereference resources that are
      within an API's domain. This may prevent possible issues with cross-site
      scripting or obtaining resources which might have no meaning
      to the client or such that the client would be unable to interpret.
      Still, there is no formal prohibition of dereferencing resources
      linked with well-known properties, e.g. rdf:seeAlso.\nIn the example above, the value of the comments
      property is a JSON object with an @id member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:\nWhile links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      Operation represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      Operation is its HTTP method. Optionally, it is
      also possible to describe what information the server expects
      or returns, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.\nThe following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them.\nThe example above references Hydra's context to map properties such
      as operation and method and values like
      Operation to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.\nIt is worth mentioning that due to the fact that Hydra is built on
      RDF, which is a graph, it may happen that a related resource
      (an object of the relation) may not be fully described in the
      resource's payload. In several circumstances (i.e. payload terms
      defined in API documentation sa described in
      Documenting a Web API
      or IriTemplate expected as a related resource as described in
      Templated Links) client may
      discover no additional statements describing it. These rules should
      be considered by the client in following scenarios:\nDocumenting a Web API\nin case of an object expected to be a hypermedia resource does not have all
        the necessary statements for which it is a subject, the client SHOULD look in the
        API documentation for more details\nin case the mentioned object, after consulting an API documentation, still
        does not have all the necessary statements for which it is a subject and both
        mentioned object's Url and Url of the initially obtained resource has the
        same scheme and authority (by means of [[!RFC3986]] sections 3.1 and 3.2), the client
        SHOULD de-reference that Url. If the resource does not have the same scheme and
        authority the client MAY choose to de-reference it (for example if the resource
        originates from another API well-known to the client)\nin case the mentioned object still does not have all the necessary
        statements for which it is a subject (i.e. de-referencing it failed
        or statements are missing), the client SHOULD either ignore the whole
        statement (i.e. for display purposes) or throw an exception (i.e. an
        IriTemplate is about to be resolved and de-referenced)\nExample of each of the situations are as follows:\nresource http://api.example.com/people should have an IriTemplate available
        as there is a complete definition of the template available at http://api.example.com/doc/.\nresource http://api.example.com/events should not have an Iri template exposed as there
        are no additional details available, neither in the initial resources' payload nor in the API documentation.\nKeep in mind that any resource described by any hypermedia control
      may fail at runtime due to various reasons. Operation details
      such as returns or possibleStatus may also vary at runtime,
      which means client SHOULD always verify received payloads at runtime.\nDocumenting a Web API\nIn Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.\nHydra's ApiDocumentation class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.\nIn Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.\nThese differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.\nMention that Hydra classes are dereferenceable
      resources.\nSince Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      supportedProperty references an intermediate data structure,
      namely instances of the SupportedProperty class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.\nAll instances of a specific class typically support the same
      operations. Hydra therefore features a supportedOperation
      property which defines the operations supported by all instances of
      a class.\nThe same feature can be used to describe the operations supported
      by values of a Link property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.\nExample shown below describes the operation's expected and returned
      value as a dereferencable resource (an RDF resource of a given class),
      but the vocabulary is not limited to only those originating
      from RDF and is enabled to other types of resources.
      Please note that in case of multiple either returned or expected types
      provided, client SHOULD assume the set includes any of the types,
      but not limited to those types and client SHOULD interpret received
      payload at runtime for possible discrepancies.\nIn addition to expected/returned resources, it is also possible to
      express similar features for headers with returnsHeader and
      expectsHeader predicates which provides a simple set of header
      names. Client SHOULD apply respective header semantics when creating
      or receiving a request natural for the protocol in use.\nThe example above enable an HTTP client to prepare a proper cross-site
      pre-flight request so the server exposes enlisted headers for the client.
      The client is also aware of the user authentication requirement necessary
      for the operation invocation.\nFor more complex scenarios it is also possible to expand selected header
      specification with both name and possible values, i.e. when defining
      expected Content-Type values of resources that can be uploaded.
      In case multiple possible values are provided, client SHOULD assume
      that the set includes any of the values, but not limited to those values.
      In order to change that default behavior it is possible to use closedSet
      predicate on the header specification indicating that the set of provided
      values is, well, closed and no other values are available. In both case the client
      SHOULD interpret received payload at runtime for possible discrepancies.\nTo wrap up everything altogether, it is also possible to attach atomic
      operations supported by, well, supported property itself. This might
      come in handy for scenarios, when resource can be partially modified.
      It can be achieved with two approaches, both having advantages and
      disadvantages.\nFirst approach would involve adding a supportedOperation to the
      intermediate structure of SupportedProperty.
      This way prevents from leaking API specific features from the API itself
      to i.e. externally defined properties. Data aggregators won't assume that
      each instance with a given property could have such an operation.\nAnother approach would require the API to elevate a specific property
      to Link, which can accept a supportedOperation. This
      is more intuitive in APIs operating with internally used vocabularies
      where assumption that every instance with that very specific property
      has the operation attached available.\nDirect usage of supportedOperation on rdf:Property
      without elevating it to the Link SHOULD NOT be implemented as clients
      may not discover such a construct correctly.\nThese are the simple example scenarios and possible usages are not
      limited to those described above.\nDue to the fact an ApiDocumentation as all other resources may fail
      at runtime, it is important to take countermeasures.
      A simple strategy to try to recover from such a situation would be to reload
      the ApiDocumentation and redo all pre-computations that were
      based on the ApiDocumentation (or at least those that lead
      to the current failure). Another, simpler approach would require
      an application to show an error message with option to return
      to a previous or home screen.\nDescribe the various properties of an operation.\nHydra also allows enriching both ApiDocumentation and
      hypermedia controls with human-readable descriptions by applying
      title and description (as shown in the examples above).
      The former states a name of such a decorated element that could
      be displayed as a label. The latter provides its description
      to be presented i.e. as a hint.\nAforementioned title and description SHOULD take precedence
      over standard rdfs:label and rdfs:comment.\nThere is one more feature related to how Linked Data works. Consider the
      example below written in turtle syntax:\nand how it could be transformed with JSON-LD framing process:\nAs you can see, additional details about ex:SomeType went
      missing, while this shouldn't happen. The fact that the IRI mentioned
      is an rdfs:Class may be meaningful for a correct interpretation
      of the received payload and this is a sole reason of why a Client
      SHOULD NOT disregard other parts of the payload that are not directly
      related to the API documentation or other hypermedia controls.\nDiscovering a Hydra-powered Web API\nThe first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look for a Link Header with a relation type
      http://www.w3.org/ns/hydra/core#apiDocumentation (this is
      the IRI identifying the hydra:apiDocumentation property).\nIn the following example, a Hydra client simply accesses the
      homepage of an API publisher (http://www.example.com)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.\nThe response in the example above contains an HTTP Link Header
      pointing to http://api.example.com/doc/.
      Retrieving that resource, the client would obtain a
      Hydra API documentation defining the API's main entry
      point:\nHydra API documentation\nPlease note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.\nIn another scenario the ApiDocumentation would be discovered from
      a bookmarked resource's representation. Api implementation SHOULD emit
      the HTTP Link header on every Api response, making
      the ApiDocumentation (and entry points it defines) discoverable
      all the time.\nIt is common to provide a separate API address after a breaking changes
      update. This prevents current clients not to get broken as these may not
      support these changes.\nWith hypermedia provided in each response payload, it may be unnecessary
      to provide such an alternative API. This is due to fact the client follows
      what the server provides and with proper margin for errors implemented
      within that client, even breaking changes can be published on the fly.\nStill, Hydra does neither have any special support for API versions, nor
      prevents them. It's fully an implementers decision on if and how
      to provide the API features.\nDescribe Hydra's Resource class? Or should that better be
    described somewhere in the beginning?\nIn many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes hydra:Collection and
      hydra:PartialCollectionView.\nA hydra:Collection can be used to reference a set of resources
      as follows:\nAs shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.\nSince collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a hydra:PartialCollectionView. It describes a specific
      view on the collection which represents only a subset of the collection's
      members. A PartialCollectionView may contain links to the
      first, next, previous, and last
      PartialCollectionView which allows a client to find all members
      of a Collection.\nSay that all these properties are optional? What about
      first and, perhaps more interestingly, last?\nA memberAssertion is a way to declare additional, implicit statements about
      members of a collection. Statements which may otherwise
      be missing from the respective member resources inlined in a collection's
      representation.\nIn the above example, adding a memberAssertion node to the collection instructs the
      client that every member of this collection is linked to the subject
      by the property. It could be written as a SPARQL triple pattern below, where
      ?m would be substituted by each member of the collection.\nA memberAssertion MUST use two and only two of the subject, property
      and object predicates. There memberAssertion predicate MAY have more than one
      such blocks, each expressing different relations between the collection members and other resources.\nIt's important to point out that the subject, property
      and object predicates are defined within the Hydra namespace and are not
      rdf terms.\nSometimes, it is impossible for a server to construct a URL because
      the URL depends on information only known by the client. A typical
      use case are URLs which enable a client to query the server. In such
      a case, the server cannot construct the URL because it does not know
      the query the client is interested in. What the server can do however,
      is to give the client a template to construct such a URL at runtime.
      In Hydra, the IriTemplate class is used to do so.\nAn IriTemplate consists of a template literal and a set
      of mappings. Each IriTemplateMapping maps a
      variable used in the template to a property and may
      optionally specify whether that variable is required or not.
      The syntax of the template literal is specified by its datatype and
      defaults to the [[!RFC6570]] URI Template syntax, which can be
      explicitly indicated by hydra:Rfc6570Template.\nThe example above maps the variable q to Hydra's
      freetextQuery property and marks it as required.
      As its name suggests, the freetextQuery property can be used
      for free text queries.\nA template syntax only details how to fill out simple string values,
      but not how to derive such string values from typed values,
      language-tagged strings, or IRIs. Hydra addresses this by
      specifying how such values are to be serialized as strings. The
      serialization of an IriTemplate's variables can be described
      by setting the variableRepresentation property to
      BasicRepresentation or ExplicitRepresentation. The
      BasicRepresentation represents values by their lexical form. It
      omits type and language information and does not differentiate between
      IRIs and literals. The ExplicitRepresentation, on the other
      hand, includes type and language information and differentiates
      between IRIs and literals by serializing values as follows:\nIRIs are represented as-is.\nLiterals, i.e., (typed) values and language-tagged strings are
        represented by their lexical form, surrounded by a single pair of
        doubles quotes (").\nIf a literal has a language, a single @ symbol is
        appended after the double-quoted lexical form, followed by a
        non-empty [[BCP47]] language code.\nIf a literal has a type, two caret symbols
        (^^) are appended after the double-quoted literal,
        followed by the full datatype IRI.\nIn both representations characters MUST NOT be escaped. In case the
      representation format is not explicitly described, clients SHOULD
      use the BasicRepresentation by default.\nAlthough ExplicitRepresentation use of
      @ and ^^ is similar, it is not the
      same as the [[Turtle]] representation for literals. Turtle literals
      require escaping of special characters, surround datatype IRIs with
      angular brackets (< and >), and also
      allow single quotes (') to indicate literals.
      ExplicitRepresentation values must not be escaped, IRIs must
      not be surrounded by any character, and only double quotes can
      indicate literals.\nBelow are some example values serialized in the different
      representations as well as the result of expanding the IRI template
      http://example.com/find/{value} with the respective
      value.\nSimilar to how Hydra's Link class allows the definition of
      properties that represent hyperlinks as described in
      ,
      the TemplatedLink class allows the definition of properties
      whose value are IRI templates. Hydra predefines one such property,
      namely the search property which can be used to document
      available search interfaces.\nIRI expansion should be performed with respect to the specification
      behind the IRI template type (RFC 6570 by default), and the product
      of this process SHOULD be an IRI. When the produced IRI is relative,
      the client SHOULD stick to RFC 3986 sections 5.1.3 and 5.1.4 to be compatible
      with most RDF serializations that support relative IRIs. Still, it may be
      preferred to use another base URI for the expansion process, which
      makes the resolveRelativeTo term useful. It allows to switch the
      IRI template expansion algorithm so the base URI is established using
      current link context, which is a subject of the relation pointing to an
      IriTemplate instance. In case that subject is a relative URI,
      default behavior SHOULD be used as fallback.\nThe example below allows to make the product of an IRI template
      expansion relative to the http://api.example.com/an-issue/ resource
      by using it as its base URI, which further enables the some:operation to
      be moved to i.e. API documentation level rather to inline it.\nWhen constructed, the IRI would effectively become similar to http://api.example.com/an-issue/1234,
      with the relative part {id} appended to the link context URL.\nIRI template operations\nThere are circumstances in which client would like to perform an operation
      not knowing the final IRI of the resource to be called. This case is especially
      in force when working with collections - client may want to add a new
      collection member, or it may need to provide more details while searching
      with other protocol's method (i.e. POST instead of GET in case of an HTTP).\nThis is achievable by attaching a supportedOperation to the property
      that connects a subject of that relation with its IRI template
      as described in the previous part of this document. Please note that
      client is still allowed to use the defined link and custom operation's
      method is optional.\nThe example above allows client to either invoke an HTTP GET or POST
      call on http://api.example.com/issues?search=search_string resource.\nThe example above allows client to invoke only an HTTP POST
      call on http://api.example.com/issues?find=search_string resource as
      the described relation of find is not a Link.\nSupported property data source\nThere are circumstances in which an API would like to inform a client on
      when to obtain values to feed data structures with details. Having all the
      necessary components like supported property, collection and IRI templates,
      it is possible to drive the client and direct it with links and operations
      to the data sources.\nIt is doable by attaching either a collection or search
      predicate to instance of supportedProperty or to property.
      In such case client SHOULD use assume that the relation leads to
      the collection of values compatible with the supported property's range
      and can be used to feed data structures with the supported property.
      It is recommended (but not mandatory) to use freetextQuery
      variable mapping in case of the search predicate as it has a
      well defined semantics and takes the burden of interpretation from
      the client.\nWhile it is possible to provide such links in both API documentation
      and within the received payload, client SHOULD use the latter link first
      if applicable. This is due to fact the the server may want to put additional
      context to narrow the collection of viable values. Redefinition does not
      make the more general one obsolete though and and can be used as a fallback.\nThe example above instructs a client that every resource of type
      schema:Event can have a relation of schema:actor, the objects of which the
      client can obtain using the search link provided.\nDescription of HTTP Status Codes and Errors\nHTTP status codes have well defined semantics and can be used to
      signal the outcome of an operation. Unfortunately, however, HTTP
      status codes by themselves are often not specific enough, making it
      difficult to understand the real cause of an error. For
      instance, a 429 Too Many Requests response is rarely
      informative enough by itself. To address this issue, Hydra defines
      a Status class which allows additional
      information to be associated with an HTTP status code.\nAn ApiDocumentation or an Operation may document the
      status codes that might be returned by the server using the
      possibleStatus property as described in
      . This allows
      a developer to understand what to expect when invoking an operation.
      It has, however, not to be considered as an extensive list of all
      potentially returned status codes; it is merely a hint. Developers
      should expect to encounter other HTTP status codes as well.\nA server may also return a Status directly in
      a response. When doing so, it often makes sense to subclass the
      Status to make its semantics more explicit.
      Hydra defines just one such subclass, namely the Error class.
      This provides an extensible framework to communicate error details to
      a client.\nFurthermore, a Status or Error returned by the server can also
      be given an identifier. When dereferenced, the Error resource can provide
      more detailed information or possible ways to resolve the problem, if applicable.\nFinally, the server SHOULD provide error descriptions using an [[!RFC7807]] standard
      by using an application/problem+json response. When doing so, the server also MUST provide
      an additional header pointing to either the built-in Hydra http://www.w3.org/ns/hydra/error
      context or any JSON-LD context that maps the terms type, title, detail,
      status and instance the same way as the standard one.\nWhile the built-in context makes the response fully compatible with the mentioned specification,
      properties not defined in the standard Hydra's error context won't be visible for Hydra aware processors.
      To overcome this, it is possible to declare a custom context pointed the same way, that would combine standard
      Hydra's standard error context and an additional JSON-LD context with either the @vocab
      or custom property mappings telling the processor on how to interpret those custom error properties.\nResources provided may have an additional hint pointing to an Error type like in the example
      above, but it is not mandatory to do so as all resources described with application/problem+json
      are considered hydra:Error.\nIt is worth to mention that it may happen (i.e. due to proxy behavior) the value of the status property
      will differ to the one received from the protocol layer.\nClient initiated pagination\nThere are situations when a client would like to provide a specific
      collection limitations, i.e. by providing query-language like member
      offset and limit or some specific page index and number of members
      per page. This is doable with offset/limit or
      pageIndex/limit predicates.\nWith those, it is possible to bind a template variables mapped
      with externally obtained values (i.e. user interaction) the same way
      as with other mappings.\nWhile the predicates enlisted above accepts non-negative integer
      numbers, there is also a possibility of providing a custom page
      reference expressed via pageReference predicate. It is possible
      to provide a custom page identifier (i.e. a GUID or a letter)
      instead of a number.\nWhile Hydra Core Vocabulary allows addressing many usage scenarios,
      not every aspect of API behavior can be covered. This
      applies especially to querying, resource projection or data structure
      description. This is due to fact that Hydra is meant to be as light
      as possible forcing to drop some of the features out of its scope.\nThat is why there is a possibility of hinting a client on what kind
      of extensions may be found or used in the received payloads.
      After discovering an extension predicate in the API documentation,
      client can assume additional details are available described with
      complementary vocabularies.\nIt is up to the used vocabulary to define how these additional details should be
      interpreted. In case client does not recognize these extensions,
      additional details should be ignored and base Hydra interpretation
      should be in force.\nServer SHOULD NOT use extensions to add statements that are in
      contradiction to base Hydra interpretation so the client is not confused.
      Server SHOULD also keep multiple extensions describing adequate
      knowledge in line regarding their description (i.e. data structure
      descriptions in various vocabularies should not cause differences).\nClient can express its preferences through the Prefer HTTP header
      by pointing the preferred extensions via IRIs as on the example below.
      The client SHOULD use the Prefer HTTP header [[!RFC7240]] with
      the hydra.extension preference as an iri attribute having
      the IRI of the extension as value to hint the server about the extension
      it supports. Multiple preferences can be expressed by providing multiple
      Prefer header values.\nServer MUST implement Prefer header handling according to
      the [[!RFC7240]] and implementers should proceed with caution.\nThe authors would like to thank the following individuals for contributing
    their ideas and providing feedback for writing this specification:
    Arnau Siches, elf Pavlik, Karol Szczepański, Mark Baker, Martijn Faassen,
    Matthias Lehmann, Ruben Verborgh, Ryan J. McDonough, Sam Goto,
    Thomas Hoppe, Tomasz Pluskiewicz, @wasabiwimp (on GitHub).\nThe Hydra Core Vocabulary in JSON-LD\n\n\nHydra simplifies the development of interoperable, hypermedia-driven Web APIs

              Building Web APIs seems still more an art than a science. How can we build APIs such that generic clients can easily use them? And how do we build those clients? Current APIs heavily rely on out-of-band information such as human-readable documentation and API-specific SDKs. However, this only allows for very simple and brittle clients that are hardcoded against specific APIs. Hydra, in contrast, is a set of technologies that allow to design APIs in a different manner, in a way that enables smarter clients.
          
      

      
          
              Hydra Core Vocabulary

              Essential building blocks for machine-accessible Hypermedia APIs

              Read the specification

              There also exists a demo Web API featuring a simple issue tracker which allows you to play with Hydra directly in your web browser.

          
          
              Linked Data Fragments

              API and client designs to publish and query Linked Data at Web-scale

              Get familiar with Linked Data Fragments or read the triple pattern fragments specification

              Various LDF data sources are already available. Query them.
          
          
              Join the Working Group
              Wanna help? Then join the Hydra W3C Community Group. Here's how:

              
                Get a free W3C account (it may take a while to get approved).
                Join the Hydra W3C Community Group.
                Bonus points: Send an email to introduce yourself to the group.
              
          
      

      
          
              Tools/Libraries/​Applications

              
                HydraConsole: a generic API console
                  for Hydra-powered Web APIs
                HydraBundle: a bundle for
                  Symfony2 to create Web APIs based on Hydra
                  (demo application)
                API Platform: a PHP framework to build Web APIs
                  with JSON-LD, Schema.org and Hydra
                hydra-java: annotate your Java beans
                  and serialize them as JSON-LD with Hydra
                URSA: a framework written in C# to create
                  Hydra-powered Web APIs
                hydrus: a set of Python based tools to create
                  Hydra-powered Web APIs
                Levanzo: Clojure library to build hypermedia driven RESTful APIs
                Argolis: Hydra hypermedia controls for .NET web applications written in Nancy
                hydra-core: a JavaScript library to work
                  with Hydra-enabled Web APIs
                SmallHydra: a small Hydra library for the ESP8266 and Arduino platform
                hydra-py: a Hydra library for Python
                  (including a Triple Patterns Fragments client)
                Alcaeus: a Hydra client library written in TypeScript
                HydraClient: a PHP client library to
                  access Hydra-powered Web APIs
                api-doc-parser: a JavaScript library to parse Hydra API documentations
                JsonLD: a JSON-LD processor implemented in PHP
                Linked Data Fragments Server: serve triple pattern fragments
                  (JavaScript,
                  Java,
                  NetKernel)
                Linked Data Fragments Client: query a Linked Data Fragments API
                  (JavaScript,
                  browser,
                  Java)
              
          
      

      
          
              Publications/​Presentations

              
                M. Lanthaler,
                  “The Web Is Changing — From Strings to Things,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                M. Lanthaler,
                  “Why and How to Optimize Your Data Architecture for an Integrated Future,”
                  presented at Presented at APIcon UK 2014 in London, England.
                  [video].
                T. Hoppe,
                  “REST APIs Today and Tomorrow - an Essay,”
                  presented at several Meetups.
                M. Lanthaler,
                  “Creating Awesome Web APIs is a Breeze,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                T. Pluskiewicz,
                  “JSON-LD and Hydra - Hypermedia API alternatively,”
                  presented at Meet.js Wrocław 2014.
                M. Lanthaler,
                  “A Deep Dive into JSON-LD and Hydra,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “Stop Reinventing the Wheel! Use Linked Data to Build Better APIs,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “The Web 3.0 is just around the corner. Be prepared!,”
                  presented at APIdays Berlin, 2014.
                R. Verborgh,
                  “The Lonesome LOD Cloud,”
                  presented at the 4th USEWOD Workshop on Usage Analysis and the Web of Data, 2014.
                R. Verborgh, M. Vander Sande, P. Colpaert,
                  S. Coppens, E. Mannens, and R. Van de Walle,
                  “Web-Scale Querying through Linked Data Fragments,”
                  in Proceedings of the 7th Workshop on Linked Data on the Web (LDOW2014) at the 23nd International
                  World Wide Web Conference (WWW2014), 2014 [slides].
                M. Lanthaler,
                  “Full-on Hypermedia APIs with Hydra,”
                  presented at the API Strategy & Practice Conference, 2014 [video].
                R. Verborgh,
                  “Hypermedia cannot be the engine,”
                  presented at the API Strategy & Practice Conference, 2014.
                C. Pautasso, E. Wilde, and R. Alarcon (editors),
                  “REST: Advanced Research Topics and Practical Applications,”
                  Springer New York, 2014.
                L. Richardson, M. Amundsen, and S. Ruby,
                  “RESTful Web APIs,” O’Reilly Media, 2013.
                M. Lanthaler,
                  “Building Next-Generation Web APIs with JSON-LD and Hydra,”
                  presented at Symfony Live Portland 2013 [slides]
                  [video].
                M. Lanthaler and C. Gütl,
                  “Hydra: A Vocabulary for Hypermedia-Driven Web APIs,”
                  in Proceedings of the 6th Workshop on Linked Data on the Web (LDOW2013) at the 22nd International
                  World Wide Web Conference (WWW2013), 2013 [slides].
                M. Lanthaler, “Creating 3rd Generation Web APIs with Hydra,”
                  in Proceedings of the 22nd International World Wide Web Conference (WWW2013), 2013, pp. 35–37
                  [slides].
                M. Lanthaler and C. Gütl,
                  “Model Your Application Domain, Not Your JSON Structures,”
                  in Proceedings of the 4th International Workshop on RESTful Design (WS-REST 2013) at the
                  22nd International World Wide Web Conference (WWW2013), 2013, pp. 1415–1420
                  [slides].\n\n\n\nHydra simplifies the development of interoperable, hypermedia-driven Web APIs

              Building Web APIs seems still more an art than a science. How can we build APIs such that generic clients can easily use them? And how do we build those clients? Current APIs heavily rely on out-of-band information such as human-readable documentation and API-specific SDKs. However, this only allows for very simple and brittle clients that are hardcoded against specific APIs. Hydra, in contrast, is a set of technologies that allow to design APIs in a different manner, in a way that enables smarter clients.
          
      

      
          
              Hydra Core Vocabulary

              Essential building blocks for machine-accessible Hypermedia APIs

              Read the specification

              There also exists a demo Web API featuring a simple issue tracker which allows you to play with Hydra directly in your web browser.

          
          
              Linked Data Fragments

              API and client designs to publish and query Linked Data at Web-scale

              Get familiar with Linked Data Fragments or read the triple pattern fragments specification

              Various LDF data sources are already available. Query them.
          
          
              Join the Working Group
              Wanna help? Then join the Hydra W3C Community Group. Here's how:

              
                Get a free W3C account (it may take a while to get approved).
                Join the Hydra W3C Community Group.
                Bonus points: Send an email to introduce yourself to the group.
              
          
      

      
          
              Tools/Libraries/​Applications

              
                HydraConsole: a generic API console
                  for Hydra-powered Web APIs
                HydraBundle: a bundle for
                  Symfony2 to create Web APIs based on Hydra
                  (demo application)
                API Platform: a PHP framework to build Web APIs
                  with JSON-LD, Schema.org and Hydra
                hydra-java: annotate your Java beans
                  and serialize them as JSON-LD with Hydra
                URSA: a framework written in C# to create
                  Hydra-powered Web APIs
                hydrus: a set of Python based tools to create
                  Hydra-powered Web APIs
                Levanzo: Clojure library to build hypermedia driven RESTful APIs
                Argolis: Hydra hypermedia controls for .NET web applications written in Nancy
                hydra-core: a JavaScript library to work
                  with Hydra-enabled Web APIs
                SmallHydra: a small Hydra library for the ESP8266 and Arduino platform
                hydra-py: a Hydra library for Python
                  (including a Triple Patterns Fragments client)
                Alcaeus: a Hydra client library written in TypeScript
                HydraClient: a PHP client library to
                  access Hydra-powered Web APIs
                api-doc-parser: a JavaScript library to parse Hydra API documentations
                JsonLD: a JSON-LD processor implemented in PHP
                Linked Data Fragments Server: serve triple pattern fragments
                  (JavaScript,
                  Java,
                  NetKernel)
                Linked Data Fragments Client: query a Linked Data Fragments API
                  (JavaScript,
                  browser,
                  Java)
              
          
      

      
          
              Publications/​Presentations

              
                M. Lanthaler,
                  “The Web Is Changing — From Strings to Things,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                M. Lanthaler,
                  “Why and How to Optimize Your Data Architecture for an Integrated Future,”
                  presented at Presented at APIcon UK 2014 in London, England.
                  [video].
                T. Hoppe,
                  “REST APIs Today and Tomorrow - an Essay,”
                  presented at several Meetups.
                M. Lanthaler,
                  “Creating Awesome Web APIs is a Breeze,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                T. Pluskiewicz,
                  “JSON-LD and Hydra - Hypermedia API alternatively,”
                  presented at Meet.js Wrocław 2014.
                M. Lanthaler,
                  “A Deep Dive into JSON-LD and Hydra,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “Stop Reinventing the Wheel! Use Linked Data to Build Better APIs,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “The Web 3.0 is just around the corner. Be prepared!,”
                  presented at APIdays Berlin, 2014.
                R. Verborgh,
                  “The Lonesome LOD Cloud,”
                  presented at the 4th USEWOD Workshop on Usage Analysis and the Web of Data, 2014.
                R. Verborgh, M. Vander Sande, P. Colpaert,
                  S. Coppens, E. Mannens, and R. Van de Walle,
                  “Web-Scale Querying through Linked Data Fragments,”
                  in Proceedings of the 7th Workshop on Linked Data on the Web (LDOW2014) at the 23nd International
                  World Wide Web Conference (WWW2014), 2014 [slides].
                M. Lanthaler,
                  “Full-on Hypermedia APIs with Hydra,”
                  presented at the API Strategy & Practice Conference, 2014 [video].
                R. Verborgh,
                  “Hypermedia cannot be the engine,”
                  presented at the API Strategy & Practice Conference, 2014.
                C. Pautasso, E. Wilde, and R. Alarcon (editors),
                  “REST: Advanced Research Topics and Practical Applications,”
                  Springer New York, 2014.
                L. Richardson, M. Amundsen, and S. Ruby,
                  “RESTful Web APIs,” O’Reilly Media, 2013.
                M. Lanthaler,
                  “Building Next-Generation Web APIs with JSON-LD and Hydra,”
                  presented at Symfony Live Portland 2013 [slides]
                  [video].
                M. Lanthaler and C. Gütl,
                  “Hydra: A Vocabulary for Hypermedia-Driven Web APIs,”
                  in Proceedings of the 6th Workshop on Linked Data on the Web (LDOW2013) at the 22nd International
                  World Wide Web Conference (WWW2013), 2013 [slides].
                M. Lanthaler, “Creating 3rd Generation Web APIs with Hydra,”
                  in Proceedings of the 22nd International World Wide Web Conference (WWW2013), 2013, pp. 35–37
                  [slides].
                M. Lanthaler and C. Gütl,
                  “Model Your Application Domain, Not Your JSON Structures,”
                  in Proceedings of the 4th International Workshop on RESTful Design (WS-REST 2013) at the
                  22nd International World Wide Web Conference (WWW2013), 2013, pp. 1415–1420
                  [slides].\n\n\n\nHydra W3C Community Group Teleconference Minutes
              The public Hydra W3C CG teleconferences and all of the decisions made in those
                 meetings are listed below. Each link takes you to the full text and,
                 if available, the audio recording of the meeting. There's a separate
                 page describing how to attend or run a conference call.
              
              Minutes for 2019-11-26
                  
                      ACTION: Add an informational paragraph to the specs with hints on how to treat additional data from the API documentation [permalink]
                  
              
              Minutes for 2019-11-12
                  
                      ACTION: Karol will provide example for the querying approach [permalink]
                  
              
              Minutes for 2019-09-03
                  
                      ACTION: Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class [permalink]
                      ACTION: serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation [permalink]
                      ACTION: Karol_Szczepanski will take care of #197 [permalink]
                  
              
              Minutes for 2019-06-25
                  
                  
              
              Minutes for 2019-05-28
                  
                      ACTION: <serialseb will add a comment to issue and attempt a PR for the documentation> [permalink]
                      ACTION:  aveltens will start working on listing movies, after finishing the cookbook example [permalink]
                  
              
              Minutes for 2019-05-14
                  
                      ACTION: serialseb would share some API examples of his own [permalink]
                      ACTION: tpluskiewicz adds a proper statement in the spec on how to undestand manages block [permalink]
                  
              
              Minutes for 2019-04-30
                  
                  
              
              Minutes for 2019-04-08
                  
                  
              
              Minutes for 2019-03-25
                  
                      ACTION: Karol_Szczepanski to create a cookbook example and documentation changes for #186 [permalink]
                      ACTION: Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents) [permalink]
                      ACTION: tpluskiewicz is to hookup slack with tweeter [permalink]
                  
              
              Minutes for 2019-02-18
                  
                      ACTION: tpluskiewicz comes with a code of conduct regarding vocabulary modifications/extensions [permalink]
                  
              
              Minutes for 2019-01-28
                  
                  
              
              Minutes for 2019-01-14
                  
                      ACTION: lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him [permalink]
                      ACTION: rubenverborgh will provide a brief agenta of that discussion [permalink]
                      ACTION: migration of the TPF repos to separate one within HydraCG [permalink]
                      ACTION: tpluskiewicz: describe on how to proceed with PR's [permalink]
                  
              
              Minutes for 2019-01-07
                  
                  
              
              Minutes for 2018-11-12
                  
                  
              
              Minutes for 2018-10-01
                  
                  
              
              Minutes for 2018-04-16
                  
                  
              
              Minutes for 2018-04-02
                  
                      ACTION: Markus to write down a proposal on how a expects "request shape" could look like [permalink]
                  
              
              Minutes for 2018-03-19
                  
                  
              
              Minutes for 2018-03-05
                  
                      ACTION: Thomas to convert ISSUE-156 into a use case document [permalink]
                  
              
              Minutes for 2018-02-05
                  
                      ACTION: Karol to send a pull request to update the vocabulary to include everything we decided so far [permalink]
                      ACTION: Pavlik to write down a few proposals for PR-154 and send a notice to the mailing list announcing the potential breaking change [permalink]
                  
              
              Minutes for 2018-01-08
                  
                  
              
              Minutes for 2017-12-11
                  
                      RESOLVED: Pause telecons over the holidays, next telecon will be on January 8th [permalink]
                      ACTION: Karol to create a pull request documenting stuff like hydra:memberTemplate in the spec as the reference client already uses them [permalink]
                  
              
              Minutes for 2017-11-27
                  
                      ACTION: Markus to render the use case documents on the Hydra homepage [permalink]
                      ACTION: Tomasz to come up with a rough structure of how the documentation should look like [permalink]
                  
              
              Minutes for 2017-10-30
                  
                      ACTION: Pavlik to create a PR to harmonize the usage of prefixes in our use case documents [permalink]
                  
              
              Minutes for 2017-10-16
                  
                      ACTION: Tomasz to extend use case 5 to include all issues discussed today [permalink]
                  
              
              Minutes for 2017-10-02
                  
                      RESOLVED: Merge Heracles PR-10 [permalink]
                  
              
              Minutes for 2017-09-18
                  
                      RESOLVED: Merge Heracles.ts PR-11 [permalink]
                      ACTION: Karol to analyse Jiira/Confluence APIs [permalink]
                      ACTION:  Pavlik to analyse meetup.com and look for another one [permalink]
                      ACTION: Markus will analyze some Google APIs [permalink]
                      ACTION: Tomasz will analyze Huddle & Foxycart [permalink]
                      RESOLVED: Merge PR-140 (https://github.com/HydraCG/Specifications/pull/140) [permalink]
                      ACTION: Markus to combine PR-10 & PR-12 and send them out for review later this week [permalink]
                  
              
              Minutes for 2017-09-04
                  
                  
              
              Minutes for 2017-08-21
                  
                      RESOLVED: Merge PR #132 that uses the manages block to advertise type of collection members [permalink]
                      ACTION: Pavlik to add some more use cases that illustrate the manages feature introduced in PR #132 [permalink]
                      ACTION: Pavlik to create a use case for issue #134 (adding existing resources to collections) [permalink]
                  
              
              Minutes for 2017-07-10
                  
                      RESOLVED: Use reviewable.io for code reviews going forward [permalink]
                      RESOLVED: Use MIT license for Heracles.ts (issue #4) [permalink]
                      RESOLVED: Merge Ruben's "Hydra architectural diagram" PR #128 (will be used to organize our work) [permalink]
                      RESOLVED: As a guiding principle, we will start designing/defining new concepts in Hydra instead of trying to reuse bits and pieces of various vocabularies from the get-go.  If we later discover that there's a considerable overlap with an existing vocabulary we may decide to use it instead of our own solution. [permalink]
                      ACTION: Pavlik, to expand use cases to make it clear why we need a solution to issue #126 [permalink]
                  
              
              Minutes for 2017-06-26
                  
                      RESOLVED: Merge schema.org actions PR #125 [permalink]
                      ACTION: Markus will try to find a tool which will help us with PR reviews; it's currently difficult to keep track what has been addressed and what hasn't [permalink]
                      ACTION: Markus to rename issue #126 to not suggest a solution [permalink]
                      ACTION: Pavlik to drive discussion regarding #126 after the issue has been renamed [permalink]
                  
              
              Minutes for 2017-06-12
                  
                      RESOLVED: Set up a new, empty Heracles.ts repository under the HydraCG organization on GitHub [permalink]
                  
              
              Minutes for 2017-05-29
                  
                      RESOLVED: Going forward, Pavlik will send out the agenda 3 days before the call [permalink]
                      RESOLVED: Merge Karol's PRs #116 #117 #122 #123 #124 [permalink]
                      RESOLVED: Merge PR #121 [permalink]
                      RESOLVED: Send Markus a mail to be invited to the Github organization; Markus will grant read-only access to any member of the CG that asks for it [permalink]
                      ACTION: Pavlik to come up with a proposal for a test suite to be used for the development of reference client [permalink]
                      ACTION: Markus to propose name of repository for Karol's TypeScript reference client under HydraCG organization on GitHub [permalink]
                  
              
              Minutes for 2017-05-15
                  
                  
              
              Minutes for 2017-05-01
                  
                      RESOLVED: Merge PR #113, #114, and #115 [permalink]
                  
              
              Minutes for 2017-04-17
                  
                      ACTION: Karol to create a first version of a markdown document describing client/server interactions before next telecon [permalink]
                      RESOLVED: Go ahead and merge Dietrich's pull request [permalink]
                      RESOLVED: Move the architectural diagram into the main repo and keep iterating on it [permalink]
                      RESOLVED: Concentrate primarily on examples to get things moving again, iterate, implement and finally update the spec [permalink]\n\n\n\nhttps://linkeddatafragments.org/specification/linked-data-fragments/\n\n\nhttps://linkeddatafragments.org/specification/triple-pattern-fragments/\n\n\nHydra simplifies the development of interoperable, hypermedia-driven Web APIs

              Building Web APIs seems still more an art than a science. How can we build APIs such that generic clients can easily use them? And how do we build those clients? Current APIs heavily rely on out-of-band information such as human-readable documentation and API-specific SDKs. However, this only allows for very simple and brittle clients that are hardcoded against specific APIs. Hydra, in contrast, is a set of technologies that allow to design APIs in a different manner, in a way that enables smarter clients.
          
      

      
          
              Hydra Core Vocabulary

              Essential building blocks for machine-accessible Hypermedia APIs

              Read the specification

              There also exists a demo Web API featuring a simple issue tracker which allows you to play with Hydra directly in your web browser.

          
          
              Linked Data Fragments

              API and client designs to publish and query Linked Data at Web-scale

              Get familiar with Linked Data Fragments or read the triple pattern fragments specification

              Various LDF data sources are already available. Query them.
          
          
              Join the Working Group
              Wanna help? Then join the Hydra W3C Community Group. Here's how:

              
                Get a free W3C account (it may take a while to get approved).
                Join the Hydra W3C Community Group.
                Bonus points: Send an email to introduce yourself to the group.
              
          
      

      
          
              Tools/Libraries/​Applications

              
                HydraConsole: a generic API console
                  for Hydra-powered Web APIs
                HydraBundle: a bundle for
                  Symfony2 to create Web APIs based on Hydra
                  (demo application)
                API Platform: a PHP framework to build Web APIs
                  with JSON-LD, Schema.org and Hydra
                hydra-java: annotate your Java beans
                  and serialize them as JSON-LD with Hydra
                URSA: a framework written in C# to create
                  Hydra-powered Web APIs
                hydrus: a set of Python based tools to create
                  Hydra-powered Web APIs
                Levanzo: Clojure library to build hypermedia driven RESTful APIs
                Argolis: Hydra hypermedia controls for .NET web applications written in Nancy
                hydra-core: a JavaScript library to work
                  with Hydra-enabled Web APIs
                SmallHydra: a small Hydra library for the ESP8266 and Arduino platform
                hydra-py: a Hydra library for Python
                  (including a Triple Patterns Fragments client)
                Alcaeus: a Hydra client library written in TypeScript
                HydraClient: a PHP client library to
                  access Hydra-powered Web APIs
                api-doc-parser: a JavaScript library to parse Hydra API documentations
                JsonLD: a JSON-LD processor implemented in PHP
                Linked Data Fragments Server: serve triple pattern fragments
                  (JavaScript,
                  Java,
                  NetKernel)
                Linked Data Fragments Client: query a Linked Data Fragments API
                  (JavaScript,
                  browser,
                  Java)
              
          
      

      
          
              Publications/​Presentations

              
                M. Lanthaler,
                  “The Web Is Changing — From Strings to Things,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                M. Lanthaler,
                  “Why and How to Optimize Your Data Architecture for an Integrated Future,”
                  presented at Presented at APIcon UK 2014 in London, England.
                  [video].
                T. Hoppe,
                  “REST APIs Today and Tomorrow - an Essay,”
                  presented at several Meetups.
                M. Lanthaler,
                  “Creating Awesome Web APIs is a Breeze,”
                  presented at the O'Reilly Open Source Conference 2014 (OSCON) in Portland
                  [video].
                T. Pluskiewicz,
                  “JSON-LD and Hydra - Hypermedia API alternatively,”
                  presented at Meet.js Wrocław 2014.
                M. Lanthaler,
                  “A Deep Dive into JSON-LD and Hydra,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “Stop Reinventing the Wheel! Use Linked Data to Build Better APIs,”
                  presented at APIcon San Francisco 2014.
                M. Lanthaler,
                  “The Web 3.0 is just around the corner. Be prepared!,”
                  presented at APIdays Berlin, 2014.
                R. Verborgh,
                  “The Lonesome LOD Cloud,”
                  presented at the 4th USEWOD Workshop on Usage Analysis and the Web of Data, 2014.
                R. Verborgh, M. Vander Sande, P. Colpaert,
                  S. Coppens, E. Mannens, and R. Van de Walle,
                  “Web-Scale Querying through Linked Data Fragments,”
                  in Proceedings of the 7th Workshop on Linked Data on the Web (LDOW2014) at the 23nd International
                  World Wide Web Conference (WWW2014), 2014 [slides].
                M. Lanthaler,
                  “Full-on Hypermedia APIs with Hydra,”
                  presented at the API Strategy & Practice Conference, 2014 [video].
                R. Verborgh,
                  “Hypermedia cannot be the engine,”
                  presented at the API Strategy & Practice Conference, 2014.
                C. Pautasso, E. Wilde, and R. Alarcon (editors),
                  “REST: Advanced Research Topics and Practical Applications,”
                  Springer New York, 2014.
                L. Richardson, M. Amundsen, and S. Ruby,
                  “RESTful Web APIs,” O’Reilly Media, 2013.
                M. Lanthaler,
                  “Building Next-Generation Web APIs with JSON-LD and Hydra,”
                  presented at Symfony Live Portland 2013 [slides]
                  [video].
                M. Lanthaler and C. Gütl,
                  “Hydra: A Vocabulary for Hypermedia-Driven Web APIs,”
                  in Proceedings of the 6th Workshop on Linked Data on the Web (LDOW2013) at the 22nd International
                  World Wide Web Conference (WWW2013), 2013 [slides].
                M. Lanthaler, “Creating 3rd Generation Web APIs with Hydra,”
                  in Proceedings of the 22nd International World Wide Web Conference (WWW2013), 2013, pp. 35–37
                  [slides].
                M. Lanthaler and C. Gütl,
                  “Model Your Application Domain, Not Your JSON Structures,”
                  in Proceedings of the 4th International Workshop on RESTful Design (WS-REST 2013) at the
                  22nd International World Wide Web Conference (WWW2013), 2013, pp. 1415–1420
                  [slides].\n\n\n\nTelephone Conferences
              How Do I Attend a Call?
              We use UberConference and IRC for our conference calls. You can dial in by browsing to
                https://www.uberconference.com/hydra-cg.
                Please also connect your IRC client to irc://irc.w3.org:6665/#hydra
                or use W3C's web IRC. IRC is used to manage the
                speaker queue, scribe, share links etc.
              The dates and times of the calls as well as the agenda can be found on the
                conference calls page in our wiki.
                Feel free to add items to the agenda that you'd like to discuss.
              After you connected and the call started ask Zakim, our IRC meeting bot, to put you on the speaker
                queue:
              
                zakim, queue+
              
              You can see who's on the queue with
              
                zakim, queue?
              
              If you want to remove yourself from the queue again, just write
              
                zakim, queue-
              
               

              How Do I Run a Call and Scribe?
              We use a few bots to run our conference calls. Please invite them before the conference
                call starts by issuing the following commands in IRC:
              
                /invite RRSAgent #hydra
                /invite Zakim #hydra
              
              After the bots joined the IRC channel, you start the meeting and tell the bots what it is about
                (plus points for deep linking the
                right agenda):
              
                trackbot, start meeting
                
                Zakim, this is https://www.uberconference.com/hydra-cg
                
                Meeting: Hydra W3C Community Group Conference Call
                Chair: Markus Lanthaler
                Agenda: https://www.w3.org/community/hydra/wiki/Conference_Calls#Agenda
              
              As people join the call, they should mark their presence (you can also do it on their behalf) using
                the following command — inserting their user name and removing the angle brackets:
              
                present+ <IRC user name>
              
              The last thing before starting the call is to elect a scribe (either a volunteer or by picking
                the person that hasn't scribed the longest)
                and document who it is with the following command:
              
                Scribe: <IRC user name>
              
              After this, the chair moderates the call. He will signal the start of a new topic on IRC with
              
                Topic: <Title of the topic that is being discussed>
              
              The scribe then transcribes what has been said by typing the user name of the person speaking
                followed by a colon and the statement such as in the example below:
              
                markus: I like this approach
              
              Literal transcription is not necessary but usually simpler than trying to summarize someone else's
                thoughts on the fly. A statement can be split into multiple lines. Please proceed continuations with
                three dots such as in
              
                markus: I like this approach
                ... it is much clearer than the previous ones
                ... and solves the problem completely
              
              If the scribe speaks, someone else can — and should — take over and
                scribe the statement in exactly the same way.
              Action items, proposals and resolutions can be recorded as follows:
              
                ACTION: <Markus to clean up meeting notes>
                PROPOSAL: <Make Hydra more generic by introducing...>
                RESOLVED: <Make Hydra more generic by introducing...>
              
              At the end of the meeting you can request RRSAgent  to publish the meeting notes (this is for W3C;
                we store them on GitHub) and ask RRSAgent and Zakim
                to leave the channel:
              
                rrsagent, please publish the minutes
                rrsagent, please make these logs world-visible
                
                rrsagent, bye
                zakim, bye
              
              After the call, please spend a few minutes to clean up the minutes, convert them to HTML and
                create a pull request to upload them to GitHub:
              
                Create a new folder using the date of the conference call in the format yyyy-mm-dd.
                Create a file irc.log containing the IRC log of the conference call.
                Open scribetool and paste the
                  IRC log in to the text field at the bottom of the screen.
                Spend two minutes to check the nicely formatted minutes.
                  
                     Are all the fields at the top such as the agenda, the scribe and the participants
                      populated correctly?
                    Is every statement attributed to the right person (it sometimes happens that you forget
                      the three dots for a continuation)?
                    Are all action items, proposals and resolutions marked up correctly?
                  
                
                Switch to HTML mode by clicking the "Show HTML" button on the right and copy the result
                  into a file called index.html. Please do not manually edit the HTML code in any way
                  as it might break automated processing of those files!
                Create a pull request to add the folder containing the two files to
                  HydraCG/Minutes on GitHub and give owners
                  permissions to add files to your pull request (this will be used to add the audio recording).
              
              Finally, please record attendance in our wiki
                and send the meeting minutes to public-hydra@w3.org.
                You can use scribetool's text output.\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-11-26
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls
                      Topics
                      
                         Ontology discover and multiple API documentations
                      
                      Action Items
                      
                         Add an informational paragraph to the specs with hints on how to treat additional data from the API documentation
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Sebastien Lambla, Tomasz Pluskiewicz, Karol Szczepański
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.
              
              Topic: Ontology discover and multiple API documentations
              Karol Szczepański:  ok, I understand we have a hypothertical SPA which consumes multiple APIs
              Sebastien Lambla: let me explain our scenario...
              ... we have a data marketplace, with multiple dataset, where you can purchase
              ... each has various types of data
              ... quite large, ontologies, 100s of types. all in the same API
              ... we have multiple providers behind the scenes
              ... a client would purchase data and get different vairables, specific to that dataset
              ... we will provide a list of context document defining the terms
              ... but the context does not provide all metadata at type level
              ... right now we have an API Documentation, which could be a good point to load the metadata
              ... so that we can discover schemas
              ... we settled on keeping one API Documentation
              ... the difficulty is that spec does not say you can retrieve type informaition on per-request basis
              ... the spec suggests there is one api documentation
              ... and there will be the same
              ... another issue is that there is what happens when there are multiple api documentation links
              ... last issue, if I describe a class in api doc, it becomes a resource the can be identified
              ... so if I use reasoning everything can potentially be dereferenced
              ... so maybe hydra:supportedOperation should have range extended to hydra:Resource
              Karol Szczepański:  if an API supports certain class, it means that it can manipulate instance thereof
              ... loosening it may be tricky
              Sebastien Lambla: for example I have a resource which supports a type which is rdfs:Class
              ... I want to be able to discover information about the rdfs:Class
              Karol Szczepański:  sounds like all you need is just to dereference that class to understand what it is
              Sebastien Lambla: but I cannot dereference like, 500 classes
              Karol Szczepański:  so those are no hash URIs?
              Sebastien Lambla: yes some are, but it's still many ontologies
              Karol Szczepański:  another idea is to provide these ontologies within the API Documentation. it's still a graph
              Sebastien Lambla: that would change JSON-LD harder to consume
              Karol Szczepański:  yes, you might get an array of nodes
              Sebastien Lambla: yes, but a generic client will not implement it the sme way
              ... so I'm saying that maybe api doc could have something extra, which is plain RDFS
              Sebastien Lambla: I need a second way of discovery
              ... feels like something is missing
              Karol Szczepański:  I don't have an answer
              ... supported classes and properties is something different than plain data models
              Sebastien Lambla: with Open API you can combine all those information
              ... and with hydra I would want one document with all the operations and all data models
              ... if it's not in a generic client, I will struggle making hydra compelling
              Tomasz Pluskiewicz:  you could use prefetch links [scribe assist by Karol Szczepański]
              ... so the ontologies can be hinted so the client can preload them earlier
              Sebastien Lambla: I could have mutliple top level nodes in the API doc
              ... but from a generic client, I'm concerned about anything we do but is not in the spec
              ... if the in the API doc graph we would allow disconnected graph
              Tomasz Pluskiewicz:  I would love to see a full-blown example
              Sebastien Lambla: we will have a draft in a few weeks once we launch
              Tomasz Pluskiewicz:  I had similar example with multiple API documentations - a books API that links books to reviews, but reviews is handled by another API [scribe assist by Karol Szczepański]
              Tomasz Pluskiewicz:  solution would be to have always to give two API documentations or just to keep API documentation that you've received and combine it somehow [scribe assist by Karol Szczepański]
              ACTION: Add an informational paragraph to the specs with hints on how to treat additional data from the API documentation\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-11-26
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls
                      Topics
                      
                         Ontology discover and multiple API documentations
                      
                      Action Items
                      
                         Add an informational paragraph to the specs with hints on how to treat additional data from the API documentation
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Sebastien Lambla, Tomasz Pluskiewicz, Karol Szczepański
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.
              
              Topic: Ontology discover and multiple API documentations
              Karol Szczepański:  ok, I understand we have a hypothertical SPA which consumes multiple APIs
              Sebastien Lambla: let me explain our scenario...
              ... we have a data marketplace, with multiple dataset, where you can purchase
              ... each has various types of data
              ... quite large, ontologies, 100s of types. all in the same API
              ... we have multiple providers behind the scenes
              ... a client would purchase data and get different vairables, specific to that dataset
              ... we will provide a list of context document defining the terms
              ... but the context does not provide all metadata at type level
              ... right now we have an API Documentation, which could be a good point to load the metadata
              ... so that we can discover schemas
              ... we settled on keeping one API Documentation
              ... the difficulty is that spec does not say you can retrieve type informaition on per-request basis
              ... the spec suggests there is one api documentation
              ... and there will be the same
              ... another issue is that there is what happens when there are multiple api documentation links
              ... last issue, if I describe a class in api doc, it becomes a resource the can be identified
              ... so if I use reasoning everything can potentially be dereferenced
              ... so maybe hydra:supportedOperation should have range extended to hydra:Resource
              Karol Szczepański:  if an API supports certain class, it means that it can manipulate instance thereof
              ... loosening it may be tricky
              Sebastien Lambla: for example I have a resource which supports a type which is rdfs:Class
              ... I want to be able to discover information about the rdfs:Class
              Karol Szczepański:  sounds like all you need is just to dereference that class to understand what it is
              Sebastien Lambla: but I cannot dereference like, 500 classes
              Karol Szczepański:  so those are no hash URIs?
              Sebastien Lambla: yes some are, but it's still many ontologies
              Karol Szczepański:  another idea is to provide these ontologies within the API Documentation. it's still a graph
              Sebastien Lambla: that would change JSON-LD harder to consume
              Karol Szczepański:  yes, you might get an array of nodes
              Sebastien Lambla: yes, but a generic client will not implement it the sme way
              ... so I'm saying that maybe api doc could have something extra, which is plain RDFS
              Sebastien Lambla: I need a second way of discovery
              ... feels like something is missing
              Karol Szczepański:  I don't have an answer
              ... supported classes and properties is something different than plain data models
              Sebastien Lambla: with Open API you can combine all those information
              ... and with hydra I would want one document with all the operations and all data models
              ... if it's not in a generic client, I will struggle making hydra compelling
              Tomasz Pluskiewicz:  you could use prefetch links [scribe assist by Karol Szczepański]
              ... so the ontologies can be hinted so the client can preload them earlier
              Sebastien Lambla: I could have mutliple top level nodes in the API doc
              ... but from a generic client, I'm concerned about anything we do but is not in the spec
              ... if the in the API doc graph we would allow disconnected graph
              Tomasz Pluskiewicz:  I would love to see a full-blown example
              Sebastien Lambla: we will have a draft in a few weeks once we launch
              Tomasz Pluskiewicz:  I had similar example with multiple API documentations - a books API that links books to reviews, but reviews is handled by another API [scribe assist by Karol Szczepański]
              Tomasz Pluskiewicz:  solution would be to have always to give two API documentations or just to keep API documentation that you've received and combine it somehow [scribe assist by Karol Szczepański]
              ACTION: Add an informational paragraph to the specs with hints on how to treat additional data from the API documentation\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-11-12
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-09-03
                      Topics
                      
                         Get a grip on collection ordering issue #172
                      
                      Action Items
                      
                         Karol will provide example for the querying approach
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Angelo Valtens
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              
              Topic: Get a grip on collection ordering issue #172
              Karol Szczepański: https://github.com/HydraCG/Specifications/issues/172
              Karol Szczepański:  Ordering touches the querying topic. Not sure if this should be in hydra core, but should at least be extendible
              Tomasz Pluskiewicz: https://prefix.zazuko.com/dtype:orderIndex
              Karol Szczepański:  2 possible solutions: Rising hydra:Collection to some kind of SortedCollection, impliying that the members are RDF Lists
              ... or leave it as is and provide a description of the ordering
              ... would be cautious with adding something to members
              ... like indices
              Karol Szczepański: aveltens: I'm not sure what kind of use case Pieter has on his mind
              Tomasz Pluskiewicz:  i.e. for UI building, client would need to be sure on how the members are sorted [scribe assist by Karol Szczepański]
              Karol Szczepański:  The client could define an order in the query and expect the API to serve in that order
              ... same es an SQL or SPARQL queries
              Tomasz Pluskiewicz:  The server should be able to indicate the order to the client, even if the client did not ask for a specific order
              ... if the response is ordered, the server should return an RDF list
              Karol Szczepański:  Pieters proposol is quite complex, introducing many new predicates / classes
              ... I prefer having quering for order as a stanard
              Tomasz Pluskiewicz:  The client nontheless needs to understand what it got. Perhaps it followed only a parameterized link and does not understand what order it requested
              Karol Szczepański:  Even if a link is follows / refresh is done, the client will request a specific order based on it's state and knows about the order
              Tomasz Pluskiewicz:  There are several issues here. What if the server implemention changed meanwhile?
              Angelo Valtens: The client would look up the API doc to know how to construct the query?
              Karol Szczepański:  We have to very different concepts. Querying the data vs shaping the data. Which path should we use? What are the benefits of each?
              Tomasz Pluskiewicz:  What about a resource /people, and the server orders them implicitly by name
              ... its not about what the server has to do, but what the server did
              Karol Szczepański:  If client knows what it needs, let it ask for it, unless it should not care
              Karol Szczepański:  let us craft some imaginatory situations in the cookbook
              ... lets link those examples / use cases to the issue
              ACTION: Karol will provide example for the querying approach
              Tomasz Pluskiewicz:  Still, Pieter is asking for the complete opposite, Indicate a partial collection view is ordered\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-11-12
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-09-03
                      Topics
                      
                         Get a grip on collection ordering issue #172
                      
                      Action Items
                      
                         Karol will provide example for the querying approach
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Angelo Valtens
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              
              Topic: Get a grip on collection ordering issue #172
              Karol Szczepański: https://github.com/HydraCG/Specifications/issues/172
              Karol Szczepański:  Ordering touches the querying topic. Not sure if this should be in hydra core, but should at least be extendible
              Tomasz Pluskiewicz: https://prefix.zazuko.com/dtype:orderIndex
              Karol Szczepański:  2 possible solutions: Rising hydra:Collection to some kind of SortedCollection, impliying that the members are RDF Lists
              ... or leave it as is and provide a description of the ordering
              ... would be cautious with adding something to members
              ... like indices
              Karol Szczepański: aveltens: I'm not sure what kind of use case Pieter has on his mind
              Tomasz Pluskiewicz:  i.e. for UI building, client would need to be sure on how the members are sorted [scribe assist by Karol Szczepański]
              Karol Szczepański:  The client could define an order in the query and expect the API to serve in that order
              ... same es an SQL or SPARQL queries
              Tomasz Pluskiewicz:  The server should be able to indicate the order to the client, even if the client did not ask for a specific order
              ... if the response is ordered, the server should return an RDF list
              Karol Szczepański:  Pieters proposol is quite complex, introducing many new predicates / classes
              ... I prefer having quering for order as a stanard
              Tomasz Pluskiewicz:  The client nontheless needs to understand what it got. Perhaps it followed only a parameterized link and does not understand what order it requested
              Karol Szczepański:  Even if a link is follows / refresh is done, the client will request a specific order based on it's state and knows about the order
              Tomasz Pluskiewicz:  There are several issues here. What if the server implemention changed meanwhile?
              Angelo Valtens: The client would look up the API doc to know how to construct the query?
              Karol Szczepański:  We have to very different concepts. Querying the data vs shaping the data. Which path should we use? What are the benefits of each?
              Tomasz Pluskiewicz:  What about a resource /people, and the server orders them implicitly by name
              ... its not about what the server has to do, but what the server did
              Karol Szczepański:  If client knows what it needs, let it ask for it, unless it should not care
              Karol Szczepański:  let us craft some imaginatory situations in the cookbook
              ... lets link those examples / use cases to the issue
              ACTION: Karol will provide example for the querying approach
              Tomasz Pluskiewicz:  Still, Pieter is asking for the complete opposite, Indicate a partial collection view is ordered\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-09-03
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-09-03
                      Topics
                      
                         Consider extending Hydra to handle non-RDF payloads
                         Return to recently discussed PRs
                         Discuss PRs in Example API repository
                      
                      Action Items
                      
                         Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
                         serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
                         Karol_Szczepanski will take care of #197
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Sebastien Lambla, Tomasz Pluskiewicz, Karol Szczepański
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Consider extending Hydra to handle non-RDF payloads
              Tomasz Pluskiewicz: I had some discussions and the only thing that is needed is the first snipped after the proposed solutions
              https://github.com/HydraCG/Specifications/issues/199
              Tomasz Pluskiewicz: #199 replaces range of the hydra:expect with rangeIncludes
              Karol Szczepański:  will be there any harm in having both range and rangeIncludes?
              Tomasz Pluskiewicz: whatever will be there, will be considered hydra:Class
              Karol Szczepański:  this is a breaking change
              Karol Szczepański:  I've suggested replacing a hydra:Class with hydra:Resource leaving range predicate
              https://github.com/HydraCG/Specifications/issues/199#issuecomment-512552384
              Tomasz Pluskiewicz: what about having both, range of hydra:Resource and rangeIncludes with more hints
              Sebastien Lambla: I'm thinking about a generic browser console, when browsing, how will it work?
              Tomasz Pluskiewicz: a completely generic browser is ultimately an excercise gowing towards utopia
              Tomasz Pluskiewicz: generic client should support at least those of the rangeIncludes values provided in the spec
              Sebastien Lambla: I may accept an event but that specific server will accept it in turtle format
              Sebastien Lambla: I think content negotiation shoulld be a topic for another call/spec modifications
              Sebastien Lambla: I think operation expectation and what can be actually sent may be somehow different
              ACTION: Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
              Tomasz Pluskiewicz: we shall start thinking aobut an esxtension which will come with those features missing
              Karol Szczepański:  I'm worried that this will end up with a core vocabulary unusable and several extensions that won't fit to each other
              ACTION: serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
              TemplatedLink cannot formally have supportedOperation
              https://github.com/HydraCG/Specifications/issues/197
              
              Topic: Return to recently discussed PRs
              ACTION: Karol_Szczepanski will take care of #197
              
              Topic: Discuss PRs in Example API repository
              https://github.com/HydraCG/api-examples/pull/8
              Tomasz Pluskiewicz: I've sidestepped the issue as type entailing is quite complicated when you go deeper
              Karol Szczepański:  indeed; what Heracles.ts does not is a simple range/domain entailing and possibly I own't go any deeper\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-09-03
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-09-03
                      Topics
                      
                         Consider extending Hydra to handle non-RDF payloads
                         Return to recently discussed PRs
                         Discuss PRs in Example API repository
                      
                      Action Items
                      
                         Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
                         serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
                         Karol_Szczepanski will take care of #197
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Sebastien Lambla, Tomasz Pluskiewicz, Karol Szczepański
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Consider extending Hydra to handle non-RDF payloads
              Tomasz Pluskiewicz: I had some discussions and the only thing that is needed is the first snipped after the proposed solutions
              https://github.com/HydraCG/Specifications/issues/199
              Tomasz Pluskiewicz: #199 replaces range of the hydra:expect with rangeIncludes
              Karol Szczepański:  will be there any harm in having both range and rangeIncludes?
              Tomasz Pluskiewicz: whatever will be there, will be considered hydra:Class
              Karol Szczepański:  this is a breaking change
              Karol Szczepański:  I've suggested replacing a hydra:Class with hydra:Resource leaving range predicate
              https://github.com/HydraCG/Specifications/issues/199#issuecomment-512552384
              Tomasz Pluskiewicz: what about having both, range of hydra:Resource and rangeIncludes with more hints
              Sebastien Lambla: I'm thinking about a generic browser console, when browsing, how will it work?
              Tomasz Pluskiewicz: a completely generic browser is ultimately an excercise gowing towards utopia
              Tomasz Pluskiewicz: generic client should support at least those of the rangeIncludes values provided in the spec
              Sebastien Lambla: I may accept an event but that specific server will accept it in turtle format
              Sebastien Lambla: I think content negotiation shoulld be a topic for another call/spec modifications
              Sebastien Lambla: I think operation expectation and what can be actually sent may be somehow different
              ACTION: Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
              Tomasz Pluskiewicz: we shall start thinking aobut an esxtension which will come with those features missing
              Karol Szczepański:  I'm worried that this will end up with a core vocabulary unusable and several extensions that won't fit to each other
              ACTION: serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
              TemplatedLink cannot formally have supportedOperation
              https://github.com/HydraCG/Specifications/issues/197
              
              Topic: Return to recently discussed PRs
              ACTION: Karol_Szczepanski will take care of #197
              
              Topic: Discuss PRs in Example API repository
              https://github.com/HydraCG/api-examples/pull/8
              Tomasz Pluskiewicz: I've sidestepped the issue as type entailing is quite complicated when you go deeper
              Karol Szczepański:  indeed; what Heracles.ts does not is a simple range/domain entailing and possibly I own't go any deeper\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-09-03
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-09-03
                      Topics
                      
                         Consider extending Hydra to handle non-RDF payloads
                         Return to recently discussed PRs
                         Discuss PRs in Example API repository
                      
                      Action Items
                      
                         Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
                         serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
                         Karol_Szczepanski will take care of #197
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Sebastien Lambla, Tomasz Pluskiewicz, Karol Szczepański
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Consider extending Hydra to handle non-RDF payloads
              Tomasz Pluskiewicz: I had some discussions and the only thing that is needed is the first snipped after the proposed solutions
              https://github.com/HydraCG/Specifications/issues/199
              Tomasz Pluskiewicz: #199 replaces range of the hydra:expect with rangeIncludes
              Karol Szczepański:  will be there any harm in having both range and rangeIncludes?
              Tomasz Pluskiewicz: whatever will be there, will be considered hydra:Class
              Karol Szczepański:  this is a breaking change
              Karol Szczepański:  I've suggested replacing a hydra:Class with hydra:Resource leaving range predicate
              https://github.com/HydraCG/Specifications/issues/199#issuecomment-512552384
              Tomasz Pluskiewicz: what about having both, range of hydra:Resource and rangeIncludes with more hints
              Sebastien Lambla: I'm thinking about a generic browser console, when browsing, how will it work?
              Tomasz Pluskiewicz: a completely generic browser is ultimately an excercise gowing towards utopia
              Tomasz Pluskiewicz: generic client should support at least those of the rangeIncludes values provided in the spec
              Sebastien Lambla: I may accept an event but that specific server will accept it in turtle format
              Sebastien Lambla: I think content negotiation shoulld be a topic for another call/spec modifications
              Sebastien Lambla: I think operation expectation and what can be actually sent may be somehow different
              ACTION: Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
              Tomasz Pluskiewicz: we shall start thinking aobut an esxtension which will come with those features missing
              Karol Szczepański:  I'm worried that this will end up with a core vocabulary unusable and several extensions that won't fit to each other
              ACTION: serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
              TemplatedLink cannot formally have supportedOperation
              https://github.com/HydraCG/Specifications/issues/197
              
              Topic: Return to recently discussed PRs
              ACTION: Karol_Szczepanski will take care of #197
              
              Topic: Discuss PRs in Example API repository
              https://github.com/HydraCG/api-examples/pull/8
              Tomasz Pluskiewicz: I've sidestepped the issue as type entailing is quite complicated when you go deeper
              Karol Szczepański:  indeed; what Heracles.ts does not is a simple range/domain entailing and possibly I own't go any deeper\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-09-03
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-09-03
                      Topics
                      
                         Consider extending Hydra to handle non-RDF payloads
                         Return to recently discussed PRs
                         Discuss PRs in Example API repository
                      
                      Action Items
                      
                         Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
                         serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
                         Karol_Szczepanski will take care of #197
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Sebastien Lambla, Tomasz Pluskiewicz, Karol Szczepański
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Consider extending Hydra to handle non-RDF payloads
              Tomasz Pluskiewicz: I had some discussions and the only thing that is needed is the first snipped after the proposed solutions
              https://github.com/HydraCG/Specifications/issues/199
              Tomasz Pluskiewicz: #199 replaces range of the hydra:expect with rangeIncludes
              Karol Szczepański:  will be there any harm in having both range and rangeIncludes?
              Tomasz Pluskiewicz: whatever will be there, will be considered hydra:Class
              Karol Szczepański:  this is a breaking change
              Karol Szczepański:  I've suggested replacing a hydra:Class with hydra:Resource leaving range predicate
              https://github.com/HydraCG/Specifications/issues/199#issuecomment-512552384
              Tomasz Pluskiewicz: what about having both, range of hydra:Resource and rangeIncludes with more hints
              Sebastien Lambla: I'm thinking about a generic browser console, when browsing, how will it work?
              Tomasz Pluskiewicz: a completely generic browser is ultimately an excercise gowing towards utopia
              Tomasz Pluskiewicz: generic client should support at least those of the rangeIncludes values provided in the spec
              Sebastien Lambla: I may accept an event but that specific server will accept it in turtle format
              Sebastien Lambla: I think content negotiation shoulld be a topic for another call/spec modifications
              Sebastien Lambla: I think operation expectation and what can be actually sent may be somehow different
              ACTION: Karol_Szczepanski will create a PR with range of the hydra:expect downgrade to hydra:Resource and introduce rangeIncludes with hydra:Class
              Tomasz Pluskiewicz: we shall start thinking aobut an esxtension which will come with those features missing
              Karol Szczepański:  I'm worried that this will end up with a core vocabulary unusable and several extensions that won't fit to each other
              ACTION: serialseb will provide raw use case scenarios of what may be needed regarding non-RDF payloads and content negotiation
              TemplatedLink cannot formally have supportedOperation
              https://github.com/HydraCG/Specifications/issues/197
              
              Topic: Return to recently discussed PRs
              ACTION: Karol_Szczepanski will take care of #197
              
              Topic: Discuss PRs in Example API repository
              https://github.com/HydraCG/api-examples/pull/8
              Tomasz Pluskiewicz: I've sidestepped the issue as type entailing is quite complicated when you go deeper
              Karol Szczepański:  indeed; what Heracles.ts does not is a simple range/domain entailing and possibly I own't go any deeper\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-06-25
              
                  
                      Agenda
                      undefined
                      Topics
                      
                         TemplatedLink cannot formally have supportedOperation
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Valtens
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.
              Karol Szczepański:  Pieter isn't here so let's skip the first point on our agenda
              ... moving on to issue #197
              
              Topic: TemplatedLink cannot formally have supportedOperation
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/198
              Karol Szczepański:  all I did was add a statement to the JSON-LD, subclassing TemplatedLink from Link
              ... this seems least intrusive. it should not break anything.
              ... alternative was to add TemplatedLink to range and domain.
              Tomasz Pluskiewicz:  yes, I just approved
              ... we did discuss this. I think it's the right thing to do
              Angelo Veltens: one question
              ... not sure. not sure how to understand hydra:Link
              ... it would be something to dereference?
              Karol Szczepański:  in general, yes
              ... Hydra adds explicit term to explicitly say "this is a link"
              Angelo Veltens: clients might try to dereference the templated link?
              Karol Szczepański:  you dereference the "right side of this relation"
              ... it allows you to define that the IRI may vary
              Tomasz Pluskiewicz:  the object is a blank node, a TemplatedLink
              Angelo Veltens: I expect the object to be dereferencable. here I cannot
              Tomasz Pluskiewicz:  can you elaborate on domain and domainIncludes?
              Karol Szczepański:  TemplatedLink did not exist in those domains. now it will be able to participate in those relations
              Tomasz Pluskiewicz:  can you give an example?
              Karol Szczepański:  hydra:title has Link in domainIncludes but not TempaltedLink.
              Tomasz Pluskiewicz:  ok, I understand
              Karol Szczepański:  I wonder if it's a problem that TempaltedLink is not dereferncable
              Tomasz Pluskiewicz:  if that's a problem than we'd need to change the approach
              Karol Szczepański:  yes, I will think it over. Angelo's doubts give me pause
              Tomasz Pluskiewicz:  Angelo, could you comment that on the PR?
              Karol Szczepański:  a one line change turned out to be not a trivial
              ... what other issue you'd like to discuss?
              Tomasz Pluskiewicz:  we have #10 in the cookbook
              Karol Szczepański: https://github.com/HydraCG/cookbook/pull/10
              Karol Szczepański:  angelo, there were change requests on that. any news?
              Angelo Veltens: ah, yes. I was busy. I will get back to it in the next week
              Karol Szczepański:  the cookbook says that client consults API Docs
              ... I would like to give impression that client use out-of-band information
              Angelo Veltens: in the example API so far we have just the collection and type of collection
              ... there are no inline operations
              Tomasz Pluskiewicz:  nothing here is out-of-band. Hydra is fully accessible by the client
              Tomasz Pluskiewicz:  I'm sure that the Api Documentation is mandatory, a design of Hydra
              Karol Szczepański:  I don't agree. we risk ending up with something like Swagger etc
              Angelo Veltens: back to the PR, I will clarify that bit
              Karol Szczepański:  I'm fine with that
              Karol Szczepański:  anything else?
              Karol Szczepański: https://gist.github.com/tpluscode/2f32c7d488ea434960f2a9b1721bbc82
              Tomasz Pluskiewicz:  I spiked this in hydra analyzer. we start building the DSL
              Karol Szczepański:  DSL as a Domain Specific Language? I find the example hart to follow
              aventels: it will generate api docs?
              Tomasz Pluskiewicz:  I think that a API testing should resemble a hypermedia client. follow your nose
              Tomasz Pluskiewicz:  I have a blog post in the making. I will share later this week
              Angelo Veltens: this will be good to test multiple implementations of the movies API
              Karol Szczepański:  I think this what Ruben was mentioning for a meeting
              ... I started porting Heracles to .NET, if you find interesting
              Angelo Veltens: not .NET here
              Karol Szczepański:  okay, I will work on this and give more info
              Karol Szczepański:  I thought to postpone the calls this summer
              Tomasz Pluskiewicz:  unless there is a big topic
              Angelo Veltens: we should decide when we continue
              Karol Szczepański:  September maybe
              Tomasz Pluskiewicz: tpluskiewicz: +1\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-05-28
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-05-28
                      Topics
                      
                         Finalize manages block PR
                         Discuss cookbook PR #9
                         Revisit property supported operations design - issue #196
                         Decide on next piece of movies example API
                         Get a grip on collection ordering issue #172
                      
                      Action Items
                      
                         
                         aveltens will start working on listing movies, after finishing the cookbook example
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      undefined
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Valtens, Sebastien Lambla
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              
              Topic: Finalize manages block PR
              Karol Szczepański:  This was approved by me and angelo
              ... merged it
              Tomasz Pluskiewicz:   This should close a number of old issues, which might wake some people
              
              Topic: Discuss cookbook PR #9
              https://github.com/HydraCG/cookbook/pull/9
              Karol Szczepański:  I am fine with it as is
              ... can live with the duplication
              Tomasz Pluskiewicz:  The ones we already have are not really drafts anymore
              Tomasz Pluskiewicz:  Should be fine to merge now
              Karol Szczepański:  indeed
              https://deploy-preview-9--hydra-cookbook.netlify.com/
              Karol Szczepański:  all checks are ok, merge
              
              Topic: Revisit property supported operations design - issue #196
              https://github.com/HydraCG/Specifications/issues/196
              Tomasz Pluskiewicz:  It might be more complicated. I am sure most people would already be doing it the same way as in the example
              Tomasz Pluskiewicz: http://www.markus-lanthaler.com/hydra/api-demo/vocab
              Tomasz Pluskiewicz: vocab:EntryPoint/myAccount
              Discussing the api-demo example
              Angelo Veltens: conclusions:
              Angelo Veltens: - spec does allow supportedOperation on both: property and supportedProperty
              - it might be confusing to have to many possibilities
              - the cookbook should provide best practices
              - same origin policy might be applied to trust only statements that came from the api itself
              Karol Szczepański:  how shall we proceed with the issue?
              Tomasz Pluskiewicz:  We will get there with the cookbook eventually
              ... supportedOperation of property is missing as an example in the spec, we could add this
              Angelo Veltens: serialseb:  Let's get feedback from API developers
              Angelo Veltens: serialseb:  Let's get feedback from API developers
              ACTION: <serialseb will add a comment to issue and attempt a PR for the documentation>
              
              Topic: Decide on next piece of movies example API
              Angelo Veltens: aveltens: We should be able to list movies that were added
              Tomasz Pluskiewicz:  Sounds reasonable
              Angelo Veltens: aveltens: Will finish the "Create  Movie" part of the cookbook before
              Angelo Veltens: aveltens: I will be able to spend less time on it
              Tomasz Pluskiewicz:  i would like to deploy some really working code
              Angelo Veltens: serialseb: I can put some time on it
              ... e.g. implementing the example with openrasta
              ... perhaps on  saturday
              ACTION: aveltens will start working on listing movies, after finishing the cookbook example
              
              Topic: Get a grip on collection ordering issue #172
              Karol Szczepański:  shall we move on, or postpone?
              Tomasz Pluskiewicz:  The main person regarding that issue is not present
              present+
              Angelo Veltens: serialseb: This could be in an additional spec that covers the more complicated stuff
              Karol Szczepański:  We discussed extensions multiple times
              ... lets focus on the core
              Karol Szczepański:  We postpone this to the next call
              ... maybe peter will join as next time
              Apologies - did this call start 7 minutes ago or an hour and 7 minutes ago?  The wiki wasn’t very clear
              Karol Szczepański: unfortunately, it started 1 hour and 7 minutes ago
              sounds good - I will adjust my calendar notification for next time!
              Karol Szczepański: excellent - I'm looking forward to hearing you next time!\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-05-28
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-05-28
                      Topics
                      
                         Finalize manages block PR
                         Discuss cookbook PR #9
                         Revisit property supported operations design - issue #196
                         Decide on next piece of movies example API
                         Get a grip on collection ordering issue #172
                      
                      Action Items
                      
                         
                         aveltens will start working on listing movies, after finishing the cookbook example
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      undefined
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Valtens, Sebastien Lambla
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              
              Topic: Finalize manages block PR
              Karol Szczepański:  This was approved by me and angelo
              ... merged it
              Tomasz Pluskiewicz:   This should close a number of old issues, which might wake some people
              
              Topic: Discuss cookbook PR #9
              https://github.com/HydraCG/cookbook/pull/9
              Karol Szczepański:  I am fine with it as is
              ... can live with the duplication
              Tomasz Pluskiewicz:  The ones we already have are not really drafts anymore
              Tomasz Pluskiewicz:  Should be fine to merge now
              Karol Szczepański:  indeed
              https://deploy-preview-9--hydra-cookbook.netlify.com/
              Karol Szczepański:  all checks are ok, merge
              
              Topic: Revisit property supported operations design - issue #196
              https://github.com/HydraCG/Specifications/issues/196
              Tomasz Pluskiewicz:  It might be more complicated. I am sure most people would already be doing it the same way as in the example
              Tomasz Pluskiewicz: http://www.markus-lanthaler.com/hydra/api-demo/vocab
              Tomasz Pluskiewicz: vocab:EntryPoint/myAccount
              Discussing the api-demo example
              Angelo Veltens: conclusions:
              Angelo Veltens: - spec does allow supportedOperation on both: property and supportedProperty
              - it might be confusing to have to many possibilities
              - the cookbook should provide best practices
              - same origin policy might be applied to trust only statements that came from the api itself
              Karol Szczepański:  how shall we proceed with the issue?
              Tomasz Pluskiewicz:  We will get there with the cookbook eventually
              ... supportedOperation of property is missing as an example in the spec, we could add this
              Angelo Veltens: serialseb:  Let's get feedback from API developers
              Angelo Veltens: serialseb:  Let's get feedback from API developers
              ACTION: <serialseb will add a comment to issue and attempt a PR for the documentation>
              
              Topic: Decide on next piece of movies example API
              Angelo Veltens: aveltens: We should be able to list movies that were added
              Tomasz Pluskiewicz:  Sounds reasonable
              Angelo Veltens: aveltens: Will finish the "Create  Movie" part of the cookbook before
              Angelo Veltens: aveltens: I will be able to spend less time on it
              Tomasz Pluskiewicz:  i would like to deploy some really working code
              Angelo Veltens: serialseb: I can put some time on it
              ... e.g. implementing the example with openrasta
              ... perhaps on  saturday
              ACTION: aveltens will start working on listing movies, after finishing the cookbook example
              
              Topic: Get a grip on collection ordering issue #172
              Karol Szczepański:  shall we move on, or postpone?
              Tomasz Pluskiewicz:  The main person regarding that issue is not present
              present+
              Angelo Veltens: serialseb: This could be in an additional spec that covers the more complicated stuff
              Karol Szczepański:  We discussed extensions multiple times
              ... lets focus on the core
              Karol Szczepański:  We postpone this to the next call
              ... maybe peter will join as next time
              Apologies - did this call start 7 minutes ago or an hour and 7 minutes ago?  The wiki wasn’t very clear
              Karol Szczepański: unfortunately, it started 1 hour and 7 minutes ago
              sounds good - I will adjust my calendar notification for next time!
              Karol Szczepański: excellent - I'm looking forward to hearing you next time!\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-05-28
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-05-28
                      Topics
                      
                         Finalize manages block PR
                         Discuss cookbook PR #9
                         Revisit property supported operations design - issue #196
                         Decide on next piece of movies example API
                         Get a grip on collection ordering issue #172
                      
                      Action Items
                      
                         
                         aveltens will start working on listing movies, after finishing the cookbook example
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      undefined
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Valtens, Sebastien Lambla
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              
              Topic: Finalize manages block PR
              Karol Szczepański:  This was approved by me and angelo
              ... merged it
              Tomasz Pluskiewicz:   This should close a number of old issues, which might wake some people
              
              Topic: Discuss cookbook PR #9
              https://github.com/HydraCG/cookbook/pull/9
              Karol Szczepański:  I am fine with it as is
              ... can live with the duplication
              Tomasz Pluskiewicz:  The ones we already have are not really drafts anymore
              Tomasz Pluskiewicz:  Should be fine to merge now
              Karol Szczepański:  indeed
              https://deploy-preview-9--hydra-cookbook.netlify.com/
              Karol Szczepański:  all checks are ok, merge
              
              Topic: Revisit property supported operations design - issue #196
              https://github.com/HydraCG/Specifications/issues/196
              Tomasz Pluskiewicz:  It might be more complicated. I am sure most people would already be doing it the same way as in the example
              Tomasz Pluskiewicz: http://www.markus-lanthaler.com/hydra/api-demo/vocab
              Tomasz Pluskiewicz: vocab:EntryPoint/myAccount
              Discussing the api-demo example
              Angelo Veltens: conclusions:
              Angelo Veltens: - spec does allow supportedOperation on both: property and supportedProperty
              - it might be confusing to have to many possibilities
              - the cookbook should provide best practices
              - same origin policy might be applied to trust only statements that came from the api itself
              Karol Szczepański:  how shall we proceed with the issue?
              Tomasz Pluskiewicz:  We will get there with the cookbook eventually
              ... supportedOperation of property is missing as an example in the spec, we could add this
              Angelo Veltens: serialseb:  Let's get feedback from API developers
              Angelo Veltens: serialseb:  Let's get feedback from API developers
              ACTION: <serialseb will add a comment to issue and attempt a PR for the documentation>
              
              Topic: Decide on next piece of movies example API
              Angelo Veltens: aveltens: We should be able to list movies that were added
              Tomasz Pluskiewicz:  Sounds reasonable
              Angelo Veltens: aveltens: Will finish the "Create  Movie" part of the cookbook before
              Angelo Veltens: aveltens: I will be able to spend less time on it
              Tomasz Pluskiewicz:  i would like to deploy some really working code
              Angelo Veltens: serialseb: I can put some time on it
              ... e.g. implementing the example with openrasta
              ... perhaps on  saturday
              ACTION: aveltens will start working on listing movies, after finishing the cookbook example
              
              Topic: Get a grip on collection ordering issue #172
              Karol Szczepański:  shall we move on, or postpone?
              Tomasz Pluskiewicz:  The main person regarding that issue is not present
              present+
              Angelo Veltens: serialseb: This could be in an additional spec that covers the more complicated stuff
              Karol Szczepański:  We discussed extensions multiple times
              ... lets focus on the core
              Karol Szczepański:  We postpone this to the next call
              ... maybe peter will join as next time
              Apologies - did this call start 7 minutes ago or an hour and 7 minutes ago?  The wiki wasn’t very clear
              Karol Szczepański: unfortunately, it started 1 hour and 7 minutes ago
              sounds good - I will adjust my calendar notification for next time!
              Karol Szczepański: excellent - I'm looking forward to hearing you next time!\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-05-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-05-14
                      Topics
                      
                         API Examples
                         Resolve pull request #185
                         Discuss rdfs:range issue #192
                         hydra:manages
                      
                      Action Items
                      
                         Sebastien would share some API examples of his own
                         Tomasz adds a proper statement in the spec on how to undestand manages block
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Sebastien Lambla
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: API Examples
              Karol Szczepański:  there are no PRs pending
              Tomasz Pluskiewicz:  I wanted to keep track on the progress
              Tomasz Pluskiewicz:  wanted to propose implementing stuff on top of the API examples
              Tomasz Pluskiewicz:  finished stuff on the front end, generic app that I maintain
              Tomasz Pluskiewicz:  Sebastian, did you have a chance to take a peek on the examples?
              Sebastien Lambla: I'm happy to review it
              Sebastien Lambla: working on server implementation with .net server
              Tomasz Pluskiewicz:  did you have any thoughts on making api examples a repository useful for yourself
              Tomasz Pluskiewicz:  following a slack chat you'd be best source of feedback
              Sebastien Lambla: we tried to follow the examples with the heracles client
              Sebastien Lambla: there were examples with divergence, that were not compatible with collections, items
              Sebastien Lambla: I'm happy going through the examples to understand whole topic
              Tomasz Pluskiewicz:  actions are relatively new
              Karol Szczepański:  actions didn't make it trough to the espec
              Sebastien Lambla: we've got a live API that uses operations
              Karol Szczepański:  I'd love to help you with whatever needs you have related with hydra that your customer needs
              Karol Szczepański:  there is some .net implementation I've made some time ago
              Tomasz Pluskiewicz:  also I did create a nancy module for hydra
              Tomasz Pluskiewicz:  there are two clients in JS so we can discover possible ways of using it
              Sebastien Lambla: some implementation workshop would come in handy
              Sebastien Lambla: is it worht of keeping several examples in same repo or to have a separate one?
              Karol Szczepański:  we've agreed on having multiple API in one example repo
              Sebastien Lambla: there are some broken things in hydra, but entrypoint, documentation and collections I have implemented
              Sebastien Lambla: there are some purchase actions on some collections
              ACTION: serialseb would share some API examples of his own
              Tomasz Pluskiewicz:  we shall create some issues to havae a backlog for future API examples
              
              Topic: Resolve pull request #185
              https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I'd love to have it merged ASAP as this PR sits there for some time
              Karol Szczepański:  we agreed on not moving toward any more complicated header constructs, thus only xsd:string sits in the terms
              Tomasz Pluskiewicz:  I din't look at this one recently
              Tomasz Pluskiewicz:  but I agree xsd:string is fine now, there shouldn't be any problem with having more detailed values in future
              
              Topic: Discuss rdfs:range issue #192
              https://github.com/HydraCG/Specifications/issues/192
              Sebastien Lambla: we're implementing rdfs:ranges on our side
              Sebastien Lambla: it's a local vocabulary
              Sebastien Lambla: we've redefined context to have the payload look like a pure JSON
              https://my.api.whenfresh.com/catalog/browse/Building/Design
              Tomasz Pluskiewicz:  maybe Karol's statement on having MAY in first point I proposed is not that bad
              Tomasz Pluskiewicz:  if taking into account Sebastiens approach
              I barely here you Tomasz :(
              Sebastien Lambla: we're dynamicaly compiling serializers, we're linking documents
              Sebastien Lambla: this is for pure performance purposes
              Sebastien Lambla: there is no JSON-LD in the backend - we cannot have it at the moment due to performance
              Sebastien Lambla: whole communication is with pure JSON and context linked
              http://docs.api.whenfresh.com/docs/guides/http/getting-postal-addresses-for-a-postcode/index.html
              Tomasz Pluskiewicz: https://github.com/HydraCG/Specifications/pull/132
              
              Topic: hydra:manages
              https://github.com/HydraCG/Specifications/issues/126
              ACTION: tpluskiewicz adds a proper statement in the spec on how to undestand manages block\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-05-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-05-14
                      Topics
                      
                         API Examples
                         Resolve pull request #185
                         Discuss rdfs:range issue #192
                         hydra:manages
                      
                      Action Items
                      
                         Sebastien would share some API examples of his own
                         Tomasz adds a proper statement in the spec on how to undestand manages block
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Sebastien Lambla
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: API Examples
              Karol Szczepański:  there are no PRs pending
              Tomasz Pluskiewicz:  I wanted to keep track on the progress
              Tomasz Pluskiewicz:  wanted to propose implementing stuff on top of the API examples
              Tomasz Pluskiewicz:  finished stuff on the front end, generic app that I maintain
              Tomasz Pluskiewicz:  Sebastian, did you have a chance to take a peek on the examples?
              Sebastien Lambla: I'm happy to review it
              Sebastien Lambla: working on server implementation with .net server
              Tomasz Pluskiewicz:  did you have any thoughts on making api examples a repository useful for yourself
              Tomasz Pluskiewicz:  following a slack chat you'd be best source of feedback
              Sebastien Lambla: we tried to follow the examples with the heracles client
              Sebastien Lambla: there were examples with divergence, that were not compatible with collections, items
              Sebastien Lambla: I'm happy going through the examples to understand whole topic
              Tomasz Pluskiewicz:  actions are relatively new
              Karol Szczepański:  actions didn't make it trough to the espec
              Sebastien Lambla: we've got a live API that uses operations
              Karol Szczepański:  I'd love to help you with whatever needs you have related with hydra that your customer needs
              Karol Szczepański:  there is some .net implementation I've made some time ago
              Tomasz Pluskiewicz:  also I did create a nancy module for hydra
              Tomasz Pluskiewicz:  there are two clients in JS so we can discover possible ways of using it
              Sebastien Lambla: some implementation workshop would come in handy
              Sebastien Lambla: is it worht of keeping several examples in same repo or to have a separate one?
              Karol Szczepański:  we've agreed on having multiple API in one example repo
              Sebastien Lambla: there are some broken things in hydra, but entrypoint, documentation and collections I have implemented
              Sebastien Lambla: there are some purchase actions on some collections
              ACTION: serialseb would share some API examples of his own
              Tomasz Pluskiewicz:  we shall create some issues to havae a backlog for future API examples
              
              Topic: Resolve pull request #185
              https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I'd love to have it merged ASAP as this PR sits there for some time
              Karol Szczepański:  we agreed on not moving toward any more complicated header constructs, thus only xsd:string sits in the terms
              Tomasz Pluskiewicz:  I din't look at this one recently
              Tomasz Pluskiewicz:  but I agree xsd:string is fine now, there shouldn't be any problem with having more detailed values in future
              
              Topic: Discuss rdfs:range issue #192
              https://github.com/HydraCG/Specifications/issues/192
              Sebastien Lambla: we're implementing rdfs:ranges on our side
              Sebastien Lambla: it's a local vocabulary
              Sebastien Lambla: we've redefined context to have the payload look like a pure JSON
              https://my.api.whenfresh.com/catalog/browse/Building/Design
              Tomasz Pluskiewicz:  maybe Karol's statement on having MAY in first point I proposed is not that bad
              Tomasz Pluskiewicz:  if taking into account Sebastiens approach
              I barely here you Tomasz :(
              Sebastien Lambla: we're dynamicaly compiling serializers, we're linking documents
              Sebastien Lambla: this is for pure performance purposes
              Sebastien Lambla: there is no JSON-LD in the backend - we cannot have it at the moment due to performance
              Sebastien Lambla: whole communication is with pure JSON and context linked
              http://docs.api.whenfresh.com/docs/guides/http/getting-postal-addresses-for-a-postcode/index.html
              Tomasz Pluskiewicz: https://github.com/HydraCG/Specifications/pull/132
              
              Topic: hydra:manages
              https://github.com/HydraCG/Specifications/issues/126
              ACTION: tpluskiewicz adds a proper statement in the spec on how to undestand manages block\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-05-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-05-14
                      Topics
                      
                         API Examples
                         Resolve pull request #185
                         Discuss rdfs:range issue #192
                         hydra:manages
                      
                      Action Items
                      
                         Sebastien would share some API examples of his own
                         Tomasz adds a proper statement in the spec on how to undestand manages block
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Sebastien Lambla
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: API Examples
              Karol Szczepański:  there are no PRs pending
              Tomasz Pluskiewicz:  I wanted to keep track on the progress
              Tomasz Pluskiewicz:  wanted to propose implementing stuff on top of the API examples
              Tomasz Pluskiewicz:  finished stuff on the front end, generic app that I maintain
              Tomasz Pluskiewicz:  Sebastian, did you have a chance to take a peek on the examples?
              Sebastien Lambla: I'm happy to review it
              Sebastien Lambla: working on server implementation with .net server
              Tomasz Pluskiewicz:  did you have any thoughts on making api examples a repository useful for yourself
              Tomasz Pluskiewicz:  following a slack chat you'd be best source of feedback
              Sebastien Lambla: we tried to follow the examples with the heracles client
              Sebastien Lambla: there were examples with divergence, that were not compatible with collections, items
              Sebastien Lambla: I'm happy going through the examples to understand whole topic
              Tomasz Pluskiewicz:  actions are relatively new
              Karol Szczepański:  actions didn't make it trough to the espec
              Sebastien Lambla: we've got a live API that uses operations
              Karol Szczepański:  I'd love to help you with whatever needs you have related with hydra that your customer needs
              Karol Szczepański:  there is some .net implementation I've made some time ago
              Tomasz Pluskiewicz:  also I did create a nancy module for hydra
              Tomasz Pluskiewicz:  there are two clients in JS so we can discover possible ways of using it
              Sebastien Lambla: some implementation workshop would come in handy
              Sebastien Lambla: is it worht of keeping several examples in same repo or to have a separate one?
              Karol Szczepański:  we've agreed on having multiple API in one example repo
              Sebastien Lambla: there are some broken things in hydra, but entrypoint, documentation and collections I have implemented
              Sebastien Lambla: there are some purchase actions on some collections
              ACTION: serialseb would share some API examples of his own
              Tomasz Pluskiewicz:  we shall create some issues to havae a backlog for future API examples
              
              Topic: Resolve pull request #185
              https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I'd love to have it merged ASAP as this PR sits there for some time
              Karol Szczepański:  we agreed on not moving toward any more complicated header constructs, thus only xsd:string sits in the terms
              Tomasz Pluskiewicz:  I din't look at this one recently
              Tomasz Pluskiewicz:  but I agree xsd:string is fine now, there shouldn't be any problem with having more detailed values in future
              
              Topic: Discuss rdfs:range issue #192
              https://github.com/HydraCG/Specifications/issues/192
              Sebastien Lambla: we're implementing rdfs:ranges on our side
              Sebastien Lambla: it's a local vocabulary
              Sebastien Lambla: we've redefined context to have the payload look like a pure JSON
              https://my.api.whenfresh.com/catalog/browse/Building/Design
              Tomasz Pluskiewicz:  maybe Karol's statement on having MAY in first point I proposed is not that bad
              Tomasz Pluskiewicz:  if taking into account Sebastiens approach
              I barely here you Tomasz :(
              Sebastien Lambla: we're dynamicaly compiling serializers, we're linking documents
              Sebastien Lambla: this is for pure performance purposes
              Sebastien Lambla: there is no JSON-LD in the backend - we cannot have it at the moment due to performance
              Sebastien Lambla: whole communication is with pure JSON and context linked
              http://docs.api.whenfresh.com/docs/guides/http/getting-postal-addresses-for-a-postcode/index.html
              Tomasz Pluskiewicz: https://github.com/HydraCG/Specifications/pull/132
              
              Topic: hydra:manages
              https://github.com/HydraCG/Specifications/issues/126
              ACTION: tpluskiewicz adds a proper statement in the spec on how to undestand manages block\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-04-30
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-04-30
                      Topics
                      
                         Advance the API examples and plan future actions
                         Publishing Heracles.ts to NPM (organization scope or user)
                         Next steps with Hydra Console prototype
                         EntryPoint type in the resource
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Valtens
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.              
              Topic: Advance the API examples and plan future actions
              Karol Szczepański:  Tomasz, you proposed
              Tomasz Pluskiewicz:  I propose that we maybe with every PR shall add a simple MD document with requirements or documentation [scribe assist by Karol Szczepański]
              Karol Szczepański: aveltens: I like the idea, I'd introduce it with next changes
              Angelo Veltens: I had this in mind. was thinking to add with next PR
              Karol Szczepański: aveltens: next it wuld be to have some sort of a collection supporting operation to create and remove movies
              Karol Szczepański:  it sound similar to the cookbook
              ... I think it's redundant
              Angelo Veltens: we could refer to the cookbook
              Karol Szczepański: Karol_szczepansk: shall we have a cookbok documented using examples from the api-examples repo?
              Tomasz Pluskiewicz:  OK - lets have a cookbok document api-examples [scribe assist by Karol Szczepański]
              Angelo Veltens: there are multiple ways to approach that
              ... we would have to mint custom class for collection, subclass of hydra:Collection
              ... the way I did it was to use only hydra identifiers and operation inline
              ... should be prefer one or another approach
              Tomasz Pluskiewicz:  we want the APIs to present different goals
              Karol Szczepański:  I think Angelo's problems is no direct way
              ... I think it's related to one of the spec issues PR #186, I think
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/186
              Tomasz Pluskiewicz:  we should have these discussion on the repo
              Karol Szczepański:  on the cookbook?
              Angelo Veltens: I don't think it's a spec issue
              .. what should I put in the cookbook
              Karol Szczepański:  the cookbook first
              Tomasz Pluskiewicz:  I think we should go with the api first. and cookbook one we're happy with the resukt
              Karol Szczepański:  do we know?
              Angelo Veltens: spec change would require cookbook first.
              Karol Szczepański:  but how will raw payload help understand the required spec change?
              Angelo Veltens: what should the api example show?
              Tomasz Pluskiewicz:  all possible solutions
              Karol Szczepański:  in the example of subclassing collection, I would not recommend.
              Angelo Veltens: I would not recommend it either. I did not use subclass because I want the client simple
              Tomasz Pluskiewicz:  you don't need subclassing. you can have multiple types.
              Karol Szczepański:  without a description it's not useful
              ... maybe we should do multiple PR, in both cookbook and examples
              Angelo Veltens: I will prepare a PR in both repositories
              Karol Szczepański:  I will experiment with those approaches in the client and console
              Angelo Veltens: the problem is client code. I tried Tomasz's client but there is a bug I opened
              Tomasz Pluskiewicz: I remember
              ... we should keep the solutions complete. test the API in real apps
              Angelo Veltens: I see the new console shows some better result
              ... the old hydra console didn't work at all
              ... what I missed in the old client is showing some error messages
              Karol Szczepański:  yes, the new console doesn't have much error handling yet
              Angelo Veltens: new comers will not use hydra if they don't have feed for errors
              Tomasz Pluskiewicz:  I was thinking about a verification tool
              Karol Szczepański:  yes, I think we made a list of possible tools already when Ruben proposed a meeting
              Tomasz Pluskiewicz:  we should go with more simple features
              Angelo Veltens: I think collections are core
              Tomasz Pluskiewicz:  hydra:Link is a more primitive building block
              Angelo Veltens: what is it good for?
              Karol Szczepański:  I think you should follow you current needs
              Angelo Veltens: the order does not have to be the same as it's written down in the cookbook
              Tomasz Pluskiewicz:  I think these examples should be implemented in a way which could server a brand new server implementation
              Tomasz Pluskiewicz:  I think we should try not to leak hydra abstractions in the descriptions
              Angelo Veltens: I could try with Link but I need a use case
              Tomasz Pluskiewicz:  right. let's go with collections but focus on the functionality
              
              Topic: Publishing Heracles.ts to NPM (organization scope or user)
              Karol Szczepański:  I want to publish the client to npm
              ... I created an organization but I don't know if it's possible to publish unde org
              Tomasz Pluskiewicz:  I think it depends on the name
              Karol Szczepański:  should it be scoped?
              Angelo Veltens: I like the scope
              Tomasz Pluskiewicz:  scoped makes sense
              Karol Szczepański:  should it be hydra or hydracg?
              
              Topic: Next steps with Hydra Console prototype
              Karol Szczepański:  it's quite early. I tested it with some APIs
              ... it doesn't look awesome but clean
              ... I'd like a better UI
              Tomasz Pluskiewicz:  it is an SPA?
              Karol Szczepański:  Markus mentioned it should be possible to push to hydra-cg.com
              Karol Szczepański:  how should proceed?
              Angelo Veltens: we should move it to hydra repositories if it's meant to be the official console
              Karol Szczepański:  the previous was on Markus' personal account
              Tomasz Pluskiewicz:  in the end it doesn't really matter
              
              Topic: EntryPoint type in the resource
              Karol Szczepański:  what I found was angelo's movies and also old example api
              ... both of you provide a type for entrypoint and it resolves to non-hydra URL
              ... and neither api provides an entrypoint in the doc
              Angelo Veltens: yes, I did not notice that
              Angelo Veltens: entrypoint indeed, could be anything
              ... but what would be an entrypoint
              Tomasz Pluskiewicz:  I think it can be anything, a collection of links\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-04-08
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-04-08
                      Topics
                      
                         Last call actions
                         Development of example API and client application
                      
                      Action Items
                      
                         Karol Szczpepanski will create repo named api-examples
                         Angelo Veltens to create a heroku account for free tier for Hydra CG
                         Tomasz Pluskiewicz will create a cookbook for a way to provide a set of values for a property
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Angelo Veltens
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Veltens
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              
              Topic: Last call actions
              Karol Szczepański:  First topic ist "Last call action points"
              Could not provide cookbook examples for PR-186 yet
              ... focused on hydra console development
              Live Demo of the console
              Karol Szczepański:  Angelo your API endpoint did not work, because no ApiDoc
              Angelo Veltens: Angelo: I did not expose the Link header, but that is fixed meanwhile
              Karol Szczepański:  Want to get the features of the old Hydra console
              Tomasz Pluskiewicz:  I set up a hook to trigger hydra-notification channel
              ... it includes issues, PRs from github and twitter
              
              Topic: Development of example API and client application
              Karol Szczepański:  There where some ideas on Slack
              Tomasz Pluskiewicz: https://github.com/gothinkster/realworld
              Karol Szczepański: - public transport ticket service
              Karol Szczepański: - PSD2 compliant bank account service
              Karol Szczepański: - bug trucker
              Karol Szczepański: - cinema ticket ordering
              Karol Szczepański: - restaurant / cofee shop ordering
              Karol Szczepański: - eCommerce
              Tomasz Pluskiewicz:  What we do could be the basis for an acceptence test suite. Given this entrypoint, when you do x, then ....
              ... one repostitory for general JSON-LD API design and several other repos that implement it  using different technologies
              Tomasz Pluskiewicz: https://github.com/HTTP-APIs/hydrus-real-world-app/blob/master/RealWorldApiDoc.jsonld
              ... Lorenzo already created a repo in HTTP-APIs org
              ... he replicated the realworld API with hydra
              ... might not be a bad idea to take the realworld API as is to be able to focus on hydra
              ... instead of discussion about domion
              Angelo Veltens: Angelo: Can we implement every feature we want to support with hydra in such an API?
              Tomasz Pluskiewicz: https://github.com/gothinkster/realworld/tree/master/api
              Tomasz Pluskiewicz:  It's not hypermedia driven, but at least a big enough starting point
              Angelo Veltens: Angelo: We could still have a second API if we see that this API will not cover everything
              Tomasz Pluskiewicz:  Let's first set up a repo with static files. JSON-LD written by hand
              Karol Szczepański:  this is similar to the tests in the reference client
              Tomasz Pluskiewicz:  Turn realworld stuff into JSON-LDs, serve them with express
              Karol Szczepański:   This way we have some comparision with other approaches
              Tomasz Pluskiewicz:  on the other hand there is client implementation
              ... once we have the server, even with static files, we could start implementing the UI
              ... Angelo you where  also interested in building a client
              Angelo Veltens: Angelo: You could have a domain-specific client that is generic  regarding the JSON structure / needed API requests
              Karol Szczepański:  How do we want to proceed?
              ... we are working on different but similar things
              Angelo Veltens: Angelo: What is the different between the Hydra Console and the generic client
              Karol Szczepański:  Hydra console is focussing on the ApiDoc, generic client more about browsing the data
              ... I like the cinema domain you are working on, Angelo, I would prefer it over realworld
              Tomasz Pluskiewicz:  You would have to take the "lead" about the cinema domain
              Karol Szczepański: let's vote
              Angelo Veltens: Angelo: What I like about the domain is that we could start with simple CRUD for movies, and advance to more complex hypermedia processes for ticketing
              Karol Szczepański: realworld example:
              Tomasz Pluskiewicz: +1/2
              Karol Szczepański: cinematic example
              Tomasz Pluskiewicz: +1
              Karol Szczepański: +1
              Karol Szczepański: cinemapi, is that correct?
              Karol Szczepański:  Shall we create a new repo for it
              Angelo Veltens: Angelo: I wonder if we want to have several APIs: movies, events, tickets, and interlink them
              Tomasz Pluskiewicz:  We should use a monorepo
              Tomasz Pluskiewicz:  Just create the repo, we could rename it
              ACTION: create repo named api-examples
              Tomasz Pluskiewicz:  we need more control over the CG from Markus
              Angelo Veltens: Angelo: Could someone add me to the group
              Tomasz Pluskiewicz:  That's the point, we cannot
              Karol Szczepański:  I will ask markus
              Tomasz Pluskiewicz:  First Action item for you Angelo would be to start with an entrypoint and API doc
              Karol Szczepański:  Feel free to use nodejs
              Tomasz Pluskiewicz:  I create a bitwarden for passwords
              ... there is zapier and netlify in it
              ACTION: aveltens to create a heroku account for free tier for Hydra CG
              Tomasz Pluskiewicz: [ a SupportedProperty;  collection [  a IriTemplate ] ]
              Tomasz Pluskiewicz: [ a SupportedProperty;  collection [  a Collection ] ]
              ACTION: tpluskiewicz will create a cookbook for a way to provide a set of values for a property\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-03-25
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-03-25
                      Topics
                      
                         Discuss open pull requests
                         Monitoring and handling of the @HydraCG Twitter account
                         Development of example API and client application
                      
                      Action Items
                      
                         Karol_Szczepanski to create a cookbook example and documentation changes for #186
                         Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
                         tpluskiewicz is to hookup slack with tweeter
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Angelo Veltens, Tomasz Pluskiewicz
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Discuss open pull requests
              Collaboration templates PR188 https://github.com/HydraCG/Specifications/pull/188
              Karol Szczepański:  this one looks fine for me
              Tomasz Pluskiewicz: there are no unresolved issues
              Karol Szczepański:  So I'll merge it ASAP
              Add support for describing headers #185 https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I've retracted template based features and now there are only simple expected/returned header names
              Angelo Veltens: seems GH screwed the diff view
              "returnsHeader": { "@id": "hydra:returnsHeader", "@type": "xsd:string" },     "expectsHeader": { "@id": "hydra:expectsHeader", "@type": "xsd:string" },
              {       "@id": "hydra:returnsHeader",       "@type": "rdf:Property",       "label": "returns header",       "comment": "Name of the header returned by the operation.",       "domain": "hydra:Operation",       "range": "xsd:string",       "vs:term_status": "testing"     },     {       "@id": "hydra:expectsHeader",       "@type": "rdf:Property",       "label": "expects header",       "comment": "Specification of the header expected by the operation.",  [CUT]
              ```
              Angelo Veltens: seems like broken line endings
              Tomasz Pluskiewicz: when you looks at GH you can change display options
              Karol Szczepański:  I'll take a look at those line endings
              Karol Szczepański:  not sure what went wrong as I don't recall chaning anything by hand
              Detailed specification for expects/returns and strongly typed collections #187 https://github.com/HydraCG/Specifications/pull/187
              Karol Szczepański:  I did oppose using SHACL to express constraints
              Angelo Veltens: I understand you don't wanto commit hydra to specific solution
              Angelo Veltens: but using self crafted elements might introduce more confusion
              Tomasz Pluskiewicz: SHACL shouldn't be a core vocab
              Tomasz Pluskiewicz: we should target a framework for extensions
              Tomasz Pluskiewicz: we could have some basic constructs and an extension for SHACL
              Angelo Veltens: I've rediscovered - another way of using hydra:expects
              ```"hydra:expects": {                      "@type": "Product",                      "hydra:supportedProperty": [                        {                          "hydra:property": "name",                          "hydra:required": true,                          "defaultValue": "shot",                          "readOnlyValue": true                        }                      ]                    }
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra
              Tomasz Pluskiewicz: which section in the document would it be?
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra#Add-Ons_for_my_Coffee
              Karol Szczepański:  I didn't introduce anything really new
              Karol Szczepański:  hydra:manages is subPropertyOf hydra:specifies and all the other constructs are the same
              Karol Szczepański:  this was due to fact that hydra:manages is bound to collection
              Angelo Veltens: how client would benefit from this PR now
              Karol Szczepański:  the biggest value would be in expressing non-RDF resources via media type constraint
              Angelo Veltens: I don't like the recursion for collection item types
              Angelo Veltens: for media types I'd go with different solution and for constraints I'd go with cookbook and examples
              Tomasz Pluskiewicz: It's not tha academic as Angelo said
              Angelo Veltens: we shall discuss it better, with examples and different approaches
              Allow returns/expects to be expressed in terms of a media type #186 https://github.com/HydraCG/Specifications/pull/186/files
              ACTION: Karol_Szczepanski to create a cookbook example and documentation changes for #186
              Angelo Veltens: maybe we should introduce expectsMediaType (as with expects or expectsHeader)
              Karol Szczepański:  what if there are both predicates for non-rdf resource
              Karol Szczepański:  i.e. expectsMediaType: image/jpeg and expects: schema:Image
              Tomasz Pluskiewicz: we shoulnd't mix returns and expects
              Tomasz Pluskiewicz: but it is a content negotiation
              Tomasz Pluskiewicz: it's not for hydra to decide whether the image as jpg and rdf is conceptually the same
              Tomasz Pluskiewicz: if the client encounteres a description with different representation they should be know on how to handle such a payload
              Karol Szczepański:  what would be meaning of this construct with both media type and RDF class expectation
              Karol Szczepański:  image and it's meta-data document are diferent resources
              Angelo Veltens: for person you could have a schema:Person as a return/expect a resource describing it, either as HTML or RDF data
              ACTION: Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
              
              Topic: Monitoring and handling of the @HydraCG Twitter account
              Tomasz Pluskiewicz: I can tweet and reply to messages
              Tomasz Pluskiewicz: for now I'm fine taking care of it alone
              Tomasz Pluskiewicz: we've created a zapier account for HydraCG
              ACTION: tpluskiewicz is to hookup slack with tweeter
              
              Topic: Development of example API and client application
              Karol Szczepański:  I'm working on a hydr console angular app
              Karol Szczepański:  I've i.e. stumbled on an issue on which links to display
              Angelo Veltens: we lack examples of server side payloads (without any specific underlying technology)
              https://screening-events.herokuapp.com
              http://cc-cinema.herokuapp.com/#/
              Karol Szczepański:  I think we shall have a call in two weeks but I'm fine with next one\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-03-25
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-03-25
                      Topics
                      
                         Discuss open pull requests
                         Monitoring and handling of the @HydraCG Twitter account
                         Development of example API and client application
                      
                      Action Items
                      
                         Karol_Szczepanski to create a cookbook example and documentation changes for #186
                         Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
                         tpluskiewicz is to hookup slack with tweeter
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Angelo Veltens, Tomasz Pluskiewicz
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Discuss open pull requests
              Collaboration templates PR188 https://github.com/HydraCG/Specifications/pull/188
              Karol Szczepański:  this one looks fine for me
              Tomasz Pluskiewicz: there are no unresolved issues
              Karol Szczepański:  So I'll merge it ASAP
              Add support for describing headers #185 https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I've retracted template based features and now there are only simple expected/returned header names
              Angelo Veltens: seems GH screwed the diff view
              "returnsHeader": { "@id": "hydra:returnsHeader", "@type": "xsd:string" },     "expectsHeader": { "@id": "hydra:expectsHeader", "@type": "xsd:string" },
              {       "@id": "hydra:returnsHeader",       "@type": "rdf:Property",       "label": "returns header",       "comment": "Name of the header returned by the operation.",       "domain": "hydra:Operation",       "range": "xsd:string",       "vs:term_status": "testing"     },     {       "@id": "hydra:expectsHeader",       "@type": "rdf:Property",       "label": "expects header",       "comment": "Specification of the header expected by the operation.",  [CUT]
              ```
              Angelo Veltens: seems like broken line endings
              Tomasz Pluskiewicz: when you looks at GH you can change display options
              Karol Szczepański:  I'll take a look at those line endings
              Karol Szczepański:  not sure what went wrong as I don't recall chaning anything by hand
              Detailed specification for expects/returns and strongly typed collections #187 https://github.com/HydraCG/Specifications/pull/187
              Karol Szczepański:  I did oppose using SHACL to express constraints
              Angelo Veltens: I understand you don't wanto commit hydra to specific solution
              Angelo Veltens: but using self crafted elements might introduce more confusion
              Tomasz Pluskiewicz: SHACL shouldn't be a core vocab
              Tomasz Pluskiewicz: we should target a framework for extensions
              Tomasz Pluskiewicz: we could have some basic constructs and an extension for SHACL
              Angelo Veltens: I've rediscovered - another way of using hydra:expects
              ```"hydra:expects": {                      "@type": "Product",                      "hydra:supportedProperty": [                        {                          "hydra:property": "name",                          "hydra:required": true,                          "defaultValue": "shot",                          "readOnlyValue": true                        }                      ]                    }
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra
              Tomasz Pluskiewicz: which section in the document would it be?
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra#Add-Ons_for_my_Coffee
              Karol Szczepański:  I didn't introduce anything really new
              Karol Szczepański:  hydra:manages is subPropertyOf hydra:specifies and all the other constructs are the same
              Karol Szczepański:  this was due to fact that hydra:manages is bound to collection
              Angelo Veltens: how client would benefit from this PR now
              Karol Szczepański:  the biggest value would be in expressing non-RDF resources via media type constraint
              Angelo Veltens: I don't like the recursion for collection item types
              Angelo Veltens: for media types I'd go with different solution and for constraints I'd go with cookbook and examples
              Tomasz Pluskiewicz: It's not tha academic as Angelo said
              Angelo Veltens: we shall discuss it better, with examples and different approaches
              Allow returns/expects to be expressed in terms of a media type #186 https://github.com/HydraCG/Specifications/pull/186/files
              ACTION: Karol_Szczepanski to create a cookbook example and documentation changes for #186
              Angelo Veltens: maybe we should introduce expectsMediaType (as with expects or expectsHeader)
              Karol Szczepański:  what if there are both predicates for non-rdf resource
              Karol Szczepański:  i.e. expectsMediaType: image/jpeg and expects: schema:Image
              Tomasz Pluskiewicz: we shoulnd't mix returns and expects
              Tomasz Pluskiewicz: but it is a content negotiation
              Tomasz Pluskiewicz: it's not for hydra to decide whether the image as jpg and rdf is conceptually the same
              Tomasz Pluskiewicz: if the client encounteres a description with different representation they should be know on how to handle such a payload
              Karol Szczepański:  what would be meaning of this construct with both media type and RDF class expectation
              Karol Szczepański:  image and it's meta-data document are diferent resources
              Angelo Veltens: for person you could have a schema:Person as a return/expect a resource describing it, either as HTML or RDF data
              ACTION: Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
              
              Topic: Monitoring and handling of the @HydraCG Twitter account
              Tomasz Pluskiewicz: I can tweet and reply to messages
              Tomasz Pluskiewicz: for now I'm fine taking care of it alone
              Tomasz Pluskiewicz: we've created a zapier account for HydraCG
              ACTION: tpluskiewicz is to hookup slack with tweeter
              
              Topic: Development of example API and client application
              Karol Szczepański:  I'm working on a hydr console angular app
              Karol Szczepański:  I've i.e. stumbled on an issue on which links to display
              Angelo Veltens: we lack examples of server side payloads (without any specific underlying technology)
              https://screening-events.herokuapp.com
              http://cc-cinema.herokuapp.com/#/
              Karol Szczepański:  I think we shall have a call in two weeks but I'm fine with next one\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-03-25
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-03-25
                      Topics
                      
                         Discuss open pull requests
                         Monitoring and handling of the @HydraCG Twitter account
                         Development of example API and client application
                      
                      Action Items
                      
                         Karol_Szczepanski to create a cookbook example and documentation changes for #186
                         Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
                         tpluskiewicz is to hookup slack with tweeter
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Angelo Veltens, Tomasz Pluskiewicz
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Discuss open pull requests
              Collaboration templates PR188 https://github.com/HydraCG/Specifications/pull/188
              Karol Szczepański:  this one looks fine for me
              Tomasz Pluskiewicz: there are no unresolved issues
              Karol Szczepański:  So I'll merge it ASAP
              Add support for describing headers #185 https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I've retracted template based features and now there are only simple expected/returned header names
              Angelo Veltens: seems GH screwed the diff view
              "returnsHeader": { "@id": "hydra:returnsHeader", "@type": "xsd:string" },     "expectsHeader": { "@id": "hydra:expectsHeader", "@type": "xsd:string" },
              {       "@id": "hydra:returnsHeader",       "@type": "rdf:Property",       "label": "returns header",       "comment": "Name of the header returned by the operation.",       "domain": "hydra:Operation",       "range": "xsd:string",       "vs:term_status": "testing"     },     {       "@id": "hydra:expectsHeader",       "@type": "rdf:Property",       "label": "expects header",       "comment": "Specification of the header expected by the operation.",  [CUT]
              ```
              Angelo Veltens: seems like broken line endings
              Tomasz Pluskiewicz: when you looks at GH you can change display options
              Karol Szczepański:  I'll take a look at those line endings
              Karol Szczepański:  not sure what went wrong as I don't recall chaning anything by hand
              Detailed specification for expects/returns and strongly typed collections #187 https://github.com/HydraCG/Specifications/pull/187
              Karol Szczepański:  I did oppose using SHACL to express constraints
              Angelo Veltens: I understand you don't wanto commit hydra to specific solution
              Angelo Veltens: but using self crafted elements might introduce more confusion
              Tomasz Pluskiewicz: SHACL shouldn't be a core vocab
              Tomasz Pluskiewicz: we should target a framework for extensions
              Tomasz Pluskiewicz: we could have some basic constructs and an extension for SHACL
              Angelo Veltens: I've rediscovered - another way of using hydra:expects
              ```"hydra:expects": {                      "@type": "Product",                      "hydra:supportedProperty": [                        {                          "hydra:property": "name",                          "hydra:required": true,                          "defaultValue": "shot",                          "readOnlyValue": true                        }                      ]                    }
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra
              Tomasz Pluskiewicz: which section in the document would it be?
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra#Add-Ons_for_my_Coffee
              Karol Szczepański:  I didn't introduce anything really new
              Karol Szczepański:  hydra:manages is subPropertyOf hydra:specifies and all the other constructs are the same
              Karol Szczepański:  this was due to fact that hydra:manages is bound to collection
              Angelo Veltens: how client would benefit from this PR now
              Karol Szczepański:  the biggest value would be in expressing non-RDF resources via media type constraint
              Angelo Veltens: I don't like the recursion for collection item types
              Angelo Veltens: for media types I'd go with different solution and for constraints I'd go with cookbook and examples
              Tomasz Pluskiewicz: It's not tha academic as Angelo said
              Angelo Veltens: we shall discuss it better, with examples and different approaches
              Allow returns/expects to be expressed in terms of a media type #186 https://github.com/HydraCG/Specifications/pull/186/files
              ACTION: Karol_Szczepanski to create a cookbook example and documentation changes for #186
              Angelo Veltens: maybe we should introduce expectsMediaType (as with expects or expectsHeader)
              Karol Szczepański:  what if there are both predicates for non-rdf resource
              Karol Szczepański:  i.e. expectsMediaType: image/jpeg and expects: schema:Image
              Tomasz Pluskiewicz: we shoulnd't mix returns and expects
              Tomasz Pluskiewicz: but it is a content negotiation
              Tomasz Pluskiewicz: it's not for hydra to decide whether the image as jpg and rdf is conceptually the same
              Tomasz Pluskiewicz: if the client encounteres a description with different representation they should be know on how to handle such a payload
              Karol Szczepański:  what would be meaning of this construct with both media type and RDF class expectation
              Karol Szczepański:  image and it's meta-data document are diferent resources
              Angelo Veltens: for person you could have a schema:Person as a return/expect a resource describing it, either as HTML or RDF data
              ACTION: Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
              
              Topic: Monitoring and handling of the @HydraCG Twitter account
              Tomasz Pluskiewicz: I can tweet and reply to messages
              Tomasz Pluskiewicz: for now I'm fine taking care of it alone
              Tomasz Pluskiewicz: we've created a zapier account for HydraCG
              ACTION: tpluskiewicz is to hookup slack with tweeter
              
              Topic: Development of example API and client application
              Karol Szczepański:  I'm working on a hydr console angular app
              Karol Szczepański:  I've i.e. stumbled on an issue on which links to display
              Angelo Veltens: we lack examples of server side payloads (without any specific underlying technology)
              https://screening-events.herokuapp.com
              http://cc-cinema.herokuapp.com/#/
              Karol Szczepański:  I think we shall have a call in two weeks but I'm fine with next one\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-03-25
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-03-25
                      Topics
                      
                         Discuss open pull requests
                         Monitoring and handling of the @HydraCG Twitter account
                         Development of example API and client application
                      
                      Action Items
                      
                         Karol_Szczepanski to create a cookbook example and documentation changes for #186
                         Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
                         tpluskiewicz is to hookup slack with tweeter
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Angelo Veltens, Tomasz Pluskiewicz
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Discuss open pull requests
              Collaboration templates PR188 https://github.com/HydraCG/Specifications/pull/188
              Karol Szczepański:  this one looks fine for me
              Tomasz Pluskiewicz: there are no unresolved issues
              Karol Szczepański:  So I'll merge it ASAP
              Add support for describing headers #185 https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  I've retracted template based features and now there are only simple expected/returned header names
              Angelo Veltens: seems GH screwed the diff view
              "returnsHeader": { "@id": "hydra:returnsHeader", "@type": "xsd:string" },     "expectsHeader": { "@id": "hydra:expectsHeader", "@type": "xsd:string" },
              {       "@id": "hydra:returnsHeader",       "@type": "rdf:Property",       "label": "returns header",       "comment": "Name of the header returned by the operation.",       "domain": "hydra:Operation",       "range": "xsd:string",       "vs:term_status": "testing"     },     {       "@id": "hydra:expectsHeader",       "@type": "rdf:Property",       "label": "expects header",       "comment": "Specification of the header expected by the operation.",  [CUT]
              ```
              Angelo Veltens: seems like broken line endings
              Tomasz Pluskiewicz: when you looks at GH you can change display options
              Karol Szczepański:  I'll take a look at those line endings
              Karol Szczepański:  not sure what went wrong as I don't recall chaning anything by hand
              Detailed specification for expects/returns and strongly typed collections #187 https://github.com/HydraCG/Specifications/pull/187
              Karol Szczepański:  I did oppose using SHACL to express constraints
              Angelo Veltens: I understand you don't wanto commit hydra to specific solution
              Angelo Veltens: but using self crafted elements might introduce more confusion
              Tomasz Pluskiewicz: SHACL shouldn't be a core vocab
              Tomasz Pluskiewicz: we should target a framework for extensions
              Tomasz Pluskiewicz: we could have some basic constructs and an extension for SHACL
              Angelo Veltens: I've rediscovered - another way of using hydra:expects
              ```"hydra:expects": {                      "@type": "Product",                      "hydra:supportedProperty": [                        {                          "hydra:property": "name",                          "hydra:required": true,                          "defaultValue": "shot",                          "readOnlyValue": true                        }                      ]                    }
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra
              Tomasz Pluskiewicz: which section in the document would it be?
              https://www.w3.org/community/hydra/wiki/Restbucks_with_Hydra#Add-Ons_for_my_Coffee
              Karol Szczepański:  I didn't introduce anything really new
              Karol Szczepański:  hydra:manages is subPropertyOf hydra:specifies and all the other constructs are the same
              Karol Szczepański:  this was due to fact that hydra:manages is bound to collection
              Angelo Veltens: how client would benefit from this PR now
              Karol Szczepański:  the biggest value would be in expressing non-RDF resources via media type constraint
              Angelo Veltens: I don't like the recursion for collection item types
              Angelo Veltens: for media types I'd go with different solution and for constraints I'd go with cookbook and examples
              Tomasz Pluskiewicz: It's not tha academic as Angelo said
              Angelo Veltens: we shall discuss it better, with examples and different approaches
              Allow returns/expects to be expressed in terms of a media type #186 https://github.com/HydraCG/Specifications/pull/186/files
              ACTION: Karol_Szczepanski to create a cookbook example and documentation changes for #186
              Angelo Veltens: maybe we should introduce expectsMediaType (as with expects or expectsHeader)
              Karol Szczepański:  what if there are both predicates for non-rdf resource
              Karol Szczepański:  i.e. expectsMediaType: image/jpeg and expects: schema:Image
              Tomasz Pluskiewicz: we shoulnd't mix returns and expects
              Tomasz Pluskiewicz: but it is a content negotiation
              Tomasz Pluskiewicz: it's not for hydra to decide whether the image as jpg and rdf is conceptually the same
              Tomasz Pluskiewicz: if the client encounteres a description with different representation they should be know on how to handle such a payload
              Karol Szczepański:  what would be meaning of this construct with both media type and RDF class expectation
              Karol Szczepański:  image and it's meta-data document are diferent resources
              Angelo Veltens: for person you could have a schema:Person as a return/expect a resource describing it, either as HTML or RDF data
              ACTION: Karol_Szczepanski close PR 186 and open a cookbook story with expectsMediaType/expects (and returns equiavelents)
              
              Topic: Monitoring and handling of the @HydraCG Twitter account
              Tomasz Pluskiewicz: I can tweet and reply to messages
              Tomasz Pluskiewicz: for now I'm fine taking care of it alone
              Tomasz Pluskiewicz: we've created a zapier account for HydraCG
              ACTION: tpluskiewicz is to hookup slack with tweeter
              
              Topic: Development of example API and client application
              Karol Szczepański:  I'm working on a hydr console angular app
              Karol Szczepański:  I've i.e. stumbled on an issue on which links to display
              Angelo Veltens: we lack examples of server side payloads (without any specific underlying technology)
              https://screening-events.herokuapp.com
              http://cc-cinema.herokuapp.com/#/
              Karol Szczepański:  I think we shall have a call in two weeks but I'm fine with next one\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-02-18
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-02-18
                      Topics
                      
                         Brief update on actions from last calls
                         API documentation limitations - PR#183
                         Allow returns/expects to be expressed in terms of a media type PR#186
                         Define client-initiated pagination PR#184
                         Add support for describing headers PR#185
                         Gitbook branding #2
                         Discuss to increase the use of Gitbook for drafting features
                      
                      Action Items
                      
                         tpluskiewicz comes with a code of conduct regarding vocabulary modifications/extensions
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Veltens
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.
              
              Topic: Brief update on actions from last calls
              Karol Szczepański:  Brecht was looking into logo alternative
              
              Topic: API documentation limitations - PR#183
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/183
              Karol Szczepański:  this tries to resolve the issue, to express strongly typed collections
              ... and explicit targets
              Tomasz Pluskiewicz:  the issue is vague
              Karol Szczepański:  if look into the issue, there are linked issues/PRs (in heracles) which explain
              ... Angel had a nice idea with `hydra:Specifies`
              aveltens: I'd like to see some use case
              .. to find the usages and see if it fits the purpose
              Tomasz Pluskiewicz:  I propose same, to discuss on concrete examples
              Karol Szczepański:  those are tricky and I wouldn't want to spend too much time on details
              ... I also proivded example implementation to check
              ... I wanted them to spark discussion
              ... I want to avoid endless discussion
              Tomasz Pluskiewicz:  we've fallen the same trap
              .. the PRs are too narrow
              Karol Szczepański:  I'd try to spend more time on these features
              ... as we can agree that those are in general good direction
              Tomasz Pluskiewicz:  I think angelo's examples are great in porposiing a generic solution
              aventens: I can come up with SHACL examples of descriptions
              ... I haven't tried yet
              Karol Szczepański:  it will work. good think about SHACL is not OWL so that makes is simple
              aveltes: yes, Solid probably will also adopt shacl
              Karol Szczepański:  I want to think about heracles.ts
              Tomasz Pluskiewicz:  maybe we should heracles to a later stage in specifying
              https://www.w3.org/community/hydra/wiki/Integration_with_SHACL
              aveltens: shacl has already been worked on
              Tomasz Pluskiewicz:  it should be easy to fit shacl in place of Hydra
              Karol Szczepański:  yes, SHACL is not different from hydra:Class
              .. next step to try fit SHACL to this
              
              Topic: Allow returns/expects to be expressed in terms of a media type PR#186
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/186
              Karol Szczepański:  similar, to define returns/expects instead of SHACL
              aveltens: yes, if we explore #183 we will come to a joint conclusion
              Karol Szczepański:  so, this one is concuded
              
              Topic: Define client-initiated pagination PR#184
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/184
              Karol Szczepański:  i proposed skip/take
              ... there was discussion about also supporting pageReference, etc
              ... for me, it's less understandable to the client
              Tomasz Pluskiewicz:  I would accept as-is and then work on IriTemplate itself
              aveltens: what would make sense if the client know how to get to the next page
              Karol Szczepański:  the hard part is defining the meaning. for example, would the page ever not be a number?
              Tomasz Pluskiewicz:  I only say it should not be too constrained
              Karol Szczepański:  maye we could add a pageIndex, defined to take a numeric value
              Tomasz Pluskiewicz:  I don't think these should be properties
              Karol Szczepański:  the for will be an object
              Tomasz Pluskiewicz:  I say we finalize this and the work on template and actual usage
              
              Topic: Add support for describing headers PR#185
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  proposes letting the client know about HTTP headers
              Tomasz Pluskiewicz:  I lack the practical example and don't agree with the use of template
              Karol Szczepański: Prefer: key=value
              Tomasz Pluskiewicz:  maybe this is too generic
              Karol Szczepański:  so you would you retract the template?
              aveltens: I propose to just define hearder which the server expects
              Tomasz Pluskiewicz:  this is something we will expand and improve in the future
              
              Topic: Gitbook branding #2
              Karol Szczepański: https://github.com/HydraCG/gitbook/issues/2
              Tomasz Pluskiewicz:  two points: 1. using the official domain; 2. subdomain name
              ... I think we agreed on cookbook.hydra-cg.com
              
              Topic: Discuss to increase the use of Gitbook for drafting features
              https://github.com/HydraCG/gitbook/pull/1
              ACTION: tpluskiewicz comes with a code of conduct regarding vocabulary modifications/extensions
              Tomasz Pluskiewicz:  I think we need to return to using the book
              aveltens: I agree that it will help us focus on the actual use cases
              Karol Szczepański:  I would like to provide more use cases
              ... of course I'd like to make it more up to date with reference client\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-02-18
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-02-18
                      Topics
                      
                         Brief update on actions from last calls
                         API documentation limitations - PR#183
                         Allow returns/expects to be expressed in terms of a media type PR#186
                         Define client-initiated pagination PR#184
                         Add support for describing headers PR#185
                         Gitbook branding #2
                         Discuss to increase the use of Gitbook for drafting features
                      
                      Action Items
                      
                         tpluskiewicz comes with a code of conduct regarding vocabulary modifications/extensions
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Angelo Veltens
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.
              
              Topic: Brief update on actions from last calls
              Karol Szczepański:  Brecht was looking into logo alternative
              
              Topic: API documentation limitations - PR#183
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/183
              Karol Szczepański:  this tries to resolve the issue, to express strongly typed collections
              ... and explicit targets
              Tomasz Pluskiewicz:  the issue is vague
              Karol Szczepański:  if look into the issue, there are linked issues/PRs (in heracles) which explain
              ... Angel had a nice idea with `hydra:Specifies`
              aveltens: I'd like to see some use case
              .. to find the usages and see if it fits the purpose
              Tomasz Pluskiewicz:  I propose same, to discuss on concrete examples
              Karol Szczepański:  those are tricky and I wouldn't want to spend too much time on details
              ... I also proivded example implementation to check
              ... I wanted them to spark discussion
              ... I want to avoid endless discussion
              Tomasz Pluskiewicz:  we've fallen the same trap
              .. the PRs are too narrow
              Karol Szczepański:  I'd try to spend more time on these features
              ... as we can agree that those are in general good direction
              Tomasz Pluskiewicz:  I think angelo's examples are great in porposiing a generic solution
              aventens: I can come up with SHACL examples of descriptions
              ... I haven't tried yet
              Karol Szczepański:  it will work. good think about SHACL is not OWL so that makes is simple
              aveltes: yes, Solid probably will also adopt shacl
              Karol Szczepański:  I want to think about heracles.ts
              Tomasz Pluskiewicz:  maybe we should heracles to a later stage in specifying
              https://www.w3.org/community/hydra/wiki/Integration_with_SHACL
              aveltens: shacl has already been worked on
              Tomasz Pluskiewicz:  it should be easy to fit shacl in place of Hydra
              Karol Szczepański:  yes, SHACL is not different from hydra:Class
              .. next step to try fit SHACL to this
              
              Topic: Allow returns/expects to be expressed in terms of a media type PR#186
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/186
              Karol Szczepański:  similar, to define returns/expects instead of SHACL
              aveltens: yes, if we explore #183 we will come to a joint conclusion
              Karol Szczepański:  so, this one is concuded
              
              Topic: Define client-initiated pagination PR#184
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/184
              Karol Szczepański:  i proposed skip/take
              ... there was discussion about also supporting pageReference, etc
              ... for me, it's less understandable to the client
              Tomasz Pluskiewicz:  I would accept as-is and then work on IriTemplate itself
              aveltens: what would make sense if the client know how to get to the next page
              Karol Szczepański:  the hard part is defining the meaning. for example, would the page ever not be a number?
              Tomasz Pluskiewicz:  I only say it should not be too constrained
              Karol Szczepański:  maye we could add a pageIndex, defined to take a numeric value
              Tomasz Pluskiewicz:  I don't think these should be properties
              Karol Szczepański:  the for will be an object
              Tomasz Pluskiewicz:  I say we finalize this and the work on template and actual usage
              
              Topic: Add support for describing headers PR#185
              Karol Szczepański: https://github.com/HydraCG/Specifications/pull/185
              Karol Szczepański:  proposes letting the client know about HTTP headers
              Tomasz Pluskiewicz:  I lack the practical example and don't agree with the use of template
              Karol Szczepański: Prefer: key=value
              Tomasz Pluskiewicz:  maybe this is too generic
              Karol Szczepański:  so you would you retract the template?
              aveltens: I propose to just define hearder which the server expects
              Tomasz Pluskiewicz:  this is something we will expand and improve in the future
              
              Topic: Gitbook branding #2
              Karol Szczepański: https://github.com/HydraCG/gitbook/issues/2
              Tomasz Pluskiewicz:  two points: 1. using the official domain; 2. subdomain name
              ... I think we agreed on cookbook.hydra-cg.com
              
              Topic: Discuss to increase the use of Gitbook for drafting features
              https://github.com/HydraCG/gitbook/pull/1
              ACTION: tpluskiewicz comes with a code of conduct regarding vocabulary modifications/extensions
              Tomasz Pluskiewicz:  I think we need to return to using the book
              aveltens: I agree that it will help us focus on the actual use cases
              Karol Szczepański:  I would like to provide more use cases
              ... of course I'd like to make it more up to date with reference client\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-28
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-28
                      Topics
                      
                         Brief update on actions from last call
                         Discuss open Pull Requests
                         Hydra logo licensing
                         Extending vocabulary with explicit actions
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Brecht Van de Vyvere
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Brief update on actions from last call
              first thing was assigned to Lorenzo of finding adventages and disadventages of going with OS organization
              there was a discussion on slack
              maybe an alternative was to organize within GSOC team rather than hydra one
              Karol Szczepański:  without any knowledge of implications and requirements I'm fine with status quo
              Tomasz Pluskiewicz:  topic should be postponed then
              second item was assigned to Rube
              about a brief agenda of the meeting about the future of hydra and hypermedia
              Karol Szczepański:  for me the brief is quite poor, lacks some details on possible take-aways
              Brecht: maybe we should raise an issue in GH to put ideas for the meeting's agenda
              third item was assigned to Karol, migration of the TPF repos to separate one within HydraCG
              Karol Szczepański:  I've failed to do anything due to inproper access levels to GH
              Karol Szczepański:  we're stuck with Markus not providing elevated priviledges
              fourth item was assigned to Tomasz, describe on how to proceed with PR's
              Tomasz Pluskiewicz:  I didn't setup any proposal for now
              Tomasz Pluskiewicz:  we'd like to move call for consensus to GH so more people will leave feedback in more formal way
              Karol Szczepański:  there are several PRs waiting so I called people on the mailing list to leave any feedback
              Karol Szczepański:  we'll merge those this week
              Tomasz Pluskiewicz:  People voted for changes on mailing list, but these were not reflected on the GH
              
              Topic: Discuss open Pull Requests
              
              Topic: Hydra logo licensing
              Logo is under Markus' ownership
              There are two ways: Markus agrees to give the logo for more permitive licence
              or we're going with new logo
              Brech: we could go with new one
              Tomasz Pluskiewicz:  there are plenty of pepole oht there, maybe someone could create one for free for us
              Karol Szczepański:  is the name licencsed as well
              Tomasz Pluskiewicz:  we could rename issue in GH to more generic, related to hydra trademark
              Tomasz Pluskiewicz:  the licence says only that hydra mark and logo are owned by Markus
              Tomasz Pluskiewicz:  it's to vauge
              
              Topic: Extending vocabulary with explicit actions
              Karol Szczepański:  there are some areas that hydra needs extenions and I was working on my vision of these extensions
              Karol Szczepański:  i.e. strongly typed collections, API documentations, non-RDF payloads
              Tomasz Pluskiewicz:  examples talks, we shall have request-response pairs illustrating attempts of doing stuff with hydra
              Tomasz Pluskiewicz: without any tooling it won't work as well
              Tomasz Pluskiewicz:  are there any hydra-enabled software you're developing in Ghent?
              Comunica
              Brecht: there is the Comunica
              Tomasz Pluskiewicz:  there is implementation in PHP
              Tomasz Pluskiewicz:  i've asked creators for feedback
              Tomasz Pluskiewicz:  API-Platform.com
              Tomasz Pluskiewicz: https://api-platform.com
              Tomasz Pluskiewicz:  could Comunica come with any feedback?\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-14
                      Topics
                      
                         Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
                         Discuss relation between Hydra Core and TPF/LDF
                         Discuss open Pull Requests
                      
                      Action Items
                      
                         lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
                         rubenverborgh will provide a brief agenta of that discussion
                         migration of the TPF repos to separate one within HydraCG
                         tpluskiewicz: describe on how to proceed with PR's
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Ruben Verborgh
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
              lorenzo-tuned: beside activity of the development group, we may actually try to create an open source organization as a direct fcreation of the community group
              lorenzo-tuned: to communicate to the public what is hydra etc.
              lorenzo-tuned: list objectives would be a standard approach to start with
              lorenzo-tuned: in context of Google Summer of Code, peapole are asking on how they can know more about hydra and the community
              lorenzo-tuned: we would like to be more organized in a transparent manner
              lorenzo-tuned: so we can interact with other actors in the field, like companies interested using the draft or contributors
              lorenzo-tuned: the draft is linked on the agenda page
              https://github.com/HTTP-APIs/hydra-cg-statute/blob/master/DRAFT.md
              Tomasz Pluskiewicz:  I don't have anything to complain
              Tomasz Pluskiewicz:  I'm a bit sceptical about some of the points of the draft
              Tomasz Pluskiewicz:  I don't undestand the implications of going legal
              Tomasz Pluskiewicz:  we're community group under W3C
              Tomasz Pluskiewicz:  this should ha ve a meaning
              lorenzo-tuned: that's why I've asked for collaboration
              lorenzo-tuned: one of the reason, was we were asked by i.e. students or organizations
              lorenzo-tuned: we could receive donations, i.e. from Google
              lorenzo-tuned: based on the number of projects or students
              lorenzo-tuned: Python-Hydra was entitled a donation from an organization
              lorenzo-tuned: collecting these donations could contribute substantially to our activity
              Tomasz Pluskiewicz:  you say about student expenses or your expenses
              Tomasz Pluskiewicz:  related to hydra-ecosystem
              Tomasz Pluskiewicz:  if we receive any money, it would be put on hydra community group shoulders
              Tomasz Pluskiewicz:  currently, HydraCG runs on either free infrastructure or those maintained by Markus
              Tomasz Pluskiewicz:  I don't feel any need to go that way
              lorenzo-tuned: students asks me to present this position to the chair - why we can't use the money we could obtain
              Karol Szczepański:  we don't know possible responsibilities of such a OS organization
              Tomasz Pluskiewicz:  when money are on the table, it's another story
              Tomasz Pluskiewicz:  we didn't start organization to obtain money for my another activyt due to huge effort and legal implications
              Tomasz Pluskiewicz:  I'd try asking Open API initiative for assistance or something
              ACTION: lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
              https://www.gov.uk/unincorporated-associations
              
              Topic: Discuss relation between Hydra Core and TPF/LDF
              Ruben Verborgh:  a brief of the history
              Ruben Verborgh:  we've ben doing hypermedia driven apis for some time
              Ruben Verborgh:  we wan't a client smart enough to query another apis
              Ruben Verborgh:  it was Markus explaining I'd rather to have you within hydra to make it stronger
              Ruben Verborgh:  we've been publishing TPF specs under hydra since then
              Ruben Verborgh:  question: is there any point in having TPF under a hydra community group
              Ruben Verborgh:  we're interested in having extensions to hydra rather than to influence hydra with our specs
              Ruben Verborgh:  maybe we should discuss in person the future of the hypermedia
              Karol Szczepański:  there was no intention in dropping other specs from hydracg
              mielvds: not sure on how many people are there
              Tomasz Pluskiewicz:  my suggestion is in force - to move TPF and other specs to separate github repos - this way the specs still can be under HydraCG with self-maintaining caopabilities of each team
              Ruben Verborgh:  this was an initial intention
              Ruben Verborgh:  it's a good start
              Ruben Verborgh:  as for the issues, a few were closed due to inactivity
              Tomasz Pluskiewicz:  as for the issues, a few were closed due to inactivity'
              Tomasz Pluskiewicz:  some of the issues may require hydra spec changes, but that's Ok, once we come to agreement on the details
              Ruben Verborgh:  I've been quite active at the beginning, later I've lost track due to various reasons
              Ruben Verborgh:  we would like to extend an open invitation to have all the people to have a disussion (in person or virtual) on the future of hypermedia
              Tomasz Pluskiewicz:  I'd be happy to visit Ghent :)
              ACTION: rubenverborgh will provide a brief agenta of that discussion
              ACTION: migration of the TPF repos to separate one within HydraCG
              Karol Szczepański:  16 issues closed, 1 is already reopened, there is an attempt to close 12 issues with minor specchanges, there are ongoing PRs
              Tomasz Pluskiewicz:  as for the automation to generate minutes, there is a PR with possible changes to be made to the process
              Tomasz Pluskiewicz: https://github.com/HydraCG/Minutes/pull/2
              
              Topic: Discuss open Pull Requests
              Tomasz Pluskiewicz:  reviews where never formalized
              Tomasz Pluskiewicz:  it was mostly Markus' show within the spec
              Tomasz Pluskiewicz:  I'd make it more strict to have more people reviewing
              Ruben Verborgh:  you can always assign me reviews
              mielvds: same here
              Tomasz Pluskiewicz:  how was it in the past when it was driven by mailing list and not a github
              Tomasz Pluskiewicz:  was there always a call for agreement in the past?
              Tomasz Pluskiewicz:  call for consensus
              Tomasz Pluskiewicz:  we could send via mailing list a call for consensus pointing to PR's
              ACTION: tpluskiewicz: describe on how to proceed with PR's\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-14
                      Topics
                      
                         Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
                         Discuss relation between Hydra Core and TPF/LDF
                         Discuss open Pull Requests
                      
                      Action Items
                      
                         lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
                         rubenverborgh will provide a brief agenta of that discussion
                         migration of the TPF repos to separate one within HydraCG
                         tpluskiewicz: describe on how to proceed with PR's
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Ruben Verborgh
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
              lorenzo-tuned: beside activity of the development group, we may actually try to create an open source organization as a direct fcreation of the community group
              lorenzo-tuned: to communicate to the public what is hydra etc.
              lorenzo-tuned: list objectives would be a standard approach to start with
              lorenzo-tuned: in context of Google Summer of Code, peapole are asking on how they can know more about hydra and the community
              lorenzo-tuned: we would like to be more organized in a transparent manner
              lorenzo-tuned: so we can interact with other actors in the field, like companies interested using the draft or contributors
              lorenzo-tuned: the draft is linked on the agenda page
              https://github.com/HTTP-APIs/hydra-cg-statute/blob/master/DRAFT.md
              Tomasz Pluskiewicz:  I don't have anything to complain
              Tomasz Pluskiewicz:  I'm a bit sceptical about some of the points of the draft
              Tomasz Pluskiewicz:  I don't undestand the implications of going legal
              Tomasz Pluskiewicz:  we're community group under W3C
              Tomasz Pluskiewicz:  this should ha ve a meaning
              lorenzo-tuned: that's why I've asked for collaboration
              lorenzo-tuned: one of the reason, was we were asked by i.e. students or organizations
              lorenzo-tuned: we could receive donations, i.e. from Google
              lorenzo-tuned: based on the number of projects or students
              lorenzo-tuned: Python-Hydra was entitled a donation from an organization
              lorenzo-tuned: collecting these donations could contribute substantially to our activity
              Tomasz Pluskiewicz:  you say about student expenses or your expenses
              Tomasz Pluskiewicz:  related to hydra-ecosystem
              Tomasz Pluskiewicz:  if we receive any money, it would be put on hydra community group shoulders
              Tomasz Pluskiewicz:  currently, HydraCG runs on either free infrastructure or those maintained by Markus
              Tomasz Pluskiewicz:  I don't feel any need to go that way
              lorenzo-tuned: students asks me to present this position to the chair - why we can't use the money we could obtain
              Karol Szczepański:  we don't know possible responsibilities of such a OS organization
              Tomasz Pluskiewicz:  when money are on the table, it's another story
              Tomasz Pluskiewicz:  we didn't start organization to obtain money for my another activyt due to huge effort and legal implications
              Tomasz Pluskiewicz:  I'd try asking Open API initiative for assistance or something
              ACTION: lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
              https://www.gov.uk/unincorporated-associations
              
              Topic: Discuss relation between Hydra Core and TPF/LDF
              Ruben Verborgh:  a brief of the history
              Ruben Verborgh:  we've ben doing hypermedia driven apis for some time
              Ruben Verborgh:  we wan't a client smart enough to query another apis
              Ruben Verborgh:  it was Markus explaining I'd rather to have you within hydra to make it stronger
              Ruben Verborgh:  we've been publishing TPF specs under hydra since then
              Ruben Verborgh:  question: is there any point in having TPF under a hydra community group
              Ruben Verborgh:  we're interested in having extensions to hydra rather than to influence hydra with our specs
              Ruben Verborgh:  maybe we should discuss in person the future of the hypermedia
              Karol Szczepański:  there was no intention in dropping other specs from hydracg
              mielvds: not sure on how many people are there
              Tomasz Pluskiewicz:  my suggestion is in force - to move TPF and other specs to separate github repos - this way the specs still can be under HydraCG with self-maintaining caopabilities of each team
              Ruben Verborgh:  this was an initial intention
              Ruben Verborgh:  it's a good start
              Ruben Verborgh:  as for the issues, a few were closed due to inactivity
              Tomasz Pluskiewicz:  as for the issues, a few were closed due to inactivity'
              Tomasz Pluskiewicz:  some of the issues may require hydra spec changes, but that's Ok, once we come to agreement on the details
              Ruben Verborgh:  I've been quite active at the beginning, later I've lost track due to various reasons
              Ruben Verborgh:  we would like to extend an open invitation to have all the people to have a disussion (in person or virtual) on the future of hypermedia
              Tomasz Pluskiewicz:  I'd be happy to visit Ghent :)
              ACTION: rubenverborgh will provide a brief agenta of that discussion
              ACTION: migration of the TPF repos to separate one within HydraCG
              Karol Szczepański:  16 issues closed, 1 is already reopened, there is an attempt to close 12 issues with minor specchanges, there are ongoing PRs
              Tomasz Pluskiewicz:  as for the automation to generate minutes, there is a PR with possible changes to be made to the process
              Tomasz Pluskiewicz: https://github.com/HydraCG/Minutes/pull/2
              
              Topic: Discuss open Pull Requests
              Tomasz Pluskiewicz:  reviews where never formalized
              Tomasz Pluskiewicz:  it was mostly Markus' show within the spec
              Tomasz Pluskiewicz:  I'd make it more strict to have more people reviewing
              Ruben Verborgh:  you can always assign me reviews
              mielvds: same here
              Tomasz Pluskiewicz:  how was it in the past when it was driven by mailing list and not a github
              Tomasz Pluskiewicz:  was there always a call for agreement in the past?
              Tomasz Pluskiewicz:  call for consensus
              Tomasz Pluskiewicz:  we could send via mailing list a call for consensus pointing to PR's
              ACTION: tpluskiewicz: describe on how to proceed with PR's\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-14
                      Topics
                      
                         Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
                         Discuss relation between Hydra Core and TPF/LDF
                         Discuss open Pull Requests
                      
                      Action Items
                      
                         lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
                         rubenverborgh will provide a brief agenta of that discussion
                         migration of the TPF repos to separate one within HydraCG
                         tpluskiewicz: describe on how to proceed with PR's
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Ruben Verborgh
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
              lorenzo-tuned: beside activity of the development group, we may actually try to create an open source organization as a direct fcreation of the community group
              lorenzo-tuned: to communicate to the public what is hydra etc.
              lorenzo-tuned: list objectives would be a standard approach to start with
              lorenzo-tuned: in context of Google Summer of Code, peapole are asking on how they can know more about hydra and the community
              lorenzo-tuned: we would like to be more organized in a transparent manner
              lorenzo-tuned: so we can interact with other actors in the field, like companies interested using the draft or contributors
              lorenzo-tuned: the draft is linked on the agenda page
              https://github.com/HTTP-APIs/hydra-cg-statute/blob/master/DRAFT.md
              Tomasz Pluskiewicz:  I don't have anything to complain
              Tomasz Pluskiewicz:  I'm a bit sceptical about some of the points of the draft
              Tomasz Pluskiewicz:  I don't undestand the implications of going legal
              Tomasz Pluskiewicz:  we're community group under W3C
              Tomasz Pluskiewicz:  this should ha ve a meaning
              lorenzo-tuned: that's why I've asked for collaboration
              lorenzo-tuned: one of the reason, was we were asked by i.e. students or organizations
              lorenzo-tuned: we could receive donations, i.e. from Google
              lorenzo-tuned: based on the number of projects or students
              lorenzo-tuned: Python-Hydra was entitled a donation from an organization
              lorenzo-tuned: collecting these donations could contribute substantially to our activity
              Tomasz Pluskiewicz:  you say about student expenses or your expenses
              Tomasz Pluskiewicz:  related to hydra-ecosystem
              Tomasz Pluskiewicz:  if we receive any money, it would be put on hydra community group shoulders
              Tomasz Pluskiewicz:  currently, HydraCG runs on either free infrastructure or those maintained by Markus
              Tomasz Pluskiewicz:  I don't feel any need to go that way
              lorenzo-tuned: students asks me to present this position to the chair - why we can't use the money we could obtain
              Karol Szczepański:  we don't know possible responsibilities of such a OS organization
              Tomasz Pluskiewicz:  when money are on the table, it's another story
              Tomasz Pluskiewicz:  we didn't start organization to obtain money for my another activyt due to huge effort and legal implications
              Tomasz Pluskiewicz:  I'd try asking Open API initiative for assistance or something
              ACTION: lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
              https://www.gov.uk/unincorporated-associations
              
              Topic: Discuss relation between Hydra Core and TPF/LDF
              Ruben Verborgh:  a brief of the history
              Ruben Verborgh:  we've ben doing hypermedia driven apis for some time
              Ruben Verborgh:  we wan't a client smart enough to query another apis
              Ruben Verborgh:  it was Markus explaining I'd rather to have you within hydra to make it stronger
              Ruben Verborgh:  we've been publishing TPF specs under hydra since then
              Ruben Verborgh:  question: is there any point in having TPF under a hydra community group
              Ruben Verborgh:  we're interested in having extensions to hydra rather than to influence hydra with our specs
              Ruben Verborgh:  maybe we should discuss in person the future of the hypermedia
              Karol Szczepański:  there was no intention in dropping other specs from hydracg
              mielvds: not sure on how many people are there
              Tomasz Pluskiewicz:  my suggestion is in force - to move TPF and other specs to separate github repos - this way the specs still can be under HydraCG with self-maintaining caopabilities of each team
              Ruben Verborgh:  this was an initial intention
              Ruben Verborgh:  it's a good start
              Ruben Verborgh:  as for the issues, a few were closed due to inactivity
              Tomasz Pluskiewicz:  as for the issues, a few were closed due to inactivity'
              Tomasz Pluskiewicz:  some of the issues may require hydra spec changes, but that's Ok, once we come to agreement on the details
              Ruben Verborgh:  I've been quite active at the beginning, later I've lost track due to various reasons
              Ruben Verborgh:  we would like to extend an open invitation to have all the people to have a disussion (in person or virtual) on the future of hypermedia
              Tomasz Pluskiewicz:  I'd be happy to visit Ghent :)
              ACTION: rubenverborgh will provide a brief agenta of that discussion
              ACTION: migration of the TPF repos to separate one within HydraCG
              Karol Szczepański:  16 issues closed, 1 is already reopened, there is an attempt to close 12 issues with minor specchanges, there are ongoing PRs
              Tomasz Pluskiewicz:  as for the automation to generate minutes, there is a PR with possible changes to be made to the process
              Tomasz Pluskiewicz: https://github.com/HydraCG/Minutes/pull/2
              
              Topic: Discuss open Pull Requests
              Tomasz Pluskiewicz:  reviews where never formalized
              Tomasz Pluskiewicz:  it was mostly Markus' show within the spec
              Tomasz Pluskiewicz:  I'd make it more strict to have more people reviewing
              Ruben Verborgh:  you can always assign me reviews
              mielvds: same here
              Tomasz Pluskiewicz:  how was it in the past when it was driven by mailing list and not a github
              Tomasz Pluskiewicz:  was there always a call for agreement in the past?
              Tomasz Pluskiewicz:  call for consensus
              Tomasz Pluskiewicz:  we could send via mailing list a call for consensus pointing to PR's
              ACTION: tpluskiewicz: describe on how to proceed with PR's\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-14
                      Topics
                      
                         Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
                         Discuss relation between Hydra Core and TPF/LDF
                         Discuss open Pull Requests
                      
                      Action Items
                      
                         lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
                         rubenverborgh will provide a brief agenta of that discussion
                         migration of the TPF repos to separate one within HydraCG
                         tpluskiewicz: describe on how to proceed with PR's
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Ruben Verborgh
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
              lorenzo-tuned: beside activity of the development group, we may actually try to create an open source organization as a direct fcreation of the community group
              lorenzo-tuned: to communicate to the public what is hydra etc.
              lorenzo-tuned: list objectives would be a standard approach to start with
              lorenzo-tuned: in context of Google Summer of Code, peapole are asking on how they can know more about hydra and the community
              lorenzo-tuned: we would like to be more organized in a transparent manner
              lorenzo-tuned: so we can interact with other actors in the field, like companies interested using the draft or contributors
              lorenzo-tuned: the draft is linked on the agenda page
              https://github.com/HTTP-APIs/hydra-cg-statute/blob/master/DRAFT.md
              Tomasz Pluskiewicz:  I don't have anything to complain
              Tomasz Pluskiewicz:  I'm a bit sceptical about some of the points of the draft
              Tomasz Pluskiewicz:  I don't undestand the implications of going legal
              Tomasz Pluskiewicz:  we're community group under W3C
              Tomasz Pluskiewicz:  this should ha ve a meaning
              lorenzo-tuned: that's why I've asked for collaboration
              lorenzo-tuned: one of the reason, was we were asked by i.e. students or organizations
              lorenzo-tuned: we could receive donations, i.e. from Google
              lorenzo-tuned: based on the number of projects or students
              lorenzo-tuned: Python-Hydra was entitled a donation from an organization
              lorenzo-tuned: collecting these donations could contribute substantially to our activity
              Tomasz Pluskiewicz:  you say about student expenses or your expenses
              Tomasz Pluskiewicz:  related to hydra-ecosystem
              Tomasz Pluskiewicz:  if we receive any money, it would be put on hydra community group shoulders
              Tomasz Pluskiewicz:  currently, HydraCG runs on either free infrastructure or those maintained by Markus
              Tomasz Pluskiewicz:  I don't feel any need to go that way
              lorenzo-tuned: students asks me to present this position to the chair - why we can't use the money we could obtain
              Karol Szczepański:  we don't know possible responsibilities of such a OS organization
              Tomasz Pluskiewicz:  when money are on the table, it's another story
              Tomasz Pluskiewicz:  we didn't start organization to obtain money for my another activyt due to huge effort and legal implications
              Tomasz Pluskiewicz:  I'd try asking Open API initiative for assistance or something
              ACTION: lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
              https://www.gov.uk/unincorporated-associations
              
              Topic: Discuss relation between Hydra Core and TPF/LDF
              Ruben Verborgh:  a brief of the history
              Ruben Verborgh:  we've ben doing hypermedia driven apis for some time
              Ruben Verborgh:  we wan't a client smart enough to query another apis
              Ruben Verborgh:  it was Markus explaining I'd rather to have you within hydra to make it stronger
              Ruben Verborgh:  we've been publishing TPF specs under hydra since then
              Ruben Verborgh:  question: is there any point in having TPF under a hydra community group
              Ruben Verborgh:  we're interested in having extensions to hydra rather than to influence hydra with our specs
              Ruben Verborgh:  maybe we should discuss in person the future of the hypermedia
              Karol Szczepański:  there was no intention in dropping other specs from hydracg
              mielvds: not sure on how many people are there
              Tomasz Pluskiewicz:  my suggestion is in force - to move TPF and other specs to separate github repos - this way the specs still can be under HydraCG with self-maintaining caopabilities of each team
              Ruben Verborgh:  this was an initial intention
              Ruben Verborgh:  it's a good start
              Ruben Verborgh:  as for the issues, a few were closed due to inactivity
              Tomasz Pluskiewicz:  as for the issues, a few were closed due to inactivity'
              Tomasz Pluskiewicz:  some of the issues may require hydra spec changes, but that's Ok, once we come to agreement on the details
              Ruben Verborgh:  I've been quite active at the beginning, later I've lost track due to various reasons
              Ruben Verborgh:  we would like to extend an open invitation to have all the people to have a disussion (in person or virtual) on the future of hypermedia
              Tomasz Pluskiewicz:  I'd be happy to visit Ghent :)
              ACTION: rubenverborgh will provide a brief agenta of that discussion
              ACTION: migration of the TPF repos to separate one within HydraCG
              Karol Szczepański:  16 issues closed, 1 is already reopened, there is an attempt to close 12 issues with minor specchanges, there are ongoing PRs
              Tomasz Pluskiewicz:  as for the automation to generate minutes, there is a PR with possible changes to be made to the process
              Tomasz Pluskiewicz: https://github.com/HydraCG/Minutes/pull/2
              
              Topic: Discuss open Pull Requests
              Tomasz Pluskiewicz:  reviews where never formalized
              Tomasz Pluskiewicz:  it was mostly Markus' show within the spec
              Tomasz Pluskiewicz:  I'd make it more strict to have more people reviewing
              Ruben Verborgh:  you can always assign me reviews
              mielvds: same here
              Tomasz Pluskiewicz:  how was it in the past when it was driven by mailing list and not a github
              Tomasz Pluskiewicz:  was there always a call for agreement in the past?
              Tomasz Pluskiewicz:  call for consensus
              Tomasz Pluskiewicz:  we could send via mailing list a call for consensus pointing to PR's
              ACTION: tpluskiewicz: describe on how to proceed with PR's\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-14
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-14
                      Topics
                      
                         Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
                         Discuss relation between Hydra Core and TPF/LDF
                         Discuss open Pull Requests
                      
                      Action Items
                      
                         lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
                         rubenverborgh will provide a brief agenta of that discussion
                         migration of the TPF repos to separate one within HydraCG
                         tpluskiewicz: describe on how to proceed with PR's
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Ruben Verborgh
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Karol Szczepański is scribing.
              
              Topic: Talk about the possibility of writing a statement of mission (Statute) for a possible OS organisation.
              lorenzo-tuned: beside activity of the development group, we may actually try to create an open source organization as a direct fcreation of the community group
              lorenzo-tuned: to communicate to the public what is hydra etc.
              lorenzo-tuned: list objectives would be a standard approach to start with
              lorenzo-tuned: in context of Google Summer of Code, peapole are asking on how they can know more about hydra and the community
              lorenzo-tuned: we would like to be more organized in a transparent manner
              lorenzo-tuned: so we can interact with other actors in the field, like companies interested using the draft or contributors
              lorenzo-tuned: the draft is linked on the agenda page
              https://github.com/HTTP-APIs/hydra-cg-statute/blob/master/DRAFT.md
              Tomasz Pluskiewicz:  I don't have anything to complain
              Tomasz Pluskiewicz:  I'm a bit sceptical about some of the points of the draft
              Tomasz Pluskiewicz:  I don't undestand the implications of going legal
              Tomasz Pluskiewicz:  we're community group under W3C
              Tomasz Pluskiewicz:  this should ha ve a meaning
              lorenzo-tuned: that's why I've asked for collaboration
              lorenzo-tuned: one of the reason, was we were asked by i.e. students or organizations
              lorenzo-tuned: we could receive donations, i.e. from Google
              lorenzo-tuned: based on the number of projects or students
              lorenzo-tuned: Python-Hydra was entitled a donation from an organization
              lorenzo-tuned: collecting these donations could contribute substantially to our activity
              Tomasz Pluskiewicz:  you say about student expenses or your expenses
              Tomasz Pluskiewicz:  related to hydra-ecosystem
              Tomasz Pluskiewicz:  if we receive any money, it would be put on hydra community group shoulders
              Tomasz Pluskiewicz:  currently, HydraCG runs on either free infrastructure or those maintained by Markus
              Tomasz Pluskiewicz:  I don't feel any need to go that way
              lorenzo-tuned: students asks me to present this position to the chair - why we can't use the money we could obtain
              Karol Szczepański:  we don't know possible responsibilities of such a OS organization
              Tomasz Pluskiewicz:  when money are on the table, it's another story
              Tomasz Pluskiewicz:  we didn't start organization to obtain money for my another activyt due to huge effort and legal implications
              Tomasz Pluskiewicz:  I'd try asking Open API initiative for assistance or something
              ACTION: lorenzo-tuned will prepare a brief of advantages or disadvantages of starting an organization, i.e. responsibilities or benefits or legal requirements known to him
              https://www.gov.uk/unincorporated-associations
              
              Topic: Discuss relation between Hydra Core and TPF/LDF
              Ruben Verborgh:  a brief of the history
              Ruben Verborgh:  we've ben doing hypermedia driven apis for some time
              Ruben Verborgh:  we wan't a client smart enough to query another apis
              Ruben Verborgh:  it was Markus explaining I'd rather to have you within hydra to make it stronger
              Ruben Verborgh:  we've been publishing TPF specs under hydra since then
              Ruben Verborgh:  question: is there any point in having TPF under a hydra community group
              Ruben Verborgh:  we're interested in having extensions to hydra rather than to influence hydra with our specs
              Ruben Verborgh:  maybe we should discuss in person the future of the hypermedia
              Karol Szczepański:  there was no intention in dropping other specs from hydracg
              mielvds: not sure on how many people are there
              Tomasz Pluskiewicz:  my suggestion is in force - to move TPF and other specs to separate github repos - this way the specs still can be under HydraCG with self-maintaining caopabilities of each team
              Ruben Verborgh:  this was an initial intention
              Ruben Verborgh:  it's a good start
              Ruben Verborgh:  as for the issues, a few were closed due to inactivity
              Tomasz Pluskiewicz:  as for the issues, a few were closed due to inactivity'
              Tomasz Pluskiewicz:  some of the issues may require hydra spec changes, but that's Ok, once we come to agreement on the details
              Ruben Verborgh:  I've been quite active at the beginning, later I've lost track due to various reasons
              Ruben Verborgh:  we would like to extend an open invitation to have all the people to have a disussion (in person or virtual) on the future of hypermedia
              Tomasz Pluskiewicz:  I'd be happy to visit Ghent :)
              ACTION: rubenverborgh will provide a brief agenta of that discussion
              ACTION: migration of the TPF repos to separate one within HydraCG
              Karol Szczepański:  16 issues closed, 1 is already reopened, there is an attempt to close 12 issues with minor specchanges, there are ongoing PRs
              Tomasz Pluskiewicz:  as for the automation to generate minutes, there is a PR with possible changes to be made to the process
              Tomasz Pluskiewicz: https://github.com/HydraCG/Minutes/pull/2
              
              Topic: Discuss open Pull Requests
              Tomasz Pluskiewicz:  reviews where never formalized
              Tomasz Pluskiewicz:  it was mostly Markus' show within the spec
              Tomasz Pluskiewicz:  I'd make it more strict to have more people reviewing
              Ruben Verborgh:  you can always assign me reviews
              mielvds: same here
              Tomasz Pluskiewicz:  how was it in the past when it was driven by mailing list and not a github
              Tomasz Pluskiewicz:  was there always a call for agreement in the past?
              Tomasz Pluskiewicz:  call for consensus
              Tomasz Pluskiewicz:  we could send via mailing list a call for consensus pointing to PR's
              ACTION: tpluskiewicz: describe on how to proceed with PR's\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2019-01-07
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2019-01-07
                      Topics
                      
                         Agreement on closing 16 issues as obsolete
                         Agreement on resolving 12 issues
                         Brief plan for next steps
                      
                      Resolutions
                      
                         obsolete issues to be labeled and closed
                      
                      Action Items
                      
                         transcription service for conference
                         close items declared as obsolete
                         Karol to create a repo for the docs/gitbook
                      
                      Chair
                      Karol Szczepański
                      Scribe
                      Tomasz Pluskiewicz
                      Present
                      Karol Szczepański, Tomasz Pluskiewicz, Lorenzo Moriondo, Thomas Bergwinkl
                      Audio Log
                      Due to technical problems, audio log is unavailable.
                  
              
              Karol Szczepański: Meeting: Hydra W3C Community Group Conference Call
              Tomasz Pluskiewicz is scribing.
              ACTION: transcription service for conference
              
              Topic: Agreement on closing 16 issues as obsolete
              Karol Szczepański:  we reviewed github issues and identified such that can be easily closed
              Karol Szczepański: https://lists.w3.org/Archives/Public/public-hydra/2019Jan/0000.html
              Tomasz Pluskiewicz:  thea cleanup was somehow offline, but in case anyone has any objections against closing and resolving any of the listed don't hesitate [scribe assist by Karol Szczepański]
              Angelo: I agree with closing them. we can always reopen
              ... Karol, you mentioned that some may require additional qork
              PROPOSAL: close the obslete issues listed
              Lorenzo Moriondo:  we close the issue and label them for reopening
              Karol Szczepański:  let's focus on the obsolete. they should be ready to close
              Tomasz Pluskiewicz:  let's label the closed issues so we can revert them back if needed [scribe assist by Karol Szczepański]
              Thomas Bergwinkl: +1
              Tomasz Pluskiewicz: +1
              Karol Szczepański: +1
              hey
              Tomasz Pluskiewicz: Angelo: +1
              RESOLUTION: obsolete issues to be labeled and closed
              
              Topic: Agreement on resolving 12 issues
              ACTION: close items declared as obsolete
              Karol Szczepański:  the second set of items have to be analyzed one by one and PRs need to be created
              Tomasz Pluskiewicz:  maybe we should label them, maybe assign to owner of the issues [scribe assist by Karol Szczepański]
              Karol Szczepański:  the are quite technical
              ... I can try to check them one by one and submit PRs
              ... these should be quick wins. I will try to present PRs for these
              ... hopefully there won't be too much discussion
              Tomasz Pluskiewicz:  what do you think if the meeting was weekly?
              Tomasz Pluskiewicz:  maybe we shall have a call every week? [scribe assist by Karol Szczepański]
              Karol Szczepański:  I'm fine with that
              Angelo: I won't be able to join every week
              Thomas Bergwinkl:  we should have enough scope
              ... otherwise people may lose interest
              ... this is my experience with rdfjs community
              Tomasz Pluskiewicz:  agent was posted late in the past
              Thomas Bergwinkl:  we can set a reminder early (Thursday)
              Lorenzeo: set a Slack reminder
              Tomasz Pluskiewicz:  use Slack an official channel
              Karol Szczepański:  someone has to be monitoring and messages get lost
              https://httpapis.slack.com
              Tomasz Pluskiewicz:  we can use an existing slack community
              http://slack.httpapis.com
              Karol Szczepański:  let's stick to bi-weekly calls
              
              Topic: Brief plan for next steps
              Karol Szczepański: - examples and spec's shape in general
              Karol Szczepański: - collections (filtering, linking, etc) - never ending story :)
              Karol Szczepański: - API documentation
              Karol Szczepański: - complete request's shape - parameters, templates, actions, operations and theory of everything
              Karol Szczepański:  maybe we could do more prototypes and then move to spec
              Thomas Bergwinkl:  when I tell people to use Hydra, they say they don't get it
              ... at least we need some place where we explain how Hydra is different
              ... I would like a better initial description
              ... my colleagues had the same problem and they worked on some description which we could put into the spec
              Error: (IRC nickname not recognized)[20:37] <lorenzo-tuned> @bergi: you are talking about something like hydraecosystem.org ?
              Karol Szczepański:  tpluskiewicz, you proposed a gitbook
              Lorenzo Moriondo:  the aim of this github page is to be a soft introduction to Hydra
              ... because it's not easy to gather the resourcea
              Karol Szczepański:  maybe not introductions to RDF. it's scare to people
              Lorenenzo: yes, it's different to student
              Karol Szczepański:  Hydra is different from other tool that it emphasises the controls
              Lorenzo Moriondo:  yes, easiest way to introduce people to REST is through entrypoints
              Karol Szczepański:  maybe we should focus on the API Documentation part
              Lorenzo Moriondo:  it may work
              Thomas Bergwinkl:  I looked at hydra ecosystem. a introduction to core concepts behind Hydra is still missing
              ... maybe through examples. I usually talk to RDF people
              angelo: I think that the best is to show working example
              https://generic.hypermedia.app
              https://generic.hypermedia.app/#/https://wikibus-test.gear.host/brochures
              https://github.com/hypermedia-app
              Error: (IRC nickname not recognized)[20:49] <lorenzo-tuned> PR to the hydraecosystem doc can be submitted here btw https://github.com/HTTP-APIs/http-apis.github.io
              Karol Szczepański:  you are using your client. having two clients may not be a good approach
              Thomas Bergwinkl:  we should check what is the overlap
              ... but everyone wants their code a bit different
              ... in the end we had to agree and build on top of a common base
              ... it's good to have variety
              Tomasz Pluskiewicz:  I don't have a problem with competing clients
              Thomas Bergwinkl:  maybe in the future we can make changes and share the new code
              ... exploring thorugh code can help find gaps in the specification
              Tomasz Pluskiewicz:  the UI is fairly decoupled from the hydra abstraction, it should be possible to replace it with another [scribe assist by Karol Szczepański]
              Karol Szczepański: - API documentation part of the hydra spec
              Karol Szczepański: - create a gitbook that should serve as a high level digestible source of knowledge about hydra
              Karol Szczepański: - provide some live demo i.e. revamped hydra console
              ACTION: Karol to create a repo for the docs/gitbook
              Lorenzo Moriondo:  it would be nice to have teams to have more people in hydra-cg
              Lorenzo Moriondo:  we should create a missions document for Hydraq so that people know what it is about
              ... we would like to talk more about this part
              Karol Szczepański:  we can talk about this next week
              ... please post to the mailing list\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2018-11-12
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls#2018-11-12
                      Topics
                      
                         Presentation of Sandeep's & Vaibhav's GSoC work
                         Talk about further plans with GSoC
                         GSoC going forward
                      
                      Chair
                      Markus Lanthaler
                      Scribe
                      Karol Szczepański
                      Present
                      Karol Szczepański, Sandeep Chauhan, Markus Lanthaler, Vaibhav Chellani, Akshay Dahiya, Tomasz Pluskiewicz, Chris Andrew, Lorenzo Moriondo, Kristian Koci
                      Audio Log
                      
                        
                            
                            Warning: Your browser does not support the HTML5 audio element,
                            please upgrade.
                            audio.mp3
                        
                      
                  
              
              Karol Szczepański is scribing.
              Sandeep Chauhan: Hey all!

              Topic: Presentation of Sandeep's & Vaibhav's GSoC work
              Sandeep Chauhan: there are some slides regarding my presentation
              Sandeep Chauhan: https://slides.com/sandeepsajan0/g/
              design of a parser of Open API to Hydra
              Open API seems to be more descriptive than Hydra
              "on-screen live presentation is performed"
              Markus Lanthaler: Am I the only one who doesn't hear anything anymore?
              Vaibhav Chellani: Multiple Parameters at different locations : Data can be received at various locations in the form of parameters , for example “header”,”body”,”path”,”query” . At times we may receive some data from header and some from body in the same request . We get only one key ie “expects” to represent the parameters . The two questions here are   How to represent the location of input data(parameter)?   How to represent multiple[CUT]
              I've asked for a briefe list of features that were available in the OpenAPI and were not in the Hydra or were difficult to implement
              Vaibhav Chellani: ill share a more comprehensive list in a while
              Vaibhav Chellani: 1. Representing endpoints like ‘A/{id}/B/C’
              Vaibhav Chellani: 2. Specifying location of input data for eg: request, body ,path,query etc along with the actual expected request type(hydraClass)
              Vaibhav Chellani: 3. Supporting array in supported_prop : There are various instances where we need to represent that the supported property (object in supportedProperty ) is a list when we have the semantic reference of an item of the list , the question here is "how can I represent a property that is supposed to be a list where each item follows a particular schema”
              Vaibhav Chellani: we also had some issues with creating unique identifiers on server side for the agent to identify easily , right now we are using uuid but the id should be verifiable on client side as well as server side hence we were toying with the idea of checksum as well.

              Topic: Talk about further plans with GSoC
              In order to attract more developers we should start with basics

              Topic: GSoC going forward
              Akshay Dahiya: http://35.224.198.158:5000/
              Akshay Dahiya: The Simulation demo Gui
              Akshay Dahiya: http://35.224.198.158:8080/api
              Akshay Dahiya: http://35.224.198.158:8081/api
              Akshay Dahiya: http://35.224.198.158:8082/api
              Akshay Dahiya: http://35.224.198.158:8083/api
              Akshay Dahiya: http://35.224.198.158:8084/api
              Akshay Dahiya: Links to all the serves (drones and central controller for the simulation)
              Akshay Dahiya: P.S - Everything can be accessed from the Gui link\n\n\n\nHydra W3C Community Group Telecon
              Minutes for 2018-10-01
              
                  
                      Agenda
                      https://www.w3.org/community/hydra/wiki/Conference_Calls
                      Topics
                      
                         Google Summer of Code
                         Next goals
                      
                      Chair
                      Markus Lanthaler
                      Scribe
                      Markus Lanthaler
                      Present
                      Markus Lanthaler, Sandeep Chauhan, Akshay Dahiya, Karol Szczepański
                  
              
              Markus Lanthaler is scribing.
              Sandeep Chauhan: hello everyone!
              Markus Lanthaler:  Hi
              Markus Lanthaler:  Please join the call at https://www.uberconference.com/hydra-cg
              Markus Lanthaler:  sandeep, your microphone is making a lot of noise
              ... sounds like a motorcycle.. unfortunately we can barely hear your voice
              Akshay Dahiya: can't hear anything

              Topic: Google Summer of Code
              Akshay Dahiya: https://github.com/HTTP-APIs/hydrus/blob/master/hydrus/parser/openapi_parser.py
              Akshay Dahiya: sandeep check your microphone
              Sandeep Chauhan: So, Can I use screenshare for presenting the demo of work?
              Akshay Dahiya: yes you can but your microphone is making a lot of noice
              Akshay Dahiya: noise*
              Markus Lanthaler:  Sandeep, we decided to postpone the demo to the next telecon
              ... as we can't hear you at all

              Topic: Next goals
              Karol Szczepański:  update spec
              Sandeep Chauhan: yeah I will try my best next time.
              Sandeep Chauhan: I don't know why is this noise.
              Karol Szczepański:  try to reach feature parity with other API description formats
              ... some stuff is already possible but spec and examples are often vague
              ... we should also update the client and stop using stuff that's not in the spec
              Markus Lanthaler:  how would you structure this work?
              Karol Szczepański:  don't know
              ... the major thing that's missing IMO is request shape we discussed earlier this year
              Markus Lanthaler:  right. the other thing we should finish is the work Pavlik started around actions
              ... if I understand you correctly your highest priority would be to update the spec, right? Not updating Heracles etc.
              Karol Szczepański:  yes, I think we reached a point where we need to work on the spec itself
              Markus Lanthaler:  how should we approach that best?
              Karol Szczepański:  I'll focus on the Angular Hydra console for now
              ... I would like to have a complete example
              ... we've got a client I think now we should extend that to a full demo that shows what Hydra can do
              ... this might then also help us to recruit more people\n\n\n\n