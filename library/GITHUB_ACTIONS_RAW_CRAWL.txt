GitHub Actions documentation Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.Overview Quickstart Start hereView all Writing workflowsGitHub Actions workflows can automate tasks throughout the software development lifecycle.Use cases and examplesExample workflows that demonstrate the features of GitHub Actions.About continuous integration with GitHub ActionsYou can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.Deploying with GitHub ActionsLearn how to control deployments with features like environments and concurrency.PopularWorkflow syntax for GitHub ActionsA workflow is a configurable automated process made up of one or more jobs. You must create a YAML file to define your workflow configuration.Writing workflowsGitHub Actions workflows can automate tasks throughout the software development lifecycle.Use cases and examplesExample workflows that demonstrate the features of GitHub Actions.What's newView all Upcoming breaking changes and releases for GitHub ActionsApril 15Windows arm64 hosted runners now available in public previewApril 14GitHub Actions: macOS 15 and Windows 2025 images are now generally availableApril 10GuidesUsing workflow templatesGitHub provides workflow templates for a variety of languages and tooling.@GitHubPublishing Node.js packagesYou can publish Node.js packages to a registry as part of your continuous integration (CI) workflow.@GitHubBuilding and testing PowerShellYou can create a continuous integration (CI) workflow to build and test your PowerShell project.@potatoqualiteeExplore guides All GitHub Actions docsAbout GitHub ActionsUnderstanding GitHub ActionsAbout continuous integration with GitHub ActionsAbout continuous deployment with GitHub ActionsWriting workflowsQuickstart for GitHub ActionsAbout workflowsUsing workflow templatesChoosing when your workflow runs • 3 articlesChoosing where your workflow runs • 2 articlesChoosing what your workflow does • 16 articlesWorkflow syntax for GitHub ActionsManaging workflow runs and deploymentsManaging workflow runs • 10 articlesManaging deployments • 5 articlesSharing automationsAvoiding duplicationCreating actions • 10 articlesReusing workflowsCreating workflow templates for your organizationSharing actions and workflows from your private repositorySharing actions and workflows with your organizationMonitoring and troubleshooting workflowsMonitoring workflows • 7 articlesTroubleshooting workflows • 4 articlesUsing GitHub-hosted runnersUsing GitHub-hosted runners • 3 articlesUsing larger runners • 4 articlesConnecting to a private network with GitHub-hosted runners • 3 articlesHosting your own runnersManaging self-hosted runners • 15 articlesManaging self-hosted runners with Actions Runner Controller • 7 articlesSecurity for GitHub ActionsSecurity guides • 5 articlesUsing artifact attestations • 4 articlesSecurity hardening your deployments • 9 articlesUse cases and examplesCreating an example workflowBuilding and testing • 12 articlesDeploying • 12 articlesPublishing packages • 5 articlesManaging projects • 5 articlesUsing containerized services • 3 articlesMigrating to GitHub ActionsUsing GitHub Actions Importer to automate migrations • 10 articlesManually migrating to GitHub Actions • 5 articlesAdministering GitHub ActionsUsage limits, billing, and administrationViewing GitHub Actions metricsSharing workflows, secrets, and runners with your organization\n\n\n\nGitHub Actions documentation Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.Overview Quickstart Start hereView all Writing workflowsGitHub Actions workflows can automate tasks throughout the software development lifecycle.Use cases and examplesExample workflows that demonstrate the features of GitHub Actions.About continuous integration with GitHub ActionsYou can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.Deploying with GitHub ActionsLearn how to control deployments with features like environments and concurrency.PopularWorkflow syntax for GitHub ActionsA workflow is a configurable automated process made up of one or more jobs. You must create a YAML file to define your workflow configuration.Writing workflowsGitHub Actions workflows can automate tasks throughout the software development lifecycle.Use cases and examplesExample workflows that demonstrate the features of GitHub Actions.What's newView all Upcoming breaking changes and releases for GitHub ActionsApril 15Windows arm64 hosted runners now available in public previewApril 14GitHub Actions: macOS 15 and Windows 2025 images are now generally availableApril 10GuidesUsing workflow templatesGitHub provides workflow templates for a variety of languages and tooling.@GitHubPublishing Node.js packagesYou can publish Node.js packages to a registry as part of your continuous integration (CI) workflow.@GitHubBuilding and testing PowerShellYou can create a continuous integration (CI) workflow to build and test your PowerShell project.@potatoqualiteeExplore guides All GitHub Actions docsAbout GitHub ActionsUnderstanding GitHub ActionsAbout continuous integration with GitHub ActionsAbout continuous deployment with GitHub ActionsWriting workflowsQuickstart for GitHub ActionsAbout workflowsUsing workflow templatesChoosing when your workflow runs • 3 articlesChoosing where your workflow runs • 2 articlesChoosing what your workflow does • 16 articlesWorkflow syntax for GitHub ActionsManaging workflow runs and deploymentsManaging workflow runs • 10 articlesManaging deployments • 5 articlesSharing automationsAvoiding duplicationCreating actions • 10 articlesReusing workflowsCreating workflow templates for your organizationSharing actions and workflows from your private repositorySharing actions and workflows with your organizationMonitoring and troubleshooting workflowsMonitoring workflows • 7 articlesTroubleshooting workflows • 4 articlesUsing GitHub-hosted runnersUsing GitHub-hosted runners • 3 articlesUsing larger runners • 4 articlesConnecting to a private network with GitHub-hosted runners • 3 articlesHosting your own runnersManaging self-hosted runners • 15 articlesManaging self-hosted runners with Actions Runner Controller • 7 articlesSecurity for GitHub ActionsSecurity guides • 5 articlesUsing artifact attestations • 4 articlesSecurity hardening your deployments • 9 articlesUse cases and examplesCreating an example workflowBuilding and testing • 12 articlesDeploying • 12 articlesPublishing packages • 5 articlesManaging projects • 5 articlesUsing containerized services • 3 articlesMigrating to GitHub ActionsUsing GitHub Actions Importer to automate migrations • 10 articlesManually migrating to GitHub Actions • 5 articlesAdministering GitHub ActionsUsage limits, billing, and administrationViewing GitHub Actions metricsSharing workflows, secrets, and runners with your organization\n\n\n\nGitHub DocsHelp for wherever you are on your GitHub journey.Get startedGet startedMigrationsAccount and profileAuthenticationBilling and paymentsSite policyCollaborative codingCodespacesRepositoriesPull requestsGitHub DiscussionsGitHub CopilotGitHub CopilotGet code suggestionsPrompt engineeringChat in GitHubCopilot Chat CookbookExtensions quickstartCI/CD and DevOpsGitHub ActionsGitHub PackagesGitHub PagesSecuritySecure codingSecret scanningSupply chain securityDependabotCode scanningSecurity advisoriesClient appsGitHub CLIGitHub MobileGitHub DesktopProject managementGitHub IssuesProjectsSearch on GitHubEnterprise and TeamsOrganizationsSecure your organizationEnterprise onboardingEnterprise administratorsGitHub Well-ArchitectedDevelopersAppsREST APIGraphQL APIWebhooksBuild Copilot ExtensionsGitHub ModelsCommunityBuilding communitiesGitHub SponsorsGitHub EducationGitHub for NonprofitsGitHub SupportContribute to GitHub DocsMore docsCodeQL query writingElectronnpmGetting startedSet up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.Connecting to GitHub with SSHYou can connect to GitHub using the Secure Shell Protocol (SSH), which provides a secure channel over an unsecured network.Creating and managing repositoriesYou can create a repository on GitHub to store and collaborate on your project's files, then manage the repository's name and location.Basic writing and formatting syntaxCreate sophisticated formatting for your prose and code on GitHub with simple syntax.PopularAbout pull requestsLearn about pull requests and draft pull requests on GitHub. Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.Authentication documentationKeep your account and data secure with features like two-factor authentication, SSH, and commit signature verification.Getting code suggestions in your IDE with GitHub CopilotUse GitHub Copilot to get code suggestions in your editor.Managing remote repositoriesLearn to work with your local repositories on your computer and remote repositories hosted on GitHub.\n\n\n\nGitHub Actions/About GitHub Actions/Understand GitHub ActionsUnderstanding GitHub ActionsLearn the basics of GitHub Actions, including core concepts and essential terminology.In this articleOverviewThe components of GitHub ActionsNext stepsOverview
GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production.
GitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository.
GitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.
The components of GitHub Actions
You can configure a GitHub Actions workflow to be triggered when an event occurs in your repository, such as a pull request being opened or an issue being created. Your workflow contains one or more jobs which can run in sequential order or in parallel. Each job will run inside its own virtual machine runner, or inside a container, and has one or more steps that either run a script that you define or run an action, which is a reusable extension that can simplify your workflow.

Workflows
A workflow is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.
Workflows are defined in the .github/workflows directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:

Building and testing pull requests
Deploying your application every time a release is created
Adding a label whenever a new issue is opened

You can reference a workflow within another workflow. For more information, see Reusing workflows.
For more information, see Writing workflows.
Events
An event is a specific activity in a repository that triggers a workflow run. For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. You can also trigger a workflow to run on a schedule, by posting to a REST API, or manually.
For a complete list of events that can be used to trigger workflows, see Events that trigger workflows.
Jobs
A job is a set of steps in a workflow that is executed on the same runner. Each step is either a shell script that will be executed, or an action that will be run. Steps are executed in order and are dependent on each other. Since each step is executed on the same runner, you can share data from one step to another. For example, you can have a step that builds your application followed by a step that tests the application that was built.
You can configure a job's dependencies with other jobs; by default, jobs have no dependencies and run in parallel. When a job takes a dependency on another job, it waits for the dependent job to complete before running.
For example, you might configure multiple build jobs for different architectures without any job dependencies and a packaging job that depends on those builds. The build jobs run in parallel, and once they complete successfully, the packaging job runs.
For more information, see Choosing what your workflow does.
Actions
An action is a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. Use an action to help reduce the amount of repetitive code that you write in your workflow files. An action can pull your Git repository from GitHub, set up the correct toolchain for your build environment, or set up the authentication to your cloud provider.
You can write your own actions, or you can find actions to use in your workflows in the GitHub Marketplace.
For more information on actions, see Sharing automations.
Runners
A runner is a server that runs your workflows when they're triggered. Each runner can run a single job at a time.
GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run your workflows. Each workflow run executes in a fresh, newly-provisioned virtual machine.
GitHub also offers larger runners, which are available in larger configurations. For more information, see Using larger runners.
If you need a different operating system or require a specific hardware configuration, you can host your own runners.
For more information about self-hosted runners, see Hosting your own runners.
Next steps
GitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:

To create a GitHub Actions workflow, see Using workflow templates.
For continuous integration (CI) workflows, see Building and testing.
For building and publishing packages, see Publishing packages.
For deploying projects, see Use cases and examples.
For automating tasks and processes on GitHub, see Managing projects.
For examples that demonstrate more complex features of GitHub Actions, see Use cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.
To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see About GitHub Certifications.\n\n\n\nGitHub Actions/About GitHub Actions/Continuous integrationAbout continuous integration with GitHub ActionsYou can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.In this articleAbout continuous integrationAbout continuous integration using GitHub ActionsWorkflow templatesFurther readingAbout continuous integration
Continuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Committing code more often detects errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.
When you commit code to your repository, you can continuously build and test the code to make sure that the commit doesn't introduce errors. Your tests can include code linters (which check style formatting), security checks, code coverage, functional tests, and other custom checks.
Building and testing your code requires a server. You can build and test updates locally before pushing code to a repository, or you can use a CI server that checks for new code commits in a repository.
About continuous integration using GitHub Actions
CI using GitHub Actions offers workflows that can build the code in your repository and run your tests. Workflows can run on GitHub-hosted virtual machines, or on machines that you host yourself. For more information, see Using GitHub-hosted runners and About self-hosted runners.
You can configure your CI workflow to run when a GitHub event occurs (for example, when new code is pushed to your repository), on a set schedule, or when an external event occurs using the repository dispatch webhook.
GitHub runs your CI tests and provides the results of each test in the pull request, so you can see whether the change in your branch introduces an error. When all CI tests in a workflow pass, the changes you pushed are ready to be reviewed by a team member or merged. When a test fails, one of your changes may have caused the failure.
When you set up CI in your repository, GitHub analyzes the code in your repository and recommends CI workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template that installs your Node.js packages and runs your tests. You can use the CI workflow template suggested by GitHub, customize the suggested workflow template, or create your own custom workflow file to run your CI tests.
In addition to helping you set up CI workflows for your project, you can use GitHub Actions to create workflows across the full software development life cycle. For example, you can use actions to deploy, package, or release your project. For more information, see Writing workflows.
For a definition of common terms, see Understanding GitHub Actions.
Workflow templates
GitHub offers CI workflow templates for a variety of languages and frameworks.
Browse the complete list of CI workflow templates offered by GitHub in the actions/starter-workflows repository.
Further reading

Building and testing
Managing billing for GitHub Actions\n\n\n\nGitHub Actions/About GitHub Actions/Continuous deploymentAbout continuous deployment with GitHub ActionsYou can create custom continuous deployment (CD) workflows directly in your GitHub repository with GitHub Actions.In this articleAbout continuous deploymentAbout continuous deployment using GitHub ActionsUsing OpenID Connect to access cloud resourcesWorkflow templates and third party actionsFurther readingAbout continuous deployment
Continuous deployment (CD) is the practice of using automation to publish and deploy software updates. As part of the typical CD process, the code is automatically built and tested before deployment.
Continuous deployment is often coupled with continuous integration. For more information about continuous integration, see About continuous integration with GitHub Actions.
About continuous deployment using GitHub Actions
You can set up a GitHub Actions workflow to deploy your software product. To verify that your product works as expected, your workflow can build the code in your repository and run your tests before deploying.
You can configure your CD workflow to run when an event occurs (for example, when new code is pushed to the default branch of your repository), on a set schedule, manually, or when an external event occurs using the repository dispatch webhook. For more information about when your workflow can run, see Events that trigger workflows.
GitHub Actions provides features that give you more control over deployments. For example, you can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, or limit access to secrets. You can use concurrency to limit your CD pipeline to a maximum of one in-progress deployment and one pending deployment. For more information about these features, see Deploying with GitHub Actions and Managing environments for deployment.
Using OpenID Connect to access cloud resources
If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect.
Workflow templates and third party actions
GitHub offers deployment workflow templates for several popular services, such as Azure Web App. To learn how to get started using a workflow template, see Using workflow templates or browse the full list of deployment workflow templates. You can also check out our more detailed guides for specific deployment workflows, such as Deploying Node.js to Azure App Service.
Many service providers also offer actions on GitHub Marketplace for deploying to their service. For the full list, see GitHub Marketplace.
Further reading

Deploying
Deploying with GitHub Actions
Managing environments for deployment
Managing billing for GitHub Actions\n\n\n\nGitHub Actions/Write workflows/QuickstartQuickstart for GitHub ActionsTry out the features of GitHub Actions in 5 minutes or less.In this articleIntroductionUsing workflow templatesPrerequisitesCreating your first workflowViewing your workflow resultsNext stepsIntroduction
GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that run tests whenever you push a change to your repository, or that deploy merged pull requests to production.
This quickstart guide shows you how to use the user interface of GitHub to add a workflow that demonstrates some of the essential features of GitHub Actions.
To get started with preconfigured workflows, browse through the list of templates in the actions/starter-workflows repository. For more information, see Using workflow templates.
For an overview of GitHub Actions workflows, see About workflows. If you want to learn about the various components that make up GitHub Actions, see Understanding GitHub Actions.
Using workflow templates
GitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects.
These workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:

CI: Continuous Integration workflows
Deployments: Deployment workflows
Automation: Automating workflows
Code Scanning: Code Scanning workflows
Pages: Pages workflows

Use these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the actions/starter-workflows repository. For more information, see Using workflow templates.
Prerequisites
This guide assumes that:


You have at least a basic knowledge of how to use GitHub. If you don't, you'll find it helpful to read some of the articles in the documentation for repositories and pull requests first. For example, see Quickstart for repositories, About branches, and About pull requests.


You have a repository on GitHub where you can add files.


You have access to GitHub Actions.
Note
 If the  Actions tab is not displayed under the name of your repository on GitHub, it may be because Actions is disabled for the repository. For more information, see Managing GitHub Actions settings for a repository.



Creating your first workflow


In your repository on GitHub, create a workflow file called github-actions-demo.yml in the .github/workflows directory. To do this:


If the .github/workflows directory already exists, navigate to that directory on GitHub, click Add file, then click Create new file, and name the file github-actions-demo.yml.


If your repository doesn't have a .github/workflows directory, go to the main page of the repository on GitHub, click Add file, then click Create new file, and name the file .github/workflows/github-actions-demo.yml. This creates the .github and workflows directories and the github-actions-demo.yml file in a single step.


Note

For GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called .github/workflows.
You can give the workflow file any name you like, but you must use .yml or .yaml as the file name extension. YAML is a markup language that's commonly used for configuration files.



Copy the following YAML contents into the github-actions-demo.yml file:
YAMLname: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 🚀
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "🎉 The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "💡 The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "🖥️ The workflow is now ready to test your code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "🍏 This job's status is ${{ job.status }}."
name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions 🚀
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "🎉 The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "💡 The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "🖥️ The workflow is now ready to test your code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "🍏 This job's status is ${{ job.status }}."

At this stage you don't need to understand the details of this workflow. For now, you can just copy and paste the contents into the file. After completing this quickstart guide, you can learn about the syntax of workflow files in About workflows, and for an explanation of GitHub Actions contexts, such as ${{ github.actor }} and ${{ github.event_name }}, see Accessing contextual information about workflow runs.


Click Commit changes.


In the "Propose changes" dialog, select either the option to commit to the default branch or the option to create a new branch and start a pull request. Then click Commit changes or Propose changes.



Committing the workflow file to a branch in your repository triggers the push event and runs your workflow.
If you chose to start a pull request, you can continue and create the pull request, but this is not necessary for the purposes of this quickstart because the commit has still been made to a branch and will trigger the new workflow.
Viewing your workflow results


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to display, in this example "GitHub Actions Demo."



From the list of workflow runs, click the name of the run you want to see, in this example "USERNAME is testing out GitHub Actions."


In the left sidebar of the workflow run page, under Jobs, click the Explore-GitHub-Actions job.



The log shows you how each of the steps was processed. Expand any of the steps to view its details.

For example, you can see the list of files in your repository:



The example workflow you just added is triggered each time code is pushed to the branch, and shows you how GitHub Actions can work with the contents of your repository. For an in-depth tutorial, see Understanding GitHub Actions.
Next steps
GitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:

To create a GitHub Actions workflow, see Using workflow templates.
For continuous integration (CI) workflows, see Building and testing.
For building and publishing packages, see Publishing packages.
For deploying projects, see Use cases and examples.
For automating tasks and processes on GitHub, see Managing projects.
For examples that demonstrate more complex features of GitHub Actions, see Use cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.
To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see About GitHub Certifications.\n\n\n\nGitHub Actions/Write workflows/About workflowsAbout workflowsGet a high-level overview of GitHub Actions workflows, including triggers, syntax, and advanced features.In this articleAbout workflowsWorkflow basicsTriggering a workflowWorkflow syntaxUsing workflow templatesAdvanced workflow featuresAbout workflows
A workflow is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.
Workflows are defined in the .github/workflows directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:

Building and testing pull requests
Deploying your application every time a release is created
Adding a label whenever a new issue is opened

Workflow basics
A workflow must contain the following basic components:

One or more events that will trigger the workflow.
One or more jobs, each of which will execute on a runner machine and run a series of one or more steps.
Each step can either run a script that you define or run an action, which is a reusable extension that can simplify your workflow.

For more information on these basic components, see Understanding GitHub Actions.

Triggering a workflow
Workflow triggers are events that cause a workflow to run. These events can be:

Events that occur in your workflow's repository
Events that occur outside of GitHub and trigger a repository_dispatch event on GitHub
Scheduled times
Manual

For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened.
For more information, see Triggering a workflow, and for a full list of events, see Events that trigger workflows.
Workflow syntax
Workflows are defined using YAML. For the full reference of the YAML syntax for authoring workflows, see Workflow syntax for GitHub Actions.
For more on managing workflow runs, such as re-running, cancelling, or deleting a workflow run, see Managing workflow runs and deployments.
Using workflow templates
GitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects.
These workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:

CI: Continuous Integration workflows
Deployments: Deployment workflows
Automation: Automating workflows
Code Scanning: Code Scanning workflows
Pages: Pages workflows

Use these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the actions/starter-workflows repository. For more information, see Using workflow templates.
Advanced workflow features
This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows.
Storing secrets
If your workflows use sensitive data, such as passwords or certificates, you can save these in GitHub as secrets and then use them in your workflows as environment variables. This means that you will be able to create and share workflows without having to embed sensitive values directly in the workflow's YAML source.
This example job demonstrates how to reference an existing secret as an environment variable, and send it as a parameter to an example command.
jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - name: Retrieve secret
        env:
          super_secret: ${{ secrets.SUPERSECRET }}
        run: |
          example-command "$super_secret"

For more information, see Using secrets in GitHub Actions.
Creating dependent jobs
By default, the jobs in your workflow all run in parallel at the same time. If you have a job that must only run after another job has completed, you can use the needs keyword to create this dependency. If one of the jobs fails, all dependent jobs are skipped; however, if you need the jobs to continue, you can define this using the if conditional statement.
In this example, the setup, build, and test jobs run in series, with build and test being dependent on the successful completion of the job that precedes them:
jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - run: ./setup_server.sh
  build:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - run: ./build_server.sh
  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: ./test_server.sh

For more information, see Using jobs in a workflow.
Using a matrix
A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. The matrix is created using the strategy keyword, which receives the build options as an array. For example, this matrix will run the job multiple times, using different versions of Node.js:
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}

For more information, see Running variations of jobs in a workflow.
Caching dependencies
If your jobs regularly reuse dependencies, you can consider caching these files to help improve performance. Once the cache is created, it is available to all workflows in the same repository.
This example demonstrates how to cache the ~/.npm directory:
jobs:
  example-job:
    steps:
      - name: Cache node modules
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-

For more information, see Caching dependencies to speed up workflows.
Using databases and service containers
If your job requires a database or cache service, you can use the services keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can use services to create a postgres container, and then use node to connect to the service.
jobs:
  container-job:
    runs-on: ubuntu-latest
    container: node:20-bookworm-slim
    services:
      postgres:
        image: postgres
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: npm ci
      - name: Connect to PostgreSQL
        run: node client.js
        env:
          POSTGRES_HOST: postgres
          POSTGRES_PORT: 5432

For more information, see Using containerized services.
Using labels to route workflows
If you want to be sure that a particular type of runner will process your job, you can use labels to control where jobs are executed. You can assign labels to a self-hosted runner in addition to their default label of self-hosted. Then, you can refer to these labels in your YAML workflow, ensuring that the job is routed in a predictable way. GitHub-hosted runners have predefined labels assigned.
This example shows how a workflow can use labels to specify the required runner:
jobs:
  example-job:
    runs-on: [self-hosted, linux, x64, gpu]

A workflow will only run on a runner that has all the labels in the runs-on array. The job will preferentially go to an idle self-hosted runner with the specified labels. If none are available and a GitHub-hosted runner with the specified labels exists, the job will go to a GitHub-hosted runner.
To learn more about self-hosted runner labels, see Using labels with self-hosted runners.
To learn more about GitHub-hosted runner labels, see Using GitHub-hosted runners.
Reusing workflows
You can call one workflow from within another workflow. This allows you to reuse workflows, avoiding duplication and making your workflows easier to maintain. For more information, see Reusing workflows.
Security hardening for workflows
GitHub provides security features that you can use to increase the security of your workflows. You can use GitHub's built-in features to ensure you are notified about vulnerabilities in the actions you consume, or to automate the process of keeping the actions in your workflows up to date. For more information, see Using GitHub's security features to secure your use of GitHub Actions.
Using environments
You can configure environments with protection rules and secrets to control the execution of jobs in a workflow. Each job in a workflow can reference a single environment. Any protection rules configured for the environment must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment.\n\n\n\nGitHub Actions/Write workflows/Use workflow templatesUsing workflow templatesGitHub provides workflow templates for a variety of languages and tooling.In this articleAbout workflow templatesChoosing and using a workflow templateFurther readingAbout workflow templates
Workflow templates are templates that help you to create your own GitHub Actions workflows for a repository. They offer an alternative to starting from a blank workflow file and are useful because some of the work will already have been done for you.
GitHub offers workflow templates for a variety of languages and tooling. When you set up workflows in your repository, GitHub analyzes the code in your repository and recommends workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template file that installs your Node.js packages and runs your tests. You can search and filter to find relevant workflow templates.
GitHub provides ready-to-use workflow templates for the following high level categories:

Deployment (CD). For more information, see About continuous deployment with GitHub Actions.


Security. For more information, see Configuring advanced setup for code scanning.


Continuous Integration (CI). For more information, see About continuous integration with GitHub Actions.
Automation. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository.

Use these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the actions/starter-workflows repository. For more information, see Using workflow templates.
You can also create your own workflow template to share with your organization. These workflow templates will appear alongside the GitHub-provided workflow templates. Anyone with write access to the organization's .github repository can set up a workflow template. For more information, see Creating workflow templates for your organization.
Choosing and using a workflow template


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



If you already have a workflow in your repository, click New workflow.


The "Choose a workflow" page shows a selection of recommended workflow templates. Find the workflow template that you want to use, then click Configure. To help you find the workflow template that you want, you can search for keywords or filter by category.


If the workflow template contains comments detailing additional setup steps, follow these steps.
There are guides to accompany many of the workflow templates for building and testing projects. For more information, see Building and testing.


Some workflow templates use secrets. For example, ${{ secrets.npm_token }}. If the workflow template uses a secret, store the value described in the secret name as a secret in your repository. For more information, see Using secrets in GitHub Actions.


Optionally, make additional changes. For example, you might want to change the value of on to change when the workflow runs.


Click Start commit.


Write a commit message and decide whether to commit directly to the default branch or to open a pull request.


Further reading


About continuous integration with GitHub Actions


Managing workflow runs and deployments


Monitoring and troubleshooting workflows


Managing billing for GitHub Actions\n\n\n\nGitHub Actions/Write workflows/Choose when workflows run/Trigger a workflowTriggering a workflowHow to automatically trigger GitHub Actions workflowsIn this articleAbout workflow triggersUsing events to trigger workflowsUsing event activity typesUsing filtersDefining inputs for manually triggered workflowsDefining inputs, outputs, and secrets for reusable workflowsUsing event informationFurther controlling how your workflow will runAvailable eventsAbout workflow triggers
Workflow triggers are events that cause a workflow to run. These events can be:

Events that occur in your workflow's repository
Events that occur outside of GitHub and trigger a repository_dispatch event on GitHub
Scheduled times
Manual

For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened.
Workflow triggers are defined with the on key. For more information, see Workflow syntax for GitHub Actions.
The following steps occur to trigger a workflow run:


An event occurs on your repository. The event has an associated commit SHA and Git ref.


GitHub searches the .github/workflows directory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event.


A workflow run is triggered for any workflows that have on: values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run.
Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) environment variables in the runner environment. For more information, see Store information in variables.


Triggering a workflow from a workflow
When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN, with the exception of workflow_dispatch and repository_dispatch, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's GITHUB_TOKEN, a new workflow will not run even when the repository contains a workflow configured to run when push events occur. For more information, see Automatic token authentication.
If you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead of GITHUB_TOKEN to trigger events that require a token.
If you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow. If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, see Managing your personal access tokens. For more information about storing secrets, see Using secrets in GitHub Actions.
To minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs.
For example, the following workflow uses a personal access token (stored as a secret called MY_TOKEN) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed.
on:
  issues:
    types:
      - opened

jobs:
  label_issue:
    runs-on: ubuntu-latest
    steps:
      - env:
          GH_TOKEN: ${{ secrets.MY_TOKEN }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          gh issue edit $ISSUE_URL --add-label "triage"

Conversely, the following workflow uses GITHUB_TOKEN to add a label to an issue. It will not trigger any workflows that run when a label is added.
on:
  issues:
    types:
      - opened

jobs:
  label_issue:
    runs-on: ubuntu-latest
    steps:
      - env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          gh issue edit $ISSUE_URL --add-label "triage"

Using events to trigger workflows
Use the on key to specify what events trigger your workflow. For more information about events you can use, see Events that trigger workflows.
Using a single event
For example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:
on: push

Using multiple events
You can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:
on: [push, fork]

If you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered.
Using activity types and filters with multiple events
You can use activity types and filters to further control when your workflow will run. For more information, see Using event activity types and Using filters. If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon (:) to all events, including events without configuration.
For example, a workflow with the following on value will run when:

A label is created
A push is made to the main branch in the repository
A push is made to a GitHub Pages-enabled branch

on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:

Using event activity types
Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run.
For example, the issue_comment event has the created, edited, and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.
on:
  label:
    types:
      - created

If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.
on:
  issues:
    types:
      - opened
      - labeled

For more information about each event and their activity types, see Events that trigger workflows.
Using filters
Some events have filters that give you more control over when your workflow should run.
For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.
on:
  push:
    branches:
      - main
      - 'releases/**'

Using filters to target specific branches for pull request events
When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches.
Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow.
If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.
The branches and branches-ignore keywords accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \. For more information about glob patterns, see the Workflow syntax for GitHub Actions.
Example: Including branches
The patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:

A branch named main (refs/heads/main)
A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name starts with releases/, like releases/10 (refs/heads/releases/10)

on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'

If a workflow is skipped due to branch filtering, path filtering, or a commit message, then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.
Example: Excluding branches
When a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:

A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name matches releases/**-alpha, like releases/beta/3-alpha (refs/heads/releases/beta/3-alpha)

on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'

Example: Including and excluding branches
You cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded.
If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead.
The order that you define patterns matters.

A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
A matching positive pattern after a negative match will include the Git ref again.

The following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona, but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.
on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

Using filters to target specific branches or tags for push events
When using the push event, you can configure a workflow to run on specific branches or tags.
Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow.
Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow.
If you define only tags/tags-ignore or only branches/branches-ignore, the workflow won't run for events affecting the undefined Git ref. If you define neither tags/tags-ignore or branches/branches-ignore, the workflow will run for events affecting either branches or tags. If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.
The branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \. For more information about glob patterns, see the Workflow syntax for GitHub Actions.
Example: Including branches and tags
The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:

A branch named main (refs/heads/main)
A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name starts with releases/, like releases/10 (refs/heads/releases/10)
A tag named v2 (refs/tags/v2)
A tag whose name starts with v1., like v1.9.1 (refs/tags/v1.9.1)

on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*

Example: Excluding branches and tags
When a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:

A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name matches releases/**-alpha, like releases/beta/3-alpha (refs/heads/releases/beta/3-alpha)
A tag named v2 (refs/tags/v2)
A tag whose name starts with v1., like v1.9 (refs/tags/v1.9)

on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*

Example: Including and excluding branches and tags
You can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded.
If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead.
The order that you define patterns matters.

A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
A matching positive pattern after a negative match will include the Git ref again.

The following workflow will run on pushes to releases/10 or releases/beta/mona, but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.
on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

Using filters to target specific paths for pull request or push events
When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags.
Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded.
Note

The order that you define paths patterns matters:

A matching negative pattern (prefixed with !) after a positive match will exclude the path.
A matching positive pattern after a negative match will include the path again.


If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.
The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions.
Example: Including paths
If at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file (.js).
on:
  push:
    paths:
      - '**.js'

If a workflow is skipped due to path filtering, branch filtering, or a commit message, then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.
Example: Excluding paths
When all the path names match patterns in paths-ignore, the workflow will not run. If any path names do not match patterns in paths-ignore, even if some path names match the patterns, the workflow will run.
A workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.
on:
  push:
    paths-ignore:
      - 'docs/**'

Example: Including and excluding paths
You cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded.
If you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead.
The order that you define paths patterns matters:

A matching negative pattern (prefixed with !) after a positive match will exclude the path.
A matching positive pattern after a negative match will include the path again.

This example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.
on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'

Git diff comparisons
Note

If you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run.

The filter determines if a workflow should run by evaluating the changed files and running them against the paths-ignore or paths list. If there are no files changed, the workflow will not run.
GitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:

Pull requests: Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.
Pushes to existing branches: A two-dot diff compares the head and base SHAs directly with each other.
Pushes to new branches: A two-dot diff against the parent of the ancestor of the deepest commit pushed.

Diffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically.
For more information, see About comparing branches in pull requests.
Using filters to target specific branches for workflow run events
When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow.
The branches and branches-ignore filters accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \. For more information about glob patterns, see the Workflow syntax for GitHub Actions.
For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/:
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches:
      - 'releases/**'

A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary:
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches-ignore:
      - "canary"

You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded.
The order that you define patterns matters.

A matching negative pattern (prefixed with !) after a positive match will exclude the branch.
A matching positive pattern after a negative match will include the branch again.

For example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha, releases/beta/3-alpha, or main.
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

Defining inputs for manually triggered workflows
When using the workflow_dispatch event, you can optionally specify inputs that are passed to the workflow.
This trigger only receives events when the workflow file is on the default branch.
The triggered workflow receives the inputs in the inputs context. For more information, see Contexts.
Note


The workflow will also receive the inputs in the github.event.inputs context. The information in the inputs context and github.event.inputs context is identical except that the inputs context preserves Boolean values as Booleans instead of converting them to strings. The choice type resolves to a string and is a single selectable option.
The maximum number of top-level properties for inputs is 10.
The maximum payload for inputs is 65,535 characters.


on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
      print_tags:
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    if: ${{ inputs.print_tags }} 
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }} 

Defining inputs, outputs, and secrets for reusable workflows
You can define inputs and secrets that a reusable workflow should receive from a calling workflow. You can also specify outputs that a reusable workflow will make available to a calling workflow. For more information, see Reusing workflows.
Using event information
Information about the event that triggered a workflow run is available in the github.event context. The properties in the github.event context depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label.
Viewing all properties of an event
Reference the webhook event documentation for common properties and example payloads. For more information, see Webhook events and payloads.
You can also print the entire github.event context to see what properties are available for the event that triggered your workflow:
jobs:
  print_context:
    runs-on: ubuntu-latest
    steps:
      - env:
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
        run: |
          echo $EVENT_CONTEXT

Accessing and using event properties
You can use the github.event context in your workflow. For example, the following workflow runs when a pull request that changes package*.json, .github/CODEOWNERS, or .github/workflows/** is opened. If the pull request author (github.event.pull_request.user.login) is not octobot or dependabot[bot], then the workflow uses the GitHub CLI to label and comment on the pull request (github.event.pull_request.number).
on:
  pull_request:
    types:
      - opened
    paths:
      - '.github/workflows/**'
      - '.github/CODEOWNERS'
      - 'package*.json'

jobs:
  triage:
    if: >-
      github.event.pull_request.user.login != 'octobot' &&
      github.event.pull_request.user.login != 'dependabot[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: "Comment about changes we can't accept"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR: ${{ github.event.pull_request.html_url }}
        run: |
          gh pr edit $PR --add-label 'invalid'
          gh pr comment $PR --body 'It looks like you edited `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**`. We do not allow contributions to these files. Please review our [contributing guidelines](https://github.com/octo-org/octo-repo/blob/main/CONTRIBUTING.md) for what contributions are accepted.'

For more information about contexts, see Accessing contextual information about workflow runs. For more information about event payloads, see Webhook events and payloads.
Further controlling how your workflow will run
If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run.
Using conditionals
You can use conditionals to further control whether jobs or steps in your workflow will run.
Example using a value in the event payload
For example, if you want the workflow to run when a specific label is added to an issue, you can trigger on the issues labeled event activity type and use a conditional to check what label triggered the workflow. The following workflow will run when any label is added to an issue in the workflow's repository, but the run_if_label_matches job will only execute if the label is named bug.
on:
  issues:
    types:
      - labeled

jobs:
  run_if_label_matches:
    if: github.event.label.name == 'bug'
    runs-on: ubuntu-latest
    steps:
      - run: echo 'The label was bug'

Example using event type
For example, if you want to run different jobs or steps depending on what event triggered the workflow, you can use a conditional to check whether a specific event type exists in the event context. The following workflow will run whenever an issue or pull request is closed. If the workflow ran because an issue was closed, the github.event context will contain a value for issue but not for pull_request. Therefore, the if_issue step will run but the if_pr step will not run. Conversely, if the workflow ran because a pull request was closed, the if_pr step will run but the if_issue step will not run.
on:
  issues:
    types:
      - closed
  pull_request:
    types:
      - closed

jobs:
  state_event_type:
    runs-on: ubuntu-latest
    steps:
    - name: if_issue
      if: github.event.issue
      run: |
        echo An issue was closed
    - name: if_pr
      if: github.event.pull_request
      run: |
        echo A pull request was closed

For more information about what information is available in the event context, see Using event information. For more information about how to use conditionals, see Evaluate expressions in workflows and actions.
Using environments to manually trigger workflow jobs
If you want to manually trigger a specific job in a workflow, you can use an environment that requires approval from a specific team or user. First, configure an environment with required reviewers. For more information, see Managing environments for deployment. Then, reference the environment name in a job in your workflow using the environment: key. Any job referencing the environment will not run until at least one reviewer approves the job.
For example, the following workflow will run whenever there is a push to main. The build job will always run. The publish job will only run after the build job successfully completes (due to needs: [build]) and after all of the rules (including required reviewers) for the environment called production pass (due to environment: production).
on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: build
        run: |
          echo 'building'

  publish:
    needs: [build]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: publish
        run: |
          echo 'publishing'

Note

Environments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.

Available events
For a full list of available events, see Events that trigger workflows.\n\n\n\nGitHub Actions/Write workflows/Choose when workflows run/Use conditions to control job executionUsing conditions to control job executionPrevent a job from running unless your conditions are met.Overview
Note

A job that is skipped will report its status as "Success". It will not prevent a pull request from merging, even if it is a required check.

You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs.
Note

The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied.

When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere.
You must always use the ${{ }} expression syntax or escape with '', "", or () when the expression starts with !, since ! is reserved notation in YAML format. For example:
if: ${{ ! startsWith(github.ref, 'refs/tags/') }}

For more information, see Evaluate expressions in workflows and actions.
Example: Only run job for specific repository
This example uses if to control when the production-deploy job can run. It will only run if the repository is named octo-repo-prod and is within the octo-org organization. Otherwise, the job will be marked as skipped.
YAMLname: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats

On a skipped job, you should see "This check was skipped."
Note

In some parts of the workflow you cannot use environment variables. Instead you can use contexts to access the value of an environment variable. For more information, see Store information in variables.\n\n\n\nGitHub Actions/Write workflows/Choose when workflows run/Events that trigger workflowsEvents that trigger workflowsYou can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.In this articleAbout events that trigger workflowsbranch_protection_rulecheck_runcheck_suitecreatedeletedeploymentdeployment_statusdiscussiondiscussion_commentforkgollumissue_commentissueslabelmerge_groupmilestonepage_buildpublicpull_requestpull_request_comment (use issue_comment)pull_request_reviewpull_request_review_commentpull_request_targetpushregistry_packagereleaserepository_dispatchschedulestatuswatchworkflow_callworkflow_dispatchworkflow_runAbout events that trigger workflows
Workflow triggers are events that cause a workflow to run. For more information about how to use workflow triggers, see Triggering a workflow.
Some events have multiple activity types. For these events, you can specify which activity types will trigger a workflow run. For more information about what each activity type means, see Webhook events and payloads.
Note

Not all webhook events trigger workflows.

branch_protection_rule

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFbranch_protection_rule- created- edited- deletedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, see About protected branches. For information about the branch protection rule APIs, see Objects in the GraphQL API documentation or REST API endpoints for branches and their settings.
For example, you can run a workflow when a branch protection rule has been created or deleted:
on:
  branch_protection_rule:
    types: [created, deleted]

check_run

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFcheck_run- created- rerequested- completed- requested_actionLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, see Using the REST API to interact with checks. For information about the check run APIs, see Objects in the GraphQL API documentation or REST API endpoints for check runs.
For example, you can run a workflow when a check run has been rerequested or completed.
on:
  check_run:
    types: [rerequested, completed]

check_suite

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFcheck_suite- completedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. Although only the completed activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions.

Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, see Using the REST API to interact with checks. For information about the check suite APIs, see Objects in the GraphQL API documentation or REST API endpoints for check suites.
For example, you can run a workflow when a check suite has been completed.
on:
  check_suite:
    types: [completed]

create

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFcreateNot applicableLast commit on the created branch or tagBranch or tag created
Note

An event will not be created when you create more than three tags at once.

Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references.
For example, you can run a workflow when the create event occurs.
on:
  create

delete

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFdeleteNot applicableLast commit on default branchDefault branch
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

An event will not be created when you delete more than three tags at once.

Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, see Mutations in the GraphQL API documentation or REST API endpoints for Git references.
For example, you can run a workflow when the delete event occurs.
on:
  delete

deployment

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFdeploymentNot applicableCommit to be deployedBranch or tag to be deployed (empty if created with a commit SHA)
Runs your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, see Mutations in the GraphQL API documentation or REST API endpoints for repositories.
For example, you can run a workflow when the deployment event occurs.
on:
  deployment

deployment_status

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFdeployment_statusNot applicableCommit to be deployedBranch or tag to be deployed (empty if commit)
Note

When a deployment status's state is set to inactive, a workflow run will not be triggered.

Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, see Mutations in the GraphQL API documentation or REST API endpoints for deployments.
For example, you can run a workflow when the deployment_status event occurs.
on:
  deployment_status

discussion

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFdiscussion- created- edited- deleted- transferred- pinned- unpinned- labeled- unlabeled- locked- unlocked- category_changed - answered - unansweredLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

Webhook events for GitHub Discussions are currently in public preview and subject to change.

Runs your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use the discussion_comment event. For more information about discussions, see About discussions. For information about the GraphQL API, see Objects.
For example, you can run a workflow when a discussion has been created, edited, or answered.
on:
  discussion:
    types: [created, edited, answered]

discussion_comment

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFdiscussion_comment- created- edited- deletedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

Webhook events for GitHub Discussions are currently in public preview and subject to change.

Runs your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the discussion event. For more information about discussions, see About discussions. For information about the GraphQL API, see Objects.
For example, you can run a workflow when a discussion comment has been created or deleted.
on:
  discussion_comment:
    types: [created, deleted]

fork

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFforkNot applicableLast commit on default branchDefault branch
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when someone forks a repository. For information about the REST API, see REST API endpoints for forks.
For example, you can run a workflow when the fork event occurs.
on:
  fork

gollum

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFgollumNot applicableLast commit on default branchDefault branch
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when someone creates or updates a Wiki page. For more information, see About wikis.
For example, you can run a workflow when the gollum event occurs.
on:
  gollum

issue_comment

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFissue_comment- created- edited- deletedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see Objects in the GraphQL API documentation or Webhook events and payloads in the REST API documentation.
For example, you can run a workflow when an issue or pull request comment has been created or deleted.
on:
  issue_comment:
    types: [created, deleted]

issue_comment on issues only or pull requests only
The issue_comment event occurs for comments on both issues and pull requests. You can use the github.event.issue.pull_request property in a conditional to take different action depending on whether the triggering object was an issue or pull request.
For example, this workflow will run the pr_commented job only if the issue_comment event originated from a pull request. It will run the issue_commented job only if the issue_comment event originated from an issue.
on: issue_comment

jobs:
  pr_commented:
    # This job only runs for pull request comments
    name: PR comment
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on PR $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}

  issue_commented:
    # This job only runs for issue comments
    name: Issue comment
    if: ${{ !github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on issue $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}

issues

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFissues- opened- edited- deleted- transferred- pinned- unpinned- closed- reopened- assigned- unassigned- labeled- unlabeled- locked- unlocked- milestoned - demilestoned - typed - untypedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use the issue_comment event. For more information about issues, see About issues. For information about the issue APIs, see Objects in the GraphQL API documentation or REST API endpoints for issues.
For example, you can run a workflow when an issue has been opened, edited, or milestoned.
on:
  issues:
    types: [opened, edited, milestoned]

label

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFlabel- created- edited- deletedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when a label in your workflow's repository is created or modified. For more information about labels, see Managing labels. For information about the label APIs, see Objects in the GraphQL API documentation or REST API endpoints for labels.
If you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use the labeled or unlabeled activity types for the issues, pull_request, pull_request_target, or discussion events instead.
For example, you can run a workflow when a label has been created or deleted.
on:
  label:
    types: [created, deleted]

merge_group

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFmerge_groupchecks_requestedSHA of the merge groupRef of the merge group
Note


More than one activity type triggers this event. Although only the checks_requested activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.
If your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include the merge_group event as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. The merge_group event is separate from the pull_request and push events.


Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information see Merging a pull request with a merge queue.
For example, you can run a workflow when the checks_requested activity has occurred.
on:
  pull_request:
    branches: [ "main" ]
  merge_group:
    types: [checks_requested]

milestone

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFmilestone- created- closed- opened- edited- deletedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, see About milestones. For information about the milestone APIs, see Objects in the GraphQL API documentation or REST API endpoints for milestones.
If you want to run your workflow when an issue is added to or removed from a milestone, use the milestoned or demilestoned activity types for the issues event instead.
For example, you can run a workflow when a milestone has been opened or deleted.
on:
  milestone:
    types: [opened, deleted]

page_build

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpage_buildNot applicableLast commit on default branchNot applicable
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, see Configuring a publishing source for your GitHub Pages site. For information about the REST API, see REST API endpoints for repositories.
For example, you can run a workflow when the page_build event occurs.
on:
  page_build

public

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpublicNot applicableLast commit on default branchDefault branch
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when your workflow's repository changes from private to public. For information about the REST API, see REST API endpoints for repositories.
For example, you can run a workflow when the public event occurs.
on:
  public

pull_request

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpull_request- assigned- unassigned- labeled- unlabeled- opened- edited- closed- reopened- synchronize- converted_to_draft- locked- unlocked- enqueued- dequeued- milestoned- demilestoned- ready_for_review- review_requested- review_request_removed- auto_merge_enabled- auto_merge_disabledLast merge commit on the GITHUB_REF branchPR merge branch refs/pull/PULL_REQUEST_NUMBER/merge
Note


More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, a workflow only runs when a pull_request event's activity type is opened, synchronize, or reopened. To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions.
Workflows will not run on pull_request activity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with the pull_request_target event will run even if the pull request has a merge conflict. Before using the pull_request_target trigger, you should be aware of the security risks. For more information, see pull_request_target.
The pull_request webhook event payload is empty for merged pull requests and pull requests that come from forked repositories.
The value of GITHUB_REF varies for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will be refs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualified ref of the branch it was merged into, for example /refs/heads/main.


Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the pull_request_review, pull_request_review_comment, or issue_comment events instead. For information about the pull request APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests.
Note that GITHUB_SHA for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use github.event.pull_request.head.sha instead.
For example, you can run a workflow when a pull request has been opened or reopened.
on:
  pull_request:
    types: [opened, reopened]

You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the specific_review_requested job will only run when a review by octo-team is requested.
on:
  pull_request:
    types: [review_requested]
jobs:
  specific_review_requested:
    runs-on: ubuntu-latest
    if: ${{ github.event.requested_team.name == 'octo-team'}}
    steps:
      - run: echo 'A review from octo-team was requested'

Running your pull_request workflow based on the head or base branch of a pull request
You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/:
on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'

Note

If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:
on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'


To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/:
on:
  pull_request:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo "The head of this PR starts with 'releases/'"

Running your pull_request workflow based on files changed in a pull request
You can also configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when a pull request includes a change to a JavaScript file (.js):
on:
  pull_request:
    paths:
      - '**.js'

Note

If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:
on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'


Running your pull_request workflow when a pull request merges
When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.
on:
  pull_request:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged

Workflows in forked repositories
Workflows don't run in forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.
With the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. The GITHUB_TOKEN has read-only permissions in pull requests from forked repositories. For more information, see Automatic token authentication.
Pull request events for forked repositories
For pull requests from a forked repository to the base repository, GitHub sends the pull_request, issue_comment, pull_request_review_comment, pull_request_review, and pull_request_target events to the base repository. No pull request events occur on the forked repository.
When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see Approving workflow runs from public forks.
For pull requests from a forked repository to a private repository, workflows only run when they are enabled, see Managing GitHub Actions settings for a repository.
Note

Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.

pull_request_comment (use issue_comment)
To run your workflow when a comment on a pull request (not on a pull request's diff) is created, edited, or deleted, use the issue_comment event. For activity related to pull request reviews or pull request review comments, use the pull_request_review or pull_request_review_comment events.
pull_request_review

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpull_request_review- submitted- edited- dismissedLast merge commit on the GITHUB_REF branchPR merge branch refs/pull/PULL_REQUEST_NUMBER/merge
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the pull_request_review_comment or issue_comment events instead. For information about the pull request review APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests.
For example, you can run a workflow when a pull request review has been edited or dismissed.
on:
  pull_request_review:
    types: [edited, dismissed]

Running a workflow when a pull request is approved
To run your workflow when a pull request has been approved, you can trigger your workflow with the submitted type of pull_request_review event, then check the review state with the github.event.review.state property. For example, this workflow will run whenever a pull request review is submitted, but the approved job will only run if the submitted review is an approving review:
on:
  pull_request_review:
    types: [submitted]

jobs:
  approved:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - run: echo "This PR was approved"

Workflows in forked repositories
Workflows don't run in forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.
With the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. The GITHUB_TOKEN has read-only permissions in pull requests from forked repositories. For more information, see Automatic token authentication.
Pull request events for forked repositories
For pull requests from a forked repository to the base repository, GitHub sends the pull_request, issue_comment, pull_request_review_comment, pull_request_review, and pull_request_target events to the base repository. No pull request events occur on the forked repository.
When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see Approving workflow runs from public forks.
For pull requests from a forked repository to a private repository, workflows only run when they are enabled, see Managing GitHub Actions settings for a repository.
Note

Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.

pull_request_review_comment

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpull_request_review_comment- created- edited- deletedLast merge commit on the GITHUB_REF branchPR merge branch refs/pull/PULL_REQUEST_NUMBER/merge
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Runs your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use the pull_request_review or issue_comment events instead. For information about the pull request review comment APIs, see Objects in the GraphQL API documentation or REST API endpoints for pull requests.
For example, you can run a workflow when a pull request review comment has been created or deleted.
on:
  pull_request_review_comment:
    types: [created, deleted]

Workflows in forked repositories
Workflows don't run in forked repositories by default. You must enable GitHub Actions in the Actions tab of the forked repository.
With the exception of GITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. The GITHUB_TOKEN has read-only permissions in pull requests from forked repositories. For more information, see Automatic token authentication.
Pull request events for forked repositories
For pull requests from a forked repository to the base repository, GitHub sends the pull_request, issue_comment, pull_request_review_comment, pull_request_review, and pull_request_target events to the base repository. No pull request events occur on the forked repository.
When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see Approving workflow runs from public forks.
For pull requests from a forked repository to a private repository, workflows only run when they are enabled, see Managing GitHub Actions settings for a repository.
Note

Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.

pull_request_target

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpull_request- assigned- unassigned- labeled- unlabeled- opened- edited- closed- reopened- synchronize- converted_to_draft- ready_for_review- locked- unlocked - review_requested - review_request_removed - auto_merge_enabled - auto_merge_disabledLast commit on the PR base branchPR base branch
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, a workflow only runs when a pull_request_target event's activity type is opened, synchronize, or reopened. To trigger workflows by different activity types, use the types keyword. For more information, see Workflow syntax for GitHub Actions.

Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated.
This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request.
To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the pull_request_target event.
Warning

For workflows that are triggered by the pull_request_target event, the GITHUB_TOKEN is granted read/write repository permission unless the permissions key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see Keeping your GitHub Actions and workflows secure: Preventing pwn requests on the GitHub Security Lab website.

For example, you can run a workflow when a pull request has been assigned, opened, synchronize, or reopened.
on:
  pull_request_target:
    types: [assigned, opened, synchronize, reopened]

Running your pull_request_target workflow based on the head or base branch of a pull request
You can use the branches or branches-ignore filter to configure your workflow to only run on pull requests that target specific branches. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with releases/:
on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'

Note

If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:
on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'


To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the github.head_ref context in a conditional. For example, this workflow will run whenever a pull request is opened, but the run_if job will only execute if the head of the pull request is a branch whose name starts with releases/:
on:
  pull_request_target:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo "The head of this PR starts with 'releases/'"

Running your pull_request_target workflow based on files changed in a pull request
You can use the paths or paths-ignore filter to configure your workflow to run when a pull request changes specific files. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when a pull request includes a change to a JavaScript file (.js):
on:
  pull_request_target:
    paths:
      - '**.js'

Note

If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts with releases/:
on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'


Running your pull_request_target workflow when a pull request merges
When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the pull_request_target closed event type along with a conditional that checks the merged value of the event. For example, the following workflow will run whenever a pull request closes. The if_merged job will only run if the pull request was also merged.
on:
  pull_request_target:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged

push

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFpushNot applicableTip commit pushed to the ref. When you delete a branch, the SHA in the workflow run (and its associated refs) reverts to the default branch of the repository.Updated ref
Note

The webhook payload available to GitHub Actions does not include the added, removed, and modified attributes in the commit object. You can retrieve the full commit object using the API. For information, see Objects in the GraphQL API documentation or REST API endpoints for commits.

Note

Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once.

Runs your workflow when you push a commit or tag, or when you create a repository from a template.
For example, you can run a workflow when the push event occurs.
on:
  push

Note

When a push webhook event triggers a workflow run, the Actions UI's "pushed by" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the "pushed by" field will be the repository admin who verified the deploy key when it was added it to a repository.

Running your workflow only when a push to specific branches occurs
You can use the branches or branches-ignore filter to configure your workflow to only run when specific branches are pushed. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when someone pushes to main or to a branch that starts with releases/.
on:
  push:
    branches:
      - 'main'
      - 'releases/**'

Note

If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts with releases/:
on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'


Running your workflow only when a push of specific tags occurs
You can use the tags or tags-ignore filter to configure your workflow to only run when specific tags are pushed. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when someone pushes a tag that starts with v1..
on:
  push:
    tags:
      - v1.**

Running your workflow only when a push affects specific files
You can use the paths or paths-ignore filter to configure your workflow to run when a push to specific files occurs. For more information, see Workflow syntax for GitHub Actions.
For example, this workflow will run when someone pushes a change to a JavaScript file (.js):
on:
  push:
    paths:
      - '**.js'

Note

If you use both the branches filter and the paths filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts with releases/:
on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'


registry_package

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFregistry_package- published- updatedCommit of the published packageBranch or tag of the published package
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:
jobs:
    job_name:
        if: $true


Runs your workflow when activity related to GitHub Packages occurs in your repository. For more information, see GitHub Packages Documentation.
For example, you can run a workflow when a new package version has been published.
on:
  registry_package:
    types: [published]

release

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFrelease- published - unpublished - created - edited - deleted - prereleased - releasedLast commit in the tagged releaseTag ref of release refs/tags/<tag_name>
Note

More than one activity type triggers this event. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

Workflows are not triggered for the created, edited, or deleted activity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft.

Note

The prereleased type will not trigger for pre-releases published from draft releases, but the published type will trigger. If you want a workflow to run when stable and pre-releases publish, subscribe to published instead of released and prereleased.

Runs your workflow when release activity in your repository occurs. For information about the release APIs, see Objects in the GraphQL API documentation or REST API endpoints for releases and release assets in the REST API documentation.
For example, you can run a workflow when a release has been published.
on:
  release:
    types: [published]

repository_dispatch

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFrepository_dispatchCustomLast commit on default branchDefault branch
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

You can use the GitHub API to trigger a webhook event called repository_dispatch when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see REST API endpoints for repositories.
When you make a request to create a repository_dispatch event, you must specify an event_type to describe the activity type. By default, all repository_dispatch activity types trigger a workflow to run. You can use the types keyword to limit your workflow to run when a specific event_type value is sent in the repository_dispatch webhook payload.
on:
  repository_dispatch:
    types: [test_result]

Note

The event_type value is limited to 100 characters.

Any data that you send through the client_payload parameter will be available in the github.event context in your workflow. For example, if you send this request body when you create a repository dispatch event:
{
  "event_type": "test_result",
  "client_payload": {
    "passed": false,
    "message": "Error: timeout"
  }
}

then you can access the payload in a workflow like this:
on:
  repository_dispatch:
    types: [test_result]

jobs:
  run_if_failure:
    if: ${{ !github.event.client_payload.passed }}
    runs-on: ubuntu-latest
    steps:
      - env:
          MESSAGE: ${{ github.event.client_payload.message }}
        run: echo $MESSAGE

Note


The maximum number of top-level properties in client_payload is 10.
The payload can contain a maximum of 65,535 characters.


schedule

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFNot applicableNot applicableLast commit on default branchDefault branch
Note



The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.


This event will only trigger a workflow run if the workflow file is on the default branch.


Scheduled workflows will only run on the default branch.


In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see Disabling and enabling a workflow.


For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last actor associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last actor Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the actor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their actor from running. Essentially, triggering a scheduled workflow requires that the status of the actor user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the user account's status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, not the user's membership status in the organization where the scheduled workflow is located.


Certain repository events change the actor associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes actor for those scheduled workflows.


For a deactivated scheduled workflow, if a user with write permissions to the repository makes a commit that changes the cron schedule on the workflow, the workflow will be reactivated, and that user will become the actor associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the cron value in the workflow and commit this change.
Example:
on:
  schedule:
    - cron: "15 4,5 * * *"   # <=== Change this value




The schedule event allows you to trigger a workflow at a scheduled time.
You can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.
This example triggers the workflow every day at 5:30 and 17:30 UTC:
on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'

A single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.
on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo "This step will be skipped on Monday and Wednesday"
      - name: Every time
        run: echo "This step will always run"

Cron syntax has five fields separated by a space, and each field represents a unit of time.
┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of the month (1 - 31)
│ │ │ ┌───────────── month (1 - 12 or JAN-DEC)
│ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT)
│ │ │ │ │
│ │ │ │ │
│ │ │ │ │
* * * * *

You can use these operators in any of the five fields:






























OperatorDescriptionExample*Any value15 * * * * runs at every minute 15 of every hour of every day.,Value list separator2,10 4,5 * * * runs at minute 2 and 10 of the 4th and 5th hour of every day.-Range of values30 4-6 * * * runs at minute 30 of the 4th, 5th, and 6th hour./Step values20/15 * * * * runs every 15 minutes starting from minute 20 through 59 (minutes 20, 35, and 50).
Note

GitHub Actions does not support the non-standard syntax @yearly, @monthly, @weekly, @daily, @hourly, and @reboot.

You can use crontab guru to help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list of crontab guru examples.
Notifications for scheduled workflows are sent to the user who last modified the cron syntax in the workflow file. For more information, see Notifications for workflow runs.
status

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFstatusNot applicableLast commit on default branchNot applicable
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when the status of a Git commit changes. For example, commits can be marked as error, failure, pending, or success. If you want to provide more details about the status change, you may want to use the check_run event. For information about the commit status APIs, see Objects in the GraphQL API documentation or REST API endpoints for commits.
For example, you can run a workflow when the status event occurs.
on:
  status

If you want to run a job in your workflow based on the new commit state, you can use the github.event.state context. For example, the following workflow triggers when a commit status changes, but the if_error_or_failure job only runs if the new commit state is error or failure.
on:
  status
jobs:
  if_error_or_failure:
    runs-on: ubuntu-latest
    if: >-
      github.event.state == 'error' ||
      github.event.state == 'failure'
    steps:
      - env:
          DESCRIPTION: ${{ github.event.description }}
        run: |
          echo The status is error or failed: $DESCRIPTION

watch

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFwatch- startedLast commit on default branchDefault branch
Note

More than one activity type triggers this event. Although only the started activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when the workflow's repository is starred. For information about the pull request APIs, see Mutations in the GraphQL API documentation or REST API endpoints for starring.
For example, you can run a workflow when someone stars a repository, which is the started activity type for a watch event.
on:
  watch:
    types: [started]

workflow_call

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFSame as the caller workflowNot applicableSame as the caller workflowSame as the caller workflow
workflow_call is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the workflow_call event, the event payload in the called workflow is the same event payload from the calling workflow. For more information see, Reusing workflows.
The example below only runs the workflow when it's called from another workflow:
on: workflow_call

workflow_dispatch

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFworkflow_dispatchNot applicableLast commit on the GITHUB_REF branch or tagBranch or tag that received dispatch
Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

To enable a workflow to be triggered manually, you need to configure the workflow_dispatch event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see Manually running a workflow.
on: workflow_dispatch

Providing inputs
You can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the ref and any inputs. When the workflow runs, you can access the input values in the inputs context. For more information, see Accessing contextual information about workflow runs.
Note


The workflow will also receive the inputs in the github.event.inputs context. The information in the inputs context and github.event.inputs context is identical except that the inputs context preserves Boolean values as Booleans instead of converting them to strings. The choice type resolves to a string and is a single selectable option.
The maximum number of top-level properties for inputs is 10.
The maximum payload for inputs is 65,535 characters.


This example defines inputs called logLevel, tags, and environment. You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using the inputs.logLevel, inputs.tags, and inputs.environment context properties.
on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug
      tags:
        description: 'Test scenario tags'
        required: false
        type: boolean
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  log-the-inputs:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Log level: $LEVEL"
          echo "Tags: $TAGS"
          echo "Environment: $ENVIRONMENT"
        env:
          LEVEL: ${{ inputs.logLevel }}
          TAGS: ${{ inputs.tags }}
          ENVIRONMENT: ${{ inputs.environment }}

If you run this workflow from a browser you must enter values for the required inputs manually before the workflow will run.

You can also pass inputs when you run a workflow from a script, or by using GitHub CLI. For example:
gh workflow run run-tests.yml -f logLevel=warning -f tags=false -f environment=staging

For more information, see the GitHub CLI information in Manually running a workflow.
workflow_run

















Webhook event payloadActivity typesGITHUB_SHAGITHUB_REFworkflow_run- completed- requested- in_progressLast commit on default branchDefault branch
Note

More than one activity type triggers this event. The requested activity type does not occur when a workflow is re-run. For information about each activity type, see Webhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the types keyword. For more information, see Workflow syntax for GitHub Actions.

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

You can't use workflow_run to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named B to F) to run sequentially after an initial workflow A has run (that is: A → B → C → D → E → F), workflows E and F will not be run.

This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the workflow_run event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow.
In this example, a workflow is configured to run after the separate "Run Tests" workflow completes.
on:
  workflow_run:
    workflows: [Run Tests]
    types:
      - completed

If you specify multiple workflows for the workflow_run event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the "Staging" workflow or the "Lab" workflow completes.
on:
  workflow_run:
    workflows: [Staging, Lab]
    types:
      - completed

Running a workflow based on the conclusion of another workflow
A workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with the github.event.workflow_run.conclusion property. For example, this workflow will run whenever a workflow named "Build" completes, but the on-success job will only run if the "Build" workflow succeeded, and the on-failure job will only run if the "Build" workflow failed:
on:
  workflow_run:
    workflows: [Build]
    types: [completed]

jobs:
  on-success:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - run: echo 'The triggering workflow passed'
  on-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - run: echo 'The triggering workflow failed'

Limiting your workflow to run based on branches
You can use the branches or branches-ignore filter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, see Workflow syntax for GitHub Actions. For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch named canary.
on:
  workflow_run:
    workflows: [Build]
    types: [requested]
    branches: [canary]

Using data from the triggering workflow
You can access the workflow_run event payload that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the workflow_run event can access these artifacts.
The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)
name: Upload data

on:
  pull_request:

jobs:
  upload:
    runs-on: ubuntu-latest

    steps:
      - name: Save PR number
        env:
          PR_NUMBER: ${{ github.event.number }}
        run: |
          mkdir -p ./pr
          echo $PR_NUMBER > ./pr/pr_number
      - uses: actions/upload-artifact@v4
        with:
          name: pr_number
          path: pr/

When a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses the github.event.workflow_run context and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact.
name: Use the data

on:
  workflow_run:
    workflows: [Upload data]
    types:
      - completed

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: 'Download artifact'
        uses: actions/github-script@v7
        with:
          script: |
            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: context.payload.workflow_run.id,
            });
            let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => {
              return artifact.name == "pr_number"
            })[0];
            let download = await github.rest.actions.downloadArtifact({
               owner: context.repo.owner,
               repo: context.repo.repo,
               artifact_id: matchArtifact.id,
               archive_format: 'zip',
            });
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            if (!fs.existsSync(temp)){
              fs.mkdirSync(temp);
            }
            fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data));

      - name: 'Unzip artifact'
        run: unzip pr_number.zip -d "${{ runner.temp }}/artifacts"

      - name: 'Comment on PR'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number')));
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: 'Thank you for the PR!'
            });\n\n\n\nGitHub Actions/Write workflows/Choose where workflows run/Choose the runner for a jobChoosing the runner for a jobDefine the type of machine that will process a job in your workflow.In this articleOverviewChoosing GitHub-hosted runnersChoosing self-hosted runnersChoosing runners in a groupOverview
Use jobs.<job_id>.runs-on to define the type of machine to run the job on.

The destination machine can be either a GitHub-hosted runner, larger runner, or a self-hosted runner.



You can target runners based on the labels assigned to them, or their group membership, or a combination of these.


You can provide runs-on as:

A single string
A single variable containing a string
An array of strings, variables containing strings, or a combination of both
A key: value pair using the group or labels keys



If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux, x64, and gpu:
runs-on: [self-hosted, linux, x64, gpu]

For more information, see Choosing self-hosted runners.


You can mix strings and variables in an array. For example:
on:
  workflow_dispatch:
    inputs:
      chosen-os:
        required: true
        type: choice
        options:
        - Ubuntu
        - macOS

jobs:
  test:
    runs-on: [self-hosted, "${{ inputs.chosen-os }}"]
    steps:
    - run: echo Hello world!



If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy.


Note

Quotation marks are not required around simple strings like self-hosted, but they are required for expressions like  "${{ inputs.chosen-os }}".

Choosing GitHub-hosted runners
If you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by runs-on.
The value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.
For more information, see About GitHub-hosted runners.
Standard GitHub-hosted runners for public repositories
For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.


  
    
      Virtual Machine
      Processor (CPU)
      Memory (RAM)
      Storage (SSD)
      Architecture
      Workflow label
    
  
  
    
      Linux
      4
      16 GB
      14 GB
       x64 
      
        ubuntu-latest,
        ubuntu-24.04,
        ubuntu-22.04,
        ubuntu-20.04
      
    
    
      Windows
      4
      16 GB
      14 GB
       x64 
      
        windows-latest,
         windows-2025,
        windows-2022,
        windows-2019
      
    
    
      Linux [Public preview]
      4
      16 GB
      14 GB
       arm64 
      
        ubuntu-24.04-arm,
        ubuntu-22.04-arm
      
    
    
      Windows [Public preview]
      4
      16 GB
      14 GB
      arm64
      
        windows-11-arm
      
    
    
      macOS
      4
      14 GB
      14 GB
       Intel 
      
        macos-13
      
    
    
      macOS
      3 (M1)
      7 GB
      14 GB
       arm64 
      
        macos-latest,
        macos-14,
        macos-15
      
    
  
Note
 The arm64 Linux and Windows runners are in public preview and subject to change.

Standard GitHub-hosted runners for  private repositories
For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions.

  
    
      Virtual Machine
      Processor (CPU)
      Memory (RAM)
      Storage (SSD)
      Architecture
      Workflow label
    
  
  
    
      Linux
      2
      7 GB
      14 GB
       x64 
      
        ubuntu-latest,
        ubuntu-24.04,
        ubuntu-22.04,
        ubuntu-20.04
      
    
    
      Windows
      2
      7 GB
      14 GB
       x64 
      
        windows-latest,
        windows-2025,
        windows-2022,
        windows-2019
      
    
    
      macOS
      4
      14 GB
      14 GB
       Intel 
      
        macos-13
      
    
    
      macOS
      3 (M1)
      7 GB
      14 GB
       arm64 
      
        macos-latest,
        macos-14,
        macos-15
      
    
  

In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners.
Note

The -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.

Warning

Beta and Deprecated Images are provided "as-is", "with all faults" and "as available" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.

Example: Specifying an operating system
runs-on: ubuntu-latest

For more information, see Using GitHub-hosted runners.
Choosing self-hosted runners
To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels.
Self-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted. You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.
Note that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.
Example: Using labels for runner selection
runs-on: [self-hosted, linux]

For more information, see About self-hosted runners and Using self-hosted runners in a workflow.
Choosing runners in a group
You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.
Runner groups can only have larger runners or self-hosted runners as members.
Example: Using groups to control where jobs are run
In this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

Example: Combining groups and labels
When you combine groups and labels, the runner must meet both requirements to be eligible to run the job.
In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v\n\n\n\nGitHub Actions/Write workflows/Choose where workflows run/Run jobs in a containerRunning jobs in a containerUse a container to run the steps in a job.In this articleOverviewDefining the container imageDefining credentials for a container registryUsing environment variables with a containerExposing network ports on a containerMounting volumes in a containerSetting container resource optionsOverview
Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.
If you do not set a container, all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container.
Note

The default shell for run steps inside a container is sh instead of bash. This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell.

Example: Running a job within a container
YAMLname: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)
name: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)

When you only specify a container image, you can omit the image keyword.
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container: node:18

Defining the container image
Use jobs.<job_id>.container.image to define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
Note

Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker.

Defining credentials for a container registry
If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password. The credentials are the same values that you would provide to the docker login command.
Example: Defining credentials for a container registry
container:
  image: ghcr.io/owner/image
  credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}

Using environment variables with a container
Use jobs.<job_id>.container.env to set a map of environment variables in the container.
Exposing network ports on a container
Use jobs.<job_id>.container.ports to set an array of ports to expose on the container.
Mounting volumes in a container
Use jobs.<job_id>.container.volumes to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
To specify a volume, you specify the source and destination path:
<source>:<destinationPath>.
The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
Example: Mounting volumes in a container
volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory

Setting container resource options
Use jobs.<job_id>.container.options to configure additional Docker container resource options. For a list of options, see docker create options.
Warning

The --network and --entrypoint options are not supported.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Use jobs in a workflowUsing jobs in a workflowUse workflows to run multiple jobs.In this articleOverviewSetting an ID for a jobSetting a name for a jobDefining prerequisite jobsOverview
A workflow run is made up of one or more jobs, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
Each job runs in a runner environment specified by runs-on.
You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and Usage limits for self-hosted runners for self-hosted runner usage limits.
If you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, see REST API endpoints for GitHub Actions.
Setting an ID for a job
Use jobs.<job_id> to give your job a unique identifier. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.
Example: Creating jobs
In this example, two jobs have been created, and their job_id values are my_first_job and my_second_job.
jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job

Setting a name for a job
Use jobs.<job_id>.name to set a name for the job, which is displayed in the GitHub UI.
Defining prerequisite jobs
Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if.
Example: Requiring successful dependent jobs
jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]

In this example, job1 must complete successfully before job2 begins, and job3 waits for both job1 and job2 to complete.
The jobs in this example run sequentially:

job1
job2
job3

Example: Not requiring successful dependent jobs
jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]

In this example, job3 uses the always() conditional expression so that it always runs after job1 and job2 have completed, regardless of whether they were successful. For more information, see Evaluate expressions in workflows and actions.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Find and customize actionsUsing pre-written building blocks in your workflowActions are the building blocks that power your workflow. A workflow can contain actions created by the community, or you can create your own actions directly within your application's repository. This guide will show you how to discover, use, and customize actions.In this articleOverviewBrowsing Marketplace actions in the workflow editorAdding an action to your workflowUsing release management for your custom actionsUsing inputs and outputs with an actionNext stepsOverview
You can use pre-written building blocks, called actions, in your workflow. An action is a pre-defined, reusable set of jobs or code that perform specific tasks within a workflow.
Actions can be:

Reusable: actions can be used across different workflows and repositories, allowing you to avoid rewriting the same code.
Pre-written: many actions are available in the GitHub Marketplace, covering a wide range of tasks like checking out code, setting up environments, running tests, and deploying applications.
Configurable: you can configure actions with inputs, outputs, and environment variables to tailor them to your specific needs.
Community-driven: you can create your own actions and share them with others or use actions developed by the community.

The actions you use in your workflow can be defined in:

The same repository as your workflow file
Any public repository
A published Docker container image on Docker Hub

GitHub Marketplace is a central location for you to find actions created by the GitHub community. GitHub Marketplace page enables you to filter for actions by category.
Browsing Marketplace actions in the workflow editor
You can search and browse actions directly in your repository's workflow editor. From the sidebar, you can search for a specific action, view featured actions, and browse featured categories. You can also view the number of stars an action has received from the GitHub community.

In your repository, browse to the workflow file you want to edit.
In the upper right corner of the file view, to open the workflow editor, click .

To the right of the editor, use the GitHub Marketplace sidebar to browse actions. Actions with the  badge indicate GitHub has verified the creator of the action as a partner organization.


Adding an action to your workflow
You can add an action to your workflow by referencing the action in your workflow file.
You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see “About the dependency graph.”
Note

To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail.

Adding an action from GitHub Marketplace
An action's listing page includes the action's version and the workflow syntax required to use the action. To keep your workflow stable even when updates are made to an action, you can reference the version of the action to use by specifying the Git or Docker tag number in your workflow file.

Navigate to the action you want to use in your workflow.
Click to view the full marketplace listing for the action.
Under "Installation", click  to copy the workflow syntax.

Paste the syntax as a new step in your workflow. For more information, see Workflow syntax for GitHub Actions.
If the action requires you to provide inputs, set them in your workflow. For information on inputs an action might require, see Using pre-written building blocks in your workflow.

You can also enable Dependabot version updates for the actions that you add to your workflow. For more information, see Keeping your actions up to date with Dependabot.
Adding an action from the same repository
If an action is defined in the same repository where your workflow file uses the action, you can reference the action with either the ‌{owner}/{repo}@{ref} or ./path/to/dir syntax in your workflow file.
Example repository file structure:
|-- hello-world (repository)
|   |__ .github
|       └── workflows
|           └── my-first-workflow.yml
|       └── actions
|           |__ hello-world-action
|               └── action.yml

The path is relative (./) to the default working directory (github.workspace, $GITHUB_WORKSPACE). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated.
Example workflow file:
jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action

The action.yml file is used to provide metadata for the action. Learn about the content of this file in Metadata syntax for GitHub Actions.
Adding an action from a different repository
If an action is defined in a different repository than your workflow file, you can reference the action with the {owner}/{repo}@{ref} syntax in your workflow file.
The action must be stored in a public repository.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/setup-node@v4

Referencing a container on Docker Hub
If an action is defined in a published Docker container image on Docker Hub, you must reference the action with the docker://{image}:{tag} syntax in your workflow file. To protect your code and data, we strongly recommend you verify the integrity of the Docker container image from Docker Hub before using it in your workflow.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8

For some examples of Docker actions, see the Docker-image.yml workflow and Creating a Docker container action.
Security hardening for using actions in your workflows
GitHub provides security features that you can use to increase the security of your workflows. You can use GitHub's built-in features to ensure you are notified about vulnerabilities in the actions you consume, or to automate the process of keeping the actions in your workflows up to date. For more information, see Using GitHub's security features to secure your use of GitHub Actions.
Using release management for your custom actions
The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action.
You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use.
Note

We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, see Security hardening for GitHub Actions and About Dependabot alerts.

Using tags
Tags are useful for letting you decide when to switch between major and minor versions, but these are more ephemeral and can be moved or deleted by the maintainer. This example demonstrates how to target an action that's been tagged as v1.0.1:
steps:
  - uses: actions/javascript-action@v1.0.1

Using SHAs
If you need more reliable versioning, you should use the SHA value associated with the version of the action. SHAs are immutable and therefore more reliable than tags or branches. However, this approach means you will not automatically receive updates for an action, including important bug fixes and security updates. You must use a commit's full SHA value, and not an abbreviated value. When selecting a SHA, you should verify it is from the action's repository and not a repository fork. This example targets an action's SHA:
steps:
  - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f

Using branches
Specifying a target branch for the action means it will always run the version currently on that branch. This approach can create problems if an update to the branch includes breaking changes. This example targets a branch named @main:
steps:
  - uses: actions/javascript-action@main

For more information, see About custom actions.
Using inputs and outputs with an action
An action often accepts or requires inputs and generates outputs that you can use. For example, an action might require you to specify a path to a file, the name of a label, or other data it will use as part of the action processing.
To see the inputs and outputs of an action, check the action.yml in the root directory of the repository.
In this example action.yml, the inputs keyword defines a required input called file-path, and includes a default value that will be used if none is specified. The outputs keyword defines an output called results-file, which tells you where to locate the results.
name: "Example"
description: "Receives file and generates output"
inputs:
  file-path: # id of input
    description: "Path to test script"
    required: true
    default: "test-file.js"
outputs:
  results-file: # id of output
    description: "Path to results file"

Next steps
To continue learning about GitHub Actions, see Understanding GitHub Actions.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/GitHub CLI in workflowsUsing GitHub CLI in workflowsYou can script with GitHub CLI in GitHub Actions workflows.Note

To learn more about GitHub CLI, see About GitHub CLI.

GitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable called GH_TOKEN to a token with the required scopes.
You can execute any GitHub CLI command. For example, this workflow uses the gh issue comment subcommand to add a comment when an issue is opened.
YAMLname: Comment when opened
on:
  issues:
    types:
      - opened
jobs:
  comment:
    runs-on: ubuntu-latest
    steps:
      - run: gh issue comment $ISSUE --body "Thank you for opening this issue!"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE: ${{ github.event.issue.html_url }}
name: Comment when opened
on:
  issues:
    types:
      - opened
jobs:
  comment:
    runs-on: ubuntu-latest
    steps:
      - run: gh issue comment $ISSUE --body "Thank you for opening this issue!"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE: ${{ github.event.issue.html_url }}

You can also execute API calls through GitHub CLI. For example, this workflow first uses the gh api subcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step. In the second step, it uses the gh issue create subcommand to create an issue containing the information from the first step.
YAMLname: Report remaining open issues
on: 
  schedule: 
    # Daily at 8:20 UTC
    - cron: '20 8 * * *'
jobs:
  track_pr:
    runs-on: ubuntu-latest
    steps:
      - run: |
          numOpenIssues="$(gh api graphql -F owner=$OWNER -F name=$REPO -f query='
            query($name: String!, $owner: String!) {
              repository(owner: $owner, name: $name) {
                issues(states:OPEN){
                  totalCount
                }
              }
            }
          ' --jq '.data.repository.issues.totalCount')"

          echo 'NUM_OPEN_ISSUES='$numOpenIssues >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
      - run: |
          gh issue create --title "Issue report" --body "$NUM_OPEN_ISSUES issues remaining" --repo $GITHUB_REPOSITORY
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
name: Report remaining open issues
on: 
  schedule: 
    # Daily at 8:20 UTC
    - cron: '20 8 * * *'
jobs:
  track_pr:
    runs-on: ubuntu-latest
    steps:
      - run: |
          numOpenIssues="$(gh api graphql -F owner=$OWNER -F name=$REPO -f query='
            query($name: String!, $owner: String!) {
              repository(owner: $owner, name: $name) {
                issues(states:OPEN){
                  totalCount
                }
              }
            }
          ' --jq '.data.repository.issues.totalCount')"

          echo 'NUM_OPEN_ISSUES='$numOpenIssues >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
      - run: |
          gh issue create --title "Issue report" --body "$NUM_OPEN_ISSUES issues remaining" --repo $GITHUB_REPOSITORY
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Workflow commandsWorkflow commands for GitHub ActionsYou can use workflow commands when running shell commands in a workflow or in an action's code.Tool navigationBashPowerShellIn this articleAbout workflow commandsUsing workflow commands to access toolkit functionsSetting a debug messageSetting a notice messageSetting a warning messageSetting an error messageGrouping log linesMasking a value in a logStopping and starting workflow commandsSending values to the pre and post actionsEnvironment filesSetting an environment variableSetting an output parameterAdding a job summaryAdding a system pathAbout workflow commands
Actions can communicate with the runner machine to set environment variables, output values used by other actions, add debug messages to the output logs, and other tasks.
Most workflow commands use the echo command in a specific format, while others are invoked by writing to a file. For more information, see Environment files.
Example of a workflow command

Bashecho "::workflow-command parameter1={data},parameter2={data}::{command value}"
echo "::workflow-command parameter1={data},parameter2={data}::{command value}"



PowerShellWrite-Output "::workflow-command parameter1={data},parameter2={data}::{command value}"
Write-Output "::workflow-command parameter1={data},parameter2={data}::{command value}"


Note

Workflow command and parameter names are case insensitive.

Warning

If you are using Command Prompt, omit double quote characters (") when using workflow commands.

Using workflow commands to access toolkit functions
The actions/toolkit includes a number of functions that can be executed as workflow commands. Use the :: syntax to run the workflow commands within your YAML file; these commands are then sent to the runner over stdout.
For example, instead of using code to create an error annotation, as below:
JavaScriptcore.error('Missing semicolon', {file: 'app.js', startLine: 1})
core.error('Missing semicolon', {file: 'app.js', startLine: 1})

Example: Creating an annotation for an error
You can use the error command in your workflow to create the same error annotation:

YAML      - name: Create annotation for build error
        run: echo "::error file=app.js,line=1::Missing semicolon"
      - name: Create annotation for build error
        run: echo "::error file=app.js,line=1::Missing semicolon"



YAML      - name: Create annotation for build error
        run: Write-Output "::error file=app.js,line=1::Missing semicolon"
      - name: Create annotation for build error
        run: Write-Output "::error file=app.js,line=1::Missing semicolon"


The following table shows which toolkit functions are available within a workflow:













































































Toolkit functionEquivalent workflow commandcore.addPathAccessible using environment file GITHUB_PATHcore.debugdebugcore.noticenoticecore.errorerrorcore.endGroupendgroupcore.exportVariableAccessible using environment file GITHUB_ENVcore.getInputAccessible using environment variable INPUT_{NAME}core.getStateAccessible using environment variable STATE_{NAME}core.isDebugAccessible using environment variable RUNNER_DEBUGcore.summaryAccessible using environment file GITHUB_STEP_SUMMARYcore.saveStateAccessible using environment file GITHUB_STATEcore.setCommandEchoechocore.setFailedUsed as a shortcut for ::error and exit 1core.setOutputAccessible using environment file GITHUB_OUTPUTcore.setSecretadd-maskcore.startGroupgroupcore.warningwarning
Setting a debug message
Prints a debug message to the log. You must create a secret named ACTIONS_STEP_DEBUG with the value true to see the debug messages set by this command in the log. For more information, see Enabling debug logging.
Text::debug::{message}
::debug::{message}

Example: Setting a debug message

Bashecho "::debug::Set the Octocat variable"
echo "::debug::Set the Octocat variable"



PowerShellWrite-Output "::debug::Set the Octocat variable"
Write-Output "::debug::Set the Octocat variable"


Setting a notice message
Creates a notice message and prints the message to the log. This message will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file.
Text::notice file={name},line={line},endLine={endLine},title={title}::{message}
::notice file={name},line={line},endLine={endLine},title={title}::{message}
















































ParameterValueRequiredDefaulttitleCustom titleNoNonefileFilenameNo.githubcolColumn number, starting at 1NoNoneendColumnEnd column numberNoNonelineLine number, starting at 1No1endLineEnd line numberNo1
Example: Setting a notice message

Bashecho "::notice file=app.js,line=1,col=5,endColumn=7::Missing semicolon"
echo "::notice file=app.js,line=1,col=5,endColumn=7::Missing semicolon"



PowerShellWrite-Output "::notice file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"
Write-Output "::notice file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"


Setting a warning message
Creates a warning message and prints the message to the log. This message will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file.
Text::warning file={name},line={line},endLine={endLine},title={title}::{message}
::warning file={name},line={line},endLine={endLine},title={title}::{message}
















































ParameterValueRequiredDefaulttitleCustom titleNoNonefileFilenameNo.githubcolColumn number, starting at 1NoNoneendColumnEnd column numberNoNonelineLine number, starting at 1No1endLineEnd line numberNo1
Example: Setting a warning message

Bashecho "::warning file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"
echo "::warning file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"



PowerShellWrite-Output "::warning file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"
Write-Output "::warning file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"


Setting an error message
Creates an error message and prints the message to the log. This message will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file.
Text::error file={name},line={line},endLine={endLine},title={title}::{message}
::error file={name},line={line},endLine={endLine},title={title}::{message}
















































ParameterValueRequiredDefaulttitleCustom titleNoNonefileFilenameNo.githubcolColumn number, starting at 1NoNoneendColumnEnd column numberNoNonelineLine number, starting at 1No1endLineEnd line numberNo1
Example: Setting an error message

Bashecho "::error file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"
echo "::error file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"



PowerShellWrite-Output "::error file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"
Write-Output "::error file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon"


Grouping log lines
Creates an expandable group in the log. To create a group, use the group command and specify a title. Anything you print to the log between the group and endgroup commands is nested inside an expandable entry in the log.
Text::group::{title}
::endgroup::
::group::{title}
::endgroup::

Example: Grouping log lines

YAMLjobs:
  bash-example:
    runs-on: ubuntu-latest
    steps:
      - name: Group of log lines
        run: |
            echo "::group::My title"
            echo "Inside group"
            echo "::endgroup::"
jobs:
  bash-example:
    runs-on: ubuntu-latest
    steps:
      - name: Group of log lines
        run: |
            echo "::group::My title"
            echo "Inside group"
            echo "::endgroup::"



YAMLjobs:
  powershell-example:
    runs-on: windows-latest
    steps:
      - name: Group of log lines
        run: |
            Write-Output "::group::My title"
            Write-Output "Inside group"
            Write-Output "::endgroup::"
jobs:
  powershell-example:
    runs-on: windows-latest
    steps:
      - name: Group of log lines
        run: |
            Write-Output "::group::My title"
            Write-Output "Inside group"
            Write-Output "::endgroup::"



Masking a value in a log
Text::add-mask::{value}
::add-mask::{value}

Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the * character. You can use an environment variable or string for the mask's value. When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output.
Example: Masking a string
When you print "Mona The Octocat" in the log, you'll see "***".

Bashecho "::add-mask::Mona The Octocat"
echo "::add-mask::Mona The Octocat"



PowerShellWrite-Output "::add-mask::Mona The Octocat"
Write-Output "::add-mask::Mona The Octocat"


Warning

Make sure you register the secret with 'add-mask' before outputting it in the build logs or using it in any other workflow commands.

Example: Masking an environment variable
When you print the variable MY_NAME or the value "Mona The Octocat" in the log, you'll see "***" instead of "Mona The Octocat".

YAMLjobs:
  bash-example:
    runs-on: ubuntu-latest
    env:
      MY_NAME: "Mona The Octocat"
    steps:
      - name: bash-version
        run: echo "::add-mask::$MY_NAME"
jobs:
  bash-example:
    runs-on: ubuntu-latest
    env:
      MY_NAME: "Mona The Octocat"
    steps:
      - name: bash-version
        run: echo "::add-mask::$MY_NAME"



YAMLjobs:
  powershell-example:
    runs-on: windows-latest
    env:
      MY_NAME: "Mona The Octocat"
    steps:
      - name: powershell-version
        run: Write-Output "::add-mask::$env:MY_NAME"
jobs:
  powershell-example:
    runs-on: windows-latest
    env:
      MY_NAME: "Mona The Octocat"
    steps:
      - name: powershell-version
        run: Write-Output "::add-mask::$env:MY_NAME"


Example: Masking a generated output within a single job
If you do not need to pass your secret from one job to another job, you can:

Generate the secret (without outputting it).
Mask it with add-mask.
Use GITHUB_OUTPUT to make the secret available to other steps within the job.


YAMLon: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        run: |
          the_secret=$((RANDOM))
          echo "::add-mask::$the_secret"
          echo "secret-number=$the_secret" >> "$GITHUB_OUTPUT"
      - name: Use that secret output (protected by a mask)
        run: |
          echo "the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}"
on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        run: |
          the_secret=$((RANDOM))
          echo "::add-mask::$the_secret"
          echo "secret-number=$the_secret" >> "$GITHUB_OUTPUT"
      - name: Use that secret output (protected by a mask)
        run: |
          echo "the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}"



YAMLon: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        shell: pwsh
        run: |
          Set-Variable -Name TheSecret -Value (Get-Random)
          Write-Output "::add-mask::$TheSecret"
          "secret-number=$TheSecret" >> $env:GITHUB_OUTPUT
      - name: Use that secret output (protected by a mask)
        shell: pwsh
        run: |
          Write-Output "the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}"
on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        shell: pwsh
        run: |
          Set-Variable -Name TheSecret -Value (Get-Random)
          Write-Output "::add-mask::$TheSecret"
          "secret-number=$TheSecret" >> $env:GITHUB_OUTPUT
      - name: Use that secret output (protected by a mask)
        shell: pwsh
        run: |
          Write-Output "the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}"


Example: Masking and passing a secret between jobs or workflows
If you want to pass a masked secret between jobs or workflows, you should store the secret in a store and then retrieve it in the subsequent job or workflow.
Setup

Set up a secret store to store the secret that you will generate during your workflow. For example, Vault.
Generate a key for reading and writing to that secret store. Store the key as a repository secret. In the following example workflow, the secret name is SECRET_STORE_CREDENTIALS. For more information, see Using secrets in GitHub Actions.

Workflow
Note

This workflow uses an imaginary secret store, secret-store, which has imaginary commands store-secret and retrieve-secret. some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29 is an imaginary action that installs the secret-store application and configures it to connect to an instance with credentials.


YAMLon: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    outputs:
      handle: ${{ steps.generate-secret.outputs.handle }}
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      id: generate-secret
      shell: bash
      run: |
        GENERATED_SECRET=$((RANDOM))
        echo "::add-mask::$GENERATED_SECRET"
        SECRET_HANDLE=$(secret-store store-secret "$GENERATED_SECRET")
        echo "handle=$SECRET_HANDLE" >> "$GITHUB_OUTPUT"
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: bash
      run: |
        SECRET_HANDLE="${{ needs.secret-generator.outputs.handle }}"
        RETRIEVED_SECRET=$(secret-store retrieve-secret "$SECRET_HANDLE")
        echo "::add-mask::$RETRIEVED_SECRET"
        echo "We retrieved our masked secret: $RETRIEVED_SECRET"
on: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    outputs:
      handle: ${{ steps.generate-secret.outputs.handle }}
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      id: generate-secret
      shell: bash
      run: |
        GENERATED_SECRET=$((RANDOM))
        echo "::add-mask::$GENERATED_SECRET"
        SECRET_HANDLE=$(secret-store store-secret "$GENERATED_SECRET")
        echo "handle=$SECRET_HANDLE" >> "$GITHUB_OUTPUT"
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: bash
      run: |
        SECRET_HANDLE="${{ needs.secret-generator.outputs.handle }}"
        RETRIEVED_SECRET=$(secret-store retrieve-secret "$SECRET_HANDLE")
        echo "::add-mask::$RETRIEVED_SECRET"
        echo "We retrieved our masked secret: $RETRIEVED_SECRET"



YAMLon: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      shell: pwsh
      run: |
        Set-Variable -Name Generated_Secret -Value (Get-Random)
        Write-Output "::add-mask::$Generated_Secret"
        Set-Variable -Name Secret_Handle -Value (Store-Secret "$Generated_Secret")
        "handle=$Secret_Handle" >> $env:GITHUB_OUTPUT
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: pwsh
      run: |
        Set-Variable -Name Secret_Handle -Value "${{ needs.secret-generator.outputs.handle }}"
        Set-Variable -Name Retrieved_Secret -Value (Retrieve-Secret "$Secret_Handle")
        echo "::add-mask::$Retrieved_Secret"
        echo "We retrieved our masked secret: $Retrieved_Secret"
on: push

jobs:
  secret-generator:
    runs-on: ubuntu-latest
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: generate secret
      shell: pwsh
      run: |
        Set-Variable -Name Generated_Secret -Value (Get-Random)
        Write-Output "::add-mask::$Generated_Secret"
        Set-Variable -Name Secret_Handle -Value (Store-Secret "$Generated_Secret")
        "handle=$Secret_Handle" >> $env:GITHUB_OUTPUT
  secret-consumer:
    runs-on: macos-latest
    needs: secret-generator
    steps:
    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29
      with:
        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}
        instance: ${{ secrets.SECRET_STORE_INSTANCE }}
    - name: use secret
      shell: pwsh
      run: |
        Set-Variable -Name Secret_Handle -Value "${{ needs.secret-generator.outputs.handle }}"
        Set-Variable -Name Retrieved_Secret -Value (Retrieve-Secret "$Secret_Handle")
        echo "::add-mask::$Retrieved_Secret"
        echo "We retrieved our masked secret: $Retrieved_Secret"


Stopping and starting workflow commands
Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command. For example, you could stop logging to output an entire script that has comments.
Text::stop-commands::{endtoken}
::stop-commands::{endtoken}

To stop the processing of workflow commands, pass a unique token to stop-commands. To resume processing workflow commands, pass the same token that you used to stop workflow commands.
Warning

Make sure the token you're using is randomly generated and unique for each run.

Text::{endtoken}::
::{endtoken}::

Example: Stopping and starting workflow commands

YAMLjobs:
  workflow-command-job:
    runs-on: ubuntu-latest
    steps:
      - name: Disable workflow commands
        run: |
          echo '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          stopMarker=$(uuidgen)
          echo "::stop-commands::$stopMarker"
          echo '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          echo "::$stopMarker::"
          echo '::warning:: This is a warning again, because stop-commands has been turned off.'
jobs:
  workflow-command-job:
    runs-on: ubuntu-latest
    steps:
      - name: Disable workflow commands
        run: |
          echo '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          stopMarker=$(uuidgen)
          echo "::stop-commands::$stopMarker"
          echo '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          echo "::$stopMarker::"
          echo '::warning:: This is a warning again, because stop-commands has been turned off.'



YAMLjobs:
  workflow-command-job:
    runs-on: windows-latest
    steps:
      - name: Disable workflow commands
        run: |
          Write-Output '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          $stopMarker = New-Guid
          Write-Output "::stop-commands::$stopMarker"
          Write-Output '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          Write-Output "::$stopMarker::"
          Write-Output '::warning:: This is a warning again, because stop-commands has been turned off.'
jobs:
  workflow-command-job:
    runs-on: windows-latest
    steps:
      - name: Disable workflow commands
        run: |
          Write-Output '::warning:: This is a warning message, to demonstrate that commands are being processed.'
          $stopMarker = New-Guid
          Write-Output "::stop-commands::$stopMarker"
          Write-Output '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'
          Write-Output "::$stopMarker::"
          Write-Output '::warning:: This is a warning again, because stop-commands has been turned off.'


Sending values to the pre and post actions
You can create environment variables for sharing with your workflow's pre: or post: actions by writing to the file located at GITHUB_STATE. For example, you can create a file with the pre: action, pass the file location to the main: action, and then use the post: action to delete the file. Alternatively, you could create a file with the main: action, pass the file location to the post: action, and also use the post: action to delete the file.
If you have multiple pre: or post: actions, you can only access the saved value in the action where it was written to GITHUB_STATE. For more information on the post: action, see Metadata syntax for GitHub Actions.
The GITHUB_STATE file is only available within an action. The saved value is stored as an environment value with the STATE_ prefix.
This example uses JavaScript to write to the GITHUB_STATE file. The resulting environment variable is named STATE_processID with the value of 12345:
JavaScriptimport * as fs from 'fs'
import * as os from 'os'

fs.appendFileSync(process.env.GITHUB_STATE, `processID=12345${os.EOL}`, {
  encoding: 'utf8'
})
import * as fs from 'fs'
import * as os from 'os'

fs.appendFileSync(process.env.GITHUB_STATE, `processID=12345${os.EOL}`, {
  encoding: 'utf8'
})

The STATE_processID variable is then exclusively available to the cleanup script running under the main action. This example runs in main and uses JavaScript to display the value assigned to the STATE_processID environment variable:
JavaScriptconsole.log("The running PID from the main action is: " + process.env.STATE_processID);
console.log("The running PID from the main action is: " + process.env.STATE_processID);

Environment files
During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. See Store information in variables. You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.
To use environment variables in a GitHub Action, you create or modify .env files using specific GitHub Actions commands.
Here's how:
YAMLname: Example Workflow for Environment Files

on: push

jobs:
  set_and_use_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo "MY_ENV_VAR=myValue" >> $GITHUB_ENV

      - name: Use environment variable
        run: |
          echo "The value of MY_ENV_VAR is $MY_ENV_VAR"

name: Example Workflow for Environment Files

on: push

jobs:
  set_and_use_env_vars:
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variable
        run: echo "MY_ENV_VAR=myValue" >> $GITHUB_ENV

      - name: Use environment variable
        run: |
          echo "The value of MY_ENV_VAR is $MY_ENV_VAR"


Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names:
YAMLsteps:
  - name: Store build timestamp
    run: echo "BUILD_TIME=$(date +'%T')" >> $GITHUB_ENV

  - name: Deploy using stored timestamp
    run: echo "Deploying at $BUILD_TIME"
steps:
  - name: Store build timestamp
    run: echo "BUILD_TIME=$(date +'%T')" >> $GITHUB_ENV

  - name: Deploy using stored timestamp
    run: echo "Deploying at $BUILD_TIME"


Note

PowerShell versions 5.1 and below (shell: powershell) do not use UTF-8 by default, so you must specify the UTF-8 encoding. For example:
YAMLjobs:
  legacy-powershell-example:
    runs-on: windows-latest
    steps:
      - shell: powershell
        run: |
          "mypath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
jobs:
  legacy-powershell-example:
    runs-on: windows-latest
    steps:
      - shell: powershell
        run: |
          "mypath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

PowerShell Core versions 6 and higher (shell: pwsh) use UTF-8 by default. For example:
YAMLjobs:
  powershell-core-example:
    runs-on: windows-latest
    steps:
      - shell: pwsh
        run: |
          "mypath" >> $env:GITHUB_PATH
jobs:
  powershell-core-example:
    runs-on: windows-latest
    steps:
      - shell: pwsh
        run: |
          "mypath" >> $env:GITHUB_PATH



Setting an environment variable
Note

To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using.


Bashecho "{environment_variable_name}={value}" >> "$GITHUB_ENV"
echo "{environment_variable_name}={value}" >> "$GITHUB_ENV"





Using PowerShell version 6 and higher:
PowerShell"{environment_variable_name}={value}" >> $env:GITHUB_ENV
"{environment_variable_name}={value}" >> $env:GITHUB_ENV



Using PowerShell version 5.1 and below:
PowerShell"{environment_variable_name}={value}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
"{environment_variable_name}={value}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append




You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to the GITHUB_ENV environment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access.
You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_*. Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, see Store information in variables.
Note

Due to security restrictions, GITHUB_ENV cannot be used to set the NODE_OPTIONS environment variable.

Example of writing an environment variable to GITHUB_ENV

YAMLsteps:
  - name: Set the value
    id: step_one
    run: |
      echo "action_state=yellow" >> "$GITHUB_ENV"
  - name: Use the value
    id: step_two
    run: |
      printf '%s\n' "$action_state" # This will output 'yellow'
steps:
  - name: Set the value
    id: step_one
    run: |
      echo "action_state=yellow" >> "$GITHUB_ENV"
  - name: Use the value
    id: step_two
    run: |
      printf '%s\n' "$action_state" # This will output 'yellow'



YAMLsteps:
  - name: Set the value
    id: step_one
    run: |
      "action_state=yellow" >> $env:GITHUB_ENV
  - name: Use the value
    id: step_two
    run: |
      Write-Output "$env:action_state" # This will output 'yellow'
steps:
  - name: Set the value
    id: step_one
    run: |
      "action_state=yellow" >> $env:GITHUB_ENV
  - name: Use the value
    id: step_two
    run: |
      Write-Output "$env:action_state" # This will output 'yellow'


Multiline strings
For multiline strings, you may use a delimiter with the following syntax.
Text{name}<<{delimiter}
{value}
{delimiter}
{name}<<{delimiter}
{value}
{delimiter}

Warning

Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead.

Example of a multiline string
This example uses EOF as the delimiter, and sets the JSON_RESPONSE environment variable to the value of the curl response.

YAMLsteps:
  - name: Set the value in bash
    id: step_one
    run: |
      {
        echo 'JSON_RESPONSE<<EOF'
        curl https://example.com
        echo EOF
      } >> "$GITHUB_ENV"
steps:
  - name: Set the value in bash
    id: step_one
    run: |
      {
        echo 'JSON_RESPONSE<<EOF'
        curl https://example.com
        echo EOF
      } >> "$GITHUB_ENV"



YAMLsteps:
  - name: Set the value in pwsh
    id: step_one
    run: |
      $EOF = (New-Guid).Guid
      "JSON_RESPONSE<<$EOF" >> $env:GITHUB_ENV
      (Invoke-WebRequest -Uri "https://example.com").Content >> $env:GITHUB_ENV
      "$EOF" >> $env:GITHUB_ENV
    shell: pwsh
steps:
  - name: Set the value in pwsh
    id: step_one
    run: |
      $EOF = (New-Guid).Guid
      "JSON_RESPONSE<<$EOF" >> $env:GITHUB_ENV
      (Invoke-WebRequest -Uri "https://example.com").Content >> $env:GITHUB_ENV
      "$EOF" >> $env:GITHUB_ENV
    shell: pwsh


Setting an output parameter
Sets a step's output parameter. Note that the step will need an id to be defined to later retrieve the output value. You can set multi-line output values with the same technique used in the Multiline strings section to define multi-line environment variables.

Bashecho "{name}={value}" >> "$GITHUB_OUTPUT"
echo "{name}={value}" >> "$GITHUB_OUTPUT"



PowerShell"{name}=value" >> $env:GITHUB_OUTPUT
"{name}=value" >> $env:GITHUB_OUTPUT


Example of setting an output parameter

This example demonstrates how to set the SELECTED_COLOR output parameter and later retrieve it:
YAML      - name: Set color
        id: color-selector
        run: echo "SELECTED_COLOR=green" >> "$GITHUB_OUTPUT"
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: echo "The selected color is $SELECTED_COLOR"
      - name: Set color
        id: color-selector
        run: echo "SELECTED_COLOR=green" >> "$GITHUB_OUTPUT"
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: echo "The selected color is $SELECTED_COLOR"



This example demonstrates how to set the SELECTED_COLOR output parameter and later retrieve it:
YAML      - name: Set color
        id: color-selector
        run: |
            "SELECTED_COLOR=green" >> $env:GITHUB_OUTPUT
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: Write-Output "The selected color is $env:SELECTED_COLOR"
      - name: Set color
        id: color-selector
        run: |
            "SELECTED_COLOR=green" >> $env:GITHUB_OUTPUT
      - name: Get color
        env:
          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}
        run: Write-Output "The selected color is $env:SELECTED_COLOR"


Adding a job summary

Bashecho "{markdown content}" >> $GITHUB_STEP_SUMMARY
echo "{markdown content}" >> $GITHUB_STEP_SUMMARY



PowerShell"{markdown content}" >> $env:GITHUB_STEP_SUMMARY
"{markdown content}" >> $env:GITHUB_STEP_SUMMARY


You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures.
Job summaries support GitHub flavored Markdown, and you can add your Markdown content for a step to the GITHUB_STEP_SUMMARY environment file. GITHUB_STEP_SUMMARY is unique for each step in a job. For more information about the per-step file that GITHUB_STEP_SUMMARY references, see Environment files.
When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time.
Example of adding a job summary

Bashecho "### Hello world! :rocket:" >> $GITHUB_STEP_SUMMARY
echo "### Hello world! :rocket:" >> $GITHUB_STEP_SUMMARY



PowerShell"### Hello world! :rocket:" >> $env:GITHUB_STEP_SUMMARY
"### Hello world! :rocket:" >> $env:GITHUB_STEP_SUMMARY



Multiline Markdown content
For multiline Markdown content, you can use >> to continuously append content for the current step. With every append operation, a newline character is automatically added.
Example of multiline Markdown content

- name: Generate list using Markdown
  run: |
    echo "This is the lead in sentence for the list" >> $GITHUB_STEP_SUMMARY
    echo "" >> $GITHUB_STEP_SUMMARY # this is a blank line
    echo "- Lets add a bullet point" >> $GITHUB_STEP_SUMMARY
    echo "- Lets add a second bullet point" >> $GITHUB_STEP_SUMMARY
    echo "- How about a third one?" >> $GITHUB_STEP_SUMMARY



- name: Generate list using Markdown
  run: |
    "This is the lead in sentence for the list" >> $env:GITHUB_STEP_SUMMARY
    "" >> $env:GITHUB_STEP_SUMMARY # this is a blank line
    "- Lets add a bullet point" >> $env:GITHUB_STEP_SUMMARY
    "- Lets add a second bullet point" >> $env:GITHUB_STEP_SUMMARY
    "- How about a third one?" >> $env:GITHUB_STEP_SUMMARY


Overwriting job summaries
To clear all content for the current step, you can use > to overwrite any previously added content in Bash, or remove -Append in PowerShell
Example of overwriting job summaries

- name: Overwrite Markdown
  run: |
    echo "Adding some Markdown content" >> $GITHUB_STEP_SUMMARY
    echo "There was an error, we need to clear the previous Markdown with some new content." > $GITHUB_STEP_SUMMARY



- name: Overwrite Markdown
  run: |
    "Adding some Markdown content" >> $env:GITHUB_STEP_SUMMARY
    "There was an error, we need to clear the previous Markdown with some new content." >> $env:GITHUB_STEP_SUMMARY


Removing job summaries
To completely remove a summary for the current step, the file that GITHUB_STEP_SUMMARY references can be deleted.
Example of removing job summaries

- name: Delete all summary content
  run: |
    echo "Adding Markdown content that we want to remove before the step ends" >> $GITHUB_STEP_SUMMARY
    rm $GITHUB_STEP_SUMMARY



- name: Delete all summary content
  run: |
    "Adding Markdown content that we want to remove before the step ends" >> $env:GITHUB_STEP_SUMMARY
    Remove-Item $env:GITHUB_STEP_SUMMARY


After a step has completed, job summaries are uploaded and subsequent steps cannot modify previously uploaded Markdown content. Summaries automatically mask any secrets that might have been added accidentally. If a job summary contains sensitive information that must be deleted, you can delete the entire workflow run to remove all its job summaries. For more information see Deleting a workflow run.
Step isolation and limits
Job summaries are isolated between steps and each step is restricted to a maximum size of 1MiB. Isolation is enforced between steps so that potentially malformed Markdown from a single step cannot break Markdown rendering for subsequent steps. If more than 1MiB of content is added for a step, then the upload for the step will fail and an error annotation will be created. Upload failures for job summaries do not affect the overall status of a step or a job. A maximum of 20 job summaries from steps are displayed per job.
Adding a system path
Prepends a directory to the system PATH variable and automatically makes it available to all subsequent actions in the current job; the currently running action cannot access the updated path variable. To see the currently defined paths for your job, you can use echo "$PATH" in a step or an action.
Example of adding a system path

This example demonstrates how to add the user $HOME/.local/bin directory to PATH:
Bashecho "$HOME/.local/bin" >> "$GITHUB_PATH"
echo "$HOME/.local/bin" >> "$GITHUB_PATH"



This example demonstrates how to add the user $env:HOMEPATH/.local/bin directory to PATH:
PowerShell"$env:HOMEPATH/.local/bin" | Out-File -FilePath "$env:GITHUB_PATH" -Append
"$env:HOMEPATH/.local/bin" | Out-File -FilePath "$env:GITHUB_PATH" -Append\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Add scriptsAdding scripts to your workflowYou can use GitHub Actions workflows to run scripts.You can use a GitHub Actions workflow to run scripts and shell commands, which are then executed on the assigned runner. This example demonstrates how to use the run keyword to execute the command npm install -g bats on the runner.
jobs:
  example-job:
    runs-on: ubuntu-latest
    steps:
      - run: npm install -g bats

To use a workflow to run a script stored in your repository you must first check out the repository to the runner. Having done this, you can use the run keyword to run the script on the runner. The following example runs two scripts, each in a separate job step. The location of the scripts on the runner is specified by setting a default working directory for run commands. For more information, see Setting a default shell and working directory.
jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./scripts
    steps:
      - name: Check out the repository to the runner
        uses: actions/checkout@v4  
      - name: Run a script
        run: ./my-script.sh
      - name: Run another script
        run: ./my-other-script.sh

Any scripts that you want a workflow job to run must be executable. You can do this either within the workflow by passing the script as an argument to the interpreter that will run the script - for example, run: bash script.sh - or by making the file itself executable. You can give the file the execute permission by using the command git update-index --chmod=+x PATH/TO/YOUR/script.sh locally, then committing and pushing the file to the repository. Alternatively, for workflows that are run on Linux and Mac runners, you can add a command to give the file the execute permission in the workflow job, prior to running the script:
jobs:
  example-job:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./scripts
    steps:
      - name: Check out the repository to the runner
        uses: actions/checkout@v4  
      - name: Make the script files executable
        run: chmod +x my-script.sh my-other-script.sh
      - name: Run the scripts
        run: |
          ./my-script.sh
          ./my-other-script.sh

For more information about the run keyword, see Workflow syntax for GitHub Actions.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Permissions for `GITHUB_TOKEN`Controlling permissions for GITHUB_TOKENModify the default permissions granted to GITHUB_TOKEN.In this articleOverviewDefining access for the GITHUB_TOKEN permissionsSetting the GITHUB_TOKEN permissions for all jobs in a workflowSetting the GITHUB_TOKEN permissions for a specific jobOverview
You can use permissions to modify the default permissions granted to the GITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication.
You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions.
For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write, or none. write includes read. If you specify the access for any of these permissions, all of those that are not specified are set to none.
Available permissions and details of what each allows an action to do:





























































































PermissionAllows an action using GITHUB_TOKEN toactionsWork with GitHub Actions. For example, actions: write permits an action to cancel a workflow run. For more information, see Permissions required for GitHub Apps.attestationsWork with artifact attestations. For example, attestations: write permits an action to generate an artifact attestation for a build. For more information, see Using artifact attestations to establish provenance for buildschecksWork with check runs and check suites. For example, checks: write permits an action to create a check run. For more information, see Permissions required for GitHub Apps.contentsWork with the contents of the repository. For example, contents: read permits an action to list the commits, and contents: write allows the action to create a release. For more information, see Permissions required for GitHub Apps.deploymentsWork with deployments. For example, deployments: write permits an action to create a new deployment. For more information, see Permissions required for GitHub Apps.discussionsWork with GitHub Discussions. For example, discussions: write permits an action to close or delete a discussion. For more information, see Using the GraphQL API for Discussions.id-tokenFetch an OpenID Connect (OIDC) token. This requires id-token: write. For more information, see About security hardening with OpenID ConnectissuesWork with issues. For example, issues: write permits an action to add a comment to an issue. For more information, see Permissions required for GitHub Apps.modelsGenerate AI inference responses with GitHub Models. For example, models: read permits an action to use the GitHub Models inference API. See Prototyping with AI models.packagesWork with GitHub Packages. For example, packages: write permits an action to upload and publish packages on GitHub Packages. For more information, see About permissions for GitHub Packages.pagesWork with GitHub Pages. For example, pages: write permits an action to request a GitHub Pages build. For more information, see Permissions required for GitHub Apps.pull-requestsWork with pull requests. For example, pull-requests: write permits an action to add a label to a pull request. For more information, see Permissions required for GitHub Apps.security-eventsWork with GitHub code scanning and Dependabot alerts. For example, security-events: read permits an action to list the Dependabot alerts for the repository, and security-events: write allows an action to update the status of a code scanning alert. For more information, see Repository permissions for 'Code scanning alerts' and Repository permissions for 'Dependabot alerts' in "Permissions required for GitHub Apps."statusesWork with commit statuses. For example, statuses:read permits an action to list the commit statuses for a given reference. For more information, see Permissions required for GitHub Apps.
Defining access for the GITHUB_TOKEN permissions
You can define the access that the GITHUB_TOKEN will permit by specifying read, write, or none as the value of the available permissions within the permissions key.
permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none

If you specify the access for any of these permissions, all of those that are not specified are set to none.
You can use the following syntax to define one of read-all or write-all access for all of the available permissions:
permissions: read-all

permissions: write-all

You can use the following syntax to disable permissions for all of the available permissions:
permissions: {}

Changing the permissions in a forked repository
You can use the permissions key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.
Setting the GITHUB_TOKEN permissions for all jobs in a workflow
You can specify permissions at the top level of a workflow, so that the setting applies to all jobs in the workflow.
Example: Setting the GITHUB_TOKEN permissions for an entire workflow
This example shows permissions being set for the GITHUB_TOKEN that will apply to all jobs in the workflow. All permissions are granted read access.
name: "My workflow"

on: [ push ]

permissions: read-all

jobs:
  ...

Setting the GITHUB_TOKEN permissions for a specific job
For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication.
By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions.
Example: Setting the GITHUB_TOKEN permissions for one job in a workflow
This example shows permissions being set for the GITHUB_TOKEN that will only apply to the job named stale. Write access is granted for the issues and pull-requests permissions. All other permissions will have no access.
jobs:
  stale:
    runs-on: ubuntu-latest

    permissions:
      issues: write
      pull-requests: write

    steps:
      - uses: actions/stale@v9\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/ExpressionsEvaluate expressions in workflows and actionsYou can evaluate expressions in workflows and actions.In this articleAbout expressionsLiteralsOperatorsFunctionsStatus check functionsObject filtersAbout expressions
You can use expressions to programmatically set environment variables in workflow files and access contexts. An expression can be any combination of literal values, references to a context, or functions. You can combine literals, context references, and functions using operators. For more information about contexts, see Accessing contextual information about workflow runs.
Expressions are commonly used with the conditional if keyword in a workflow file to determine whether a step should run. When an if conditional is true, the step will run.
You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string.
${{ <expression> }}
Note

The exception to this rule is when you are using expressions in an if clause, where, optionally, you can usually omit ${{ and }}. For more information about if conditionals, see Workflow syntax for GitHub Actions.

Warning

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.

Example setting an environment variable
env:
  MY_ENV_VAR: ${{ <expression> }}

Literals
As part of an expression, you can use boolean, null, number, or string data types.

























Data typeLiteral valuebooleantrue or falsenullnullnumberAny number format supported by JSON.stringYou don't need to enclose strings in ${{ and }}. However, if you do, you must use single quotes (') around the string. To use a literal single quote, escape the literal single quote using an additional single quote (''). Wrapping with double quotes (") will throw an error.
Note that in conditionals, falsy values (false, 0, -0, "", '', null) are coerced to false and truthy (true and other non-falsy values) are coerced to true.
Example of literals
env:
  myNull: ${{ null }}
  myBoolean: ${{ false }}
  myIntegerNumber: ${{ 711 }}
  myFloatNumber: ${{ -9.2 }}
  myHexNumber: ${{ 0xff }}
  myExponentialNumber: ${{ -2.99e-2 }}
  myString: Mona the Octocat
  myStringInBraces: ${{ 'It''s open source!' }}

Operators

























































OperatorDescription( )Logical grouping[ ]Index.Property de-reference!Not<Less than<=Less than or equal>Greater than>=Greater than or equal==Equal!=Not equal&&And||Or
Note


GitHub ignores case when comparing strings.
steps.<step_id>.outputs.<output_name> evaluates as a string. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. For more information, see Accessing contextual information about workflow runs.
For numerical comparison, the fromJSON() function can be used to convert a string to a number. For more information on the fromJSON() function, see fromJSON.


GitHub performs loose equality comparisons.


If the types do not match, GitHub coerces the type to a number. GitHub casts data types to a number using these conversions:





























TypeResultNull0Booleantrue returns 1  false returns 0StringParsed from any legal JSON number format, otherwise NaN.  Note: empty string returns 0.ArrayNaNObjectNaN


When NaN is one of the operands of any relational comparison (>, <, >=, <=), the result is always false. For more information, see the NaN Mozilla docs.


GitHub ignores case when comparing strings.


Objects and arrays are only considered equal when they are the same instance.


GitHub offers ternary operator like behaviour that you can use in expressions. By using a ternary operator in this way, you can dynamically set the value of an environment variable based on a condition, without having to write separate if-else blocks for each possible option.
Example
env:
  MY_ENV_VAR: ${{ github.ref == 'refs/heads/main' && 'value_for_main_branch' || 'value_for_other_branches' }}

In this example, we're using a ternary operator to set the value of the MY_ENV_VAR environment variable based on whether the GitHub reference is set to refs/heads/main or not. If it is, the variable is set to value_for_main_branch. Otherwise, it is set to value_for_other_branches.
It is important to note that the first value after the && must be truthy. Otherwise, the value after the || will always be returned.
Functions
GitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions:





























TypeResultNull''Boolean'true' or 'false'NumberDecimal format, exponential for large numbersArrayArrays are not converted to a stringObjectObjects are not converted to a string
contains
contains( search, item )
Returns true if search contains item. If search is an array, this function returns true if the item is an element in the array. If search is a string, this function returns true if the item is a substring of search. This function is not case sensitive. Casts values to a string.
Example using a string
contains('Hello world', 'llo') returns true.
Example using an object filter
contains(github.event.issue.labels.*.name, 'bug') returns true if the issue related to the event has a label "bug".
For more information, see Object filters.
Example matching an array of strings
Instead of writing github.event_name == "push" || github.event_name == "pull_request", you can use contains() with fromJSON() to check if an array of strings contains an item.
For example, contains(fromJSON('["push", "pull_request"]'), github.event_name) returns true if github.event_name is "push" or "pull_request".
startsWith
startsWith( searchString, searchValue )
Returns true when searchString starts with searchValue. This function is not case sensitive. Casts values to a string.
Example of startsWith
startsWith('Hello world', 'He') returns true.
endsWith
endsWith( searchString, searchValue )
Returns true if searchString ends with searchValue. This function is not case sensitive. Casts values to a string.
Example of endsWith
endsWith('Hello world', 'ld') returns true.
format
format( string, replaceValue0, replaceValue1, ..., replaceValueN)
Replaces values in the string, with the variable replaceValueN. Variables in the string are specified using the {N} syntax, where N is an integer. You must specify at least one replaceValue and string. There is no maximum for the number of variables (replaceValueN) you can use. Escape curly braces using double braces.
Example of format
format('Hello {0} {1} {2}', 'Mona', 'the', 'Octocat')

Returns 'Hello Mona the Octocat'.
Example escaping braces
format('{{Hello {0} {1} {2}!}}', 'Mona', 'the', 'Octocat')

Returns '{Hello Mona the Octocat!}'.
join
join( array, optionalSeparator )
The value for array can be an array or a string. All values in array are concatenated into a string. If you provide optionalSeparator, it is inserted between the concatenated values. Otherwise, the default separator , is used. Casts values to a string.
Example of join
join(github.event.issue.labels.*.name, ', ') may return 'bug, help wanted'
toJSON
toJSON(value)
Returns a pretty-print JSON representation of value. You can use this function to debug the information provided in contexts.
Example of toJSON
toJSON(job) might return { "status": "success" }
fromJSON
fromJSON(value)
Returns a JSON object or JSON data type for value. You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects.
Example returning a JSON object
This workflow sets a JSON matrix in one job, and passes it to the next job using an output and fromJSON.
YAMLname: build
on: push
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo "matrix={\"include\":[{\"project\":\"foo\",\"config\":\"Debug\"},{\"project\":\"bar\",\"config\":\"Release\"}]}" >> $GITHUB_OUTPUT
  job2:
    needs: job1
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}
    steps:
      - run: echo "Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}"
name: build
on: push
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: echo "matrix={\"include\":[{\"project\":\"foo\",\"config\":\"Debug\"},{\"project\":\"bar\",\"config\":\"Release\"}]}" >> $GITHUB_OUTPUT
  job2:
    needs: job1
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}
    steps:
      - run: echo "Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}"

Example returning a JSON data type
This workflow uses fromJSON to convert environment variables from a string to a Boolean or integer.
YAMLname: print
on: push
env:
  continue: true
  time: 3
jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - continue-on-error: ${{ fromJSON(env.continue) }}
        timeout-minutes: ${{ fromJSON(env.time) }}
        run: echo ...
name: print
on: push
env:
  continue: true
  time: 3
jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - continue-on-error: ${{ fromJSON(env.continue) }}
        timeout-minutes: ${{ fromJSON(env.time) }}
        run: echo ...

The workflow uses the fromJSON() function to convert the environment variable continue from a string to a boolean, allowing it to determine whether to continue-on-error or not. Similarly, it converts the time environment variable from a string to an integer, setting the timeout for the job in minutes.
hashFiles
hashFiles(path)
Returns a single hash for the set of files that matches the path pattern. You can provide a single path pattern or multiple path patterns separated by commas. The path is relative to the GITHUB_WORKSPACE directory and can only include files inside of the GITHUB_WORKSPACE. This function calculates an individual SHA-256 hash for each matched file, and then uses those hashes to calculate a final SHA-256 hash for the set of files. If the path pattern does not match any files, this returns an empty string. For more information about SHA-256, see SHA-2.
You can use pattern matching characters to match file names. Pattern matching for hashFiles follows glob pattern matching and is case-insensitive on Windows. For more information about supported pattern matching characters, see the Patterns section in the @actions/glob documentation.
Examples with a single pattern
Matches any package-lock.json file in the repository.
hashFiles('**/package-lock.json')
Matches all .js files in the src directory at root level, but ignores any subdirectories of src.
hashFiles('/src/*.js')
Matches all .rb files in the lib directory at root level, including any subdirectories of lib.
hashFiles('/lib/**/*.rb')
Examples with multiple patterns
Creates a hash for any package-lock.json and Gemfile.lock files in the repository.
hashFiles('**/package-lock.json', '**/Gemfile.lock')
Creates a hash for all .rb files in the lib directory at root level, including any subdirectories of lib, but excluding .rb files in the foo subdirectory.
hashFiles('/lib/**/*.rb', '!/lib/foo/*.rb')
Status check functions
You can use the following status check functions as expressions in if conditionals. A default status check of success() is applied unless you include one of these functions. For more information about if conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions.
success
Returns true when all previous steps have succeeded.
Example of success
steps:
  ...
  - name: The job has succeeded
    if: ${{ success() }}

always
Causes the step to always execute, and returns true, even when canceled. The always expression is best used at the step level or on tasks that you expect to run even when a job is canceled. For example, you can use always to send logs even when a job is canceled.
Warning

Avoid using always for any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative: if: ${{ !cancelled() }}

Example of always
if: ${{ always() }}

cancelled
Returns true if the workflow was canceled.
Example of cancelled
if: ${{ cancelled() }}

failure
Returns true when any previous step of a job fails. If you have a chain of dependent jobs, failure() returns true if any ancestor job fails.
Example of failure
steps:
  ...
  - name: The job has failed
    if: ${{ failure() }}

failure with conditions
You can include extra conditions for a step to run after a failure, but you must still include failure() to override the default status check of success() that is automatically applied to if conditions that don't contain a status check function.
Example of failure with conditions
steps:
  ...
  - name: Failing step
    id: demo
    run: exit 1
  - name: The demo step has failed
    if: ${{ failure() && steps.demo.conclusion == 'failure' }}

Object filters
You can use the * syntax to apply a filter and select matching items in a collection.
For example, consider an array of objects named fruits.
[
  { "name": "apple", "quantity": 1 },
  { "name": "orange", "quantity": 2 },
  { "name": "pear", "quantity": 1 }
]

The filter fruits.*.name returns the array [ "apple", "orange", "pear" ].
You may also use the * syntax on an object. For example, suppose you have an object named vegetables.

{
  "scallions":
  {
    "colors": ["green", "white", "red"],
    "ediblePortions": ["roots", "stalks"],
  },
  "beets":
  {
    "colors": ["purple", "red", "gold", "white", "pink"],
    "ediblePortions": ["roots", "stems", "leaves"],
  },
  "artichokes":
  {
    "colors": ["green", "purple", "red", "black"],
    "ediblePortions": ["hearts", "stems", "leaves"],
  },
}

The filter vegetables.*.ediblePortions could evaluate to:

[
  ["roots", "stalks"],
  ["hearts", "stems", "leaves"],
  ["roots", "stems", "leaves"],
]

Since objects don't preserve order, the order of the output cannot be guaranteed.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/VariablesStore information in variablesGitHub sets default variables for each GitHub Actions workflow run. You can also set custom variables for use in a single workflow or multiple workflows.In this articleAbout variablesDefining environment variables for a single workflowDefining configuration variables for multiple workflowsUsing contexts to access variable valuesDefault environment variablesDetecting the operating systemPassing values between steps and jobs in a workflowAbout variables
Variables provide a way to store and reuse non-sensitive configuration information. You can store any configuration data such as compiler flags, usernames, or server names as variables. Variables are interpolated on the runner machine that runs your workflow. Commands that run in actions or workflow steps can create, read, and modify variables.
You can set your own custom variables or use the default environment variables that GitHub sets automatically. For more information, see Default environment variables.
You can set a custom variable in two ways.

To define an environment variable for use in a single workflow, you can use the env key in the workflow file. For more information, see Defining environment variables for a single workflow.
To define a configuration variable across multiple workflows, you can define it at the organization, repository, or environment level. For more information, see Defining configuration variables for multiple workflows.

Warning

By default, variables render unmasked in your build outputs. If you need greater security for sensitive information, such as passwords, use secrets instead. For more information, see About secrets.

Defining environment variables for a single workflow
To set a custom environment variable for a single workflow, you can define it using the env key in the workflow file. The scope of a custom variable set by this method is limited to the element in which it is defined. You can define variables that are scoped for:

The entire workflow, by using env at the top level of the workflow file.
The contents of a job within a workflow, by using jobs.<job_id>.env.
A specific step within a job, by using jobs.<job_id>.steps[*].env.

YAMLname: Greeting on variable day

on:
  workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: "Say Hello Mona it's Monday"
        run: echo "$Greeting $First_Name. Today is $DAY_OF_WEEK!"
        env:
          First_Name: Mona
name: Greeting on variable day

on:
  workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: "Say Hello Mona it's Monday"
        run: echo "$Greeting $First_Name. Today is $DAY_OF_WEEK!"
        env:
          First_Name: Mona

You can access env variable values using runner environment variables or using contexts. The example above shows three custom variables being used as runner environment variables in an echo command: $DAY_OF_WEEK, $Greeting, and $First_Name. The values for these variables are set, and scoped, at the workflow, job, and step level respectively. The interpolation of these variables happens on the runner.
The commands in the run steps of a workflow, or a referenced action, are processed by the shell you are using on the runner. The instructions in the other parts of a workflow are processed by GitHub Actions and are not sent to the runner. You can use either runner environment variables or contexts in run steps, but in the parts of a workflow that are not sent to the runner you must use contexts to access variable values. For more information, see Using contexts to access variable values.
Because runner environment variable interpolation is done after a workflow job is sent to a runner machine, you must use the appropriate syntax for the shell that's used on the runner. In this example, the workflow specifies ubuntu-latest. By default, Linux runners use the bash shell, so you must use the syntax $NAME. By default, Windows runners use PowerShell, so you would use the syntax $env:NAME. For more information about shells, see Workflow syntax for GitHub Actions.
Naming conventions for environment variables
When you set an environment variable, you cannot use any of the default environment variable names. For a complete list of default environment variables, see Default environment variables below. If you attempt to override the value of one of these default variables, the assignment is ignored.
Note

You can list the entire set of environment variables that are available to a workflow step by using run: env in a step and then examining the output for the step.

Defining configuration variables for multiple workflows
You can create configuration variables for use across multiple workflows, and can define them at either the organization, repository, or environment level.
For example, you can use configuration variables to set default values for parameters passed to build tools at an organization level, but then allow repository owners to override these parameters on a case-by-case basis.
When you define configuration variables, they are automatically available in the vars context. For more information, see Using the vars context to access configuration variable values.
Configuration variable precedence
If a variable with the same name exists at multiple levels, the variable at the lowest level takes precedence. For example, if an organization-level variable has the same name as a repository-level variable, then the repository-level variable takes precedence. Similarly, if an organization, repository, and environment all have a variable with the same name, the environment-level variable takes precedence.
For reusable workflows, the variables from the caller workflow's repository are used. Variables from the repository that contains the called workflow are not made available to the caller workflow.
Naming conventions for configuration variables
The following rules apply to configuration variable names:

Can only contain alphanumeric characters ([a-z], [A-Z], [0-9]) or underscores (_). Spaces are not allowed.
Must not start with the GITHUB_ prefix.
Must not start with a number.
Are case insensitive.
Must be unique to the repository, organization, or enterprise where they are created.

Creating configuration variables for a repository
To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have admin access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Security" section of the sidebar, select  Secrets and variables, then click Actions.


Click the Variables tab.



Click New repository variable.


In the Name field, enter a name for your variable.


In the Value field, enter the value for your variable.


Click Add variable.


Creating configuration variables for an environment
To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have admin access. For more information on environments, see Managing environments for deployment.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click Environments.


Click on the environment that you want to add a variable to.


Under Environment variables, click Add variable.


In the Name field, enter a name for your variable.


In the Value field, enter the value for your variable.


Click Add variable.


Creating configuration variables for an organization
Note

Organization-level secrets and variables are not accessible by private repositories for GitHub Free. For more information about upgrading your GitHub subscription, see Upgrading your account's plan.

When creating a secret or variable in an organization, you can use a policy to limit access by repository. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories.
Organization owners can create secrets or variables at the organization level.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Security" section of the sidebar, select  Secrets and variables, then click Actions.


Click the Variables tab.



Click New organization variable.


In the Name field, enter a name for your variable.


In the Value field, enter the value for your variable.


From the Repository access dropdown list, choose an access policy.


Click Add variable.


Limits for configuration variables
Individual variables are limited to 48 KB in size.
You can store up to 1,000 organization variables, 500 variables per repository, and 100 variables per environment. The total combined size limit for organization and repository variables is 256 KB per workflow run.
A workflow created in a repository can access the following number of variables:

Up to 500 repository variables, if the total size of repository variables is less than 256 KB. If the total size of repository variables exceeds 256 KB, only the repository variables that fall below the limit will be available (as sorted alphabetically by variable name).
Up to 1,000 organization variables, if the total combined size of repository and organization variables is less than 256 KB. If the total combined size of organization and repository variables exceeds 256 KB, only the organization variables that fall below that limit will be available (after accounting for repository variables and as sorted alphabetically by variable name).
Up to 100 environment-level variables.

Note

Environment-level variables do not count toward the 256 KB total size limit. If you exceed the combined size limit for repository and organization variables and still need additional variables, you can use an environment and define additional variables in the environment.

Using contexts to access variable values
Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see Accessing contextual information about workflow runs. There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see Accessing contextual information about workflow runs.
You can access environment variable values using the env context and configuration variable values using the vars context.
Using the env context to access environment variable values
In addition to runner environment variables, GitHub Actions allows you to set and read env key values using contexts. Environment variables and contexts are intended for use at different points in the workflow.
The run steps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example, $NAME for the bash shell on a Linux runner, or $env:NAME for PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax ${{ CONTEXT.PROPERTY }}, to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner.
However, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, an if conditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in an if conditional statement to access the value of an variable.
YAMLname: Conditional env variable

on: workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: "Say Hello Mona it's Monday"
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        run: echo "$Greeting $First_Name. Today is $DAY_OF_WEEK!"
        env:
          First_Name: Mona
name: Conditional env variable

on: workflow_dispatch

env:
  DAY_OF_WEEK: Monday

jobs:
  greeting_job:
    runs-on: ubuntu-latest
    env:
      Greeting: Hello
    steps:
      - name: "Say Hello Mona it's Monday"
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        run: echo "$Greeting $First_Name. Today is $DAY_OF_WEEK!"
        env:
          First_Name: Mona

In this modification of the earlier example, we've introduced an if conditional. The workflow step is now only run if DAY_OF_WEEK is set to "Monday". We access this value from the if conditional statement by using the env context. The env context is not required for the variables referenced within the run command. They are referenced as runner environment variables and are interpolated after the job is received by the runner. We could, however, have chosen to interpolate those variables before sending the job to the runner, by using contexts. The resulting output would be the same.
run: echo "${{ env.Greeting }} ${{ env.First_Name }}. Today is ${{ env.DAY_OF_WEEK }}!"

Note

Contexts are usually denoted using the dollar sign and curly braces, as ${{ context.property }}. In an if conditional, the ${{ and }} are optional, but if you use them they must enclose the entire comparison statement, as shown above.

You will commonly use either the env or github context to access variable values in parts of the workflow that are processed before jobs are sent to runners.




















ContextUse caseExampleenvReference custom variables defined in the workflow.${{ env.MY_VARIABLE }}githubReference information about the workflow run and the event that triggered the run.${{ github.repository }}
Warning

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.

Using the vars context to access configuration variable values
Configuration variables can be accessed across the workflow using vars context. For more information, see Accessing contextual information about workflow runs.
If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string.
The following example shows using configuration variables with the vars context across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels.
YAMLon:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo "repository variable : $REPOSITORY_VAR"
        echo "organization variable : $ORGANIZATION_VAR"
        echo "overridden variable : $OVERRIDE_VAR"
        echo "variable from shell environment : $env_var"
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}
on:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo "repository variable : $REPOSITORY_VAR"
        echo "organization variable : $ORGANIZATION_VAR"
        echo "overridden variable : $OVERRIDE_VAR"
        echo "variable from shell environment : $env_var"
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}

Default environment variables
The default environment variables that GitHub sets are available to every step in a workflow.
Because default environment variables are set by GitHub and not defined in a workflow, they are not accessible through the env context. However, most of the default variables have a corresponding, and similarly named, context property. For example, the value of the GITHUB_REF variable can be read during workflow processing using the ${{ github.ref }} context property.
You can't overwrite the value of the default environment variables named GITHUB_* and RUNNER_*. Currently you can overwrite the value of the CI variable. However, it's not guaranteed that this will always be possible. For more information about setting environment variables, see Defining environment variables for a single workflow and Workflow commands for GitHub Actions.
We strongly recommend that actions use variables to access the filesystem rather than using hardcoded file paths. GitHub sets variables for actions to use in all runner environments.

























































































































































































VariableDescriptionCIAlways set to true.GITHUB_ACTIONThe name of the action currently running, or the id of a step. For example, for an action, __repo-owner_name-of-action-repo.GitHub removes special characters, and uses the name __run when the current step runs a script without an id. If you use the same script or action more than once in the same job, the name will include a suffix that consists of the sequence number preceded by an underscore. For example, the first script you run will have the name __run, and the second script will be named __run_2. Similarly, the second invocation of actions/checkout will be actionscheckout2.GITHUB_ACTION_PATHThe path where an action is located. This property is only supported in composite actions. You can use this path to change directories to where the action is located and access other files in that same repository. For example, /home/runner/work/_actions/repo-owner/name-of-action-repo/v1.GITHUB_ACTION_REPOSITORYFor a step executing an action, this is the owner and repository name of the action. For example, actions/checkout.GITHUB_ACTIONSAlways set to true when GitHub Actions is running the workflow. You can use this variable to differentiate when tests are being run locally or by GitHub Actions.GITHUB_ACTORThe name of the person or app that initiated the workflow. For example, octocat.GITHUB_ACTOR_IDThe account ID of the person or app that triggered the initial workflow run. For example, 1234567. Note that this is different from the actor username.GITHUB_API_URLReturns the API URL. For example: https://api.github.com.GITHUB_BASE_REFThe name of the base ref or target branch of the pull request in a workflow run. This is only set when the event that triggers a workflow run is either pull_request or pull_request_target. For example, main.GITHUB_ENVThe path on the runner to the file that sets variables from workflow commands. The path to this file is unique to the current step and changes for each step in a job. For example, /home/runner/work/_temp/_runner_file_commands/set_env_87406d6e-4979-4d42-98e1-3dab1f48b13a. For more information, see Workflow commands for GitHub Actions.GITHUB_EVENT_NAMEThe name of the event that triggered the workflow. For example, workflow_dispatch.GITHUB_EVENT_PATHThe path to the file on the runner that contains the full event webhook payload. For example, /github/workflow/event.json.GITHUB_GRAPHQL_URLReturns the GraphQL API URL. For example: https://api.github.com/graphql.GITHUB_HEAD_REFThe head ref or source branch of the pull request in a workflow run. This property is only set when the event that triggers a workflow run is either pull_request or pull_request_target. For example, feature-branch-1.GITHUB_JOBThe job_id of the current job. For example, greeting_job.GITHUB_OUTPUTThe path on the runner to the file that sets the current step's outputs from workflow commands. The path to this file is unique to the current step and changes for each step in a job. For example, /home/runner/work/_temp/_runner_file_commands/set_output_a50ef383-b063-46d9-9157-57953fc9f3f0. For more information, see Workflow commands for GitHub Actions.GITHUB_PATHThe path on the runner to the file that sets system PATH variables from workflow commands. The path to this file is unique to the current step and changes for each step in a job. For example, /home/runner/work/_temp/_runner_file_commands/add_path_899b9445-ad4a-400c-aa89-249f18632cf5. For more information, see Workflow commands for GitHub Actions.GITHUB_REFThe fully-formed ref of the branch or tag that triggered the workflow run. For workflows triggered by push, this is the branch or tag ref that was pushed. For workflows triggered by pull_request, this is the pull request merge branch. For workflows triggered by release, this is the release tag created. For other triggers, this is the branch or tag ref that triggered the workflow run. This is only set if a branch or tag is available for the event type. The ref given is fully-formed, meaning that for branches the format is refs/heads/<branch_name>. For pull requests events except pull_request_target, it is refs/pull/<pr_number>/merge. pull_request_target events have the ref from the base branch. For tags it is refs/tags/<tag_name>. For example, refs/heads/feature-branch-1.GITHUB_REF_NAMEThe short ref name of the branch or tag that triggered the workflow run. This value matches the branch or tag name shown on GitHub. For example, feature-branch-1.For pull requests, the format is <pr_number>/merge.GITHUB_REF_PROTECTEDtrue if branch protections or rulesets are configured for the ref that triggered the workflow run.GITHUB_REF_TYPEThe type of ref that triggered the workflow run. Valid values are branch or tag.GITHUB_REPOSITORYThe owner and repository name. For example, octocat/Hello-World.GITHUB_REPOSITORY_IDThe ID of the repository. For example, 123456789. Note that this is different from the repository name.GITHUB_REPOSITORY_OWNERThe repository owner's name. For example, octocat.GITHUB_REPOSITORY_OWNER_IDThe repository owner's account ID. For example, 1234567. Note that this is different from the owner's name.GITHUB_RETENTION_DAYSThe number of days that workflow run logs and artifacts are kept. For example, 90.GITHUB_RUN_ATTEMPTA unique number for each attempt of a particular workflow run in a repository. This number begins at 1 for the workflow run's first attempt, and increments with each re-run. For example, 3.GITHUB_RUN_IDA unique number for each workflow run within a repository. This number does not change if you re-run the workflow run. For example, 1658821493.GITHUB_RUN_NUMBERA unique number for each run of a particular workflow in a repository. This number begins at 1 for the workflow's first run, and increments with each new run. This number does not change if you re-run the workflow run. For example, 3.GITHUB_SERVER_URLThe URL of the GitHub server. For example: https://github.com.GITHUB_SHAThe commit SHA that triggered the workflow. The value of this commit SHA depends on the event that triggered the workflow. For more information, see Events that trigger workflows. For example, ffac537e6cbbf934b08745a378932722df287a53.GITHUB_STEP_SUMMARYThe path on the runner to the file that contains job summaries from workflow commands. The path to this file is unique to the current step and changes for each step in a job. For example, /home/runner/_layout/_work/_temp/_runner_file_commands/step_summary_1cb22d7f-5663-41a8-9ffc-13472605c76c. For more information, see Workflow commands for GitHub Actions.GITHUB_TRIGGERING_ACTORThe username of the user that initiated the workflow run. If the workflow run is a re-run, this value may differ from github.actor. Any workflow re-runs will use the privileges of github.actor, even if the actor initiating the re-run (github.triggering_actor) has different privileges.GITHUB_WORKFLOWThe name of the workflow. For example, My test workflow. If the workflow file doesn't specify a name, the value of this variable is the full path of the workflow file in the repository.GITHUB_WORKFLOW_REFThe ref path to the workflow. For example, octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch.GITHUB_WORKFLOW_SHAThe commit SHA for the workflow file.GITHUB_WORKSPACEThe default working directory on the runner for steps, and the default location of your repository when using the checkout action. For example, /home/runner/work/my-repo-name/my-repo-name.RUNNER_ARCHThe architecture of the runner executing the job. Possible values are X86, X64, ARM, or ARM64.RUNNER_DEBUGThis is set only if debug logging is enabled, and always has the value of 1. It can be useful as an indicator to enable additional debugging or verbose logging in your own job steps.RUNNER_ENVIRONMENTThe environment of the runner executing the job. Possible values are: github-hosted for GitHub-hosted runners provided by GitHub, and self-hosted for self-hosted runners configured by the repository owner.RUNNER_NAMEThe name of the runner executing the job. This name may not be unique in a workflow run as runners at the repository and organization levels could use the same name. For example, Hosted AgentRUNNER_OSThe operating system of the runner executing the job. Possible values are Linux, Windows, or macOS. For example, WindowsRUNNER_TEMPThe path to a temporary directory on the runner. This directory is emptied at the beginning and end of each job. Note that files will not be removed if the runner's user account does not have permission to delete them. For example, D:\a\_tempRUNNER_TOOL_CACHEThe path to the directory containing preinstalled tools for GitHub-hosted runners. For more information, see Using GitHub-hosted runners. For example, C:\hostedtoolcache\windows
Note

If you need to use a workflow run's URL from within a job, you can combine these variables: $GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID

Detecting the operating system
You can write a single workflow file that can be used for different operating systems by using the RUNNER_OS default environment variable and the corresponding context property ${{ runner.os }}. For example, the following workflow could be run successfully if you changed the operating system from macos-latest to windows-latest without having to alter the syntax of the environment variables, which differs depending on the shell being used by the runner.
YAMLon: workflow_dispatch

jobs:
  if-Windows-else:
    runs-on: macos-latest
    steps:
      - name: condition 1
        if: runner.os == 'Windows'
        run: echo "The operating system on the runner is $env:RUNNER_OS."
      - name: condition 2
        if: runner.os != 'Windows'
        run: echo "The operating system on the runner is not Windows, it's $RUNNER_OS."
on: workflow_dispatch

jobs:
  if-Windows-else:
    runs-on: macos-latest
    steps:
      - name: condition 1
        if: runner.os == 'Windows'
        run: echo "The operating system on the runner is $env:RUNNER_OS."
      - name: condition 2
        if: runner.os != 'Windows'
        run: echo "The operating system on the runner is not Windows, it's $RUNNER_OS."

In this example, the two if statements check the os property of the runner context to determine the operating system of the runner. if conditionals are processed by GitHub Actions, and only steps where the check resolves as true are sent to the runner. Here one of the checks will always be true and the other false, so only one of these steps is sent to the runner. Once the job is sent to the runner, the step is executed and the environment variable in the echo command is interpolated using the appropriate syntax ($env:NAME for PowerShell on Windows, and $NAME for bash and sh on Linux and macOS). In this example, the statement runs-on: macos-latest means that the second step will be run.
Passing values between steps and jobs in a workflow
If you generate a value in one step of a job, you can use the value in subsequent steps of the same job by assigning the value to an existing or new environment variable and then writing this to the GITHUB_ENV environment file. The environment file can be used directly by an action, or from a shell command in the workflow file by using the run keyword. For more information, see Workflow commands for GitHub Actions.
If you want to pass a value from a step in one job in a workflow to a step in another job in the workflow, you can define the value as a job output. You can then reference this job output from a step in another job. For more information, see Workflow syntax for GitHub Actions.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/ContextsAccessing contextual information about workflow runsYou can access context information in workflows and actions.In this articleAbout contextsgithub contextenv contextvars contextjob contextjobs contextsteps contextrunner contextsecrets contextstrategy contextmatrix contextneeds contextinputs contextAbout contexts
Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects.
Contexts, objects, and properties will vary significantly under different workflow run conditions. For example, the matrix context is only populated for jobs in a matrix.
You can access contexts using the expression syntax. For more information, see Evaluate expressions in workflows and actions.
${{ <context> }}
Warning

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.







































































Context nameTypeDescriptiongithubobjectInformation about the workflow run. For more information, see github context.envobjectContains variables set in a workflow, job, or step. For more information, see env context.varsobjectContains variables set at the repository, organization, or environment levels. For more information, see vars context.jobobjectInformation about the currently running job. For more information, see job context.jobsobjectFor reusable workflows only, contains outputs of jobs from the reusable workflow. For more information, see jobs context.stepsobjectInformation about the steps that have been run in the current job. For more information, see steps context.runnerobjectInformation about the runner that is running the current job. For more information, see runner context.secretsobjectContains the names and values of secrets that are available to a workflow run. For more information, see secrets context.strategyobjectInformation about the matrix execution strategy for the current job. For more information, see strategy context.matrixobjectContains the matrix properties defined in the workflow that apply to the current job. For more information, see matrix context.needsobjectContains the outputs of all jobs that are defined as a dependency of the current job. For more information, see needs context.inputsobjectContains the inputs of a reusable or manually triggered workflow. For more information, see inputs context.
As part of an expression, you can access context information using one of two syntaxes.

Index syntax: github['sha']
Property dereference syntax: github.sha

In order to use property dereference syntax, the property name must start with a letter or _ and contain only alphanumeric characters, -, or _.
If you attempt to dereference a nonexistent property, it will evaluate to an empty string.
Determining when to use contexts
GitHub Actions includes a collection of variables called contexts and a similar collection of variables called default variables. These variables are intended for use at different points in the workflow:

Default environment variables: These environment variables exist only on the runner that is executing your job. For more information, see Store information in variables.
Contexts: You can use most contexts at any point in your workflow, including when default variables would be unavailable. For example, you can use contexts with expressions to perform initial processing before the job is routed to a runner for execution; this allows you to use a context with the conditional if keyword to determine whether a step should run. Once the job is running, you can also retrieve context variables from the runner that is executing the job, such as runner.os. For details of where you can use various contexts within a workflow, see Context availability.

The following example demonstrates how these different types of variables can be used together in a job:
YAMLname: CI
on: push
jobs:
  prod-check:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying to production server on branch $GITHUB_REF"
name: CI
on: push
jobs:
  prod-check:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying to production server on branch $GITHUB_REF"

In this example, the if statement checks the github.ref context to determine the current branch name; if the name is refs/heads/main, then the subsequent steps are executed. The if check is processed by GitHub Actions, and the job is only sent to the runner if the result is true. Once the job is sent to the runner, the step is executed and refers to the $GITHUB_REF variable from the runner.
Context availability
Different contexts are available throughout a workflow run. For example, the secrets context may only be used at certain places within a job.
In addition, some functions may only be used in certain places. For example, the hashFiles function is not available everywhere.
The following table lists the restrictions on where each context and special function can be used within a workflow. The listed contexts are only available for the given workflow key, and may not be used anywhere else. Unless listed below, a function can be used anywhere.




















































































































































































Workflow keyContextSpecial functionsrun-namegithub, inputs, varsNoneconcurrencygithub, inputs, varsNoneenvgithub, secrets, inputs, varsNonejobs.<job_id>.concurrencygithub, needs, strategy, matrix, inputs, varsNonejobs.<job_id>.containergithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.container.credentialsgithub, needs, strategy, matrix, env, vars, secrets, inputsNonejobs.<job_id>.container.env.<env_id>github, needs, strategy, matrix, job, runner, env, vars, secrets, inputsNonejobs.<job_id>.container.imagegithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.continue-on-errorgithub, needs, strategy, vars, matrix, inputsNonejobs.<job_id>.defaults.rungithub, needs, strategy, matrix, env, vars, inputsNonejobs.<job_id>.envgithub, needs, strategy, matrix, vars, secrets, inputsNonejobs.<job_id>.environmentgithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.environment.urlgithub, needs, strategy, matrix, job, runner, env, vars, steps, inputsNonejobs.<job_id>.ifgithub, needs, vars, inputsalways, cancelled, success, failurejobs.<job_id>.namegithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.outputs.<output_id>github, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputsNonejobs.<job_id>.runs-ongithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.secrets.<secrets_id>github, needs, strategy, matrix, secrets, inputs, varsNonejobs.<job_id>.servicesgithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.services.<service_id>.credentialsgithub, needs, strategy, matrix, env, vars, secrets, inputsNonejobs.<job_id>.services.<service_id>.env.<env_id>github, needs, strategy, matrix, job, runner, env, vars, secrets, inputsNonejobs.<job_id>.steps.continue-on-errorgithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.steps.envgithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.steps.ifgithub, needs, strategy, matrix, job, runner, env, vars, steps, inputsalways, cancelled, success, failure, hashFilesjobs.<job_id>.steps.namegithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.steps.rungithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.steps.timeout-minutesgithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.steps.withgithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.steps.working-directorygithub, needs, strategy, matrix, job, runner, env, vars, secrets, steps, inputshashFilesjobs.<job_id>.strategygithub, needs, vars, inputsNonejobs.<job_id>.timeout-minutesgithub, needs, strategy, matrix, vars, inputsNonejobs.<job_id>.with.<with_id>github, needs, strategy, matrix, inputs, varsNoneon.workflow_call.inputs.<inputs_id>.defaultgithub, inputs, varsNoneon.workflow_call.outputs.<output_id>.valuegithub, jobs, vars, inputsNone
Example: printing context information to the log
You can print the contents of contexts to the log for debugging. The toJSON function is required to pretty-print JSON objects to the log.
Warning

When using the whole github context, be mindful that it includes sensitive information such as github.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.

YAMLname: Context testing
on: push

jobs:
  dump_contexts_to_log:
    runs-on: ubuntu-latest
    steps:
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "$GITHUB_CONTEXT"
      - name: Dump job context
        env:
          JOB_CONTEXT: ${{ toJson(job) }}
        run: echo "$JOB_CONTEXT"
      - name: Dump steps context
        env:
          STEPS_CONTEXT: ${{ toJson(steps) }}
        run: echo "$STEPS_CONTEXT"
      - name: Dump runner context
        env:
          RUNNER_CONTEXT: ${{ toJson(runner) }}
        run: echo "$RUNNER_CONTEXT"
      - name: Dump strategy context
        env:
          STRATEGY_CONTEXT: ${{ toJson(strategy) }}
        run: echo "$STRATEGY_CONTEXT"
      - name: Dump matrix context
        env:
          MATRIX_CONTEXT: ${{ toJson(matrix) }}
        run: echo "$MATRIX_CONTEXT"
name: Context testing
on: push

jobs:
  dump_contexts_to_log:
    runs-on: ubuntu-latest
    steps:
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: echo "$GITHUB_CONTEXT"
      - name: Dump job context
        env:
          JOB_CONTEXT: ${{ toJson(job) }}
        run: echo "$JOB_CONTEXT"
      - name: Dump steps context
        env:
          STEPS_CONTEXT: ${{ toJson(steps) }}
        run: echo "$STEPS_CONTEXT"
      - name: Dump runner context
        env:
          RUNNER_CONTEXT: ${{ toJson(runner) }}
        run: echo "$RUNNER_CONTEXT"
      - name: Dump strategy context
        env:
          STRATEGY_CONTEXT: ${{ toJson(strategy) }}
        run: echo "$STRATEGY_CONTEXT"
      - name: Dump matrix context
        env:
          MATRIX_CONTEXT: ${{ toJson(matrix) }}
        run: echo "$MATRIX_CONTEXT"

github context
The github context contains information about the workflow run and the event that triggered the run. You can also read most of the github context data in environment variables. For more information about environment variables, see Store information in variables.
Warning

When using the whole github context, be mindful that it includes sensitive information such as github.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.



















































































































































































































Property nameTypeDescriptiongithubobjectThe top-level context available during any job or step in a workflow. This object contains all the properties listed below.github.actionstringThe name of the action currently running, or the id of a step. GitHub removes special characters, and uses the name __run when the current step runs a script without an id. If you use the same action more than once in the same job, the name will include a suffix with the sequence number with underscore before it. For example, the first script you run will have the name __run, and the second script will be named __run_2. Similarly, the second invocation of actions/checkout will be actionscheckout2.github.action_pathstringThe path where an action is located. This property is only supported in composite actions. You can use this path to access files located in the same repository as the action, for example by changing directories to the path:  cd ${{ github.action_path }} .github.action_refstringFor a step executing an action, this is the ref of the action being executed. For example, v2.Do not use in the run keyword. To make this context work with composite actions, reference it within the env context of the composite action.github.action_repositorystringFor a step executing an action, this is the owner and repository name of the action. For example, actions/checkout.Do not use in the run keyword. To make this context work with composite actions, reference it within the env context of the composite action.github.action_statusstringFor a composite action, the current result of the composite action.github.actorstringThe username of the user that triggered the initial workflow run. If the workflow run is a re-run, this value may differ from github.triggering_actor. Any workflow re-runs will use the privileges of github.actor, even if the actor initiating the re-run (github.triggering_actor) has different privileges.github.actor_idstringThe account ID of the person or app that triggered the initial workflow run. For example, 1234567. Note that this is different from the actor username.github.api_urlstringThe URL of the GitHub REST API.github.base_refstringThe base_ref or target branch of the pull request in a workflow run. This property is only available when the event that triggers a workflow run is either pull_request or pull_request_target.github.envstringPath on the runner to the file that sets environment variables from workflow commands. This file is unique to the current step and is a different file for each step in a job. For more information, see Workflow commands for GitHub Actions.github.eventobjectThe full event webhook payload. You can access individual properties of the event using this context. This object is identical to the webhook payload of the event that triggered the workflow run, and is different for each event. The webhooks for each GitHub Actions event is linked in Events that trigger workflows. For example, for a workflow run triggered by the push event, this object contains the contents of the push webhook payload.github.event_namestringThe name of the event that triggered the workflow run.github.event_pathstringThe path to the file on the runner that contains the full event webhook payload.github.graphql_urlstringThe URL of the GitHub GraphQL API.github.head_refstringThe head_ref or source branch of the pull request in a workflow run. This property is only available when the event that triggers a workflow run is either pull_request or pull_request_target.github.jobstringThe job_id of the current job.  Note: This context property is set by the Actions runner, and is only available within the execution steps of a job. Otherwise, the value of this property will be null.github.pathstringPath on the runner to the file that sets system PATH variables from workflow commands. This file is unique to the current step and is a different file for each step in a job. For more information, see Workflow commands for GitHub Actions.github.refstringThe fully-formed ref of the branch or tag that triggered the workflow run. For workflows triggered by push, this is the branch or tag ref that was pushed. For workflows triggered by pull_request, this is the pull request merge branch. For workflows triggered by release, this is the release tag created. For other triggers, this is the branch or tag ref that triggered the workflow run. This is only set if a branch or tag is available for the event type. The ref given is fully-formed, meaning that for branches the format is refs/heads/<branch_name>. For pull requests events except pull_request_target, it is refs/pull/<pr_number>/merge. pull_request_target events have the ref from the base branch. For tags it is refs/tags/<tag_name>. For example, refs/heads/feature-branch-1.github.ref_namestringThe short ref name of the branch or tag that triggered the workflow run. This value matches the branch or tag name shown on GitHub. For example, feature-branch-1.For pull requests, the format is <pr_number>/merge.github.ref_protectedbooleantrue if branch protections or rulesets are configured for the ref that triggered the workflow run.github.ref_typestringThe type of ref that triggered the workflow run. Valid values are branch or tag.github.repositorystringThe owner and repository name. For example, octocat/Hello-World.github.repository_idstringThe ID of the repository. For example, 123456789. Note that this is different from the repository name.github.repository_ownerstringThe repository owner's username. For example, octocat.github.repository_owner_idstringThe repository owner's account ID. For example, 1234567. Note that this is different from the owner's name.github.repositoryUrlstringThe Git URL to the repository. For example, git://github.com/octocat/hello-world.git.github.retention_daysstringThe number of days that workflow run logs and artifacts are kept.github.run_idstringA unique number for each workflow run within a repository. This number does not change if you re-run the workflow run.github.run_numberstringA unique number for each run of a particular workflow in a repository. This number begins at 1 for the workflow's first run, and increments with each new run. This number does not change if you re-run the workflow run.github.run_attemptstringA unique number for each attempt of a particular workflow run in a repository. This number begins at 1 for the workflow run's first attempt, and increments with each re-run.github.secret_sourcestringThe source of a secret used in a workflow. Possible values are None, Actions, Codespaces, or Dependabot.github.server_urlstringThe URL of the GitHub server. For example: https://github.com.github.shastringThe commit SHA that triggered the workflow. The value of this commit SHA depends on the event that triggered the workflow. For more information, see Events that trigger workflows. For example, ffac537e6cbbf934b08745a378932722df287a53.github.tokenstringA token to authenticate on behalf of the GitHub App installed on your repository. This is functionally equivalent to the GITHUB_TOKEN secret. For more information, see Automatic token authentication.   Note: This context property is set by the Actions runner, and is only available within the execution steps of a job. Otherwise, the value of this property will be null.github.triggering_actorstringThe username of the user that initiated the workflow run. If the workflow run is a re-run, this value may differ from github.actor. Any workflow re-runs will use the privileges of github.actor, even if the actor initiating the re-run (github.triggering_actor) has different privileges.github.workflowstringThe name of the workflow. If the workflow file doesn't specify a name, the value of this property is the full path of the workflow file in the repository.github.workflow_refstringThe ref path to the workflow. For example, octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch.github.workflow_shastringThe commit SHA for the workflow file.github.workspacestringThe default working directory on the runner for steps, and the default location of your repository when using the checkout action.
Example contents of the github context
The following example context is from a workflow run triggered by the push event. The event object in this example has been truncated because it is identical to the contents of the push webhook payload.
Note

This context is an example only. The contents of a context depends on the workflow that you are running. Contexts, objects, and properties will vary significantly under different workflow run conditions.

{
  "token": "***",
  "job": "dump_contexts_to_log",
  "ref": "refs/heads/my_branch",
  "sha": "c27d339ee6075c1f744c5d4b200f7901aad2c369",
  "repository": "octocat/hello-world",
  "repository_owner": "octocat",
  "repositoryUrl": "git://github.com/octocat/hello-world.git",
  "run_id": "1536140711",
  "run_number": "314",
  "retention_days": "90",
  "run_attempt": "1",
  "actor": "octocat",
  "workflow": "Context testing",
  "head_ref": "",
  "base_ref": "",
  "event_name": "push",
  "event": {
    ...
  },
  "server_url": "https://github.com",
  "api_url": "https://api.github.com",
  "graphql_url": "https://api.github.com/graphql",
  "ref_name": "my_branch",
  "ref_protected": false,
  "ref_type": "branch",
  "secret_source": "Actions",
  "workspace": "/home/runner/work/hello-world/hello-world",
  "action": "github_step",
  "event_path": "/home/runner/work/_temp/_github_workflow/event.json",
  "action_repository": "",
  "action_ref": "",
  "path": "/home/runner/work/_temp/_runner_file_commands/add_path_b037e7b5-1c88-48e2-bf78-eaaab5e02602",
  "env": "/home/runner/work/_temp/_runner_file_commands/set_env_b037e7b5-1c88-48e2-bf78-eaaab5e02602"
}

Example usage of the github context
This example workflow uses the github.event_name context to run a job only if the workflow run was triggered by the pull_request event.
YAMLname: Run CI
on: [push, pull_request]

jobs:
  normal_ci:
    runs-on: ubuntu-latest
    steps:
      - name: Run normal CI
        run: echo "Running normal CI"

  pull_request_ci:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - name: Run PR CI
        run: echo "Running PR only CI"
name: Run CI
on: [push, pull_request]

jobs:
  normal_ci:
    runs-on: ubuntu-latest
    steps:
      - name: Run normal CI
        run: echo "Running normal CI"

  pull_request_ci:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    steps:
      - name: Run PR CI
        run: echo "Running PR only CI"

env context
The env context contains variables that have been set in a workflow, job, or step. It does not contain variables inherited by the runner process. For more information about setting variables in your workflow, see Workflow syntax for GitHub Actions.
You can retrieve the values of variables stored in env context and use these values in your workflow file. You can use the env context in any key in a workflow step except for the id and uses keys. For more information on the step syntax, see Workflow syntax for GitHub Actions.
If you want to use the value of a variable inside a runner, use the runner operating system's normal method for reading environment variables.




















Property nameTypeDescriptionenvobjectThis context changes for each step in a job. You can access this context from any step in a job. This object contains the properties listed below.env.<env_name>stringThe value of a specific environment variable.
Example contents of the env context
The contents of the env context is a mapping of variable names to their values. The context's contents can change depending on where it is used in the workflow run. In this example, the env context contains two variables.
{
  "first_name": "Mona",
  "super_duper_var": "totally_awesome"
}

Example usage of the env context
This example workflow shows variables being set in the env context at the workflow, job, and step levels. The ${{ env.VARIABLE-NAME }} syntax is then used to retrieve variable values within individual steps in the workflow.
When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.
YAMLname: Hi Mascot
on: push
env:
  mascot: Mona
  super_duper_var: totally_awesome

jobs:
  windows_job:
    runs-on: windows-latest
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Mona
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Octocat
        env:
          mascot: Octocat
  linux_job:
    runs-on: ubuntu-latest
    env:
      mascot: Tux
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Tux
name: Hi Mascot
on: push
env:
  mascot: Mona
  super_duper_var: totally_awesome

jobs:
  windows_job:
    runs-on: windows-latest
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Mona
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Octocat
        env:
          mascot: Octocat
  linux_job:
    runs-on: ubuntu-latest
    env:
      mascot: Tux
    steps:
      - run: echo 'Hi ${{ env.mascot }}'  # Hi Tux

vars context
Note

Configuration variables for GitHub Actions are in public preview and subject to change.

The vars context contains custom configuration variables set at the organization, repository, and environment levels. For more information about defining configuration variables for use in multiple workflows, see Store information in variables.
Example contents of the vars context
The contents of the vars context is a mapping of configuration variable names to their values.
{
  "mascot": "Mona"
}

Example usage of the vars context
This example workflow shows how configuration variables set at the repository, environment, or organization levels are automatically available using the vars context.
Note

Configuration variables at the environment level are automatically available after their environment is declared by the runner.

If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string.
The following example shows using configuration variables with the vars context across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels.
YAMLon:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo "repository variable : $REPOSITORY_VAR"
        echo "organization variable : $ORGANIZATION_VAR"
        echo "overridden variable : $OVERRIDE_VAR"
        echo "variable from shell environment : $env_var"
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}
on:
  workflow_dispatch:
env:
  # Setting an environment variable with the value of a configuration variable
  env_var: ${{ vars.ENV_CONTEXT_VAR }}

jobs:
  display-variables:
    name: ${{ vars.JOB_NAME }}
    # You can use configuration variables with the `vars` context for dynamic jobs
    if: ${{ vars.USE_VARIABLES == 'true' }}
    runs-on: ${{ vars.RUNNER }}
    environment: ${{ vars.ENVIRONMENT_STAGE }}
    steps:
    - name: Use variables
      run: |
        echo "repository variable : $REPOSITORY_VAR"
        echo "organization variable : $ORGANIZATION_VAR"
        echo "overridden variable : $OVERRIDE_VAR"
        echo "variable from shell environment : $env_var"
      env:
        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}
        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}
        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}
        
    - name: ${{ vars.HELLO_WORLD_STEP }}
      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}
      uses: actions/hello-world-javascript-action@main
      with:
        who-to-greet: ${{ vars.GREET_NAME }}

job context
The job context contains information about the currently running job.























































Property nameTypeDescriptionjobobjectThis context changes for each job in a workflow run. You can access this context from any step in a job. This object contains all the properties listed below.job.containerobjectInformation about the job's container. For more information about containers, see Workflow syntax for GitHub Actions.job.container.idstringThe ID of the container.job.container.networkstringThe ID of the container network. The runner creates the network used by all containers in a job.job.servicesobjectThe service containers created for a job. For more information about service containers, see Workflow syntax for GitHub Actions.job.services.<service_id>.idstringThe ID of the service container.job.services.<service_id>.networkstringThe ID of the service container network. The runner creates the network used by all containers in a job.job.services.<service_id>.portsobjectThe exposed ports of the service container.job.statusstringThe current status of the job. Possible values are success, failure, or cancelled.
Example contents of the job context
This example job context uses a PostgreSQL service container with mapped ports. If there are no containers or service containers used in a job, the job context only contains the status property.
{
  "status": "success",
  "container": {
    "network": "github_network_53269bd575974817b43f4733536b200c"
  },
  "services": {
    "postgres": {
      "id": "60972d9aa486605e66b0dad4abb638dc3d9116f566579e418166eedb8abb9105",
      "ports": {
        "5432": "49153"
      },
      "network": "github_network_53269bd575974817b43f4733536b200c"
    }
  }
}

Example usage of the job context
This example workflow configures a PostgreSQL service container, and automatically maps port 5432 in the service container to a randomly chosen available port on the host. The job context is used to access the number of the port that was assigned on the host.
YAMLname: PostgreSQL Service Example
on: push
jobs:
  postgres-job:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
        ports:
          # Maps TCP port 5432 in the service container to a randomly chosen available port on the host.
          - 5432

    steps:
      - run: pg_isready -h localhost -p ${{ job.services.postgres.ports[5432] }}
      - run: echo "Run tests against Postgres"
name: PostgreSQL Service Example
on: push
jobs:
  postgres-job:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
        ports:
          # Maps TCP port 5432 in the service container to a randomly chosen available port on the host.
          - 5432

    steps:
      - run: pg_isready -h localhost -p ${{ job.services.postgres.ports[5432] }}
      - run: echo "Run tests against Postgres"

jobs context
The jobs context is only available in reusable workflows, and can only be used to set outputs for a reusable workflow. For more information, see Reusing workflows.






























Property nameTypeDescriptionjobsobjectThis is only available in reusable workflows, and can only be used to set outputs for a reusable workflow. This object contains all the properties listed below.jobs.<job_id>.resultstringThe result of a job in the reusable workflow. Possible values are success, failure, cancelled, or skipped.jobs.<job_id>.outputsobjectThe set of outputs of a job in a reusable workflow.jobs.<job_id>.outputs.<output_name>stringThe value of a specific output for a job in a reusable workflow.
Example contents of the jobs context
This example jobs context contains the result and outputs of a job from a reusable workflow run.
{
  "example_job": {
    "result": "success",
    "outputs": {
      "output1": "hello",
      "output2": "world"
    }
  }
}

Example usage of the jobs context
This example reusable workflow uses the jobs context to set outputs for the reusable workflow. Note how the outputs flow up from the steps, to the job, then to the workflow_call trigger. For more information, see Reusing workflows.
YAMLname: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: "The first output string"
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: "The second output string"
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo "firstword=hello" >> $GITHUB_OUTPUT
      - id: step2
        run: echo "secondword=world" >> $GITHUB_OUTPUT
name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: "The first output string"
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: "The second output string"
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo "firstword=hello" >> $GITHUB_OUTPUT
      - id: step2
        run: echo "secondword=world" >> $GITHUB_OUTPUT

steps context
The steps context contains information about the steps in the current job that have an id specified and have already run.



































Property nameTypeDescriptionstepsobjectThis context changes for each step in a job. You can access this context from any step in a job. This object contains all the properties listed below.steps.<step_id>.outputsobjectThe set of outputs defined for the step. For more information, see Metadata syntax for GitHub Actions.steps.<step_id>.conclusionstringThe result of a completed step after continue-on-error is applied. Possible values are success, failure, cancelled, or skipped. When a continue-on-error step fails, the outcome is failure, but the final conclusion is success.steps.<step_id>.outcomestringThe result of a completed step before continue-on-error is applied. Possible values are success, failure, cancelled, or skipped. When a continue-on-error step fails, the outcome is failure, but the final conclusion is success.steps.<step_id>.outputs.<output_name>stringThe value of a specific output.
Example contents of the steps context
This example steps context shows two previous steps that had an id specified. The first step had the id named checkout, the second generate_number. The generate_number step had an output named random_number.
{
  "checkout": {
    "outputs": {},
    "outcome": "success",
    "conclusion": "success"
  },
  "generate_number": {
    "outputs": {
      "random_number": "1"
    },
    "outcome": "success",
    "conclusion": "success"
  }
}

Example usage of the steps context
This example workflow generates a random number as an output in one step, and a later step uses the steps context to read the value of that output.
YAMLname: Generate random failure
on: push
jobs:
  randomly-failing-job:
    runs-on: ubuntu-latest
    steps:
      - name: Generate 0 or 1
        id: generate_number
        run: echo "random_number=$(($RANDOM % 2))" >> $GITHUB_OUTPUT
      - name: Pass or fail
        run: |
          if [[ ${{ steps.generate_number.outputs.random_number }} == 0 ]]; then exit 0; else exit 1; fi
name: Generate random failure
on: push
jobs:
  randomly-failing-job:
    runs-on: ubuntu-latest
    steps:
      - name: Generate 0 or 1
        id: generate_number
        run: echo "random_number=$(($RANDOM % 2))" >> $GITHUB_OUTPUT
      - name: Pass or fail
        run: |
          if [[ ${{ steps.generate_number.outputs.random_number }} == 0 ]]; then exit 0; else exit 1; fi

runner context
The runner context contains information about the runner that is executing the current job.


















































Property nameTypeDescriptionrunnerobjectThis context changes for each job in a workflow run. This object contains all the properties listed below.runner.namestringThe name of the runner executing the job. This name may not be unique in a workflow run as runners at the repository and organization levels could use the same name.runner.osstringThe operating system of the runner executing the job. Possible values are Linux, Windows, or macOS.runner.archstringThe architecture of the runner executing the job. Possible values are X86, X64, ARM, or ARM64.runner.tempstringThe path to a temporary directory on the runner. This directory is emptied at the beginning and end of each job. Note that files will not be removed if the runner's user account does not have permission to delete them.runner.tool_cachestringThe path to the directory containing preinstalled tools for GitHub-hosted runners. For more information, see Using GitHub-hosted runners.runner.debugstringThis is set only if debug logging is enabled, and always has the value of 1. It can be useful as an indicator to enable additional debugging or verbose logging in your own job steps.runner.environmentstringThe environment of the runner executing the job. Possible values are: github-hosted for GitHub-hosted runners provided by GitHub, and self-hosted for self-hosted runners configured by the repository owner.
Example contents of the runner context
The following example context is from a Linux GitHub-hosted runner.
{
  "os": "Linux",
  "arch": "X64",
  "name": "GitHub Actions 2",
  "tool_cache": "/opt/hostedtoolcache",
  "temp": "/home/runner/work/_temp"
}

Example usage of the runner context
This example workflow uses the runner context to set the path to the temporary directory to write logs, and if the workflow fails, it uploads those logs as artifact.
YAMLname: Build
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build with logs
        run: |
          mkdir ${{ runner.temp }}/build_logs
          echo "Logs from building" > ${{ runner.temp }}/build_logs/build.logs
          exit 1
      - name: Upload logs on fail
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: Build failure logs
          path: ${{ runner.temp }}/build_logs
name: Build
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build with logs
        run: |
          mkdir ${{ runner.temp }}/build_logs
          echo "Logs from building" > ${{ runner.temp }}/build_logs/build.logs
          exit 1
      - name: Upload logs on fail
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: Build failure logs
          path: ${{ runner.temp }}/build_logs

secrets context
The secrets context contains the names and values of secrets that are available to a workflow run. The secrets context is not available for composite actions due to security reasons. If you want to pass a secret to a composite action, you need to do it explicitly as an input. For more information about secrets, see Using secrets in GitHub Actions.
GITHUB_TOKEN is a secret that is automatically created for every workflow run, and is always included in the secrets context. For more information, see Automatic token authentication.
Warning

If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally.


























Property nameTypeDescriptionsecretsobjectThis context is the same for each job in a workflow run. You can access this context from any step in a job. This object contains all the properties listed below.secrets.GITHUB_TOKENstringAutomatically created token for each workflow run. For more information, see Automatic token authentication.secrets.<secret_name>stringThe value of a specific secret.
Example contents of the secrets context
The following example contents of the secrets context shows the automatic GITHUB_TOKEN, as well as two other secrets available to the workflow run.
{
  "github_token": "***",
  "NPM_TOKEN": "***",
  "SUPERSECRET": "***"
}

Example usage of the secrets context
This example workflow uses the GitHub CLI, which requires the GITHUB_TOKEN as the value for the GH_TOKEN input parameter:
YAMLname: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title "Issue title" --body "Issue body"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
name: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title "Issue title" --body "Issue body"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

strategy context
For workflows with a matrix, the strategy context contains information about the matrix execution strategy for the current job.



































Property nameTypeDescriptionstrategyobjectThis context changes for each job in a workflow run. You can access this context from any job or step in a workflow. This object contains all the properties listed below.strategy.fail-fastbooleanWhen this evaluates to true, all in-progress jobs are canceled if any job in a matrix fails. For more information, see Workflow syntax for GitHub Actions.strategy.job-indexnumberThe index of the current job in the matrix. Note: This number is a zero-based number. The first job's index in the matrix is 0.strategy.job-totalnumberThe total number of jobs in the matrix. Note: This number is not a zero-based number. For example, for a matrix with four jobs, the value of job-total is 4.strategy.max-parallelnumberThe maximum number of jobs that can run simultaneously when using a matrix job strategy. For more information, see Workflow syntax for GitHub Actions.
Example contents of the strategy context
The following example contents of the strategy context is from a matrix with four jobs, and is taken from the final job. Note the difference between the zero-based job-index number, and job-total which is not zero-based.
{
  "fail-fast": true,
  "job-index": 3,
  "job-total": 4,
  "max-parallel": 4
}

Example usage of the strategy context
This example workflow uses the strategy.job-index property to set a unique name for a log file for each job in a matrix.
YAMLname: Test strategy
on: push

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [1, 2]
        node: [14, 16]
    steps:
      - run: echo "Mock test logs" > test-job-${{ strategy.job-index }}.txt
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: Build log for job ${{ strategy.job-index }}
          path: test-job-${{ strategy.job-index }}.txt
name: Test strategy
on: push

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [1, 2]
        node: [14, 16]
    steps:
      - run: echo "Mock test logs" > test-job-${{ strategy.job-index }}.txt
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: Build log for job ${{ strategy.job-index }}
          path: test-job-${{ strategy.job-index }}.txt

matrix context
For workflows with a matrix, the matrix context contains the matrix properties defined in the workflow file that apply to the current job. For example, if you configure a matrix with the os and node keys, the matrix context object includes the os and node properties with the values that are being used for the current job.
There are no standard properties in the matrix context, only those which are defined in the workflow file.




















Property nameTypeDescriptionmatrixobjectThis context is only available for jobs in a matrix, and changes for each job in a workflow run. You can access this context from any job or step in a workflow. This object contains the properties listed below.matrix.<property_name>stringThe value of a matrix property.
Example contents of the matrix context
The following example contents of the matrix context is from a job in a matrix that has the os and node matrix properties defined in the workflow. The job is executing the matrix combination of an ubuntu-latest OS and Node.js version 16.
{
  "os": "ubuntu-latest",
  "node": 16
}

Example usage of the matrix context
This example workflow creates a matrix with os and node keys. It uses the matrix.os property to set the runner type for each job, and uses the matrix.node property to set the Node.js version for each job.
YAMLname: Test matrix
on: push

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - name: Output node version
        run: node --version
name: Test matrix
on: push

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - name: Output node version
        run: node --version

needs context
The needs context contains outputs from all jobs that are defined as a direct dependency of the current job. Note that this doesn't include implicitly dependent jobs (for example, dependent jobs of a dependent job). For more information on defining job dependencies, see Workflow syntax for GitHub Actions.



































Property nameTypeDescriptionneedsobjectThis context is only populated for workflow runs that have dependent jobs, and changes for each job in a workflow run. You can access this context from any job or step in a workflow. This object contains all the properties listed below.needs.<job_id>objectA single job that the current job depends on.needs.<job_id>.outputsobjectThe set of outputs of a job that the current job depends on.needs.<job_id>.outputs.<output name>stringThe value of a specific output for a job that the current job depends on.needs.<job_id>.resultstringThe result of a job that the current job depends on. Possible values are success, failure, cancelled, or skipped.
Example contents of the needs context
The following example contents of the needs context shows information for two jobs that the current job depends on.
{
  "build": {
    "result": "success",
    "outputs": {
      "build_id": "123456"
    }
  },
  "deploy": {
    "result": "failure",
    "outputs": {}
  }
}

Example usage of the needs context
This example workflow has three jobs: a build job that does a build, a deploy job that requires the build job, and a debug job that requires both the build and deploy jobs and runs only if there is a failure in the workflow. The deploy job also uses the needs context to access an output from the build job.
YAMLname: Build and deploy
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.build_step.outputs.build_id }}
    steps:
      - name: Build
        id: build_step
        run: echo "build_id=$RANDOM" >> $GITHUB_OUTPUT
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying build ${{ needs.build.outputs.build_id }}"
  debug:
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: ${{ failure() }}
    steps:
      - run: echo "Failed to build and deploy"
name: Build and deploy
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.build_step.outputs.build_id }}
    steps:
      - name: Build
        id: build_step
        run: echo "build_id=$RANDOM" >> $GITHUB_OUTPUT
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying build ${{ needs.build.outputs.build_id }}"
  debug:
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: ${{ failure() }}
    steps:
      - run: echo "Failed to build and deploy"

inputs context
The inputs context contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow. For reusable workflows, the input names and types are defined in the workflow_call event configuration of a reusable workflow, and the input values are passed from jobs.<job_id>.with in an external workflow that calls the reusable workflow. For manually triggered workflows, the inputs are defined in the workflow_dispatch event configuration of a workflow.
The properties in the inputs context are defined in the workflow file. They are only available in a reusable workflow or in a workflow triggered by the workflow_dispatch event




















Property nameTypeDescriptioninputsobjectThis context is only available in a reusable workflow or in a workflow triggered by the workflow_dispatch event. You can access this context from any job or step in a workflow. This object contains the properties listed below.inputs.<name>string or number or boolean or choiceEach input value passed from an external workflow.
Example contents of the inputs context
The following example contents of the inputs context is from a workflow that has defined the build_id, deploy_target, and perform_deploy inputs.
{
  "build_id": 123456768,
  "deploy_target": "deployment_sys_1a",
  "perform_deploy": true
}

Example usage of the inputs context in a reusable workflow
This example reusable workflow uses the inputs context to get the values of the build_id, deploy_target, and perform_deploy inputs that were passed to the reusable workflow from the caller workflow.
YAMLname: Reusable deploy workflow
on:
  workflow_call:
    inputs:
      build_id:
        required: true
        type: number
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo "Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}"
name: Reusable deploy workflow
on:
  workflow_call:
    inputs:
      build_id:
        required: true
        type: number
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo "Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}"

Example usage of the inputs context in a manually triggered workflow
This example workflow triggered by a workflow_dispatch event uses the inputs context to get the values of the build_id, deploy_target, and perform_deploy inputs that were passed to the workflow.
YAMLon:
  workflow_dispatch:
    inputs:
      build_id:
        required: true
        type: string
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo "Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}"
on:
  workflow_dispatch:
    inputs:
      build_id:
        required: true
        type: string
      deploy_target:
        required: true
        type: string
      perform_deploy:
        required: true
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ inputs.perform_deploy }}
    steps:
      - name: Deploy build to target
        run: echo "Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}"\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Pass informationPassing information between jobsYou can define outputs to pass information from one job to another.Overview
You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs.
Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.
Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions.
If an output is skipped because it may contain a secret, you will see the following warning message: "Skip output {output.Key} since it may contain secret." For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows.
To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs.
Example: Defining outputs for a job
jobs:
  job1:
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      output1: ${{ steps.step1.outputs.test }}
      output2: ${{ steps.step2.outputs.test }}
    steps:
      - id: step1
        run: echo "test=hello" >> "$GITHUB_OUTPUT"
      - id: step2
        run: echo "test=world" >> "$GITHUB_OUTPUT"
  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - env:
          OUTPUT1: ${{needs.job1.outputs.output1}}
          OUTPUT2: ${{needs.job1.outputs.output2}}
        run: echo "$OUTPUT1 $OUTPUT2"

Using Job Outputs in a Matrix Job
Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      output_1: ${{ steps.gen_output.outputs.output_1 }}
      output_2: ${{ steps.gen_output.outputs.output_2 }}
      output_3: ${{ steps.gen_output.outputs.output_3 }}
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - name: Generate output
        id: gen_output
        run: |
          version="${{ matrix.version }}"
          echo "output_${version}=${version}" >> "$GITHUB_OUTPUT"
  job2:
    runs-on: ubuntu-latest
    needs: [job1]
    steps:
      # Will show
      # {
      #   "output_1": "1",
      #   "output_2": "2",
      #   "output_3": "3"
      # }
      - run: echo '${{ toJSON(needs.job1.outputs) }}'

Warning

Actions does not guarantee the order that matrix jobs will run in. Ensure that the output name is unique, otherwise the last matrix job that runs will override the output value.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Set default values for jobsSetting a default shell and working directoryDefine the default settings that will apply to all jobs in the workflow, or all steps in a job.In this articleOverviewSetting default shell and working directorySetting default values for a specific jobSetting default shell and working directory for a jobOverview
Use defaults to create a map of default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, see jobs.<job_id>.defaults.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
Setting default shell and working directory
You can use defaults.run to provide default shell and working-directory options for all run steps in a workflow. You can also set default settings for run that are only available to a job. For more information, see jobs.<job_id>.defaults.run. You cannot use contexts or expressions in this keyword.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
Example: Set the default shell and working directory
defaults:
  run:
    shell: bash
    working-directory: ./scripts

Setting default values for a specific job
Use jobs.<job_id>.defaults to create a map of default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, see defaults.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
Setting default shell and working directory for a job
Use jobs.<job_id>.defaults.run to provide default shell and working-directory to all run steps in the job.
You can provide default shell and working-directory options for all run steps in a job. You can also set default settings for run for the entire workflow. For more information, see defaults.run.
These can be overriden at the jobs.<job_id>.defaults.run and jobs.<job_id>.steps[*].run levels.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
Example: Setting default run step options for a job
jobs:
  job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/EnvironmentsUsing environments for deploymentSpecify a deployment environment in your workflow.In this articleAbout environmentsUsing an environment in a workflowAbout environments
Environments are used to describe a general deployment target like production, staging, or development. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.
Each job in a workflow can reference a single environment. Any protection rules configured for the environment must pass before a job referencing the environment is sent to a runner. The job can access the environment's secrets only after the job is sent to a runner.
When a workflow references an environment, the environment will appear in the repository's deployments. For more information about viewing current and previous deployments, see Viewing deployment history.
Using an environment in a workflow
You can specify an environment for each job in your workflow. To do so, add a jobs.<job_id>.environment key followed by the name of the environment.
For example, this workflow will use an environment called production.
name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps

When the above workflow runs, the deployment job will be subject to any rules configured for the production environment. For example, if the environment requires reviewers, the job will pause until one of the reviewers approves the job.
You can also specify a URL for the environment. The specified URL will appear on the deployments page for the repository (accessed by clicking Environments on the home page of your repository) and in the visualization graph for the workflow run. If a pull request triggered the workflow, the URL is also displayed as a View deployment button in the pull request timeline. When using the "Require deployments to succeed before merging" rule, only the name specified is being checked even if a URL has also been specified. See About protected branches.
name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://github.com
    steps:
      - name: deploy
        # ...deployment-specific steps\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/ConcurrencyControl the concurrency of workflows and jobsRun a single job at a time.In this articleOverviewUsing concurrency in different scenariosMonitoring your current jobs in your organization or enterpriseOverview
By default, GitHub Actions allows multiple jobs within the same workflow, multiple workflow runs within the same repository, and multiple workflow runs across a repository owner's account to run concurrently. This means that multiple instances of the same workflow or job can run at the same time, performing the same steps.
GitHub Actions also allows you to disable concurrent execution. This can be useful for controlling your account’s or organization’s resources in situations where running multiple workflows or jobs at the same time could cause conflicts or consume more Actions minutes and storage than expected.
For example, the ability to run workflows concurrently means that if multiple commits are pushed to a repository in quick succession, each push could trigger a separate workflow run, and these runs will execute concurrently.
Using concurrency in different scenarios
You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github, inputs, vars, needs, strategy, and matrix. For more information about expressions, see Evaluate expressions in workflows and actions.
You can also specify concurrency at the workflow level. For more information, see concurrency.
This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.
To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts.
Note


The concurrency group name is case insensitive. For example, prod and Prod will be treated as the same concurrency group.
Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.


Example: Using concurrency and the default behavior
The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs.
For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:
on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:
on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true

Example: Concurrency groups
Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.
The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables.
It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.
This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.
In this example, job-1 is part of a concurrency group named staging_environment. This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.
jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true

Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:
on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

Example: Using concurrency to cancel any in-progress job or run
To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true:
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

Note that in this example, without defining a particular concurrency group, GitHub Actions will cancel any in-progress run of the job or workflow.
Example: Using a fallback value
If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.
concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

Example: Only cancel in-progress jobs or runs for the current workflow
If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.
To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

Example: Only cancel in-progress jobs on specific branches
If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.
To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}

In this example, multiple pushes to a release/1.2.3 branch would not cancel in-progress runs. Pushes to another branch, such as main, would cancel in-progress runs.
Monitoring your current jobs in your organization or enterprise
To identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, see Monitoring your current jobs.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Run job variationsRunning variations of jobs in a workflowCreate a matrix to define variations for each job.In this articleAbout matrix strategiesUsing a matrix strategyExpanding or adding matrix configurationsExcluding matrix configurationsExample: Using an output to define two matricesHandling failuresDefining the maximum number of concurrent jobsAbout matrix strategies
A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems.
Using a matrix strategy
Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest]:
jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]

A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables.
By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:

{version: 10, os: ubuntu-latest}
{version: 10, os: windows-latest}
{version: 12, os: ubuntu-latest}
{version: 12, os: windows-latest}
{version: 14, os: ubuntu-latest}
{version: 14, os: windows-latest}

A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.
The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs.
Example: Using a single-dimension matrix
You can specify a single variable to create a single-dimension matrix.
For example, the following workflow defines the variable version with the values [10, 12, 14]. The workflow will run three jobs, one for each value in the variable. Each job will access the version value through the matrix.version context and pass the value as node-version to the actions/setup-node action.
jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

Example: Using a multi-dimension matrix
You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables.
For example, the following workflow specifies two variables:

Two operating systems specified in the os variable
Three Node.js versions specified in the version variable

The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action.
jobs:
  example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

A variable configuration in a matrix can be an array of objects.
matrix:
  os:
    - ubuntu-latest
    - macos-latest
  node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider

This matrix produces 4 jobs with corresponding contexts.
- matrix.os: ubuntu-latest
  matrix.node.version: 14
- matrix.os: ubuntu-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
  matrix.node.version: 14
- matrix.os: macos-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider

Example: Using contexts to create matrices
You can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs.
For example, the following workflow triggers on the repository_dispatch event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix version variable will have a value of [12, 14, 16]. For more information about the repository_dispatch trigger, see Events that trigger workflows.
{
  "event_type": "test",
  "client_payload": {
    "versions": [12, 14, 16]
  }
}

on:
  repository_dispatch:
    types:
      - test
 
jobs:
  example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

Expanding or adding matrix configurations
Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects.
For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten.
For example, this matrix:
strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat

will result in six jobs with the following matrix combinations:

{fruit: apple, animal: cat, color: pink, shape: circle}
{fruit: apple, animal: dog, color: green, shape: circle}
{fruit: pear, animal: cat, color: pink}
{fruit: pear, animal: dog, color: green}
{fruit: banana}
{fruit: banana, animal: cat}

following this logic:

{color: green} is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.
{color: pink, animal: cat} adds color:pink only to the original matrix combinations that include animal: cat. This overwrites the color: green that was added by the previous include entry.
{fruit: apple, shape: circle} adds shape: circle only to the original matrix combinations that include fruit: apple.
{fruit: banana} cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.
{fruit: banana, animal: cat} cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the {fruit: banana} matrix combination because that combination was not one of the original matrix combinations.

Example: Expanding configurations
For example, the following workflow will run four jobs, one for each combination of os and node. When the job for the os value of windows-latest and node value of 16 runs, an additional variable called npm with the value of 6 will be included in the job.
jobs:
  example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version

Example: Adding configurations
For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17.
jobs:
  example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17

If you don't specify any matrix variables, all configurations under include will run. For example, the following workflow would run two jobs, one for each include entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.
jobs:
  includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: "production"
            datacenter: "site-a"
          - site: "staging"
            datacenter: "site-b"

Excluding matrix configurations
To remove specific configurations defined in the matrix, use jobs.<job_id>.strategy.matrix.exclude. An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches {os: macos-latest, version: 12, environment: production}, and the two excluded jobs that match {os: windows-latest, version: 16}.
strategy:
  matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}

Note

All include combinations are processed after exclude. This allows you to use include to add back combinations that were previously excluded.

Example: Using an output to define two matrices
You can use the output from one job to define matrices for multiple jobs.
For example, the following workflow demonstrates how to define a matrix of values in one job, use that matrix in a second jobs to produce artifacts, and then consume those artifacts in a third job. Each artifact is associated with a value from the matrix.
YAMLname: shared matrix
on:
  push:
  workflow_dispatch:

jobs:
  define-matrix:
    runs-on: ubuntu-latest

    outputs:
      colors: ${{ steps.colors.outputs.colors }}

    steps:
      - name: Define Colors
        id: colors
        run: |
          echo 'colors=["red", "green", "blue"]' >> "$GITHUB_OUTPUT"

  produce-artifacts:
    runs-on: ubuntu-latest
    needs: define-matrix
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
      - name: Define Color
        env:
          color: ${{ matrix.color }}
        run: |
          echo "$color" > color
      - name: Produce Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.color }}
          path: color

  consume-artifacts:
    runs-on: ubuntu-latest
    needs:
    - define-matrix
    - produce-artifacts
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
    - name: Retrieve Artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.color }}

    - name: Report Color
      run: |
        cat color
name: shared matrix
on:
  push:
  workflow_dispatch:

jobs:
  define-matrix:
    runs-on: ubuntu-latest

    outputs:
      colors: ${{ steps.colors.outputs.colors }}

    steps:
      - name: Define Colors
        id: colors
        run: |
          echo 'colors=["red", "green", "blue"]' >> "$GITHUB_OUTPUT"

  produce-artifacts:
    runs-on: ubuntu-latest
    needs: define-matrix
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
      - name: Define Color
        env:
          color: ${{ matrix.color }}
        run: |
          echo "$color" > color
      - name: Produce Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.color }}
          path: color

  consume-artifacts:
    runs-on: ubuntu-latest
    needs:
    - define-matrix
    - produce-artifacts
    strategy:
      matrix:
        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}

    steps:
    - name: Retrieve Artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ matrix.color }}

    - name: Report Color
      run: |
        cat color

Handling failures
You can control how job failures are handled with jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error.
jobs.<job_id>.strategy.fail-fast applies to the entire matrix. If jobs.<job_id>.strategy.fail-fast is set to true or its expression evaluates to true, GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to true.
jobs.<job_id>.continue-on-error applies to a single job. If jobs.<job_id>.continue-on-error is true, other jobs in the matrix will continue running even if the job with jobs.<job_id>.continue-on-error: true fails.
You can use jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error together. For example, the following workflow will start four jobs. For each job, continue-on-error is determined by the value of matrix.experimental. If any of the jobs with continue-on-error: false fail, all jobs that are in progress or queued will be cancelled. If the job with continue-on-error: true fails, the other jobs will not be affected.
jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true

Defining the maximum number of concurrent jobs
By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a matrix job strategy, use jobs.<job_id>.strategy.max-parallel.
For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.
jobs:
  example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Cache dependenciesCaching dependencies to speed up workflowsTo make your workflows faster and more efficient, you can create and use caches for dependencies and other commonly reused files.In this articleAbout caching workflow dependenciesComparing artifacts and dependency cachingRestrictions for accessing a cacheUsing the cache actionMatching a cache keyUsage limits and eviction policyManaging cachesAbout caching workflow dependencies
Workflow runs often reuse the same outputs or downloaded dependencies from one run to another. For example, package and dependency management tools such as Maven, Gradle, npm, and Yarn keep a local cache of downloaded dependencies.
Jobs on GitHub-hosted runners start in a clean runner image and must download dependencies each time, causing increased network utilization, longer runtime, and increased cost. To help speed up the time it takes to recreate files like dependencies, GitHub can cache files you frequently use in workflows.
To cache dependencies for a job, you can use GitHub's cache action. The action creates and restores a cache identified by a unique key. Alternatively, if you are caching the package managers listed below, using their respective setup-* actions requires minimal configuration and will create and restore dependency caches for you.

































Package managerssetup-* action for cachingnpm, Yarn, pnpmsetup-nodepip, pipenv, Poetrysetup-pythonGradle, Mavensetup-javaRubyGemssetup-rubyGo go.sumsetup-go.NET NuGetsetup-dotnet
Warning

Be mindful of the following when using caching with GitHub Actions:

We recommend that you don't store any sensitive information in the cache. For example, sensitive information can include access tokens or login credentials stored in a file in the cache path. Also, command line interface (CLI) programs like docker login can save access credentials in a configuration file. Anyone with read access can create a pull request on a repository and access the contents of a cache. Forks of a repository can also create pull requests on the base branch and access caches on the base branch.
When using self-hosted runners, caches from workflow runs are stored on GitHub-owned cloud storage. A customer-owned storage solution is only available with GitHub Enterprise Server.


Comparing artifacts and dependency caching
Artifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably.

Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.
Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.

For more information on workflow run artifacts, see Storing and sharing data from a workflow.
Restrictions for accessing a cache
Access restrictions provide cache isolation and security by creating a logical boundary between different branches or tags.
Workflow runs can restore caches created in either the current branch or the default branch (usually main). If a workflow run is triggered for a pull request, it can also restore caches created in the base branch, including base branches of forked repositories. For example, if the branch feature-b has the base branch feature-a, a workflow run triggered on a pull request would have access to caches created in the default main branch, the base feature-a branch, and the current feature-b branch.
Workflow runs cannot restore caches created for child branches or sibling branches. For example, a cache created for the child feature-b branch would not be accessible to a workflow run triggered on the parent main branch. Similarly, a cache created for the feature-a branch with the base main would not be accessible to its sibling feature-c branch with the base main. Workflow runs also cannot restore caches created for different tag names. For example, a cache created for the tag release-a with the base main would not be accessible to a workflow run triggered for the tag release-b with the base main.
When a cache is created by a workflow run triggered on a pull request, the cache is created for the merge ref (refs/pull/.../merge). Because of this, the cache will have a limited scope and can only be restored by re-runs of the pull request. It cannot be restored by the base branch or other pull requests targeting that base branch.
Multiple workflow runs in a repository can share caches. A cache created for a branch in a workflow run can be accessed and restored from another workflow run for the same repository and branch.
Using the cache action
The cache action will attempt to restore a cache based on the key you provide. When the action finds a cache that exactly matches the key, the action restores the cached files to the path you configure.
You can optionally provide a list of restore-keys to use in case the key doesn't match an existing cache. A list of restore-keys is useful when you are restoring a cache from another branch because restore-keys can partially match cache keys. For more information about matching restore-keys, see Matching a cache key.
If there is an exact match to the provided key, this is considered a cache hit. If no cache exactly matches the provided key, this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the key you provided and contains the files you specify in path. For more information about how this is handled, see Cache hits and misses.
You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key.
Input parameters for the cache action


key: Required The key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail.


path: Required The path(s) on the runner to cache or restore.


You can specify a single path, or you can add multiple paths on separate lines. For example:
- name: Cache Gradle packages
  uses: actions/cache@v4
  with:
    path: |
      ~/.gradle/caches
      ~/.gradle/wrapper



You can specify either directories or single files, and glob patterns are supported.


You can specify absolute paths, or paths relative to the workspace directory.




restore-keys: Optional A string containing alternative restore keys, with each restore key placed on a new line. If no cache hit occurs for key, these restore keys are used sequentially in the order provided to find and restore a cache. For example:
restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-



enableCrossOsArchive: Optional A boolean value that when enabled, allows Windows runners to save or restore caches independent of the operating system the cache was created on. If this parameter is not set, it defaults to false. For more information, see Cross OS cache in the Actions Cache documentation.


Output parameters for the cache action

cache-hit: A boolean value to indicate an exact match was found for the key.

Cache hits and misses
When key exactly matches an existing cache, it's called a cache hit, and the action restores the cached files to the path directory.
When key doesn't match an existing cache, it's called a cache miss, and a new cache is automatically created if the job completes successfully.
When a cache miss occurs, the action also searches your specified restore-keys for any matches:

If you provide restore-keys, the cache action sequentially searches for any caches that match the list of restore-keys.

When there is an exact match, the action restores the files in the cache to the path directory.
If there are no exact matches, the action searches for partial matches of the restore keys. When the action finds a partial match, the most recent cache is restored to the path directory.


The cache action completes and the next step in the job runs.
If the job completes successfully, the action automatically creates a new cache with the contents of the path directory.

For a more detailed explanation of the cache matching process, see Matching a cache key.
Example using the cache action
This example creates a new cache when the packages in package-lock.json file change, or when the runner's operating system changes. The cache key uses contexts and expressions to generate a key that includes the runner's operating system and a SHA-256 hash of the package-lock.json file.
YAMLname: Caching with npm
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache node modules
        id: cache-npm
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
        name: List the state of node modules
        continue-on-error: true
        run: npm list

      - name: Install dependencies
        run: npm install

      - name: Build
        run: npm run build

      - name: Test
        run: npm test
name: Caching with npm
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache node modules
        id: cache-npm
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
        name: List the state of node modules
        continue-on-error: true
        run: npm list

      - name: Install dependencies
        run: npm install

      - name: Build
        run: npm run build

      - name: Test
        run: npm test

Using contexts to create cache keys
A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, see Accessing contextual information about workflow runs and Evaluate expressions in workflows and actions.
Using expressions to create a key allows you to automatically create a new cache when dependencies change.
For example, you can create a key using an expression that calculates the hash of an npm package-lock.json file. So, when the dependencies that make up the package-lock.json file change, the cache key changes and a new cache is automatically created.
npm-${{ hashFiles('package-lock.json') }}

GitHub evaluates the expression hash "package-lock.json" to derive the final key.
npm-d5ea0750

Using the output of the cache action
You can use the output of the cache action to do something based on whether a cache hit or miss occurred. When an exact match is found for a cache for the specified key, the cache-hit output is set to true.
In the example workflow above, there is a step that lists the state of the Node modules if a cache miss occurred:
- if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
  name: List the state of node modules
  continue-on-error: true
  run: npm list

Matching a cache key
The cache action first searches for cache hits for key and the cache version in the branch containing the workflow run. If there is no hit, it searches for restore-keys and the version. If there are still no hits in the current branch, the cache action retries same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see Restrictions for accessing a cache.
Cache version is a way to stamp a cache with metadata of the path and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see Cache Version in the Actions Cache documentation.
restore-keys allows you to specify a list of alternate restore keys to use when there is a cache miss on key. You can create multiple restore keys ordered from the most specific to least specific. The cache action searches the restore-keys in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache.
Example using multiple restore keys
restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-

The runner evaluates the expressions, which resolve to these restore-keys:
restore-keys: |
  npm-feature-d5ea0750
  npm-feature-
  npm-

The restore key npm-feature- matches any key that starts with the string npm-feature-. For example, both of the keys npm-feature-fd3052de and npm-feature-a9b253ff match the restore key. The cache with the most recent creation date would be used. The keys in this example are searched in the following order:

npm-feature-d5ea0750 matches a specific hash.
npm-feature- matches cache keys prefixed with npm-feature-.
npm- matches any keys prefixed with npm-.

Example of search priority
key:
  npm-feature-d5ea0750
restore-keys: |
  npm-feature-
  npm-

For example, if a pull request contains a feature branch and targets the default branch (main), the action searches for key and restore-keys in the following order:

Key npm-feature-d5ea0750 in the feature branch
Key npm-feature- in the feature branch
Key npm- in the feature branch
Key npm-feature-d5ea0750 in the main branch
Key npm-feature- in the main branch
Key npm- in the main branch

Usage limits and eviction policy
GitHub will remove any cache entries that have not been accessed in over 7 days. There is no limit on the number of caches you can store, but the total size of all caches in a repository is limited to 10 GB. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository.
If you exceed the limit, GitHub will save the new cache but will begin evicting caches until the total size is less than the repository limit. The cache eviction process may cause cache thrashing, where caches are created and deleted at a high frequency. To reduce this, you can review the caches for a repository and take corrective steps, such as removing caching from specific workflows. For more information, see Managing caches.
Managing caches
To manage caches created from your workflows, you can:

View a list of all cache entries for a repository.
Filter and sort the list of caches using specific metadata such as cache size, creation time, or last accessed time.
Delete cache entries from a repository.
Monitor aggregate cache usage for repositories and organizations.

There are multiple ways to manage caches for your repositories:


Using the GitHub web interface, as shown below.


Using the REST API. For more information, see REST API endpoints for GitHub Actions cache.


Installing the gh cache subcommand to manage your caches from the command line. For more information, see the GitHub CLI documentation.
Note

If you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed.



Viewing cache entries
You can use the web interface to view a list of cache entries for a repository. In the cache list, you can see how much disk space each cache is using, when the cache was created, and when the cache was last used.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, under the "Management" section, click  Caches.


Review the list of cache entries for the repository.

To search for cache entries used for a specific branch, click the Branch dropdown menu and select a branch. The cache list will display all of the caches used for the selected branch.
To search for cache entries with a specific cache key, use the syntax key: key-name in the Filter caches field. The cache list will display caches from all branches where the key was used.




Deleting cache entries
Users with write access to a repository can use the GitHub web interface to delete cache entries.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, under the "Management" section, click  Caches.


To the right of the cache entry you want to delete, click .



Force deleting cache entries
Caches have branch scope restrictions in place, which means some caches have limited usage options. For more information on cache scope restrictions, see Restrictions for accessing a cache, earlier in this article. If caches limited to a specific branch are using a lot of storage quota, it may cause caches from the default branch to be created and deleted at a high frequency.
For example, a repository could have many new pull requests opened, each with their own caches that are restricted to that branch. These caches could take up the majority of the cache storage for that repository. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository. In order to prevent cache thrashing when this happens, you can set up workflows to delete caches on a faster cadence than the cache eviction policy will. You can use the GitHub CLI to delete caches for specific branches.
The following example workflow uses gh cache to delete up to 100 caches created by a branch once a pull request is closed.
To run the following example on cross-repository pull requests or pull requests from forks, you can trigger the workflow with the pull_request_target event. If you do use pull_request_target to trigger the workflow, there are security considerations to keep in mind. For more information, see Events that trigger workflows.
name: cleanup caches by a branch
on:
  pull_request:
    types:
      - closed

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup
        run: |
          echo "Fetching list of cache key"
          cacheKeysForPR=$(gh cache list --ref $BRANCH --limit 100 --json id --jq '.[].id')

          ## Setting this to not fail the workflow while deleting cache keys.
          set +e
          echo "Deleting caches..."
          for cacheKey in $cacheKeysForPR
          do
              gh cache delete $cacheKey
          done
          echo "Done"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          BRANCH: refs/pull/${{ github.event.pull_request.number }}/merge

Alternatively, you can use the API to automatically list or delete all caches on your own cadence. For more information, see REST API endpoints for GitHub Actions cache.\n\n\n\nGitHub Actions/Write workflows/Choose what workflows do/Store artifactsStoring and sharing data from a workflowArtifacts allow you to share data between jobs in a workflow and store data once that workflow has completed.In this articleAbout workflow artifactsComparing artifacts and dependency cachingUploading build and test artifactsGenerating artifact attestations for buildsConfiguring a custom artifact retention periodDownloading or deleting artifactsValidating artifactsPassing data between jobs in a workflowArtifacts from deleted workflow runsFurther readingAbout workflow artifacts
Artifacts allow you to persist data after a job has completed, and share that data with another job in the same workflow. An artifact is a file or collection of files produced during a workflow run. For example, you can use artifacts to save your build and test output after a workflow run has ended. All actions and workflows called within a run have write access to that run's artifacts.
By default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see Usage limits, billing, and administration. The retention period for a pull request restarts each time someone pushes a new commit to the pull request.
These are some of the common artifacts that you can upload:

Log files and core dumps
Test results, failures, and screenshots
Binary or compressed files
Stress test performance output and code coverage results

Storing artifacts uses storage space on GitHub. GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. See Choosing the runner for a job. For private repositories, each GitHub account receives a certain amount of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is controlled by spending limits. For more information, see Managing billing for GitHub Actions.
Artifacts are uploaded during a workflow run, and you can view an artifact's name and size in the UI. When an artifact is downloaded using the GitHub UI, all files that were individually uploaded as part of the artifact get zipped together into a single file. This means that billing is calculated based on the size of the uploaded artifact and not the size of the zip file.
GitHub provides two actions that you can use to upload and download build artifacts. For more information, see the upload-artifact and download-artifact actions.
To share data between jobs:

Uploading files: Give the uploaded file a name and upload the data before the job ends.
Downloading files: You can only download artifacts that were uploaded during the same workflow run. When you download a file, you can reference it by name.

The steps of a job share the same environment on the runner machine, but run in their own individual processes. To pass data between steps in a job, you can use inputs and outputs. For more information about inputs and outputs, see Metadata syntax for GitHub Actions.
Comparing artifacts and dependency caching
Artifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably.

Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.
Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.

For more information on dependency caching, see Caching dependencies to speed up workflows.
Uploading build and test artifacts
You can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, see About continuous integration with GitHub Actions.
The output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage.
You can use the upload-artifact action to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided then artifact will be used as the default name. For more information on syntax, see the actions/upload-artifact action.
Example
For example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in the dist directory, you would deploy the files in the dist directory to your web application server if all tests completed successfully.
|-- hello-world (repository)
|   └── dist
|   └── tests
|   └── src
|       └── sass/app.scss
|       └── app.ts
|   └── output
|       └── test
|

This example shows you how to create a workflow for a Node.js project that builds the code in the src directory and runs the tests in the tests directory. You can assume that running npm test produces a code coverage report named code-coverage.html stored in the output/test/ directory.
The workflow uploads the production artifacts in the dist directory, but excludes any markdown files. It also uploads the code-coverage.html report as another artifact.
YAMLname: Node CI

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: npm install, build, and test
        run: |
          npm install
          npm run build --if-present
          npm test
      - name: Archive production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-without-markdown
          path: |
            dist
            !dist/**/*.md
      - name: Archive code coverage results
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-report
          path: output/test/code-coverage.html
name: Node CI

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: npm install, build, and test
        run: |
          npm install
          npm run build --if-present
          npm test
      - name: Archive production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-without-markdown
          path: |
            dist
            !dist/**/*.md
      - name: Archive code coverage results
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-report
          path: output/test/code-coverage.html

Generating artifact attestations for builds
Artifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.
When you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:

A link to the workflow associated with the artifact.
The repository, organization, environment, commit SHA, and triggering event for the artifact.
Other information from the OIDC token used to establish provenance. For more information, see About security hardening with OpenID Connect.

You can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.
You can access attestations after a build run, underneath the list of the artifacts the build produced.
For more information, see Using artifact attestations to establish provenance for builds.
Configuring a custom artifact retention period
You can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can use retention-days with the upload-artifact action. This example demonstrates how to set a custom retention period of 5 days for the artifact named my-artifact:
YAML  - name: 'Upload Artifact'
    uses: actions/upload-artifact@v4
    with:
      name: my-artifact
      path: my_file.txt
      retention-days: 5
  - name: 'Upload Artifact'
    uses: actions/upload-artifact@v4
    with:
      name: my-artifact
      path: my_file.txt
      retention-days: 5

The retention-days value cannot exceed the retention limit set by the repository, organization, or enterprise.
Downloading or deleting artifacts
During a workflow run, you can use the download-artifact action to download artifacts that were previously uploaded in the same workflow run.
After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see Downloading workflow artifacts, Removing workflow artifacts, and REST API endpoints for GitHub Actions artifacts.
Downloading artifacts during a workflow run
The actions/download-artifact action can be used to download previously uploaded artifacts during a workflow run.
Note

If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. See Download Artifacts from other Workflow Runs or Repositories in the documentation for the download-artifact action.

Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is artifact.
- name: Download a single artifact
  uses: actions/download-artifact@v4
  with:
    name: my-artifact

You can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts.
- name: Download all workflow run artifacts
  uses: actions/download-artifact@v4

If you download all workflow run's artifacts, a directory for each artifact is created using its name.
For more information on syntax, see the actions/download-artifact action.
Validating artifacts
Every time the upload-artifact action is used it returns an output called digest. This is a SHA256 digest of the Artifact you uploaded during a workflow run.
When the download-artifact action is then used to download that artifact, it automatically calculates the digest for that downloaded artifact and validates that it matches the output from the upload-artifact step.
If the digest does not match, the run will display a warning in the UI and in the job logs.
To view the SHA256 digest you can open the logs for the upload-artifact job or check in the Artifact output that appears in the workflow run UI.
Passing data between jobs in a workflow
You can use the upload-artifact and download-artifact actions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see the actions/upload-artifact and download-artifact actions.
Jobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses the needs keyword to ensure that job_1, job_2, and job_3 run sequentially. For example, job_2 requires job_1 using the needs: job_1 syntax.
Job 1 performs these steps:

Performs a math calculation and saves the result to a text file called math-homework.txt.
Uses the upload-artifact action to upload the math-homework.txt file with the artifact name homework_pre.

Job 2 uses the result in the previous job:

Downloads the homework_pre artifact uploaded in the previous job. By default, the download-artifact action downloads artifacts to the workspace directory that the step is executing in. You can use the path input parameter to specify a different download directory.
Reads the value in the math-homework.txt file, performs a math calculation, and saves the result to math-homework.txt again, overwriting its contents.
Uploads the math-homework.txt file. As artifacts are considered immutable in v4, the artifact is passed a different input, homework_final, as a name.

Job 3 displays the result uploaded in the previous job:

Downloads the homework_final artifact from Job 2.
Prints the result of the math equation to the log.

The full math operation performed in this workflow example is (3 + 7) x 9 = 90.
YAMLname: Share data between jobs

on: [push]

jobs:
  job_1:
    name: Add 3 and 7
    runs-on: ubuntu-latest
    steps:
      - shell: bash
        run: |
          expr 3 + 7 > math-homework.txt
      - name: Upload math result for job 1
        uses: actions/upload-artifact@v4
        with:
          name: homework_pre
          path: math-homework.txt

  job_2:
    name: Multiply by 9
    needs: job_1
    runs-on: windows-latest
    steps:
      - name: Download math result for job 1
        uses: actions/download-artifact@v4
        with:
          name: homework_pre
      - shell: bash
        run: |
          value=`cat math-homework.txt`
          expr $value \* 9 > math-homework.txt
      - name: Upload math result for job 2
        uses: actions/upload-artifact@v4
        with:
          name: homework_final
          path: math-homework.txt

  job_3:
    name: Display results
    needs: job_2
    runs-on: macOS-latest
    steps:
      - name: Download math result for job 2
        uses: actions/download-artifact@v4
        with:
          name: homework_final
      - name: Print the final result
        shell: bash
        run: |
          value=`cat math-homework.txt`
          echo The result is $value
name: Share data between jobs

on: [push]

jobs:
  job_1:
    name: Add 3 and 7
    runs-on: ubuntu-latest
    steps:
      - shell: bash
        run: |
          expr 3 + 7 > math-homework.txt
      - name: Upload math result for job 1
        uses: actions/upload-artifact@v4
        with:
          name: homework_pre
          path: math-homework.txt

  job_2:
    name: Multiply by 9
    needs: job_1
    runs-on: windows-latest
    steps:
      - name: Download math result for job 1
        uses: actions/download-artifact@v4
        with:
          name: homework_pre
      - shell: bash
        run: |
          value=`cat math-homework.txt`
          expr $value \* 9 > math-homework.txt
      - name: Upload math result for job 2
        uses: actions/upload-artifact@v4
        with:
          name: homework_final
          path: math-homework.txt

  job_3:
    name: Display results
    needs: job_2
    runs-on: macOS-latest
    steps:
      - name: Download math result for job 2
        uses: actions/download-artifact@v4
        with:
          name: homework_final
      - name: Print the final result
        shell: bash
        run: |
          value=`cat math-homework.txt`
          echo The result is $value

The workflow run will archive any artifacts that it generated. For more information on downloading archived artifacts, see Downloading workflow artifacts.
Artifacts from deleted workflow runs
When a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: Deleting a workflow run, Delete a workflow run, or gh run delete.
Further reading

Managing billing for GitHub Actions.\n\n\n\nGitHub Actions/Write workflows/Workflow syntaxWorkflow syntax for GitHub ActionsA workflow is a configurable automated process made up of one or more jobs. You must create a YAML file to define your workflow configuration.In this articleAbout YAML syntax for workflowsnamerun-nameonon.<event_name>.typeson.<pull_request|pull_request_target>.<branches|branches-ignore>on.push.<branches|tags|branches-ignore|tags-ignore>on.<push|pull_request|pull_request_target>.<paths|paths-ignore>on.scheduleon.workflow_callon.workflow_call.inputson.workflow_call.inputs.<input_id>.typeon.workflow_call.outputson.workflow_call.secretson.workflow_call.secrets.<secret_id>on.workflow_call.secrets.<secret_id>.requiredon.workflow_run.<branches|branches-ignore>on.workflow_dispatchon.workflow_dispatch.inputson.workflow_dispatch.inputs.<input_id>.requiredon.workflow_dispatch.inputs.<input_id>.typepermissionsenvdefaultsdefaults.rundefaults.run.shelldefaults.run.working-directoryconcurrencyjobsjobs.<job_id>jobs.<job_id>.namejobs.<job_id>.permissionsjobs.<job_id>.needsjobs.<job_id>.ifjobs.<job_id>.runs-onjobs.<job_id>.environmentjobs.<job_id>.concurrencyjobs.<job_id>.outputsjobs.<job_id>.envjobs.<job_id>.defaultsjobs.<job_id>.defaults.runjobs.<job_id>.defaults.run.shelljobs.<job_id>.defaults.run.working-directoryjobs.<job_id>.stepsjobs.<job_id>.steps[*].idjobs.<job_id>.steps[*].ifjobs.<job_id>.steps[*].namejobs.<job_id>.steps[*].usesjobs.<job_id>.steps[*].runjobs.<job_id>.steps[*].working-directoryjobs.<job_id>.steps[*].shelljobs.<job_id>.steps[*].withjobs.<job_id>.steps[*].with.argsjobs.<job_id>.steps[*].with.entrypointjobs.<job_id>.steps[*].envjobs.<job_id>.steps[*].continue-on-errorjobs.<job_id>.steps[*].timeout-minutesjobs.<job_id>.timeout-minutesjobs.<job_id>.strategyjobs.<job_id>.strategy.matrixjobs.<job_id>.strategy.matrix.includejobs.<job_id>.strategy.matrix.excludejobs.<job_id>.strategy.fail-fastjobs.<job_id>.strategy.max-paralleljobs.<job_id>.continue-on-errorjobs.<job_id>.containerjobs.<job_id>.container.imagejobs.<job_id>.container.credentialsjobs.<job_id>.container.envjobs.<job_id>.container.portsjobs.<job_id>.container.volumesjobs.<job_id>.container.optionsjobs.<job_id>.servicesjobs.<job_id>.services.<service_id>.imagejobs.<job_id>.services.<service_id>.credentialsjobs.<job_id>.services.<service_id>.envjobs.<job_id>.services.<service_id>.portsjobs.<job_id>.services.<service_id>.volumesjobs.<job_id>.services.<service_id>.optionsjobs.<job_id>.usesjobs.<job_id>.withjobs.<job_id>.with.<input_id>jobs.<job_id>.secretsjobs.<job_id>.secrets.inheritjobs.<job_id>.secrets.<secret_id>Filter pattern cheat sheetAbout YAML syntax for workflows
Workflow files use YAML syntax, and must have either a .yml or .yaml file extension. If you're new to YAML and want to learn more, see Learn YAML in Y minutes.
You must store workflow files in the .github/workflows directory of your repository.
name
The name of the workflow. GitHub displays the names of your workflows under your repository's "Actions" tab. If you omit name, GitHub displays the workflow file path relative to the root of the repository.
run-name
The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's "Actions" tab. If run-name is omitted or is only whitespace, then the run name is set to event-specific information for the workflow run. For example, for a workflow triggered by a push or pull_request event, it is set as the commit message or the title of the pull request.
This value can include expressions and can reference the github and inputs contexts.
Example of run-name
run-name: Deploy to ${{ inputs.deploy_target }} by @${{ github.actor }}

on
To automatically trigger a workflow, use on to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows.
You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections.
Using a single event
For example, a workflow with the following on value will run when a push is made to any branch in the workflow's repository:
on: push

Using multiple events
You can specify a single event or multiple events. For example, a workflow with the following on value will run when a push is made to any branch in the repository or when someone forks the repository:
on: [push, fork]

If you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered.
Using activity types
Some events have activity types that give you more control over when your workflow should run. Use on.<event_name>.types to define the type of event activity that will trigger a workflow run.
For example, the issue_comment event has the created, edited, and deleted activity types. If your workflow triggers on the label event, it will run whenever a label is created, edited, or deleted. If you specify the created activity type for the label event, your workflow will run when a label is created but not when a label is edited or deleted.
on:
  label:
    types:
      - created

If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.
on:
  issues:
    types:
      - opened
      - labeled

For more information about each event and their activity types, see Events that trigger workflows.
Using filters
Some events have filters that give you more control over when your workflow should run.
For example, the push event has a branches filter that causes your workflow to run only when a push to a branch that matches the branches filter occurs, instead of when any push occurs.
on:
  push:
    branches:
      - main
      - 'releases/**'

Using activity types and filters with multiple events
If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon (:) to all events, including events without configuration.
For example, a workflow with the following on value will run when:

A label is created
A push is made to the main branch in the repository
A push is made to a GitHub Pages-enabled branch

on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:

on.<event_name>.types
Use on.<event_name>.types to define the type of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the label is triggered when a label is created, edited, or deleted. The types keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the types keyword is unnecessary.
You can use an array of event types. For more information about each event and their activity types, see Events that trigger workflows.
on:
  label:
    types: [created, edited]

on.<pull_request|pull_request_target>.<branches|branches-ignore>
When using the pull_request and pull_request_target events, you can configure a workflow to run only for pull requests that target specific branches.
Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow.
If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.
The branches and branches-ignore keywords accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \. For more information about glob patterns, see the Workflow syntax for GitHub Actions.
Example: Including branches
The patterns defined in branches are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event for a pull request targeting:

A branch named main (refs/heads/main)
A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name starts with releases/, like releases/10 (refs/heads/releases/10)

on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'

If a workflow is skipped due to branch filtering, path filtering, or a commit message, then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.
Example: Excluding branches
When a pattern matches the branches-ignore pattern, the workflow will not run. The patterns defined in branches-ignore are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a pull_request event unless the pull request is targeting:

A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name matches releases/**-alpha, like releases/beta/3-alpha (refs/heads/releases/beta/3-alpha)

on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'

Example: Including and excluding branches
You cannot use branches and branches-ignore to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded.
If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead.
The order that you define patterns matters.

A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
A matching positive pattern after a negative match will include the Git ref again.

The following workflow will run on pull_request events for pull requests that target releases/10 or releases/beta/mona, but not for pull requests that target releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.
on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

on.push.<branches|tags|branches-ignore|tags-ignore>
When using the push event, you can configure a workflow to run on specific branches or tags.
Use the branches filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the branches-ignore filter when you only want to exclude branch name patterns. You cannot use both the branches and branches-ignore filters for the same event in a workflow.
Use the tags filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the tags-ignore filter when you only want to exclude tag name patterns. You cannot use both the tags and tags-ignore filters for the same event in a workflow.
If you define only tags/tags-ignore or only branches/branches-ignore, the workflow won't run for events affecting the undefined Git ref. If you define neither tags/tags-ignore or branches/branches-ignore, the workflow will run for events affecting either branches or tags. If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.
The branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \. For more information about glob patterns, see the Workflow syntax for GitHub Actions.
Example: Including branches and tags
The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event to:

A branch named main (refs/heads/main)
A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name starts with releases/, like releases/10 (refs/heads/releases/10)
A tag named v2 (refs/tags/v2)
A tag whose name starts with v1., like v1.9.1 (refs/tags/v1.9.1)

on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*

Example: Excluding branches and tags
When a pattern matches the branches-ignore or tags-ignore pattern, the workflow will not run. The patterns defined in branches and tags are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a push event, unless the push event is to:

A branch named mona/octocat (refs/heads/mona/octocat)
A branch whose name matches releases/**-alpha, like releases/beta/3-alpha (refs/heads/releases/beta/3-alpha)
A tag named v2 (refs/tags/v2)
A tag whose name starts with v1., like v1.9 (refs/tags/v1.9)

on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*

Example: Including and excluding branches and tags
You can't use branches and branches-ignore to filter the same event in a single workflow. Similarly, you can't use tags and tags-ignore to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the branches or tags filter along with the ! character to indicate which branches or tags should be excluded.
If you define a branch with the ! character, you must also define at least one branch without the ! character. If you only want to exclude branches, use branches-ignore instead. Similarly, if you define a tag with the ! character, you must also define at least one tag without the ! character. If you only want to exclude tags, use tags-ignore instead.
The order that you define patterns matters.

A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
A matching positive pattern after a negative match will include the Git ref again.

The following workflow will run on pushes to releases/10 or releases/beta/mona, but not on releases/10-alpha or releases/beta/3-alpha because the negative pattern !releases/**-alpha follows the positive pattern.
on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

on.<push|pull_request|pull_request_target>.<paths|paths-ignore>
When using the push and pull_request events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags.
Use the paths filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the paths-ignore filter when you only want to exclude file path patterns. You cannot use both the paths and paths-ignore filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded.
Note

The order that you define paths patterns matters:

A matching negative pattern (prefixed with !) after a positive match will exclude the path.
A matching positive pattern after a negative match will include the path again.


If you define both branches/branches-ignore and paths/paths-ignore, the workflow will only run when both filters are satisfied.
The paths and paths-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions.
Example: Including paths
If at least one path matches a pattern in the paths filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file (.js).
on:
  push:
    paths:
      - '**.js'

If a workflow is skipped due to path filtering, branch filtering, or a commit message, then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.
Example: Excluding paths
When all the path names match patterns in paths-ignore, the workflow will not run. If any path names do not match patterns in paths-ignore, even if some path names match the patterns, the workflow will run.
A workflow with the following path filter will only run on push events that include at least one file outside the docs directory at the root of the repository.
on:
  push:
    paths-ignore:
      - 'docs/**'

Example: Including and excluding paths
You cannot use paths and paths-ignore to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the paths filter prefixed with the ! character to indicate which paths should be excluded.
If you define a path with the ! character, you must also define at least one path without the ! character. If you only want to exclude paths, use paths-ignore instead.
The order that you define paths patterns matters:

A matching negative pattern (prefixed with !) after a positive match will exclude the path.
A matching positive pattern after a negative match will include the path again.

This example runs anytime the push event includes a file in the sub-project directory or its subdirectories, unless the file is in the sub-project/docs directory. For example, a push that changed sub-project/index.js or sub-project/src/index.js will trigger a workflow run, but a push changing only sub-project/docs/readme.md will not.
on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'

Git diff comparisons
Note

If you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run.

The filter determines if a workflow should run by evaluating the changed files and running them against the paths-ignore or paths list. If there are no files changed, the workflow will not run.
GitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:

Pull requests: Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.
Pushes to existing branches: A two-dot diff compares the head and base SHAs directly with each other.
Pushes to new branches: A two-dot diff against the parent of the ancestor of the deepest commit pushed.

Diffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically.
For more information, see About comparing branches in pull requests.
on.schedule
You can use on.schedule to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.
This example triggers the workflow every day at 5:30 and 17:30 UTC:
on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'

A single workflow can be triggered by multiple schedule events. You can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.
on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo "This step will be skipped on Monday and Wednesday"
      - name: Every time
        run: echo "This step will always run"

For more information about cron syntax, see Events that trigger workflows.
on.workflow_call
Use on.workflow_call to define the inputs and outputs for a reusable workflow. You can also map the secrets that are available to the called workflow. For more information on reusable workflows, see Reusing workflows.
on.workflow_call.inputs
When using the workflow_call keyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow. For more information about the workflow_call keyword, see Events that trigger workflows.
In addition to the standard input parameters that are available, on.workflow_call.inputs requires a type parameter. For more information, see on.workflow_call.inputs.<input_id>.type.
If a default parameter is not set, the default value of the input is false for a boolean, 0 for a number, and "" for a string.
Within the called workflow, you can use the inputs context to refer to an input. For more information, see Accessing contextual information about workflow runs.
If a caller workflow passes an input that is not specified in the called workflow, this results in an error.
Example of on.workflow_call.inputs
on:
  workflow_call:
    inputs:
      username:
        description: 'A username passed from the caller workflow'
        default: 'john-doe'
        required: false
        type: string

jobs:
  print-username:
    runs-on: ubuntu-latest

    steps:
      - name: Print the input name to STDOUT
        run: echo The username is ${{ inputs.username }}

For more information, see Reusing workflows.
on.workflow_call.inputs.<input_id>.type
Required if input is defined for the on.workflow_call keyword. The value of this parameter is a string specifying the data type of the input. This must be one of: boolean, number, or string.
on.workflow_call.outputs
A map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optional description, and a value. The value must be set to the value of an output from a job within the called workflow.
In the example below, two outputs are defined for this reusable workflow: workflow_output1 and workflow_output2. These are mapped to outputs called job_output1 and job_output2, both from a job called my_job.
Example of on.workflow_call.outputs
on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      workflow_output1:
        description: "The first job output"
        value: ${{ jobs.my_job.outputs.job_output1 }}
      workflow_output2:
        description: "The second job output"
        value: ${{ jobs.my_job.outputs.job_output2 }}

For information on how to reference a job output, see jobs.<job_id>.outputs. For more information, see Reusing workflows.
on.workflow_call.secrets
A map of the secrets that can be used in the called workflow.
Within the called workflow, you can use the secrets context to refer to a secret.
Note

If you are passing the secret to a nested reusable workflow, then you must use jobs.<job_id>.secrets again to pass the secret. For more information, see Reusing workflows.

If a caller workflow passes a secret that is not specified in the called workflow, this results in an error.
Example of on.workflow_call.secrets
on:
  workflow_call:
    secrets:
      access-token:
        description: 'A token passed from the caller workflow'
        required: false

jobs:

  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
    # passing the secret to an action
      - name: Pass the received secret to an action
        uses: ./.github/actions/my-action
        with:
          token: ${{ secrets.access-token }}

  # passing the secret to a nested reusable workflow
  pass-secret-to-workflow:
    uses: ./.github/workflows/my-workflow
    secrets:
       token: ${{ secrets.access-token }}

on.workflow_call.secrets.<secret_id>
A string identifier to associate with the secret.
on.workflow_call.secrets.<secret_id>.required
A boolean specifying whether the secret must be supplied.
on.workflow_run.<branches|branches-ignore>
When using the workflow_run event, you can specify what branches the triggering workflow must run on in order to trigger your workflow.
The branches and branches-ignore filters accept glob patterns that use characters like *, **, +, ?, ! and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with \. For more information about glob patterns, see the Workflow syntax for GitHub Actions.
For example, a workflow with the following trigger will only run when the workflow named Build runs on a branch whose name starts with releases/:
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches:
      - 'releases/**'

A workflow with the following trigger will only run when the workflow named Build runs on a branch that is not named canary:
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches-ignore:
      - "canary"

You cannot use both the branches and branches-ignore filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the branches filter along with the ! character to indicate which branches should be excluded.
The order that you define patterns matters.

A matching negative pattern (prefixed with !) after a positive match will exclude the branch.
A matching positive pattern after a negative match will include the branch again.

For example, a workflow with the following trigger will run when the workflow named Build runs on a branch that is named releases/10 or releases/beta/mona but will not releases/10-alpha, releases/beta/3-alpha, or main.
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

on.workflow_dispatch
When using the workflow_dispatch event, you can optionally specify inputs that are passed to the workflow.
This trigger only receives events when the workflow file is on the default branch.
on.workflow_dispatch.inputs
The triggered workflow receives the inputs in the inputs context. For more information, see Contexts.
Note


The workflow will also receive the inputs in the github.event.inputs context. The information in the inputs context and github.event.inputs context is identical except that the inputs context preserves Boolean values as Booleans instead of converting them to strings. The choice type resolves to a string and is a single selectable option.
The maximum number of top-level properties for inputs is 10.
The maximum payload for inputs is 65,535 characters.


Example of on.workflow_dispatch.inputs
on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
      print_tags:
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    if: ${{ inputs.print_tags }} 
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }} 

on.workflow_dispatch.inputs.<input_id>.required
A boolean specifying whether the input must be supplied.
on.workflow_dispatch.inputs.<input_id>.type
The value of this parameter is a string specifying the data type of the input. This must be one of: boolean, choice, number, environment or string.
permissions
You can use permissions to modify the default permissions granted to the GITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication.
You can use permissions either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the permissions key within a specific job, all actions and run commands within that job that use the GITHUB_TOKEN gain the access rights you specify. For more information, see jobs.<job_id>.permissions.
For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write, or none. write includes read. If you specify the access for any of these permissions, all of those that are not specified are set to none.
Available permissions and details of what each allows an action to do:





























































































PermissionAllows an action using GITHUB_TOKEN toactionsWork with GitHub Actions. For example, actions: write permits an action to cancel a workflow run. For more information, see Permissions required for GitHub Apps.attestationsWork with artifact attestations. For example, attestations: write permits an action to generate an artifact attestation for a build. For more information, see Using artifact attestations to establish provenance for buildschecksWork with check runs and check suites. For example, checks: write permits an action to create a check run. For more information, see Permissions required for GitHub Apps.contentsWork with the contents of the repository. For example, contents: read permits an action to list the commits, and contents: write allows the action to create a release. For more information, see Permissions required for GitHub Apps.deploymentsWork with deployments. For example, deployments: write permits an action to create a new deployment. For more information, see Permissions required for GitHub Apps.discussionsWork with GitHub Discussions. For example, discussions: write permits an action to close or delete a discussion. For more information, see Using the GraphQL API for Discussions.id-tokenFetch an OpenID Connect (OIDC) token. This requires id-token: write. For more information, see About security hardening with OpenID ConnectissuesWork with issues. For example, issues: write permits an action to add a comment to an issue. For more information, see Permissions required for GitHub Apps.modelsGenerate AI inference responses with GitHub Models. For example, models: read permits an action to use the GitHub Models inference API. See Prototyping with AI models.packagesWork with GitHub Packages. For example, packages: write permits an action to upload and publish packages on GitHub Packages. For more information, see About permissions for GitHub Packages.pagesWork with GitHub Pages. For example, pages: write permits an action to request a GitHub Pages build. For more information, see Permissions required for GitHub Apps.pull-requestsWork with pull requests. For example, pull-requests: write permits an action to add a label to a pull request. For more information, see Permissions required for GitHub Apps.security-eventsWork with GitHub code scanning and Dependabot alerts. For example, security-events: read permits an action to list the Dependabot alerts for the repository, and security-events: write allows an action to update the status of a code scanning alert. For more information, see Repository permissions for 'Code scanning alerts' and Repository permissions for 'Dependabot alerts' in "Permissions required for GitHub Apps."statusesWork with commit statuses. For example, statuses:read permits an action to list the commit statuses for a given reference. For more information, see Permissions required for GitHub Apps.
Defining access for the GITHUB_TOKEN scopes
You can define the access that the GITHUB_TOKEN will permit by specifying read, write, or none as the value of the available permissions within the permissions key.
permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none

If you specify the access for any of these permissions, all of those that are not specified are set to none.
You can use the following syntax to define one of read-all or write-all access for all of the available permissions:
permissions: read-all

permissions: write-all

You can use the following syntax to disable permissions for all of the available permissions:
permissions: {}

Changing the permissions in a forked repository
You can use the permissions key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.
Setting the GITHUB_TOKEN permissions for all jobs in a workflow
You can specify permissions at the top level of a workflow, so that the setting applies to all jobs in the workflow.
Example: Setting the GITHUB_TOKEN permissions for an entire workflow
This example shows permissions being set for the GITHUB_TOKEN that will apply to all jobs in the workflow. All permissions are granted read access.
name: "My workflow"

on: [ push ]

permissions: read-all

jobs:
  ...

env
A map of variables that are available to the steps of all jobs in the workflow. You can also set variables that are only available to the steps of a single job or to a single step. For more information, see jobs.<job_id>.env and jobs.<job_id>.steps[*].env.
Variables in the env map cannot be defined in terms of other variables in the map.
When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.
Example of env
env:
  SERVER: production

defaults
Use defaults to create a map of default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, see jobs.<job_id>.defaults.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
defaults.run
You can use defaults.run to provide default shell and working-directory options for all run steps in a workflow. You can also set default settings for run that are only available to a job. For more information, see jobs.<job_id>.defaults.run. You cannot use contexts or expressions in this keyword.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
Example: Set the default shell and working directory
defaults:
  run:
    shell: bash
    working-directory: ./scripts

defaults.run.shell
Use shell to define the shell for a step. This keyword can reference several contexts. For more information, see Contexts.



























































Supported platformshell parameterDescriptionCommand run internallyLinux / macOSunspecifiedThe default shell on non-Windows platforms. Note that this runs a different command to when bash is specified explicitly. If bash is not found in the path, this is treated as sh.bash -e {0}AllbashThe default shell on non-Windows platforms with a fallback to sh. When specifying a bash shell on Windows, the bash shell included with Git for Windows is used.bash --noprofile --norc -eo pipefail {0}AllpwshThe PowerShell Core. GitHub appends the extension .ps1 to your script name.pwsh -command ". '{0}'"AllpythonExecutes the python command.python {0}Linux / macOSshThe fallback behavior for non-Windows platforms if no shell is provided and bash is not found in the path.sh -e {0}WindowscmdGitHub appends the extension .cmd to your script name and substitutes for {0}.%ComSpec% /D /E:ON /V:OFF /S /C "CALL "{0}"".WindowspwshThis is the default shell used on Windows. The PowerShell Core. GitHub appends the extension .ps1 to your script name. If your self-hosted Windows runner does not have PowerShell Core installed, then PowerShell Desktop is used instead.pwsh -command ". '{0}'".WindowspowershellThe PowerShell Desktop. GitHub appends the extension .ps1 to your script name.powershell -command ". '{0}'".
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
defaults.run.working-directory
Use working-directory to define the working directory for the shell for a step. This keyword can reference several contexts. For more information, see Contexts.
Tip

Ensure the working-directory you assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

concurrency
Use concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use github, inputs and vars contexts. For more information about expressions, see Evaluate expressions in workflows and actions.
You can also specify concurrency at the job level. For more information, see jobs.<job_id>.concurrency.
This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.
To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts.
Note


The concurrency group name is case insensitive. For example, prod and Prod will be treated as the same concurrency group.
Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.


Example: Using concurrency and the default behavior
The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs.
For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:
on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:
on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true

Example: Concurrency groups
Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.
The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables.
It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.
This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.
In this example, job-1 is part of a concurrency group named staging_environment. This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.
jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true

Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:
on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

Example: Using concurrency to cancel any in-progress job or run
To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true:
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

Note that in this example, without defining a particular concurrency group, GitHub Actions will cancel any in-progress run of the job or workflow.
Example: Using a fallback value
If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.
concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

Example: Only cancel in-progress jobs or runs for the current workflow
If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.
To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

Example: Only cancel in-progress jobs on specific branches
If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.
To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}

In this example, multiple pushes to a release/1.2.3 branch would not cancel in-progress runs. Pushes to another branch, such as main, would cancel in-progress runs.
jobs
A workflow run is made up of one or more jobs, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
Each job runs in a runner environment specified by runs-on.
You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and Usage limits for self-hosted runners for self-hosted runner usage limits.
If you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, see REST API endpoints for GitHub Actions.
jobs.<job_id>
Use jobs.<job_id> to give your job a unique identifier. The key job_id is a string and its value is a map of the job's configuration data. You must replace <job_id> with a string that is unique to the jobs object. The <job_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.
Example: Creating jobs
In this example, two jobs have been created, and their job_id values are my_first_job and my_second_job.
jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job

jobs.<job_id>.name
Use jobs.<job_id>.name to set a name for the job, which is displayed in the GitHub UI.
jobs.<job_id>.permissions
For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the GITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication.
By specifying the permission within a job definition, you can configure a different set of permissions for the GITHUB_TOKEN for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see permissions.
For each of the available permissions, shown in the table below, you can assign one of the access levels: read (if applicable), write, or none. write includes read. If you specify the access for any of these permissions, all of those that are not specified are set to none.
Available permissions and details of what each allows an action to do:





























































































PermissionAllows an action using GITHUB_TOKEN toactionsWork with GitHub Actions. For example, actions: write permits an action to cancel a workflow run. For more information, see Permissions required for GitHub Apps.attestationsWork with artifact attestations. For example, attestations: write permits an action to generate an artifact attestation for a build. For more information, see Using artifact attestations to establish provenance for buildschecksWork with check runs and check suites. For example, checks: write permits an action to create a check run. For more information, see Permissions required for GitHub Apps.contentsWork with the contents of the repository. For example, contents: read permits an action to list the commits, and contents: write allows the action to create a release. For more information, see Permissions required for GitHub Apps.deploymentsWork with deployments. For example, deployments: write permits an action to create a new deployment. For more information, see Permissions required for GitHub Apps.discussionsWork with GitHub Discussions. For example, discussions: write permits an action to close or delete a discussion. For more information, see Using the GraphQL API for Discussions.id-tokenFetch an OpenID Connect (OIDC) token. This requires id-token: write. For more information, see About security hardening with OpenID ConnectissuesWork with issues. For example, issues: write permits an action to add a comment to an issue. For more information, see Permissions required for GitHub Apps.modelsGenerate AI inference responses with GitHub Models. For example, models: read permits an action to use the GitHub Models inference API. See Prototyping with AI models.packagesWork with GitHub Packages. For example, packages: write permits an action to upload and publish packages on GitHub Packages. For more information, see About permissions for GitHub Packages.pagesWork with GitHub Pages. For example, pages: write permits an action to request a GitHub Pages build. For more information, see Permissions required for GitHub Apps.pull-requestsWork with pull requests. For example, pull-requests: write permits an action to add a label to a pull request. For more information, see Permissions required for GitHub Apps.security-eventsWork with GitHub code scanning and Dependabot alerts. For example, security-events: read permits an action to list the Dependabot alerts for the repository, and security-events: write allows an action to update the status of a code scanning alert. For more information, see Repository permissions for 'Code scanning alerts' and Repository permissions for 'Dependabot alerts' in "Permissions required for GitHub Apps."statusesWork with commit statuses. For example, statuses:read permits an action to list the commit statuses for a given reference. For more information, see Permissions required for GitHub Apps.
Defining access for the GITHUB_TOKEN scopes
You can define the access that the GITHUB_TOKEN will permit by specifying read, write, or none as the value of the available permissions within the permissions key.
permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none

If you specify the access for any of these permissions, all of those that are not specified are set to none.
You can use the following syntax to define one of read-all or write-all access for all of the available permissions:
permissions: read-all

permissions: write-all

You can use the following syntax to disable permissions for all of the available permissions:
permissions: {}

Changing the permissions in a forked repository
You can use the permissions key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.
Example: Setting the GITHUB_TOKEN permissions for one job in a workflow
This example shows permissions being set for the GITHUB_TOKEN that will only apply to the job named stale. Write access is granted for the issues and pull-requests permissions. All other permissions will have no access.
jobs:
  stale:
    runs-on: ubuntu-latest

    permissions:
      issues: write
      pull-requests: write

    steps:
      - uses: actions/stale@v9

jobs.<job_id>.needs
Use jobs.<job_id>.needs to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the always() conditional expression in jobs.<job_id>.if.
Example: Requiring successful dependent jobs
jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]

In this example, job1 must complete successfully before job2 begins, and job3 waits for both job1 and job2 to complete.
The jobs in this example run sequentially:

job1
job2
job3

Example: Not requiring successful dependent jobs
jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]

In this example, job3 uses the always() conditional expression so that it always runs after job1 and job2 have completed, regardless of whether they were successful. For more information, see Evaluate expressions in workflows and actions.
jobs.<job_id>.if
You can use the jobs.<job_id>.if conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs.
Note

The jobs.<job_id>.if condition is evaluated before jobs.<job_id>.strategy.matrix is applied.

When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere.
You must always use the ${{ }} expression syntax or escape with '', "", or () when the expression starts with !, since ! is reserved notation in YAML format. For example:
if: ${{ ! startsWith(github.ref, 'refs/tags/') }}

For more information, see Evaluate expressions in workflows and actions.
Example: Only run job for specific repository
This example uses if to control when the production-deploy job can run. It will only run if the repository is named octo-repo-prod and is within the octo-org organization. Otherwise, the job will be marked as skipped.
YAMLname: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats

jobs.<job_id>.runs-on
Use jobs.<job_id>.runs-on to define the type of machine to run the job on.

The destination machine can be either a GitHub-hosted runner, larger runner, or a self-hosted runner.



You can target runners based on the labels assigned to them, or their group membership, or a combination of these.


You can provide runs-on as:

A single string
A single variable containing a string
An array of strings, variables containing strings, or a combination of both
A key: value pair using the group or labels keys



If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified runs-on values. For example, here the job will only run on a self-hosted runner that has the labels linux, x64, and gpu:
runs-on: [self-hosted, linux, x64, gpu]

For more information, see Choosing self-hosted runners.


You can mix strings and variables in an array. For example:
on:
  workflow_dispatch:
    inputs:
      chosen-os:
        required: true
        type: choice
        options:
        - Ubuntu
        - macOS

jobs:
  test:
    runs-on: [self-hosted, "${{ inputs.chosen-os }}"]
    steps:
    - run: echo Hello world!



If you would like to run your workflow on multiple machines, use jobs.<job_id>.strategy.


Note

Quotation marks are not required around simple strings like self-hosted, but they are required for expressions like  "${{ inputs.chosen-os }}".

Choosing GitHub-hosted runners
If you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by runs-on.
The value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.
For more information, see About GitHub-hosted runners.
Standard GitHub-hosted runners for public repositories
For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.


  
    
      Virtual Machine
      Processor (CPU)
      Memory (RAM)
      Storage (SSD)
      Architecture
      Workflow label
    
  
  
    
      Linux
      4
      16 GB
      14 GB
       x64 
      
        ubuntu-latest,
        ubuntu-24.04,
        ubuntu-22.04,
        ubuntu-20.04
      
    
    
      Windows
      4
      16 GB
      14 GB
       x64 
      
        windows-latest,
         windows-2025,
        windows-2022,
        windows-2019
      
    
    
      Linux [Public preview]
      4
      16 GB
      14 GB
       arm64 
      
        ubuntu-24.04-arm,
        ubuntu-22.04-arm
      
    
    
      Windows [Public preview]
      4
      16 GB
      14 GB
      arm64
      
        windows-11-arm
      
    
    
      macOS
      4
      14 GB
      14 GB
       Intel 
      
        macos-13
      
    
    
      macOS
      3 (M1)
      7 GB
      14 GB
       arm64 
      
        macos-latest,
        macos-14,
        macos-15
      
    
  
Note
 The arm64 Linux and Windows runners are in public preview and subject to change.

Standard GitHub-hosted runners for  private repositories
For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions.

  
    
      Virtual Machine
      Processor (CPU)
      Memory (RAM)
      Storage (SSD)
      Architecture
      Workflow label
    
  
  
    
      Linux
      2
      7 GB
      14 GB
       x64 
      
        ubuntu-latest,
        ubuntu-24.04,
        ubuntu-22.04,
        ubuntu-20.04
      
    
    
      Windows
      2
      7 GB
      14 GB
       x64 
      
        windows-latest,
        windows-2025,
        windows-2022,
        windows-2019
      
    
    
      macOS
      4
      14 GB
      14 GB
       Intel 
      
        macos-13
      
    
    
      macOS
      3 (M1)
      7 GB
      14 GB
       arm64 
      
        macos-latest,
        macos-14,
        macos-15
      
    
  

In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners.
Note

The -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.

Warning

Beta and Deprecated Images are provided "as-is", "with all faults" and "as available" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.

Example: Specifying an operating system
runs-on: ubuntu-latest

For more information, see Using GitHub-hosted runners.
Choosing self-hosted runners
To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels.
Self-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted. You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.
Note that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.
Example: Using labels for runner selection
runs-on: [self-hosted, linux]

For more information, see About self-hosted runners and Using self-hosted runners in a workflow.
Choosing runners in a group
You can use runs-on to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.
Runner groups can only have larger runners or self-hosted runners as members.
Example: Using groups to control where jobs are run
In this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

Example: Combining groups and labels
When you combine groups and labels, the runner must meet both requirements to be eligible to run the job.
In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

jobs.<job_id>.environment
Use jobs.<job_id>.environment to define the environment that the job references.
You can provide the environment as only the environment name, or as an environment object with the name and url. The URL maps to environment_url in the deployments API. For more information about the deployments API, see REST API endpoints for repositories.
Note

All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see Managing environments for deployment.

Example: Using a single environment name
environment: staging_environment

Example: Using environment name and URL
environment:
  name: production_environment
  url: https://github.com

The value of url can be an expression. Allowed expression contexts: github, inputs, vars, needs, strategy, matrix, job, runner, env, and steps. For more information about expressions, see Evaluate expressions in workflows and actions.
Example: Using output as URL
environment:
  name: production_environment
  url: ${{ steps.step_id.outputs.url_output }}

The value of name can be an expression. Allowed expression contexts: github, inputs, vars, needs, strategy, and matrix. For more information about expressions, see Evaluate expressions in workflows and actions.
Example: Using an expression as environment name
environment:
  name: ${{ github.ref_name }}

jobs.<job_id>.concurrency
You can use jobs.<job_id>.concurrency to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: github, inputs, vars, needs, strategy, and matrix. For more information about expressions, see Evaluate expressions in workflows and actions.
You can also specify concurrency at the workflow level. For more information, see concurrency.
This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any existing pending job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.
To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify cancel-in-progress as an expression with any of the allowed expression contexts.
Note


The concurrency group name is case insensitive. For example, prod and Prod will be treated as the same concurrency group.
Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.


Example: Using concurrency and the default behavior
The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The concurrency keyword allows you to control the concurrency of workflow runs.
For example, you can use the concurrency keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:
on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

You can also limit the concurrency of jobs within a workflow by using the concurrency keyword at the job level:
on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true

Example: Concurrency groups
Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.
The concurrency key is used to group workflows or jobs together into a concurrency group. When you define a concurrency key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same concurrency key, GitHub Actions will cancel any workflow or job already running with that key. The concurrency key can be a hard-coded string, or it can be a dynamic expression that includes context variables.
It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.
This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.
In this example, job-1 is part of a concurrency group named staging_environment. This means that if a new run of job-1 is triggered, any runs of the same job in the staging_environment concurrency group that are already in progress will be cancelled.
jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true

Alternatively, using a dynamic expression such as concurrency: ci-${{ github.ref }} in your workflow means that the workflow or job would be part of a concurrency group named ci- followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:
on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

Example: Using concurrency to cancel any in-progress job or run
To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the concurrency key with the cancel-in-progress option set to true:
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

Note that in this example, without defining a particular concurrency group, GitHub Actions will cancel any in-progress run of the job or workflow.
Example: Using a fallback value
If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, github.head_ref is only defined on pull_request events. If your workflow responds to other events in addition to pull_request events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on pull_request events only; if github.head_ref is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.
concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

Example: Only cancel in-progress jobs or runs for the current workflow
If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.
To only cancel in-progress runs of the same workflow, you can use the github.workflow property to build the concurrency group:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

Example: Only cancel in-progress jobs on specific branches
If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with cancel-in-progress. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.
To only cancel in-progress runs of the same workflow when not running on a release branch, you can set cancel-in-progress to an expression similar to the following:
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}

In this example, multiple pushes to a release/1.2.3 branch would not cancel in-progress runs. Pushes to another branch, such as main, would cancel in-progress runs.
jobs.<job_id>.outputs
You can use jobs.<job_id>.outputs to create a map of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see jobs.<job_id>.needs.
Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.
Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions.
If an output is skipped because it may contain a secret, you will see the following warning message: "Skip output {output.Key} since it may contain secret." For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows.
To use job outputs in a dependent job, you can use the needs context. For more information, see Accessing contextual information about workflow runs.
Example: Defining outputs for a job
jobs:
  job1:
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      output1: ${{ steps.step1.outputs.test }}
      output2: ${{ steps.step2.outputs.test }}
    steps:
      - id: step1
        run: echo "test=hello" >> "$GITHUB_OUTPUT"
      - id: step2
        run: echo "test=world" >> "$GITHUB_OUTPUT"
  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - env:
          OUTPUT1: ${{needs.job1.outputs.output1}}
          OUTPUT2: ${{needs.job1.outputs.output2}}
        run: echo "$OUTPUT1 $OUTPUT2"

Using Job Outputs in a Matrix Job
Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.
jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      output_1: ${{ steps.gen_output.outputs.output_1 }}
      output_2: ${{ steps.gen_output.outputs.output_2 }}
      output_3: ${{ steps.gen_output.outputs.output_3 }}
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - name: Generate output
        id: gen_output
        run: |
          version="${{ matrix.version }}"
          echo "output_${version}=${version}" >> "$GITHUB_OUTPUT"
  job2:
    runs-on: ubuntu-latest
    needs: [job1]
    steps:
      # Will show
      # {
      #   "output_1": "1",
      #   "output_2": "2",
      #   "output_3": "3"
      # }
      - run: echo '${{ toJSON(needs.job1.outputs) }}'

Warning

Actions does not guarantee the order that matrix jobs will run in. Ensure that the output name is unique, otherwise the last matrix job that runs will override the output value.

jobs.<job_id>.env
A map of variables that are available to all steps in the job. You can set variables for the entire workflow or an individual step. For more information, see env and jobs.<job_id>.steps[*].env.
When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.
Example of jobs.<job_id>.env
jobs:
  job1:
    env:
      FIRST_NAME: Mona

jobs.<job_id>.defaults
Use jobs.<job_id>.defaults to create a map of default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, see defaults.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
jobs.<job_id>.defaults.run
Use jobs.<job_id>.defaults.run to provide default shell and working-directory to all run steps in the job.
You can provide default shell and working-directory options for all run steps in a job. You can also set default settings for run for the entire workflow. For more information, see defaults.run.
These can be overriden at the jobs.<job_id>.defaults.run and jobs.<job_id>.steps[*].run levels.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
jobs.<job_id>.defaults.run.shell
Use shell to define the shell for a step. This keyword can reference several contexts. For more information, see Contexts.



























































Supported platformshell parameterDescriptionCommand run internallyLinux / macOSunspecifiedThe default shell on non-Windows platforms. Note that this runs a different command to when bash is specified explicitly. If bash is not found in the path, this is treated as sh.bash -e {0}AllbashThe default shell on non-Windows platforms with a fallback to sh. When specifying a bash shell on Windows, the bash shell included with Git for Windows is used.bash --noprofile --norc -eo pipefail {0}AllpwshThe PowerShell Core. GitHub appends the extension .ps1 to your script name.pwsh -command ". '{0}'"AllpythonExecutes the python command.python {0}Linux / macOSshThe fallback behavior for non-Windows platforms if no shell is provided and bash is not found in the path.sh -e {0}WindowscmdGitHub appends the extension .cmd to your script name and substitutes for {0}.%ComSpec% /D /E:ON /V:OFF /S /C "CALL "{0}"".WindowspwshThis is the default shell used on Windows. The PowerShell Core. GitHub appends the extension .ps1 to your script name. If your self-hosted Windows runner does not have PowerShell Core installed, then PowerShell Desktop is used instead.pwsh -command ". '{0}'".WindowspowershellThe PowerShell Desktop. GitHub appends the extension .ps1 to your script name.powershell -command ". '{0}'".
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.
jobs.<job_id>.defaults.run.working-directory
Use working-directory to define the working directory for the shell for a step. This keyword can reference several contexts. For more information, see Contexts.
Tip

Ensure the working-directory you assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

Example: Setting default run step options for a job
jobs:
  job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts

jobs.<job_id>.steps
A job contains a sequence of tasks called steps. Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job.
GitHub only displays the first 1,000 checks, however, you can run an unlimited number of steps as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and Usage limits for self-hosted runners for self-hosted runner usage limits.
Example of jobs.<job_id>.steps
name: Greeting from Mona

on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - name: Print a greeting
        env:
          MY_VAR: Hi there! My name is
          FIRST_NAME: Mona
          MIDDLE_NAME: The
          LAST_NAME: Octocat
        run: |
          echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.

jobs.<job_id>.steps[*].id
A unique identifier for the step. You can use the id to reference the step in contexts. For more information, see Accessing contextual information about workflow runs.
jobs.<job_id>.steps[*].if
You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs.
When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere.
You must always use the ${{ }} expression syntax or escape with '', "", or () when the expression starts with !, since ! is reserved notation in YAML format. For example:
if: ${{ ! startsWith(github.ref, 'refs/tags/') }}

For more information, see Evaluate expressions in workflows and actions.
Example: Using contexts
This step only runs when the event type is a pull_request and the event action is unassigned.
steps:
  - name: My first step
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}
    run: echo This event is a pull request that had an assignee removed.

Example: Using status check functions
The my backup step only runs when the previous step of a job fails. For more information, see Evaluate expressions in workflows and actions.
steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0

Example: Using secrets
Secrets cannot be directly referenced in if: conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job.
If a secret has not been set, the return value of an expression referencing the secret (such as ${{ secrets.SuperSecret }} in the example) will be an empty string.
name: Run a step if a secret has been set
on: push
jobs:
  my-jobname:
    runs-on: ubuntu-latest
    env:
      super_secret: ${{ secrets.SuperSecret }}
    steps:
      - if: ${{ env.super_secret != '' }}
        run: echo 'This step will only run if the secret has a value set.'
      - if: ${{ env.super_secret == '' }}
        run: echo 'This step will only run if the secret does not have a value set.'

For more information, see Accessing contextual information about workflow runs and Using secrets in GitHub Actions.
jobs.<job_id>.steps[*].name
A name for your step to display on GitHub.
jobs.<job_id>.steps[*].uses
Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image.
We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update.

Using the commit SHA of a released action version is the safest for stability and security.
If the action publishes major version tags, you should expect to receive critical fixes and security patches while still retaining compatibility. Note that this behavior is at the discretion of the action's author.
Using the default branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break.

Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required.
Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see runs-on.
Example: Using versioned actions
steps:
  # Reference a specific commit
  - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
  # Reference the major version of a release
  - uses: actions/checkout@v4
  # Reference a specific version
  - uses: actions/checkout@v4.2.0
  # Reference a branch
  - uses: actions/checkout@main

Example: Using a public action
{owner}/{repo}@{ref}
You can specify a branch, ref, or SHA in a public GitHub repository.
jobs:
  my_first_job:
    steps:
      - name: My first step
        # Uses the default branch of a public repository
        uses: actions/heroku@main
      - name: My second step
        # Uses a specific version tag of a public repository
        uses: actions/aws@v2.0.1

Example: Using a public action in a subdirectory
{owner}/{repo}/{path}@{ref}
A subdirectory in a public GitHub repository at a specific branch, ref, or SHA.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/aws/ec2@main

Example: Using an action in the same repository as the workflow
./path/to/dir
The path to the directory that contains the action in your workflow's repository. You must check out your repository before using the action.
Example repository file structure:
|-- hello-world (repository)
|   |__ .github
|       └── workflows
|           └── my-first-workflow.yml
|       └── actions
|           |__ hello-world-action
|               └── action.yml

The path is relative (./) to the default working directory (github.workspace, $GITHUB_WORKSPACE). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated.
Example workflow file:
jobs:
  my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action

Example: Using a Docker Hub action
docker://{image}:{tag}
A Docker image published on Docker Hub.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8

Example: Using the GitHub Packages Container registry
docker://{host}/{image}:{tag}
A public Docker image in the GitHub Packages Container registry.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://ghcr.io/OWNER/IMAGE_NAME

Example: Using a Docker public registry action
docker://{host}/{image}:{tag}
A Docker image in a public registry. This example uses the Google Container Registry at gcr.io.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: docker://gcr.io/cloud-builders/gradle

Example: Using an action inside a different private repository than the workflow
Your workflow must checkout the private repository and reference the action locally. Generate a personal access token and add the token as a secret. For more information, see Managing your personal access tokens and Using secrets in GitHub Actions.
Replace PERSONAL_ACCESS_TOKEN in the example with the name of your secret.
jobs:
  my_first_job:
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          repository: octocat/my-private-repo
          ref: v1.0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          path: ./.github/actions/my-private-repo
      - name: Run my action
        uses: ./.github/actions/my-private-repo/my-action

Alternatively, use a GitHub App instead of a personal access token in order to ensure your workflow continues to run even if the personal access token owner leaves. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow.
jobs.<job_id>.steps[*].run
Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a name, the step name will default to the text specified in the run command.
Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see jobs.<job_id>.steps[*].shell.
Each run keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example:


A single-line command:
- name: Install Dependencies
  run: npm install



A multi-line command:
- name: Clean install dependencies and build
  run: |
    npm ci
    npm run build



jobs.<job_id>.steps[*].working-directory
Using the working-directory keyword, you can specify the working directory of where to run the command.
- name: Clean temp directory
  run: rm -rf *
  working-directory: ./temp

Alternatively, you can specify a default working directory for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.working-directory and jobs.<job_id>.defaults.run.working-directory.
You can also use a run step to run a script. For more information, see Adding scripts to your workflow.
jobs.<job_id>.steps[*].shell
You can override the default shell settings in the runner's operating system and the job's default using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the run keyword.



























































Supported platformshell parameterDescriptionCommand run internallyLinux / macOSunspecifiedThe default shell on non-Windows platforms. Note that this runs a different command to when bash is specified explicitly. If bash is not found in the path, this is treated as sh.bash -e {0}AllbashThe default shell on non-Windows platforms with a fallback to sh. When specifying a bash shell on Windows, the bash shell included with Git for Windows is used.bash --noprofile --norc -eo pipefail {0}AllpwshThe PowerShell Core. GitHub appends the extension .ps1 to your script name.pwsh -command ". '{0}'"AllpythonExecutes the python command.python {0}Linux / macOSshThe fallback behavior for non-Windows platforms if no shell is provided and bash is not found in the path.sh -e {0}WindowscmdGitHub appends the extension .cmd to your script name and substitutes for {0}.%ComSpec% /D /E:ON /V:OFF /S /C "CALL "{0}"".WindowspwshThis is the default shell used on Windows. The PowerShell Core. GitHub appends the extension .ps1 to your script name. If your self-hosted Windows runner does not have PowerShell Core installed, then PowerShell Desktop is used instead.pwsh -command ". '{0}'".WindowspowershellThe PowerShell Desktop. GitHub appends the extension .ps1 to your script name.powershell -command ". '{0}'".
Alternatively, you can specify a default shell for all run steps in a job, or for all run steps in the entire workflow. For more information, see defaults.run.shell and jobs.<job_id>.defaults.run.shell.
Example: Running a command using Bash
steps:
  - name: Display the path
    shell: bash
    run: echo $PATH

Example: Running a command using Windows cmd
steps:
  - name: Display the path
    shell: cmd
    run: echo %PATH%

Example: Running a command using PowerShell Core
steps:
  - name: Display the path
    shell: pwsh
    run: echo ${env:PATH}

Example: Using PowerShell Desktop to run a command
steps:
  - name: Display the path
    shell: powershell
    run: echo ${env:PATH}

Example: Running an inline Python script
steps:
  - name: Display the path
    shell: python
    run: |
      import os
      print(os.environ['PATH'])

Custom shell
You can set the shell value to a template string using command [options] {0} [more_options]. GitHub interprets the first whitespace-delimited word of the string as the command, and inserts the file name for the temporary script at {0}.
For example:
steps:
  - name: Display the environment variables and their values
    shell: perl {0}
    run: |
      print %ENV

The command used, perl in this example, must be installed on the runner.
For information about the software included on GitHub-hosted runners, see Using GitHub-hosted runners.
Exit codes and error action preference
For built-in shell keywords, we provide the following defaults that are executed by GitHub-hosted runners. You should use these guidelines when running shell scripts.


bash/sh:

By default, fail-fast behavior is enforced using set -e for both sh and bash. When shell: bash is specified, -o pipefail is also applied to enforce early exit from pipelines that generate a non-zero exit status.
You can take full control over shell parameters by providing a template string to the shell options. For example, bash {0}.
sh-like shells exit with the exit code of the last command executed in a script, which is also the default behavior for actions. The runner will report the status of the step as fail/succeed based on this exit code.



powershell/pwsh

Fail-fast behavior when possible. For pwsh and powershell built-in shell, we will prepend $ErrorActionPreference = 'stop' to script contents.
We append if ((Test-Path -LiteralPath variable:\LASTEXITCODE)) { exit $LASTEXITCODE } to powershell scripts so action statuses reflect the script's last exit code.
Users can always opt out by not using the built-in shell, and providing a custom shell option like: pwsh -File {0}, or powershell -Command "& '{0}'", depending on need.



cmd

There doesn't seem to be a way to fully opt into fail-fast behavior other than writing your script to check each error code and respond accordingly. Because we can't actually provide that behavior by default, you need to write this behavior into your script.
cmd.exe will exit with the error level of the last program it executed, and it will return the error code to the runner. This behavior is internally consistent with the previous sh and pwsh default behavior and is the cmd.exe default, so this behavior remains intact.



jobs.<job_id>.steps[*].with
A map of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed with INPUT_ and converted to upper case.
Input parameters defined for a Docker container must use args. For more information, see jobs.<job_id>.steps[*].with.args.
Example of jobs.<job_id>.steps[*].with
Defines the three input parameters (first_name, middle_name, and last_name) defined by the hello_world action. These input variables will be accessible to the hello-world action as INPUT_FIRST_NAME, INPUT_MIDDLE_NAME, and INPUT_LAST_NAME environment variables.
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/hello_world@main
        with:
          first_name: Mona
          middle_name: The
          last_name: Octocat

jobs.<job_id>.steps[*].with.args
A string that defines the inputs for a Docker container. GitHub passes the args to the container's ENTRYPOINT when the container starts up. An array of strings is not supported by this parameter. A single argument that includes spaces should be surrounded by double quotes "".
Example of jobs.<job_id>.steps[*].with.args
steps:
  - name: Explain why this job ran
    uses: octo-org/action-name@main
    with:
      entrypoint: /bin/echo
      args: The ${{ github.event_name }} event triggered this step.

The args are used in place of the CMD instruction in a Dockerfile. If you use CMD in your Dockerfile, use the guidelines ordered by preference:

Document required arguments in the action's README and omit them from the CMD instruction.
Use defaults that allow using the action without specifying any args.
If the action exposes a --help flag, or something similar, use that as the default to make your action self-documenting.

jobs.<job_id>.steps[*].with.entrypoint
Overrides the Docker ENTRYPOINT in the Dockerfile, or sets it if one wasn't already specified. Unlike the Docker ENTRYPOINT instruction which has a shell and exec form, entrypoint keyword accepts only a single string defining the executable to be run.
Example of jobs.<job_id>.steps[*].with.entrypoint
steps:
  - name: Run a custom command
    uses: octo-org/action-name@main
    with:
      entrypoint: /a/different/executable

The entrypoint keyword is meant to be used with Docker container actions, but you can also use it with JavaScript actions that don't define any inputs.
jobs.<job_id>.steps[*].env
Sets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job. For more information, see env and jobs.<job_id>.env.
When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.
Public actions may specify expected variables in the README file. If you are setting a secret or sensitive value, such as a password or token, you must set secrets using the secrets context. For more information, see Accessing contextual information about workflow runs.
Example of jobs.<job_id>.steps[*].env
steps:
  - name: My first action
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      FIRST_NAME: Mona
      LAST_NAME: Octocat

jobs.<job_id>.steps[*].continue-on-error
Prevents a job from failing when a step fails. Set to true to allow a job to pass when this step fails.
jobs.<job_id>.steps[*].timeout-minutes
The maximum number of minutes to run the step before killing the process.
Fractional values are not supported. timeout-minutes must be a positive integer.
jobs.<job_id>.timeout-minutes
The maximum number of minutes to let a job run before GitHub automatically cancels it. Default: 360
If the timeout exceeds the job execution time limit for the runner, the job will be canceled when the execution time limit is met instead. For more information about job execution time limits, see Usage limits, billing, and administration for GitHub-hosted runners and Usage limits for self-hosted runners for self-hosted runner usage limits.
Note

The GITHUB_TOKEN expires when a job finishes or after a maximum of 24 hours. For self-hosted runners, the token may be the limiting factor if the job timeout is greater than 24 hours. For more information on the GITHUB_TOKEN, see Automatic token authentication.

jobs.<job_id>.strategy
Use jobs.<job_id>.strategy to use a matrix strategy for your jobs. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. For more information, see Running variations of jobs in a workflow.
jobs.<job_id>.strategy.matrix
Use jobs.<job_id>.strategy.matrix to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called version with the value [10, 12, 14] and a variable called os with the value [ubuntu-latest, windows-latest]:
jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]

A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the os and version variables.
By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:

{version: 10, os: ubuntu-latest}
{version: 10, os: windows-latest}
{version: 12, os: ubuntu-latest}
{version: 12, os: windows-latest}
{version: 14, os: ubuntu-latest}
{version: 14, os: windows-latest}

A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.
The variables that you define become properties in the matrix context, and you can reference the property in other areas of your workflow file. In this example, you can use matrix.version and matrix.os to access the current value of version and os that the job is using. For more information, see Accessing contextual information about workflow runs.
Example: Using a single-dimension matrix
You can specify a single variable to create a single-dimension matrix.
For example, the following workflow defines the variable version with the values [10, 12, 14]. The workflow will run three jobs, one for each value in the variable. Each job will access the version value through the matrix.version context and pass the value as node-version to the actions/setup-node action.
jobs:
  example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

Example: Using a multi-dimension matrix
You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables.
For example, the following workflow specifies two variables:

Two operating systems specified in the os variable
Three Node.js versions specified in the version variable

The workflow will run six jobs, one for each combination of the os and version variables. Each job will set the runs-on value to the current os value and will pass the current version value to the actions/setup-node action.
jobs:
  example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

A variable configuration in a matrix can be an array of objects.
matrix:
  os:
    - ubuntu-latest
    - macos-latest
  node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider

This matrix produces 4 jobs with corresponding contexts.
- matrix.os: ubuntu-latest
  matrix.node.version: 14
- matrix.os: ubuntu-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
  matrix.node.version: 14
- matrix.os: macos-latest
  matrix.node.version: 20
  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider

Example: Using contexts to create matrices
You can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs.
For example, the following workflow triggers on the repository_dispatch event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix version variable will have a value of [12, 14, 16]. For more information about the repository_dispatch trigger, see Events that trigger workflows.
{
  "event_type": "test",
  "client_payload": {
    "versions": [12, 14, 16]
  }
}

on:
  repository_dispatch:
    types:
      - test
 
jobs:
  example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

jobs.<job_id>.strategy.matrix.include
Use jobs.<job_id>.strategy.matrix.include to expand existing matrix configurations or to add new configurations. The value of include is a list of objects.
For each object in the include list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten.
For example, this matrix:
strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat

will result in six jobs with the following matrix combinations:

{fruit: apple, animal: cat, color: pink, shape: circle}
{fruit: apple, animal: dog, color: green, shape: circle}
{fruit: pear, animal: cat, color: pink}
{fruit: pear, animal: dog, color: green}
{fruit: banana}
{fruit: banana, animal: cat}

following this logic:

{color: green} is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.
{color: pink, animal: cat} adds color:pink only to the original matrix combinations that include animal: cat. This overwrites the color: green that was added by the previous include entry.
{fruit: apple, shape: circle} adds shape: circle only to the original matrix combinations that include fruit: apple.
{fruit: banana} cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.
{fruit: banana, animal: cat} cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the {fruit: banana} matrix combination because that combination was not one of the original matrix combinations.

Example: Expanding configurations
For example, the following workflow will run four jobs, one for each combination of os and node. When the job for the os value of windows-latest and node value of 16 runs, an additional variable called npm with the value of 6 will be included in the job.
jobs:
  example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version

Example: Adding configurations
For example, this matrix will run 10 jobs, one for each combination of os and version in the matrix, plus a job for the os value of windows-latest and version value of 17.
jobs:
  example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17

If you don't specify any matrix variables, all configurations under include will run. For example, the following workflow would run two jobs, one for each include entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.
jobs:
  includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: "production"
            datacenter: "site-a"
          - site: "staging"
            datacenter: "site-b"

jobs.<job_id>.strategy.matrix.exclude
To remove specific configurations defined in the matrix, use jobs.<job_id>.strategy.matrix.exclude. An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches {os: macos-latest, version: 12, environment: production}, and the two excluded jobs that match {os: windows-latest, version: 16}.
strategy:
  matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}

Note

All include combinations are processed after exclude. This allows you to use include to add back combinations that were previously excluded.

jobs.<job_id>.strategy.fail-fast
You can control how job failures are handled with jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error.
jobs.<job_id>.strategy.fail-fast applies to the entire matrix. If jobs.<job_id>.strategy.fail-fast is set to true or its expression evaluates to true, GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to true.
jobs.<job_id>.continue-on-error applies to a single job. If jobs.<job_id>.continue-on-error is true, other jobs in the matrix will continue running even if the job with jobs.<job_id>.continue-on-error: true fails.
You can use jobs.<job_id>.strategy.fail-fast and jobs.<job_id>.continue-on-error together. For example, the following workflow will start four jobs. For each job, continue-on-error is determined by the value of matrix.experimental. If any of the jobs with continue-on-error: false fail, all jobs that are in progress or queued will be cancelled. If the job with continue-on-error: true fails, the other jobs will not be affected.
jobs:
  test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true

jobs.<job_id>.strategy.max-parallel
By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a matrix job strategy, use jobs.<job_id>.strategy.max-parallel.
For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.
jobs:
  example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]

jobs.<job_id>.continue-on-error
Prevents a workflow run from failing when a job fails. Set to true to allow a workflow run to pass when this job fails.
Example: Preventing a specific failing matrix job from failing a workflow run
You can allow specific jobs in a job matrix to fail without failing the workflow run. For example, if you wanted to only allow an experimental job with node set to 15 to fail without failing the workflow run.
runs-on: ${{ matrix.os }}
continue-on-error: ${{ matrix.experimental }}
strategy:
  fail-fast: false
  matrix:
    node: [13, 14]
    os: [macos-latest, ubuntu-latest]
    experimental: [false]
    include:
      - node: 15
        os: ubuntu-latest
        experimental: true

jobs.<job_id>.container
Note

If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:

If you are using GitHub-hosted runners, you must use an Ubuntu runner.
If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed.


Use jobs.<job_id>.container to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.
If you do not set a container, all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container.
Note

The default shell for run steps inside a container is sh instead of bash. This can be overridden with jobs.<job_id>.defaults.run or jobs.<job_id>.steps[*].shell.

Example: Running a job within a container
YAMLname: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)
name: CI
on:
  push:
    branches: [ main ]
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)

When you only specify a container image, you can omit the image keyword.
jobs:
  container-test-job:
    runs-on: ubuntu-latest
    container: node:18

jobs.<job_id>.container.image
Use jobs.<job_id>.container.image to define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
Note

Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker.

jobs.<job_id>.container.credentials
If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password. The credentials are the same values that you would provide to the docker login command.
Example: Defining credentials for a container registry
container:
  image: ghcr.io/owner/image
  credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}

jobs.<job_id>.container.env
Use jobs.<job_id>.container.env to set a map of environment variables in the container.
jobs.<job_id>.container.ports
Use jobs.<job_id>.container.ports to set an array of ports to expose on the container.
jobs.<job_id>.container.volumes
Use jobs.<job_id>.container.volumes to set an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
To specify a volume, you specify the source and destination path:
<source>:<destinationPath>.
The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
Example: Mounting volumes in a container
volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory

jobs.<job_id>.container.options
Use jobs.<job_id>.container.options to configure additional Docker container resource options. For a list of options, see docker create options.
Warning

The --network and --entrypoint options are not supported.

jobs.<job_id>.services
Note

If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:

If you are using GitHub-hosted runners, you must use an Ubuntu runner.
If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed.


Used to host service containers for a job in a workflow. Service containers are useful for creating databases or cache services like Redis. The runner automatically creates a Docker network and manages the life cycle of the service containers.
If you configure your job to run in a container, or your step uses container actions, you don't need to map ports to access the service or action. Docker automatically exposes all ports between containers on the same Docker user-defined bridge network. You can directly reference the service container by its hostname. The hostname is automatically mapped to the label name you configure for the service in the workflow.
If you configure the job to run directly on the runner machine and your step doesn't use a container action, you must map any required Docker service container ports to the Docker host (the runner machine). You can access the service container using localhost and the mapped port.
For more information about the differences between networking service containers, see About service containers.
Example: Using localhost
This example creates two services: nginx and redis. When you specify the container port but not the host port, the container port is randomly assigned to a free port on the host. GitHub sets the assigned host port in the ${{job.services.<service_name>.ports}} context. In this example, you can access the service host ports using the ${{ job.services.nginx.ports['80'] }} and ${{ job.services.redis.ports['6379'] }} contexts.
services:
  nginx:
    image: nginx
    # Map port 8080 on the Docker host to port 80 on the nginx container
    ports:
      - 8080:80
  redis:
    image: redis
    # Map random free TCP port on Docker host to port 6379 on redis container
    ports:
      - 6379/tcp
steps:
  - run: |
      echo "Redis available on 127.0.0.1:${{ job.services.redis.ports['6379'] }}"
      echo "Nginx available on 127.0.0.1:${{ job.services.nginx.ports['80'] }}"

jobs.<job_id>.services.<service_id>.image
The Docker image to use as the service container to run the action. The value can be the Docker Hub image name or a registry name.
If jobs.<job_id>.services.<service_id>.image is assigned an empty string, the service will not start. You can use this to set up conditional services, similar to the following example.
services:
  nginx:
    image: ${{ options.nginx == true && 'nginx' || '' }}

jobs.<job_id>.services.<service_id>.credentials
If the image's container registry requires authentication to pull the image, you can use jobs.<job_id>.container.credentials to set a map of the username and password. The credentials are the same values that you would provide to the docker login command.
Example of jobs.<job_id>.services.<service_id>.credentials
services:
  myservice1:
    image: ghcr.io/owner/myservice1
    credentials:
      username: ${{ github.actor }}
      password: ${{ secrets.github_token }}
  myservice2:
    image: dockerhub_org/myservice2
    credentials:
      username: ${{ secrets.DOCKER_USER }}
      password: ${{ secrets.DOCKER_PASSWORD }}

jobs.<job_id>.services.<service_id>.env
Sets a map of environment variables in the service container.
jobs.<job_id>.services.<service_id>.ports
Sets an array of ports to expose on the service container.
jobs.<job_id>.services.<service_id>.volumes
Sets an array of volumes for the service container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
To specify a volume, you specify the source and destination path:
<source>:<destinationPath>.
The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
Example of jobs.<job_id>.services.<service_id>.volumes
volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory

jobs.<job_id>.services.<service_id>.options
Additional Docker container resource options. For a list of options, see docker create options.
Warning

The --network option is not supported.

jobs.<job_id>.uses
The location and version of a reusable workflow file to run as a job. Use one of the following syntaxes:

{owner}/{repo}/.github/workflows/{filename}@{ref} for reusable workflows in public and private repositories.
./.github/workflows/{filename} for reusable workflows in the same repository.

In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions.
If you use the second syntax option (without {owner}/{repo} and @{ref}) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword.
Example of jobs.<job_id>.uses
jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1

For more information, see Reusing workflows.
jobs.<job_id>.with
When a job is used to call a reusable workflow, you can use with to provide a map of inputs that are passed to the called workflow.
Any inputs that you pass must match the input specifications defined in the called workflow.
Unlike jobs.<job_id>.steps[*].with, the inputs you pass with jobs.<job_id>.with are not available as environment variables in the called workflow. Instead, you can reference the inputs by using the inputs context.
Example of jobs.<job_id>.with
jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    with:
      username: mona

jobs.<job_id>.with.<input_id>
A pair consisting of a string identifier for the input and the value of the input. The identifier must match the name of an input defined by on.workflow_call.inputs.<inputs_id> in the called workflow. The data type of the value must match the type defined by on.workflow_call.inputs.<input_id>.type in the called workflow.
Allowed expression contexts: github, and needs.
jobs.<job_id>.secrets
When a job is used to call a reusable workflow, you can use secrets to provide a map of secrets that are passed to the called workflow.
Any secrets that you pass must match the names defined in the called workflow.
Example of jobs.<job_id>.secrets
jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    secrets:
      access-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

jobs.<job_id>.secrets.inherit
Use the inherit keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The inherit keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.
Example of jobs.<job_id>.secrets.inherit
on:
  workflow_dispatch:

jobs:
  pass-secrets-to-workflow:
    uses: ./.github/workflows/called-workflow.yml
    secrets: inherit

on:
  workflow_call:

jobs:
  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
      - name: Use a repo or org secret from the calling workflow.
        run: echo ${{ secrets.CALLING_WORKFLOW_SECRET }}

jobs.<job_id>.secrets.<secret_id>
A pair consisting of a string identifier for the secret and the value of the secret. The identifier must match the name of a secret defined by on.workflow_call.secrets.<secret_id> in the called workflow.
Allowed expression contexts: github, needs, and secrets.
Filter pattern cheat sheet
You can use special characters in path, branch, and tag filters.

*: Matches zero or more characters, but does not match the / character. For example, Octo* matches Octocat.
**: Matches zero or more of any character.
?: Matches zero or one of the preceding character.
+: Matches one or more of the preceding character.
[] Matches one alphanumeric character listed in the brackets or included in ranges. Ranges can only include a-z, A-Z, and 0-9. For example, the range[0-9a-z] matches any digit or lowercase letter. For example, [CB]at matches Cat or Bat and [1-2]00 matches 100 and 200.
!: At the start of a pattern makes it negate previous positive patterns. It has no special meaning if not the first character.

The characters *, [, and ! are special characters in YAML. If you start a pattern with *, [, or !, you must enclose the pattern in quotes. Also, if you use a flow sequence with a pattern containing [ and/or ], the pattern must be enclosed in quotes.
# Valid
paths:
  - '**/README.md'

# Invalid - creates a parse error that
# prevents your workflow from running.
paths:
  - **/README.md

# Valid
branches: [ main, 'release/v[0-9].[0-9]' ]

# Invalid - creates a parse error
branches: [ main, release/v[0-9].[0-9] ]

For more information about branch, tag, and path filter syntax, see on.<push>.<branches|tags>, on.<pull_request>.<branches|tags>, and on.<push|pull_request>.paths.
Patterns to match branches and tags


















































PatternDescriptionExample matchesfeature/*The * wildcard matches any character, but does not match slash (/).feature/my-branchfeature/your-branchfeature/**The ** wildcard matches any character including slash (/) in branch and tag names.feature/beta-a/my-branchfeature/your-branchfeature/mona/the/octocatmainreleases/mona-the-octocatMatches the exact name of a branch or tag name.mainreleases/mona-the-octocat'*'Matches all branch and tag names that don't contain a slash (/). The * character is a special character in YAML. When you start a pattern with *, you must use quotes.mainreleases'**'Matches all branch and tag names. This is the default behavior when you don't use a branches or tags filter.all/the/branchesevery/tag'*feature'The * character is a special character in YAML. When you start a pattern with *, you must use quotes.mona-featurefeaturever-10-featurev2*Matches branch and tag names that start with v2.v2v2.0v2.9v[12].[0-9]+.[0-9]+Matches all semantic versioning branches and tags with major version 1 or 2.v1.10.1v2.0.0
Patterns to match file paths
Path patterns must match the whole path, and start from the repository's root.





















































































PatternDescription of matchesExample matches'*'The * wildcard matches any character, but does not match slash (/). The * character is a special character in YAML. When you start a pattern with *, you must use quotes.README.mdserver.rb'*.jsx?'The ? character matches zero or one of the preceding character.page.jspage.jsx'**'The ** wildcard matches any character including slash (/). This is the default behavior when you don't use a path filter.all/the/files.md'*.js'The * wildcard matches any character, but does not match slash (/). Matches all .js files at the root of the repository.app.jsindex.js'**.js'Matches all .js files in the repository.index.jsjs/index.jssrc/js/app.jsdocs/*All files within the root of the docs directory only, at the root of the repository.docs/README.mddocs/file.txtdocs/**Any files in the docs directory and its subdirectories at the root of the repository.docs/README.mddocs/mona/octocat.txtdocs/**/*.mdA file with a .md suffix anywhere in the docs directory.docs/README.mddocs/mona/hello-world.mddocs/a/markdown/file.md'**/docs/**'Any files in a docs directory anywhere in the repository.docs/hello.mddir/docs/my-file.txtspace/docs/plan/space.doc'**/README.md'A README.md file anywhere in the repository.README.mdjs/README.md'**/*src/**'Any file in a folder with a src suffix anywhere in the repository.a/src/app.jsmy-src/code/js/app.js'**/*-post.md'A file with the suffix -post.md anywhere in the repository.my-post.mdpath/their-post.md'**/migrate-*.sql'A file with the prefix migrate- and suffix .sql anywhere in the repository.migrate-10909.sqldb/migrate-v1.0.sqldb/sept/migrate-v1.sql'*.md''!README.md'Using an exclamation mark (!) in front of a pattern negates it. When a file matches a pattern and also matches a negative pattern defined later in the file, the file will not be included.hello.mdDoes not matchREADME.mddocs/hello.md'*.md''!README.md'README*Patterns are checked sequentially. A pattern that negates a previous pattern will re-include file paths.hello.mdREADME.mdREADME.doc\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Manually run a workflowManually running a workflowWhen a workflow is configured to run on the workflow_dispatch event, you can run the workflow using the Actions tab on GitHub, GitHub CLI, or the REST API.Tool navigationGitHub CLIWeb browserIn this articleConfiguring a workflow to run manuallyRunning a workflowRunning a workflow using the REST APIConfiguring a workflow to run manually
To run a workflow manually, the workflow must be configured to run on the workflow_dispatch event.
To trigger the workflow_dispatch event, your workflow must be in the default branch. For more information about configuring the workflow_dispatch event, see Events that trigger workflows.
Write access to the repository is required to perform these steps.
Running a workflow



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the name of the workflow you want to run.



Above the list of workflow runs, click the Run workflow button.
Note

To see the Run workflow button, your workflow file must use the workflow_dispatch event trigger. Only workflow files that use the workflow_dispatch event trigger will have the option to run the workflow manually using the Run workflow button. For more information about configuring the workflow_dispatch event, see Events that trigger workflows.




Select the Branch dropdown menu and click a branch to run the workflow on.


If the workflow requires input, fill in the fields.


Click Run workflow.




Note

To learn more about GitHub CLI, see About GitHub CLI.

To run a workflow, use the workflow run subcommand. Replace the workflow parameter with either the name, ID, or file name of the workflow you want to run. For example, "Link Checker", 1234567, or "link-check-test.yml". If you don't specify a workflow, GitHub CLI returns an interactive menu for you to choose a workflow.
gh workflow run WORKFLOW

If your workflow accepts inputs, GitHub CLI will prompt you to enter them. Alternatively, you can use -f or -F to add an input in key=value format. Use -F to read from a file.
gh workflow run greet.yml -f name=mona -f greeting=hello -F data=@myfile.txt

You can also pass inputs as JSON by using standard input.
echo '{"name":"mona", "greeting":"hello"}' | gh workflow run greet.yml --json

To run a workflow on a branch other than the repository's default branch, use the --ref flag.
gh workflow run WORKFLOW --ref BRANCH

To view the progress of the workflow run, use the run watch subcommand and select the run from the interactive list.
gh run watch


Running a workflow using the REST API
When using the REST API, you configure the inputs and ref as request body parameters. If the inputs are omitted, the default values defined in the workflow file are used.
Note

You can define up to 10 inputs for a workflow_dispatch event.

For more information about using the REST API, see REST API endpoints for workflows.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Re-run workflows and jobsRe-running workflows and jobsYou can re-run a workflow run, all failed jobs in a workflow run, or specific jobs in a workflow run up to 30 days after its initial run.Who can use this feature?People with write permissions to a repository can re-run workflows in the repository.Tool navigationGitHub CLIWeb browserIn this articleAbout re-running workflows and jobsRe-running all the jobs in a workflowRe-running failed jobs in a workflowRe-running a specific job in a workflowRe-running workflows and jobs with reusable workflowsReviewing previous workflow runsAbout re-running workflows and jobs
Re-running a workflow or jobs in a workflow uses the same GITHUB_SHA (commit SHA) and GITHUB_REF (Git ref) of the original event that triggered the workflow run. The workflow will use the privileges of the actor who initially triggered the workflow, not the privileges of the actor who initiated the re-run. You can re-run a workflow or jobs in a workflow for up to 30 days after the initial run. You cannot re-run jobs in a workflow once its logs have passed their retention limits. For more information, see Usage limits, billing, and administration. When you re-run a workflow or jobs in a workflow, you can enable debug logging for the re-run. This will enable runner diagnostic logging and step debug logging for the re-run. For more information about debug logging, see Enabling debug logging
Re-running all the jobs in a workflow



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


In the upper-right corner of the workflow, re-run jobs.


If any jobs failed, select the  Re-run jobs dropdown menu and click Re-run all jobs.


If no jobs failed, click Re-run all jobs.




Optionally, to enable runner diagnostic logging and step debug logging for the re-run, select Enable debug logging.


Click Re-run jobs.




Note

To learn more about GitHub CLI, see About GitHub CLI.

To re-run a failed workflow run, use the run rerun subcommand. Replace run-id with the ID of the failed run that you want to re-run. If you don't specify a run-id, GitHub CLI returns an interactive menu for you to choose a recent failed run.
gh run rerun RUN_ID

To enable runner diagnostic logging and step debug logging for the re-run, use the --debug flag.
gh run rerun RUN_ID --debug

To view the progress of the workflow run, use the run watch subcommand and select the run from the interactive list.
gh run watch


Re-running failed jobs in a workflow
If any jobs in a workflow run failed, you can re-run just the jobs that failed. When you re-run failed jobs in a workflow, a new workflow run will start for all failed jobs and their dependents. Any outputs for any successful jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


In the upper-right corner of the workflow, select the  Re-run jobs dropdown menu, and click Re-run failed jobs.


Optionally, to enable runner diagnostic logging and step debug logging for the re-run, select Enable debug logging.


Click Re-run jobs.




To re-run failed jobs in a workflow run, use the run rerun subcommand with the --failed flag. Replace run-id with the ID of the run for which you want to re-run failed jobs. If you don't specify a run-id, GitHub CLI returns an interactive menu for you to choose a recent failed run.
gh run rerun RUN_ID --failed

To enable runner diagnostic logging and step debug logging for the re-run, use the --debug flag.
gh run rerun RUN_ID --failed --debug


Re-running a specific job in a workflow
When you re-run a specific job in a workflow, a new workflow run will start for the job and any dependents. Any outputs for any other jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


Under the "Jobs" section of the left sidebar, next to the job that you want to re-run, click .


Optionally, to enable runner diagnostic logging and step debug logging for the re-run, select Enable debug logging.


Click Re-run jobs.




To re-run a specific job in a workflow run, use the run rerun subcommand with the --job flag. Replace job-id with the ID of the job that you want to re-run.
gh run rerun --job JOB_ID

To enable runner diagnostic logging and step debug logging for the re-run, use the --debug flag.
gh run rerun --job JOB_ID --debug


Re-running workflows and jobs with reusable workflows
Reusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, see Reusing workflows.
When you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:

Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, see Re-running workflows and jobs.
Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, see Re-running workflows and jobs. For more information about re-running a specific job in a workflow, see Re-running workflows and jobs.

Reviewing previous workflow runs
You can view the results from your previous attempts at running a workflow. You can also view previous workflow runs using the API. For more information, see REST API endpoints for workflow runs.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


To the right of the run name, select the Latest dropdown menu and click a previous run attempt.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Cancel a workflowCanceling a workflowYou can cancel a workflow run that is in progress. When you cancel a workflow run, GitHub cancels all jobs and steps that are a part of that workflow.In this articleCanceling a workflow runSteps GitHub takes to cancel a workflow runWrite access to the repository is required to perform these steps.
Canceling a workflow run


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the queued or in progress run that you want to cancel.


In the upper-right corner of the workflow, click Cancel workflow.



Steps GitHub takes to cancel a workflow run
When canceling workflow run, you may be running other software that uses resources that are related to the workflow run. To help you free up resources related to the workflow run, it may help to understand the steps GitHub performs to cancel a workflow run.

To cancel the workflow run, the server re-evaluates if conditions for all currently running jobs. If the condition evaluates to true, the job will not get canceled. For example, the condition if: always() would evaluate to true and the job continues to run. When there is no condition, that is the equivalent of the condition if: success(), which only runs if the previous step finished successfully.
For jobs that need to be canceled, the server sends a cancellation message to all the runner machines with jobs that need to be canceled.
For jobs that continue to run, the server re-evaluates if conditions for the unfinished steps. If the condition evaluates to true, the step continues to run. You can use the cancelled expression to apply a status check of cancelled(). For more information see Evaluate expressions in workflows and actions.
For steps that need to be canceled, the runner machine sends SIGINT/Ctrl-C to the step's entry process (node for javascript action, docker for container action, and bash/cmd/pwd when using run in a step). If the process doesn't exit within 7500 ms, the runner will send SIGTERM/Ctrl-Break to the process, then wait for 2500 ms for the process to exit. If the process is still running, the runner kills the process tree.
After the 5 minutes cancellation timeout period, the server will force terminate all jobs and steps that don't finish running or fail to complete the cancellation process.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Disable & enable a workflowDisabling and enabling a workflowYou can disable and re-enable a workflow using the GitHub UI, the REST API, or GitHub CLI.Tool navigationGitHub CLIWeb browserIn this articleDisabling a workflowEnabling a workflowDisabling a workflow allows you to stop a workflow from being triggered without having to delete the file from the repo. You can easily re-enable the workflow again on GitHub.
Temporarily disabling a workflow can be useful in many scenarios. These are a few examples where disabling a workflow might be helpful:

A workflow error that produces too many or wrong requests, impacting external services negatively.
A workflow that is not critical and is consuming too many minutes on your account.
A workflow that sends requests to a service that is down.
Workflows on a forked repository that aren't needed (for example, scheduled workflows).

Warning

To prevent unnecessary workflow runs, scheduled workflows may be disabled automatically. When a public repository is forked, scheduled workflows are disabled by default. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days.

You can also disable and enable a workflow using the REST API. For more information, see REST API endpoints for workflows.
Disabling a workflow



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to disable.


Click  to display a dropdown menu and click Disable workflow.





Note

To learn more about GitHub CLI, see About GitHub CLI.

To disable a workflow, use the workflow disable subcommand. Replace workflow with either the name, ID, or file name of the workflow you want to disable. For example, "Link Checker", 1234567, or "link-check-test.yml". If you don't specify a workflow, GitHub CLI returns an interactive menu for you to choose a workflow.
gh workflow disable WORKFLOW


Enabling a workflow

You can re-enable a workflow that was previously disabled.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to enable.



Click Enable workflow.




To enable a workflow, use the workflow enable subcommand. Replace workflow with either the name, ID, or file name of the workflow you want to enable. For example, "Link Checker", 1234567, or "link-check-test.yml". If you don't specify a workflow, GitHub CLI returns an interactive menu for you to choose a workflow.
gh workflow enable WORKFLOW\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Skip workflow runsSkipping workflow runsYou can skip workflow runs triggered by the push and pull_request events by including a command in your commit message.Note

If a workflow is skipped due to path filtering, branch filtering or a commit message (see below), then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.

Workflows that would otherwise be triggered using on: push or on: pull_request won't be triggered if you add any of the following strings to the commit message in a push, or the HEAD commit of a pull request:

[skip ci]
[ci skip]
[no ci]
[skip actions]
[actions skip]

Alternatively, you can add a skip-checks trailer to your commit message. The trailers section should be included at the end of your commit message and be preceded by two empty lines. If you already have other trailers in your commit message, skip-checks should be last. You can use either of the following:

skip-checks:true
skip-checks: true

By default, Git automatically removes consecutive newlines. To leave the commit message exactly as you entered it, use the --cleanup=verbatim option on your commit. For more information, see --cleanup=<mode> in the Git documentation.
You won't be able to merge the pull request if your repository is configured to require specific checks to pass first. To allow the pull request to be merged you can push a new commit to the pull request without the skip instruction in the commit message.
Note

Skip instructions only apply to the push and pull_request events. For example, adding [skip ci] to a commit message won't stop a workflow that's triggered on: pull_request_target from running.

Skip instructions only apply to the workflow run(s) that would be triggered by the commit that contains the skip instructions. You can also disable a workflow from running. For more information, see Disabling and enabling a workflow.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Delete a workflow runDeleting a workflow runYou can delete a workflow run that has been completed, or is more than two weeks old.Write access to the repository is required to perform these steps.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



To delete a workflow run, select , then click Delete workflow run.



Review the confirmation prompt and click Yes, permanently delete this workflow run.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Download workflow artifactsDownloading workflow artifactsYou can download archived artifacts before they automatically expire.Who can use this feature?People who are signed into GitHub and have read access to a repository can download workflow artifacts.Tool navigationGitHub CLIWeb browserBy default, GitHub stores build logs and artifacts for 90 days, and you can customize this retention period, depending on the type of repository. For more information, see Managing GitHub Actions settings for a repository.
Read access to the repository is required to perform these steps.



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


In the "Artifacts" section, click the artifact you want to download.





Note

To learn more about GitHub CLI, see About GitHub CLI.

GitHub CLI will download each artifact into separate directories based on the artifact name. If only a single artifact is specified, it will be extracted into the current directory.
To download all artifacts generated by a workflow run, use the run download subcommand. Replace run-id with the ID of the run that you want to download artifacts from. If you don't specify a run-id, GitHub CLI returns an interactive menu for you to choose a recent run.
gh run download RUN_ID

To download a specific artifact from a run, use the run download subcommand. Replace run-id with the ID of the run that you want to download artifacts from. Replace artifact-name with the name of the artifact that you want to download.
gh run download RUN_ID -n ARTIFACT_NAME

You can specify more than one artifact.
gh run download RUN_ID> -n ARTIFACT_NAME-1 -n ARTIFACT_NAME-2

To download specific artifacts across all runs in a repository, use the run download subcommand.
gh run download -n ARTIFACT_NAME-1 ARTIFACT_NAME-2\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Remove workflow artifactsRemoving workflow artifactsYou can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub.In this articleDeleting an artifactSetting the retention period for an artifactFinding the expiration date of an artifactArtifacts from deleted workflow runsDeleting an artifact
Warning

Once you delete an artifact, it cannot be restored.

Write access to the repository is required to perform these steps.
By default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see Usage limits, billing, and administration.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


Under Artifacts, click  next to the artifact you want to remove.



Setting the retention period for an artifact
Retention periods for artifacts and logs can be configured at the repository, organization, and enterprise level. For more information, see Usage limits, billing, and administration.
You can also define a custom retention period for individual artifacts using the actions/upload-artifact action in a workflow. For more information, see Storing and sharing data from a workflow.
Finding the expiration date of an artifact
You can use the API to confirm the date that an artifact is scheduled to be deleted. For more information, see the expires_at value returned by the REST API. For more information, see REST API endpoints for GitHub Actions artifacts.
Artifacts from deleted workflow runs
When a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: Deleting a workflow run, Delete a workflow run, or gh run delete.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Approve public fork runsApproving workflow runs from public forksWhen an outside contributor submits a pull request to a public repository, a maintainer with write access may need to approve some workflow runs.In this articleAbout workflow runs from public forksApproving workflow runs on a pull request from a public forkAbout workflow runs from public forks
Anyone can fork a public repository, and then submit a pull request that proposes changes to the repository's GitHub Actions workflows. Although workflows from forks do not have access to sensitive data such as secrets, they can be an annoyance for maintainers if they are modified for abusive purposes.
To help prevent this, workflows on pull requests to public repositories from some outside contributors will not run automatically, and might need to be approved first. Depending on the "Approval for running fork pull request workflows from contributors" setting, workflows on pull requests to public repositories will not run automatically and may need approval if:

The pull request is created by a user that requires approvals based on the selected policy.
The pull request event is triggered by a user that requires approvals based on the selected policy.

By default, all first-time contributors require approval to run workflows.
Workflows triggered by pull_request_target events are run in the context of the base branch. Since the base branch is considered trusted, workflows triggered by these events will always run, regardless of approval settings. For more information about the pull_request_target event, see Events that trigger workflows.
Warning
 These workflow approval policies are intended to restrict the set of users that can execute workflows in GitHub Actions runners that could lead to unexpected resource and compute consumption when using GitHub-hosted runners. If you are using self-hosted runners, potentially malicious user-controlled workflow code will execute automatically if the user is allowed to bypass approval in the set approval policy or if the pull request is approved. You must consider the risk of executing this code in your infrastructure and should review and follow the self-hosted runner security recommendations regardless of the approval settings utilized. See Security hardening for GitHub Actions.

You can configure workflow approval requirements for a repository, organization, or enterprise.
Workflow runs that have been awaiting approval for more than 30 days are automatically deleted.
Approving workflow runs on a pull request from a public fork
Maintainers with write access to a repository can use the following procedure to review and run workflows on pull requests from contributors that require approval.


Under your repository name, click  Pull requests.



In the list of pull requests, click the pull request you'd like to review.


On the pull request, click  Files changed.



Inspect the proposed changes in the pull request and ensure that you are comfortable running your workflows on the pull request branch. You should be especially alert to any proposed changes in the .github/workflows/ directory that affect workflow files.


If you are comfortable with running workflows on the pull request branch, return to the  Conversation tab, and under "Workflow(s) awaiting approval", click Approve and run.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage workflow runs/Approve private fork runsApproving workflow runs from private forksWhen someone without write access submits a pull request to a private repository, a maintainer may need to approve any workflow runs.Who can use this feature?Maintainers with write access to a repository can approve workflow runs.In this articleAbout workflow runs from private forksApproving workflow runs on a pull request from a private forkAbout workflow runs from private forks
If you rely on using forks of your private repositories, you can configure policies that control how users can run workflows on pull_request events. Available to private repositories only, you can configure these policy settings for organizations or repositories. For more information, see Enforcing policies for GitHub Actions in your enterprise.
Approving workflow runs on a pull request from a private fork
Maintainers with write access to a repository can use the following procedure to review and run workflows on pull requests from contributors that require approval.


Under your repository name, click  Pull requests.



In the list of pull requests, click the pull request you'd like to review.


On the pull request, click  Files changed.



Inspect the proposed changes in the pull request and ensure that you are comfortable running your workflows on the pull request branch. You should be especially alert to any proposed changes in the .github/workflows/ directory that affect workflow files.


If you are comfortable with running workflows on the pull request branch, return to the  Conversation tab, and under "Workflow(s) awaiting approval", click Approve and run.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage deployments/Deployment historyViewing deployment historyView current and previous deployments for your repository.In this articleAbout deployment historyViewing your repository's deployment historyAbout deployment history
You can deliver deployments through GitHub Actions and environments or with the REST API and third party apps. For more information about using environments to deploy with GitHub Actions, see Managing environments for deployment. For more information about deployments with the REST API, see REST API endpoints for repositories.
On the deployments page of your repository, you can view the following aspects of your deployments.

Currently active deployments across various environments
Deployments filtered by environment
Your repository's full deployment history
Associated commits that triggered the deployment
Connected GitHub Actions workflow logs
The deployment URL (if one exists)
The source pull request and branch related to each deployment
Deployment statuses. For more information about deployment statuses, see REST API endpoints for deployments.

By default, the deployments page shows currently active deployments from select environments and a timeline of the latest deployments for all environments.
Viewing your repository's deployment history

In the right-hand sidebar of the home page of your repository, click Deployments.
Once you are on the "Deployments" page, you can view the following information about your deployment history.

To view recent deployments for a specific environment, in the "Environments" section of the left sidebar, click an environment.
To pin an environment to the top of the deployment history list, repository administrators can click  to the right of the environment. You can pin up to ten environments.
To view the commit that triggered a deployment, in the deployment history list, click the commit message for the deployment you want to view.
Note
Deployments from commits that originate from a fork outside of the repository will not show links to the source pull request and branch related to each deployment. For more information about forks, see About forks.


To view the URL for a deployment, to the right of the commit message in the deployment history list, click .
To navigate to the workflow run logs associated with a deployment, to the right of the commit message in the deployment history list, click , then click View logs.


Optionally, to filter the deployment history list, create a filter.

Click on the  Filter button.
Click  Add a filter.
Choose a qualifier you would like to filter the deployment history by.
Depending on the qualifier you chose, fill out information in the "Operator" and "Value" columns.
Optionally, click  Add a filter to add another filter.
Click Apply.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage deployments/Manage environmentsManaging environments for deploymentYou can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.Who can use this feature?Repository ownersEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.In this articleAbout environmentsDeployment protection rulesEnvironment secretsEnvironment variablesCreating an environmentDeleting an environmentHow environments relate to deploymentsNext stepsAbout environments
Environments are used to describe a general deployment target like production, staging, or development. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. For more information about viewing deployments to environments, see Viewing deployment history.
You can configure environments with protection rules and secrets. When a workflow job references an environment, the job won't start until all of the environment's protection rules pass. A job also cannot access secrets that are defined in an environment until all the deployment protection rules pass.
Optionally, you can bypass an environment's protection rules and force all pending jobs referencing the environment to proceed. For more information, see Reviewing deployments.
Note

Users with GitHub Free plans can only configure environments for public repositories. If you convert a repository from public to private, any configured protection rules or environment secrets will be ignored, and you will not be able to configure any environments. If you convert your repository back to public, you will have access to any previously configured protection rules and environment secrets.
Organizations with GitHub Team and users with GitHub Pro can configure environments for private repositories. For more information, see GitHub’s plans.

Deployment protection rules
Deployment protection rules require specific conditions to pass before a job referencing the environment can proceed. You can use deployment protection rules to require a manual approval, delay a job, or restrict the environment to certain branches. You can also create and implement custom protection rules powered by GitHub Apps to use third-party systems to control deployments referencing environments configured on GitHub.
Third-party systems can be observability systems, change management systems, code quality systems, or other manual configurations that you use to assess readiness before deployments are safely rolled out to environments.
Note

Any number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.

Required reviewers
Use required reviewers to require a specific person or team to approve workflow jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
You also have the option to prevent self-reviews for deployments to protected environments. If you enable this setting, users who initiate a deployment cannot approve the deployment job, even if they are a required reviewer. This ensures that deployments to protected environments are always reviewed by more than one person.
For more information on reviewing jobs that reference an environment with required reviewers, see Reviewing deployments.
Note

If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, required reviewers are only available for public repositories.

Wait timer
Use a wait timer to delay a job for a specific amount of time after the job is initially triggered. The time (in minutes) must be an integer between 1 and 43,200 (30 days). Wait time will not count towards your billable time.
Note

If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, wait timers are only available for public repositories.

Deployment branches and tags
Use deployment branches and tags to restrict which branches and tags can deploy to the environment. Below are the options for deployment branches and tags for an environment:


No restriction: No restriction on which branch or tag can deploy to the environment.


Protected branches only: Only branches with branch protection rules enabled can deploy to the environment. If no branch protection rules are defined for any branch in the repository, then all branches can deploy. For more information about branch protection rules, see About protected branches.
Note

Deployment workflow runs triggered by tags with the same name as a protected branch and forks with branches that match the protected branch name cannot deploy to the environment.



Selected branches and tags: Only branches and tags that match your specified name patterns can deploy to the environment.
If you specify releases/* as a deployment branch or tag rule, only a branch or tag whose name begins with releases/ can deploy to the environment. (Wildcard characters will not match /. To match branches or tags that begin with release/ and contain an additional single slash, use release/*/*.) If you add main as a branch rule, a branch named main can also deploy to the environment. For more information about syntax options for deployment branches, see the Ruby File.fnmatch documentation.
Note

Name patterns must be configured for branches or tags individually.



Note

Deployment branches and tags are available for all public repositories. For users on GitHub Pro or GitHub Team plans, deployment branches and tags are also available for private repositories.

Allow administrators to bypass configured protection rules
By default, administrators can bypass the protection rules and force deployments to specific environments. For more information, see Reviewing deployments.
Alternatively, you can configure environments to disallow bypassing the protection rules for all deployments to the environment.
Note

Allowing administrators to bypass protection rules is only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans.

Custom deployment protection rules
Note

Custom deployment protection rules are currently in public preview and subject to change.

You can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub. For more information, see Creating custom deployment protection rules.
Once custom deployment protection rules have been created and installed on a repository, you can enable the custom deployment protection rule for any environment in the repository. For more information about configuring and enabling custom deployment protection rules, see Configuring custom deployment protection rules.
Note

Custom deployment protection rules are only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans.

Environment secrets
Secrets stored in an environment are only available to workflow jobs that reference the environment. If the environment requires approval, a job cannot access environment secrets until one of the required reviewers approves it. For more information about secrets, see About secrets.
Note


Workflows that run on self-hosted runners are not run in an isolated container, even if they use environments. Environment secrets should be treated with the same level of security as repository and organization secrets. For more information, see Security hardening for GitHub Actions.
If you are using GitHub Free, environment secrets are only available in public repositories. For access to environment secrets in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. For more information on switching your plan, see Upgrading your account's plan.


Environment variables
Variables stored in an environment are only available to workflow jobs that reference the environment. These variables are only accessible using the vars context. For more information, see Store information in variables.
Note

Environment variables are available for all public repositories. For users on GitHub Pro or GitHub Team plans, environment variables are also available for private repositories.

Creating an environment
To configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must have admin access.
Note


Creation of an environment in a private repository is available to organizations with GitHub Team and users with GitHub Pro.
Some features for environments have no or limited availability for private repositories. If you are unable to access a feature described in the instructions below, please see the documentation linked in the related step for availability information.




On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click Environments.


Click New environment.


Enter a name for the environment, then click Configure environment. Environment names are not case sensitive. An environment name may not exceed 255 characters and must be unique within the repository.


Optionally, specify people or teams that must approve workflow jobs that use this environment. For more information, see Required reviewers.

Select Required reviewers.
Enter up to 6 people or teams. Only one of the required reviewers needs to approve the job for it to proceed.
Optionally, to prevent users from approving workflows runs that they triggered, select Prevent self-review.
Click Save protection rules.



Optionally, specify the amount of time to wait before allowing workflow jobs that use this environment to proceed. For more information, see Wait timer.

Select Wait timer.
Enter the number of minutes to wait.
Click Save protection rules.



Optionally, disallow bypassing configured protection rules. For more information, see Allow administrators to bypass configured protection rules.

Deselect Allow administrators to bypass configured protection rules.
Click Save protection rules.



Optionally, enable any custom deployment protection rules that have been created with GitHub Apps. For more information, see Custom deployment protection rules.

Select the custom protection rule you want to enable.
Click Save protection rules.



Optionally, specify what branches and tags can deploy to this environment. For more information, see Deployment branches and tags.


Select the desired option in the Deployment branches dropdown.


If you chose Selected branches and tags, to add a new rule, click Add deployment branch or tag rule


In the "Ref type" dropdown menu, depending on what rule you want to apply, click  Branch or  Tag.


Enter the name pattern for the branch or tag that you want to allow.
Note

Name patterns must be configured for branches or tags individually.



Click Add rule.




Optionally, add environment secrets. These secrets are only available to workflow jobs that use the environment. Additionally, workflow jobs that use this environment can only access these secrets after any configured rules (for example, required reviewers) pass. For more information, see Environment secrets.

Under Environment secrets, click Add Secret.
Enter the secret name.
Enter the secret value.
Click Add secret.



Optionally, add environment variables. These variables are only available to workflow jobs that use the environment, and are only accessible using the vars context. For more information, see Environment variables.

Under Environment variables, click Add Variable.
Enter the variable name.
Enter the variable value.
Click Add variable.



You can also create and configure environments through the REST API. For more information, see REST API endpoints for deployment environments, REST API endpoints for GitHub Actions Secrets, REST API endpoints for GitHub Actions variables, and REST API endpoints for deployment branch policies.
Running a workflow that references an environment that does not exist will create an environment with the referenced name. If the environment is created from running implicit page builds (for example, from a branch or folder source), the source branch will be added as a protection rule to the environment. Otherwise, the newly created environment will not have any protection rules or secrets configured. Anyone that can edit workflows in the repository can create environments via a workflow file, but only repository admins can configure the environment.
Deleting an environment
To configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must have admin access.
Deleting an environment will delete all secrets and protection rules associated with the environment. Any jobs currently waiting because of protection rules from the deleted environment will automatically fail.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click Environments.


Next to the environment that you want to delete, click .


Click I understand, delete this environment.


You can also delete environments through the REST API. For more information, see REST API endpoints for repositories.
How environments relate to deployments
When a workflow job that references an environment runs, it creates a deployment object with the environment property set to the name of your environment. As the workflow progresses, it also creates deployment status objects with the environment property set to the name of your environment, the environment_url property set to the URL for environment (if specified in the workflow), and the state property set to the status of the job.
You can access these objects through the REST API or GraphQL API. You can also subscribe to these webhook events. For more information, see REST API endpoints for repositories, Objects (GraphQL API), or Webhook events and payloads.
Next steps
GitHub Actions provides several features for managing your deployments. For more information, see Deploying with GitHub Actions.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage deployments/Review deploymentsReviewing deploymentsYou can approve or reject jobs awaiting review.Who can use this feature?Environments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.In this articleAbout required reviews in workflowsApproving or rejecting a jobBypassing deployment protection rulesAbout required reviews in workflows
Jobs that reference an environment configured with required reviewers will wait for an approval before starting. While a job is awaiting approval, it has a status of "Waiting". If a job is not approved within 30 days, it will automatically fail.
For more information about environments and required approvals, see Managing environments for deployment. For information about how to review deployments with the REST API, see REST API endpoints for workflow runs.
Approving or rejecting a job

Navigate to the workflow run that requires review. For more information about navigating to a workflow run, see Viewing workflow run history.
If the run requires review, you will see a notification for the review request. On the notification, click Review deployments.
Select the job environment(s) to approve or reject. Optionally, leave a comment.
Approve or reject:

To approve the job, click Approve and deploy. Once a job is approved (and any other deployment protection rules have passed), the job will proceed. At this point, the job can access any secrets stored in the environment.
To reject the job, click Reject. If a job is rejected, the workflow will fail.



Note

If the targeted environment is configured to prevent self-approvals for deployments, you will not be able to approve a deployment from a workflow run you initiated. For more information, see Managing environments for deployment.

Bypassing deployment protection rules
If you have configured deployment protection rules that control whether software can be deployed to an environment, you can bypass these rules and force all pending jobs referencing the environment to proceed.
Note


You cannot bypass deployment protection rules if the environment has been configured to prevent admins from bypassing configured protection rules. For more information, see Managing environments for deployment.
You can only bypass deployment protection rules during workflow execution when a job referencing the environment is in a "Pending" state.



Navigate to the workflow run. For more information about navigating to a workflow run, see Viewing workflow run history.
To the right of Deployment protection rules, click Start all waiting jobs.

In the pop-up window, select the environments for which you want to bypass deployment protection rules.
Under Leave a comment, enter a description for bypassing the deployment protection rules.
Click I understand the consequences, start deploying.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage deployments/Create custom protection rulesCreating custom deployment protection rulesUse GitHub Apps to automate protecting deployments with third-party systems.Who can use this feature?Custom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see GitHub’s plans.In this articleAbout custom deployment protection rulesUsing custom deployment protection rules to approve or reject deploymentsCreating a custom deployment protection rule with GitHub AppsApproving or rejecting deploymentsPublishing custom deployment protection rules in the GitHub MarketplaceNote

Custom deployment protection rules are currently in public preview and subject to change.

About custom deployment protection rules
You can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub.
Custom deployment protection rules are powered by GitHub Apps and run based on webhooks and callbacks. Approval or rejection of a workflow job is based on consumption of the deployment_protection_rule webhook. For more information, see Webhook events and payloads and Approving or rejecting deployments.
Once you have created a custom deployment protection rule and installed it on your repository, the custom deployment protection rule will automatically be available for all environments in the repository.
Using custom deployment protection rules to approve or reject deployments
Deployments to an environment can be approved or rejected based on the conditions defined in any external service like an approved ticket in an IT Service Management (ITSM) system, vulnerable scan result on dependencies, or stable health metrics of a cloud resource. The decision to approve or reject deployments is at the discretion of the integrating third-party application and the gating conditions you define in them. The following are a few use cases for which you can create a deployment protection rule.

ITSM & Security Operations: you can check for service readiness by validating quality, security, and compliance processes that verify deployment readiness.
Observability systems: you can consult monitoring or observability systems (Asset Performance Management Systems and logging aggregators, cloud resource health verification systems, etc.) for verifying the safety and deployment readiness.
Code quality & testing tools: you can check for automated tests on CI builds which need to be deployed to an environment.

Alternatively, you can write your own protection rules for any of the above use cases or you can define any custom logic to safely approve or reject deployments from pre-production to production environments.
Creating a custom deployment protection rule with GitHub Apps


Create a GitHub App. For more information, see Registering a GitHub App. Configure the GitHub App as follows.

Optionally, in the Callback URL text field under "Identifying and authorizing users," enter the callback URL. For more information, see About the user authorization callback URL.
Under "Permissions," select Repository permissions.
To the right of "Actions," click the drop down menu and select Access: Read-only.

To the right of "Deployments," click the drop down menu and select Access: Read and write.

Under "Subscribe to events," select Deployment protection rule.




Install the custom deployment protection rule in your repositories and enable it for use. For more information, see Configuring custom deployment protection rules.


Approving or rejecting deployments
Once a workflow reaches a job that references an environment that has the custom deployment protection rule enabled, GitHub sends a POST request to a URL you configure containing the deployment_protection_rule payload. You can write your deployment protection rule to automatically send REST API requests that approve or reject the deployment based on the deployment_protection_rule payload. Configure your REST API requests as follows.


Validate the incoming POST request. For more information, see Validating webhook deliveries.


Use a JSON Web Token to authenticate as a GitHub App. For more information, see Authenticating as a GitHub App.


Using the installation ID from the deployment_protection_rule webhook payload, generate an install token. For more information, see About authentication with a GitHub App.
curl --request POST \
--url "https://api.github.com/app/installations/INSTALLATION_ID/ACCESS_TOKENS" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer {jwt}" \
--header "Content-Type: application/json" \
--data \
'{ \
   "repository_ids": [321], \
   "permissions": { \
      "deployments": "write" \
   } \
}'



Optionally, to add a status report without taking any other action to GitHub, send a POST request to /repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule. In the request body, omit the state. For more information, see REST API endpoints for workflow runs. You can post a status report on the same deployment up to 10 times. Status reports support Markdown formatting and can be up to 1024 characters long.


To approve or reject a request, send a POST request to /repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule. In the request body, set the state property to either approved or rejected. For more information, see REST API endpoints for workflow runs.


Optionally, request the status of an approval for a workflow run by sending a GET request to /repos/OWNER/REPOSITORY_ID/actions/runs/RUN_ID/approvals. For more information, see REST API endpoints for workflow runs.


Optionally, review the deployment on GitHub. For more information, see Reviewing deployments.


Publishing custom deployment protection rules in the GitHub Marketplace
You can publish your GitHub App to the GitHub Marketplace to allow developers to discover suitable protection rules and install it across their GitHub repositories. Or you can browse existing custom deployment protection rules to suit your needs. For more information, see About GitHub Marketplace for apps and Listing an app on GitHub Marketplace.\n\n\n\nGitHub Actions/Manage workflows and deployments/Manage deployments/Configure custom protection rulesConfiguring custom deployment protection rulesUse GitHub Apps to automate protecting deployments with third-party systems.Who can use this feature?Custom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see GitHub’s plans.In this articleAbout custom deployment protection rulesUsing existing custom deployment protection rulesPrerequisitesEnabling custom deployment protection rules for the environmentNote

Custom deployment protection rules are currently in public preview and subject to change.

About custom deployment protection rules
Custom deployment protection rules are powered by GitHub Apps. Once a deployment protection rule is configured and installed in a repository, it can be enabled for any environments in the repository.
After you enable a custom deployment protection rule on an environment, every time a workflow step targets that environment, the deployment protection rule will run automatically. For more information about targeting an environment for deployments, see Managing environments for deployment.
When a custom deployment protection rule is triggered it will wait for up to 30 days for a webhook event response before it times out and the workflow job fails.
For more information about creating your own custom deployment protection rules, see Creating custom deployment protection rules.
Note

Any number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.

Using existing custom deployment protection rules
You can choose to create your own custom deployment protection rules or you may use any existing custom deployment protection rules.
The following is a list of official partner implementations for deployment protection rules.

Datadog: you can enforce protection rules on your GitHub Actions deployment workflows using Datadog monitors. For more information, see Gating your GitHub Actions Deployments with Datadog Monitors in the Datadog documentation.
Honeycomb: you can define thresholds to reject or approve deployments based on data you are sending to Honeycomb. For more information, see the Honeycomb app in the GitHub Marketplace.
New Relic: for more information, see the New Relic app in the GitHub Marketplace.
NCM NodeSource: for more information, see the NCM NodeSource app in the GitHub Marketplace.
Sentry: for more information, see the Sentry Deployment Gate app in the GitHub Marketplace.
ServiceNow: for more information, see GitHub integration with DevOps Change Velocity in the ServiceNow documentation.

Prerequisites
In order for a custom deployment protection rule to be available to all environments in a repository, you must first install the custom deployment protection rule on the repository. For more information, see Installing your own GitHub App.
After a custom deployment protection rule has been installed in a repository, it must be enabled for each environment where you want the rule to apply.
Enabling custom deployment protection rules for the environment


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click Environments.


Select the environment you want to configure.


Under "Deployment protection rules," check the box next to each custom deployment protection rule you want to enable for the environment.


Click Save protection rules.


Once a custom deployment protection rule has been enabled for an environment, it will automatically run whenever a workflow reaches a job that references the environment. You can see the results of an approval or rejection for your deployment by reviewing the details of the deployment. For more information, see Reviewing deployments.\n\n\n\nGitHub Actions/Share automations/Avoid duplicationAvoiding duplicationYou can use reusable workflows or composite actions to avoid duplicating the content of workflows.In this articleAbout reusable workflows and composite actionsComparison of reusable workflows and composite actionsAbout reusable workflows and composite actions
Reusable workflows and composite actions are two ways to avoid duplicating the content of workflows.
Reusable workflows allow you to reuse an entire workflow, including all of its jobs and steps. This is particularly useful when you have a complete CI/CD process that you want to use across multiple repositories. Reusable workflows can be centrally maintained, in one location, but used in many repositories across your organization.
Composite actions allow you to combine multiple steps into a single action. You can then run this bundle of steps as a single step within a workflow. This is useful if you have a sequence of steps that will be used in more than one workflow. Composite actions allow you refactor long YAML workflow files into much smaller files and avoid copying and pasting between workflow files.
Reusable workflows and composite actions solve similar problems, but have a few important differences. Most of the time you can use either solution. But some of the time, you’ll need to use one or the other, as described later in this article.
For details of how to create and use reusable workflows and composite actions, see Reusing workflows and Creating a composite action.
Comparison of reusable workflows and composite actions

Workflow jobs - Composite actions contain a series of steps, that are run as a single step within the caller workflow. Unlike reusable workflows, they cannot contain jobs.
Logging - When a composite action runs, the log will show just the step in the caller workflow that ran the composite action, not the individual steps within the composite action. With reusable workflows, every job and step is logged separately.
Specifying runners - Reusable workflows contain one or more jobs. As with all workflow jobs, the jobs in a reusable workflow specify the type of machine on which the job will run. Therefore, if the steps must be run on a type of machine that might be different from the machine chosen for the calling workflow job, then you should use a reusable workflow, not a composite action.
Passing output to steps - A composite action is run as a step within a workflow job, and you can have multiple steps before or after the step that runs the composite action. Reusable workflows are called directly within a job, and not from within a job step. You can't add steps to a job after calling a reusable workflow, so you can't use GITHUB_ENV to pass values to subsequent job steps in the caller workflow.

Key differences between reusable workflows and composite actions









































Reusable workflowsComposite actionsA YAML file, very similar to any standard workflow fileAn action containing a bundle of workflow stepsEach reusable workflow is a single file in the .github/workflows directory of a repositoryEach composite action is a separate repository, or a directory, containing an action.yml file and, optionally, other filesCalled by referencing a specific YAML fileCalled by referencing a repository or directory in which the action is definedCalled directly within a job, not from a stepRun as a step within a jobCan contain multiple jobsDoes not contain jobsEach step is logged in real-timeLogged as one step even if it contains multiple stepsCan connect a maximum of four levels of workflowsCan be nested to have up to 10 composite actions in one workflowCan use secretsCannot use secrets\n\n\n\nGitHub Actions/Share automations/Create actions/About custom actionsAbout custom actionsActions are individual tasks that you can combine to create jobs and customize your workflow. You can create your own actions, or use and customize actions shared by the GitHub community.In this articleAbout custom actionsTypes of actionsChoosing a location for your actionEnsuring compatibility with other platformsUsing release management for actionsCreating a README file for your actionComparing GitHub Actions to GitHub AppsFurther readingAbout custom actions
You can create actions by writing custom code that interacts with your repository in any way you'd like, including integrating with GitHub's APIs and any publicly available third-party API. For example, an action can publish npm modules, send SMS alerts when urgent issues are created, or deploy production-ready code.
You can write your own actions to use in your workflow or share the actions you build with the GitHub community. To share actions you've built with everyone, your repository must be public.
Actions can run directly on a machine or in a Docker container. You can define an action's inputs, outputs, and environment variables.
Types of actions
You can build Docker container, JavaScript, and composite actions. Actions require a metadata file to define the inputs, outputs and main entrypoint for your action. The metadata filename must be action.yml. For more information, see Metadata syntax for GitHub Actions.






























TypeLinuxmacOSWindowsDocker containerJavaScriptComposite Actions

Docker container actions
Docker containers package the environment with the GitHub Actions code. This creates a more consistent and reliable unit of work because the consumer of the action does not need to worry about the tools or dependencies.
A Docker container allows you to use specific versions of an operating system, dependencies, tools, and code. For actions that must run in a specific environment configuration, Docker is an ideal option because you can customize the operating system and tools. Because of the latency to build and retrieve the container, Docker container actions are slower than JavaScript actions.
Docker container actions can only execute on runners with a Linux operating system. Self-hosted runners must use a Linux operating system and have Docker installed to run Docker container actions. For more information about the requirements of self-hosted runners, see About self-hosted runners.
JavaScript actions
JavaScript actions can run directly on a runner machine, and separate the action code from the environment used to run the code. Using a JavaScript action simplifies the action code and executes faster than a Docker container action.
To ensure your JavaScript actions are compatible with all GitHub-hosted runners (Ubuntu, Windows, and macOS), the packaged JavaScript code you write should be pure JavaScript and not rely on other binaries. JavaScript actions run directly on the runner and use binaries that already exist in the runner image.
If you're developing a Node.js project, the GitHub Actions Toolkit provides packages that you can use in your project to speed up development. For more information, see the actions/toolkit repository.
Composite Actions
A composite action allows you to combine multiple workflow steps within one action. For example, you can use this feature to bundle together multiple run commands into an action, and then have a workflow that executes the bundled commands as a single step using that action. To see an example, check out Creating a composite action.
Choosing a location for your action
If you're developing an action for other people to use, we recommend keeping the action in its own repository instead of bundling it with other application code. This allows you to version, track, and release the action just like any other software.
Storing an action in its own repository makes it easier for the GitHub community to discover the action, narrows the scope of the code base for developers fixing issues and extending the action, and decouples the action's versioning from the versioning of other application code.
If you're building an action that you don't plan to make available to others, you  can store the action's files in any location in your repository. If you plan to combine action, workflow, and application code in a single repository, we recommend storing actions in the .github directory. For example, .github/actions/action-a and .github/actions/action-b.
Ensuring compatibility with other platforms
Many people access GitHub at a domain other than GitHub.com, such as GHE.com or a custom domain for GitHub Enterprise Server.
To ensure that your action is compatible with other platforms, do not use any hard-coded references to API URLs such as https://api.github.com. Instead, you can:


Use environment variables (see Store information in variables):

For the REST API, use the GITHUB_API_URL environment variable.
For GraphQL, use the GITHUB_GRAPHQL_URL environment variable.



Use a toolkit such as @actions/github, which can automatically set the correct URLs.


Using release management for actions
This section explains how you can use release management to distribute updates to your actions in a predictable way.
Good practices for release management
If you're developing an action for other people to use, we recommend using release management to control how you distribute updates. Users can expect an action's patch version to include necessary critical fixes and security patches, while still remaining compatible with their existing workflows. You should consider releasing a new major version whenever your changes affect compatibility.
Under this release management approach, users should not be referencing an action's default branch, as it's likely to contain the latest code and consequently might be unstable. Instead, you can recommend that your users specify a major version when using your action, and only direct them to a more specific version if they encounter issues.
To use a specific action version, users can configure their GitHub Actions workflow to target a tag, a commit's SHA, or a branch named for a release.
Using tags for release management
We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions:

Create and validate a release on a release branch (such as release/v1) before creating the release tag (for example, v1.0.2).
Create a release using semantic versioning. For more information, see Managing releases in a repository.
Move the major version tag (such as v1, v2) to point to the Git ref of the current release. For more information, see Git basics - tagging.
Introduce a new major version tag (v2) for changes that will break existing workflows. For example, changing an action's inputs would be a breaking change.
Major versions can be initially released with a beta tag to indicate their status, for example, v2-beta. The -beta tag can then be removed when ready.

This example demonstrates how a user can reference a major release tag:
steps:
    - uses: actions/javascript-action@v1

This example demonstrates how a user can reference a specific patch release tag:
steps:
    - uses: actions/javascript-action@v1.0.1

Using branches for release management
If you prefer to use branch names for release management, this example demonstrates how to reference a named branch:
steps:
    - uses: actions/javascript-action@v1-beta

Using a commit's SHA for release management
Each Git commit receives a calculated SHA value, which is unique and immutable. Your action's users might prefer to rely on a commit's SHA value, as this approach can be more reliable than specifying a tag, which could be deleted or moved. However, this means that users will not receive further updates made to the action. You must use a commit's full SHA value, and not an abbreviated value.
steps:
    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f

Creating a README file for your action
We recommend creating a README file to help people learn how to use your action. You can include this information in your README.md:

A detailed description of what the action does
Required input and output arguments
Optional input and output arguments
Secrets the action uses
Environment variables the action uses
An example of how to use your action in a workflow

Comparing GitHub Actions to GitHub Apps
GitHub Marketplace offers tools to improve your workflow. Understanding the differences and the benefits of each tool will allow you to select the best tool for your job. For more information about building apps, see About creating GitHub Apps.
Strengths of GitHub Actions and GitHub Apps
While both GitHub Actions and GitHub Apps provide ways to build automation and workflow tools, they each have strengths that make them useful in different ways.
GitHub Apps:

Run persistently and can react to events quickly.
Work great when persistent data is needed.
Work best with API requests that aren't time consuming.
Run on a server or compute infrastructure that you provide.

GitHub Actions:

Provide automation that can perform continuous integration and continuous deployment.
Can run directly on runner machines or in Docker containers.
Can include access to a clone of your repository, enabling deployment and publishing tools, code formatters, and command line tools to access your code.
Don't require you to deploy code or serve an app.
Have a simple interface to create and use secrets, which enables actions to interact with third-party services without needing to store the credentials of the person using the action.

Further reading

Workflow commands for GitHub Actions\n\n\n\nGitHub Actions/Share automations/Create actions/Create a Docker container actionCreating a Docker container actionThis guide shows you the minimal steps required to build a Docker container action.In this articleIntroductionPrerequisitesCreating a DockerfileCreating an action metadata fileWriting the action codeCreating a READMECommit, tag, and push your actionTesting out your action in a workflowAccessing files created by a container actionExample Docker container actions on GitHub.comIntroduction
In this guide, you'll learn about the basic components needed to create and use a packaged Docker container action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints "Hello World" in the logs or "Hello [who-to-greet]" if you provide a custom name.
Once you complete this project, you should understand how to build your own Docker container action and test it in a workflow.
Self-hosted runners must use a Linux operating system and have Docker installed to run Docker container actions. For more information about the requirements of self-hosted runners, see About self-hosted runners.
Warning

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.

Prerequisites

You must create a repository on GitHub and clone it to your workstation. For more information, see Creating a new repository and Cloning a repository.
If your repository uses Git LFS, you must include the objects in archives of your repository. For more information, see Managing Git LFS objects in archives of your repository.
You may find it helpful to have a basic understanding of GitHub Actions, environment variables and the Docker container filesystem. For more information, see Store information in variables and Using GitHub-hosted runners.

Creating a Dockerfile
In your new hello-world-docker-action directory, create a new Dockerfile file. Make sure that your filename is capitalized correctly (use a capital D but not a capital f) if you're having issues. For more information, see Dockerfile support for GitHub Actions.
Dockerfile
Dockerfile# Container image that runs your code
FROM alpine:3.10

# Copies your code file from your action repository to the filesystem path `/` of the container
COPY entrypoint.sh /entrypoint.sh

# Code file to execute when the docker container starts up (`entrypoint.sh`)
ENTRYPOINT ["/entrypoint.sh"]
# Container image that runs your code
FROM alpine:3.10

# Copies your code file from your action repository to the filesystem path `/` of the container
COPY entrypoint.sh /entrypoint.sh

# Code file to execute when the docker container starts up (`entrypoint.sh`)
ENTRYPOINT ["/entrypoint.sh"]

Creating an action metadata file
Create a new action.yml file in the hello-world-docker-action directory you created above. For more information, see Metadata syntax for GitHub Actions.
action.yml
YAML# action.yml
name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.who-to-greet }}
# action.yml
name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.who-to-greet }}

This metadata defines one who-to-greet input and one time output parameter. To pass inputs to the Docker container, you should declare the input using inputs and pass the input in the args keyword. Everything you include in args is passed to the container, but for better discoverability for users of your action, we recommended using inputs.
GitHub will build an image from your Dockerfile, and run commands in a new container using this image.
Writing the action code
You can choose any base Docker image and, therefore, any language for your action. The following shell script example uses the who-to-greet input variable to print "Hello [who-to-greet]" in the log file.
Next, the script gets the current time and sets it as an output variable that actions running later in a job can use. In order for GitHub to recognize output variables, you must write them to the $GITHUB_OUTPUT environment file: echo "<output name>=<value>" >> $GITHUB_OUTPUT. For more information, see Workflow commands for GitHub Actions.


Create a new entrypoint.sh file in the hello-world-docker-action directory.


Add the following code to your entrypoint.sh file.
entrypoint.sh
Shell#!/bin/sh -l

echo "Hello $1"
time=$(date)
echo "time=$time" >> $GITHUB_OUTPUT

#!/bin/sh -l

echo "Hello $1"
time=$(date)
echo "time=$time" >> $GITHUB_OUTPUT


If entrypoint.sh executes without any errors, the action's status is set to success. You can also explicitly set exit codes in your action's code to provide an action's status. For more information, see Setting exit codes for actions.


Make your entrypoint.sh file executable. Git provides a way to explicitly change the permission mode of a file so that it doesn’t get reset every time there is a clone/fork.
Shellgit add entrypoint.sh
git update-index --chmod=+x entrypoint.sh
git add entrypoint.sh
git update-index --chmod=+x entrypoint.sh



Optionally, to check the permission mode of the file in the git index, run the following command.
Shellgit ls-files --stage entrypoint.sh
git ls-files --stage entrypoint.sh

An output like 100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       entrypoint.sh means the file has the executable permission. In this example, 755 denotes the executable permission.


Creating a README
To let people know how to use your action, you can create a README file. A README is most helpful when you plan to share your action publicly, but is also a great way to remind you or your team how to use the action.
In your hello-world-docker-action directory, create a README.md file that specifies the following information:

A detailed description of what the action does.
Required input and output arguments.
Optional input and output arguments.
Secrets the action uses.
Environment variables the action uses.
An example of how to use your action in a workflow.

README.md
Markdown# Hello world docker action

This action prints "Hello World" or "Hello" + the name of a person to greet to the log.

## Inputs

## `who-to-greet`

**Required** The name of the person to greet. Default `"World"`.

## Outputs

## `time`

The time we greeted you.

## Example usage

uses: actions/hello-world-docker-action@v2
with:
  who-to-greet: 'Mona the Octocat'
# Hello world docker action

This action prints "Hello World" or "Hello" + the name of a person to greet to the log.

## Inputs

## `who-to-greet`

**Required** The name of the person to greet. Default `"World"`.

## Outputs

## `time`

The time we greeted you.

## Example usage

uses: actions/hello-world-docker-action@v2
with:
  who-to-greet: 'Mona the Octocat'

Commit, tag, and push your action
From your terminal, commit your action.yml, entrypoint.sh, Dockerfile, and README.md files.
It's best practice to also add a version tag for releases of your action. For more information on versioning your action, see About custom actions.
Shellgit add action.yml entrypoint.sh Dockerfile README.md
git commit -m "My first action is ready"
git tag -a -m "My first action release" v1
git push --follow-tags
git add action.yml entrypoint.sh Dockerfile README.md
git commit -m "My first action is ready"
git tag -a -m "My first action release" v1
git push --follow-tags

Testing out your action in a workflow
Now you're ready to test your action out in a workflow.

When an action is in a private repository, you can control who can access it. For more information, see Managing GitHub Actions settings for a repository.
When an action is in an internal repository, the action can only be used in workflows in the same repository.
Public actions can be used by workflows in any repository.

Example using a public action
The following workflow code uses the completed hello world action in the public actions/hello-world-docker-action repository. Copy the following workflow example code into a .github/workflows/main.yml file, but replace the actions/hello-world-docker-action with your repository and action name. You can also replace the who-to-greet input with your name. Public actions can be used even if they're not published to GitHub Marketplace. For more information, see Publishing actions in GitHub Marketplace.
.github/workflows/main.yml
YAMLon: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: actions/hello-world-docker-action@v2
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"
on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: actions/hello-world-docker-action@v2
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"

Example using a private action
Copy the following example workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name. This private action can't be published to GitHub Marketplace, and can only be used in this repository.
.github/workflows/main.yml
YAMLon: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"
on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"

From your repository, click the Actions tab, and select the latest workflow run. Under Jobs or in the visualization graph, click A job to say hello.
Click Hello world action step, and you should see "Hello Mona the Octocat" or the name you used for the who-to-greet input printed in the log. To see the timestamp, click Get the output time.
Accessing files created by a container action
When a container action runs, it will automatically map the default working directory (GITHUB_WORKSPACE) on the runner with the /github/workspace directory on the container. Any files added to this directory on the container will be available to any subsequent steps in the same job. For example, if you have a container action that builds your project, and you would like to upload the build output as an artifact, you can use the following steps.
workflow.yml
YAMLjobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Output build artifacts to /github/workspace on the container.
      - name: Containerized Build
        uses: ./.github/actions/my-container-action

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workspace_artifacts
          path: ${{ github.workspace }}
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Output build artifacts to /github/workspace on the container.
      - name: Containerized Build
        uses: ./.github/actions/my-container-action

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workspace_artifacts
          path: ${{ github.workspace }}

For more information about uploading build output as an artifact, see Storing and sharing data from a workflow.
Example Docker container actions on GitHub.com
You can find many examples of Docker container actions on GitHub.com.

github/issue-metrics
microsoft/infersharpaction
microsoft/ps-docs\n\n\n\nGitHub Actions/Share automations/Create actions/Create a JavaScript actionCreating a JavaScript actionIn this guide, you'll learn how to build a JavaScript action using the actions toolkit.In this articleIntroductionPrerequisitesCreating an action metadata fileAdding actions toolkit packagesWriting the action codeCreating a READMECommit, tag, and push your actionTesting out your action in a workflowTemplate repositories for creating JavaScript actionsExample JavaScript actions on GitHub.comIntroduction
In this guide, you'll learn about the basic components needed to create and use a packaged JavaScript action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints "Hello World" in the logs or "Hello [who-to-greet]" if you provide a custom name.
This guide uses the GitHub Actions Toolkit Node.js module to speed up development. For more information, see the actions/toolkit repository.
Once you complete this project, you should understand how to build your own JavaScript action and test it in a workflow.
To ensure your JavaScript actions are compatible with all GitHub-hosted runners (Ubuntu, Windows, and macOS), the packaged JavaScript code you write should be pure JavaScript and not rely on other binaries. JavaScript actions run directly on the runner and use binaries that already exist in the runner image.
Warning

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.

Prerequisites
Before you begin, you'll need to download Node.js and create a public GitHub repository.


Download and install Node.js 20.x, which includes npm.
https://nodejs.org/en/download/


Create a new public repository on GitHub and call it "hello-world-javascript-action". For more information, see Creating a new repository.


Clone your repository to your computer. For more information, see Cloning a repository.


From your terminal, change directories into your new repository.
Shellcd hello-world-javascript-action
cd hello-world-javascript-action



From your terminal, initialize the directory with npm to generate a package.json file.
Shellnpm init -y
npm init -y



Creating an action metadata file
Create a new file named action.yml in the hello-world-javascript-action directory with the following example code. For more information, see Metadata syntax for GitHub Actions.
YAMLname: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'node20'
  main: 'index.js'
name: 'Hello World'
description: 'Greet someone and record the time'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  time: # id of output
    description: 'The time we greeted you'
runs:
  using: 'node20'
  main: 'index.js'

This file defines the who-to-greet input and time output. It also tells the action runner how to start running this JavaScript action.
Adding actions toolkit packages
The actions toolkit is a collection of Node.js packages that allow you to quickly build JavaScript actions with more consistency.
The toolkit @actions/core package provides an interface to the workflow commands, input and output variables, exit statuses, and debug messages.
The toolkit also offers a @actions/github package that returns an authenticated Octokit REST client and access to GitHub Actions contexts.
The toolkit offers more than the core and github packages. For more information, see the actions/toolkit repository.
At your terminal, install the actions toolkit core and github packages.
Shellnpm install @actions/core
npm install @actions/github
npm install @actions/core
npm install @actions/github

Now you should see a node_modules directory with the modules you just installed and a package-lock.json file with the installed module dependencies and the versions of each installed module.
Writing the action code
This action uses the toolkit to get the who-to-greet input variable required in the action's metadata file and prints "Hello [who-to-greet]" in a debug message in the log. Next, the script gets the current time and sets it as an output variable that actions running later in a job can use.
GitHub Actions provide context information about the webhook event, Git refs, workflow, action, and the person who triggered the workflow. To access the context information, you can use the github package. The action you'll write will print the webhook event payload to the log.
Add a new file called index.js, with the following code.
JavaScriptconst core = require('@actions/core');
const github = require('@actions/github');

try {
  // `who-to-greet` input defined in action metadata file
  const nameToGreet = core.getInput('who-to-greet');
  console.log(`Hello ${nameToGreet}!`);
  const time = (new Date()).toTimeString();
  core.setOutput("time", time);
  // Get the JSON webhook payload for the event that triggered the workflow
  const payload = JSON.stringify(github.context.payload, undefined, 2)
  console.log(`The event payload: ${payload}`);
} catch (error) {
  core.setFailed(error.message);
}
const core = require('@actions/core');
const github = require('@actions/github');

try {
  // `who-to-greet` input defined in action metadata file
  const nameToGreet = core.getInput('who-to-greet');
  console.log(`Hello ${nameToGreet}!`);
  const time = (new Date()).toTimeString();
  core.setOutput("time", time);
  // Get the JSON webhook payload for the event that triggered the workflow
  const payload = JSON.stringify(github.context.payload, undefined, 2)
  console.log(`The event payload: ${payload}`);
} catch (error) {
  core.setFailed(error.message);
}

If an error is thrown in the above index.js example, core.setFailed(error.message); uses the actions toolkit @actions/core package to log a message and set a failing exit code. For more information, see Setting exit codes for actions.
Creating a README
To let people know how to use your action, you can create a README file. A README is most helpful when you plan to share your action publicly, but is also a great way to remind you or your team how to use the action.
In your hello-world-javascript-action directory, create a README.md file that specifies the following information:

A detailed description of what the action does.
Required input and output arguments.
Optional input and output arguments.
Secrets the action uses.
Environment variables the action uses.
An example of how to use your action in a workflow.

Markdown# Hello world javascript action

This action prints "Hello World" or "Hello" + the name of a person to greet to the log.

## Inputs

### `who-to-greet`

**Required** The name of the person to greet. Default `"World"`.

## Outputs

### `time`

The time we greeted you.

## Example usage

```yaml
uses: actions/hello-world-javascript-action@e76147da8e5c81eaf017dede5645551d4b94427b
with:
  who-to-greet: 'Mona the Octocat'
```
# Hello world javascript action

This action prints "Hello World" or "Hello" + the name of a person to greet to the log.

## Inputs

### `who-to-greet`

**Required** The name of the person to greet. Default `"World"`.

## Outputs

### `time`

The time we greeted you.

## Example usage

```yaml
uses: actions/hello-world-javascript-action@e76147da8e5c81eaf017dede5645551d4b94427b
with:
  who-to-greet: 'Mona the Octocat'
```

Commit, tag, and push your action
GitHub downloads each action run in a workflow during runtime and executes it as a complete package of code before you can use workflow commands like run to interact with the runner machine. This means you must include any package dependencies required to run the JavaScript code. You'll need to check in the toolkit core and github packages to your action's repository.
From your terminal, commit your action.yml, index.js, node_modules, package.json, package-lock.json, and README.md files. If you added a .gitignore file that lists node_modules, you'll need to remove that line to commit the node_modules directory.
It's best practice to also add a version tag for releases of your action. For more information on versioning your action, see About custom actions.
Shellgit add action.yml index.js node_modules/* package.json package-lock.json README.md
git commit -m "My first action is ready"
git tag -a -m "My first action release" v1.1
git push --follow-tags
git add action.yml index.js node_modules/* package.json package-lock.json README.md
git commit -m "My first action is ready"
git tag -a -m "My first action release" v1.1
git push --follow-tags

Checking in your node_modules directory can cause problems. As an alternative, you can use a tool called @vercel/ncc to compile your code and modules into one file used for distribution.


Install vercel/ncc by running this command in your terminal.
npm i -g @vercel/ncc


Compile your index.js file.
ncc build index.js --license licenses.txt
You'll see a new dist/index.js file with your code and the compiled modules. You will also see an accompanying dist/licenses.txt file containing all the licenses of the node_modules you are using.


Change the main keyword in your action.yml file to use the new dist/index.js file.
main: 'dist/index.js'


If you already checked in your node_modules directory, remove it.
rm -rf node_modules/*


From your terminal, commit the updates to your action.yml, dist/index.js, and node_modules files.
Shellgit add action.yml dist/index.js node_modules/*
git commit -m "Use vercel/ncc"
git tag -a -m "My first action release" v1.1
git push --follow-tags
git add action.yml dist/index.js node_modules/*
git commit -m "Use vercel/ncc"
git tag -a -m "My first action release" v1.1
git push --follow-tags



Testing out your action in a workflow
Now you're ready to test your action out in a workflow.
Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository.
Example using a public action
This example demonstrates how your new public action can be run from within an external repository.
Copy the following YAML into a new file at .github/workflows/main.yml, and update the uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b line with your username and the name of the public repository you created above. You can also replace the who-to-greet input with your name.
YAMLon: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"
on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - name: Hello world action step
        id: hello
        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"

When this workflow is triggered, the runner will download the hello-world-javascript-action action from your public repository and then execute it.
Example using a private action
Copy the workflow code into a .github/workflows/main.yml file in your action's repository. You can also replace the who-to-greet input with your name.
.github/workflows/main.yml
YAMLon: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"
on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      # To use this repository's private action,
      # you must check out the repository
      - name: Checkout
        uses: actions/checkout@v4
      - name: Hello world action step
        uses: ./ # Uses an action in the root directory
        id: hello
        with:
          who-to-greet: 'Mona the Octocat'
      # Use the output from the `hello` step
      - name: Get the output time
        run: echo "The time was ${{ steps.hello.outputs.time }}"

From your repository, click the Actions tab, and select the latest workflow run. Under Jobs or in the visualization graph, click A job to say hello.
Click Hello world action step, and you should see "Hello Mona the Octocat" or the name you used for the who-to-greet input printed in the log. To see the timestamp, click Get the output time.
Template repositories for creating JavaScript actions
GitHub provides template repositories for creating JavaScript and TypeScript actions. You can use these templates to quickly get started with creating a new action that includes tests, linting, and other recommended practices.

javascript-action template repository
typescript-action template repository

Example JavaScript actions on GitHub.com
You can find many examples of JavaScript actions on GitHub.com.

DevExpress/testcafe-action
duckduckgo/privacy-configuration\n\n\n\nGitHub Actions/Share automations/Create actions/Create a composite actionCreating a composite actionIn this guide, you'll learn how to build a composite action.Platform navigationMacWindowsLinuxIn this articleIntroductionPrerequisitesCreating an action metadata fileTesting out your action in a workflowCreating a composite action within the same repositoryExample composite actions on GitHubIntroduction
In this guide, you'll learn about the basic components needed to create and use a packaged composite action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints "Hello World" and then "Goodbye", or if you provide a custom name, it prints "Hello [who-to-greet]" and then "Goodbye". The action also maps a random number to the random-number output variable, and runs a script named goodbye.sh.
Once you complete this project, you should understand how to build your own composite action and test it in a workflow.
Warning

When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.

Composite actions and reusable workflows
Composite actions allow you to collect a series of workflow job steps into a single action which you can then run as a single job step in multiple workflows. Reusable workflows provide another way of avoiding duplication, by allowing you to run a complete workflow from within other workflows. For more information, see Avoiding duplication.
Prerequisites
Note

This example explains how to create a composite action within a separate repository. However, it is possible to create a composite action within the same repository. For more information, see Creating a composite action.

Before you begin, you'll create a repository on GitHub.


Create a new public repository on GitHub. You can choose any repository name, or use the following hello-world-composite-action example. You can add these files after your project has been pushed to GitHub. For more information, see Creating a new repository.


Clone your repository to your computer. For more information, see Cloning a repository.


From your terminal, change directories into your new repository.
Shellcd hello-world-composite-action
cd hello-world-composite-action



In the hello-world-composite-action repository, create a new file called goodbye.sh with example code:
Shellecho "echo Goodbye" > goodbye.sh
echo "echo Goodbye" > goodbye.sh



From your terminal, make goodbye.sh executable.

Shellchmod +x goodbye.sh
chmod +x goodbye.sh



Shellchmod +x goodbye.sh
chmod +x goodbye.sh



Shellgit add --chmod=+x -- goodbye.sh
git add --chmod=+x -- goodbye.sh




From your terminal, check in your goodbye.sh file.

Shellgit add goodbye.sh
git commit -m "Add goodbye script"
git push
git add goodbye.sh
git commit -m "Add goodbye script"
git push



Shellgit add goodbye.sh
git commit -m "Add goodbye script"
git push
git add goodbye.sh
git commit -m "Add goodbye script"
git push



Shellgit commit -m "Add goodbye script"
git push
git commit -m "Add goodbye script"
git push




Creating an action metadata file


In the hello-world-composite-action repository, create a new file called action.yml and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions.
YAMLname: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: "Random number"
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: "composite"
  steps:
    - name: Set Greeting
      run: echo "Hello $INPUT_WHO_TO_GREET."
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo "random-number=$(echo $RANDOM)" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo "$GITHUB_ACTION_PATH" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash

name: 'Hello World'
description: 'Greet someone'
inputs:
  who-to-greet:  # id of input
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  random-number:
    description: "Random number"
    value: ${{ steps.random-number-generator.outputs.random-number }}
runs:
  using: "composite"
  steps:
    - name: Set Greeting
      run: echo "Hello $INPUT_WHO_TO_GREET."
      shell: bash
      env:
        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}

    - name: Random Number Generator
      id: random-number-generator
      run: echo "random-number=$(echo $RANDOM)" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set GitHub Path
      run: echo "$GITHUB_ACTION_PATH" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}

    - name: Run goodbye.sh
      run: goodbye.sh
      shell: bash


This file defines the who-to-greet input, maps the random generated number to the random-number output variable, adds the action's path to the runner system path (to locate the goodbye.sh script during execution), and runs the goodbye.sh script.
For more information about managing outputs, see Metadata syntax for GitHub Actions.
For more information about how to use github.action_path, see Accessing contextual information about workflow runs.


From your terminal, check in your action.yml file.
Shellgit add action.yml
git commit -m "Add action"
git push
git add action.yml
git commit -m "Add action"
git push



From your terminal, add a tag. This example uses a tag called v1. For more information, see About custom actions.
Shellgit tag -a -m "Description of this release" v1
git push --follow-tags
git tag -a -m "Description of this release" v1
git push --follow-tags



Testing out your action in a workflow
The following workflow code uses the completed hello world action that you made in Creating a composite action.
Copy the workflow code into a .github/workflows/main.yml file in another repository, replacing OWNER and SHA with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the who-to-greet input with your name.
YAMLon: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number "$RANDOM_NUMBER"
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}
on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: OWNER/hello-world-composite-action@SHA
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number "$RANDOM_NUMBER"
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}

From your repository, click the Actions tab, and select the latest workflow run. The output should include: "Hello Mona the Octocat", the result of the "Goodbye" script, and a random number.
Creating a composite action within the same repository


Create a new subfolder called hello-world-composite-action, this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the .github/actions subfolder to make organization easier.


In the hello-world-composite-action folder, do the same steps to create the goodbye.sh script
Shellecho "echo Goodbye" > goodbye.sh
echo "echo Goodbye" > goodbye.sh


Shellchmod +x goodbye.sh
chmod +x goodbye.sh



Shellchmod +x goodbye.sh
chmod +x goodbye.sh



Shellgit add --chmod=+x -- goodbye.sh
git add --chmod=+x -- goodbye.sh



Shellgit add goodbye.sh
git commit -m "Add goodbye script"
git push
git add goodbye.sh
git commit -m "Add goodbye script"
git push



Shellgit add goodbye.sh
git commit -m "Add goodbye script"
git push
git add goodbye.sh
git commit -m "Add goodbye script"
git push



Shellgit commit -m "Add goodbye script"
git push
git commit -m "Add goodbye script"
git push




In the hello-world-composite-action folder, create the action.yml file based on the steps in Creating a composite action.


When using the action, use the relative path to the folder where the composite action's action.yml file is located in the uses key. The below example assumes it is in the .github/actions/hello-world-composite-action folder.


YAMLon: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number "$RANDOM_NUMBER"
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}
on: [push]

jobs:
  hello_world_job:
    runs-on: ubuntu-latest
    name: A job to say hello
    steps:
      - uses: actions/checkout@v4
      - id: foo
        uses: ./.github/actions/hello-world-composite-action
        with:
          who-to-greet: 'Mona the Octocat'
      - run: echo random-number "$RANDOM_NUMBER"
        shell: bash
        env:
          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}

Example composite actions on GitHub
You can find many examples of composite actions on GitHub.

microsoft/action-python
microsoft/gpt-review
tailscale/github-action\n\n\n\nGitHub Actions/Share automations/Create actions/Metadata syntaxMetadata syntax for GitHub ActionsYou can create actions to perform tasks in your repository. Actions require a metadata file that uses YAML syntax.In this articleAbout YAML syntax for GitHub Actionsnameauthordescriptioninputsoutputs for Docker container and JavaScript actionsoutputs for composite actionsrunsruns for JavaScript actionsruns for composite actionsruns for Docker container actionsbrandingChanging the metadata file nameAbout YAML syntax for GitHub Actions
All actions require a metadata file. The metadata filename must be either action.yml or action.yaml. The preferred format is action.yml. The data in the metadata file defines the inputs, outputs, and runs configuration for your action.
Action metadata files use YAML syntax. If you're new to YAML, you can read Learn YAML in five minutes.
name
Required The name of your action. GitHub displays the name in the Actions tab to help visually identify actions in each job.
author
Optional The name of the action's author.
description
Required A short description of the action.
inputs
Optional Input parameters allow you to specify data that the action expects to use during runtime. GitHub stores input parameters as environment variables. We recommend using lowercase input ids.
Example: Specifying inputs
This example configures two inputs: num-octocats and octocat-eye-color. The num-octocats input is not required and will default to a value of 1. octocat-eye-color is required and has no default value.
Note

Actions using required: true will not automatically return an error if the input is not specified.

Workflow files that use this action can use the with keyword to set an input value for octocat-eye-color. For more information about the with syntax, see Workflow syntax for GitHub Actions.
inputs:
  num-octocats:
    description: 'Number of Octocats'
    required: false
    default: '1'
  octocat-eye-color:
    description: 'Eye color of the Octocats'
    required: true

When you specify an input, GitHub creates an environment variable for the input with the name INPUT_<VARIABLE_NAME>. The environment variable created converts input names to uppercase letters and replaces spaces with _ characters.
If the action is written using a composite, then it will not automatically get INPUT_<VARIABLE_NAME>. With composite actions you can use inputs Accessing contextual information about workflow runs to access action inputs.
To access the environment variable in a Docker container action, you must pass the input using the args keyword in the action metadata file. For more information about the action metadata file for Docker container actions, see Creating a Docker container action.
For example, if a workflow defined the num-octocats and octocat-eye-color inputs, the action code could read the values of the inputs using the INPUT_NUM-OCTOCATS and INPUT_OCTOCAT-EYE-COLOR environment variables.
inputs.<input_id>
Required A string identifier to associate with the input. The value of <input_id> is a map of the input's metadata. The <input_id> must be a unique identifier within the inputs object. The <input_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.
inputs.<input_id>.description
Required A string description of the input parameter.
inputs.<input_id>.required
Optional A boolean to indicate whether the action requires the input parameter. Set to true when the parameter is required.
inputs.<input_id>.default
Optional A string representing the default value. The default value is used when an input parameter isn't specified in a workflow file.
inputs.<input_id>.deprecationMessage
Optional If the input parameter is used, this string is logged as a warning message. You can use this warning to notify users that the input is closing down and mention any alternatives.
outputs for Docker container and JavaScript actions
Optional Output parameters allow you to declare data that an action sets. Actions that run later in a workflow can use the output data set in previously run actions. For example, if you had an action that performed the addition of two inputs (x + y = z), the action could output the sum (z) for other actions to use as an input.
Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.
If you don't declare an output in your action metadata file, you can still set outputs and use them in a workflow. For more information on setting outputs in an action, see Workflow commands for GitHub Actions.
Example: Declaring outputs for Docker container and JavaScript actions
outputs:
  sum: # id of the output
    description: 'The sum of the inputs'

outputs.<output_id>
Required A string identifier to associate with the output. The value of <output_id> is a map of the output's metadata. The <output_id> must be a unique identifier within the outputs object. The <output_id> must start with a letter or _ and contain only alphanumeric characters, -, or _.
outputs.<output_id>.description
Required A string description of the output parameter.
outputs for composite actions
Optional outputs use the same parameters as outputs.<output_id> and outputs.<output_id>.description (see outputs for Docker container and JavaScript actions), but also includes the value token.
Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.
Example: Declaring outputs for composite actions
outputs:
  random-number:
    description: "Random number"
    value: ${{ steps.random-number-generator.outputs.random-id }}
runs:
  using: "composite"
  steps:
    - id: random-number-generator
      run: echo "random-id=$(echo $RANDOM)" >> $GITHUB_OUTPUT
      shell: bash

outputs.<output_id>.value
Required The value that the output parameter will be mapped to. You can set this to a string or an expression with context. For example, you can use the steps context to set the value of an output to the output value of a step.
For more information on how to use context syntax, see Accessing contextual information about workflow runs.
runs
Required Specifies whether this is a JavaScript action, a composite action, or a Docker container action and how the action is executed.
runs for JavaScript actions
Required Configures the path to the action's code and the runtime used to execute the code.
Example: Using Node.js v20
runs:
  using: 'node20'
  main: 'main.js'

runs.using for JavaScript actions
Required The runtime used to execute the code specified in main.

Use node20 for Node.js v20.

runs.main
Required The file that contains your action code. The runtime specified in using executes this file.
runs.pre
Optional Allows you to run a script at the start of a job, before the main: action begins. For example, you can use pre: to run a prerequisite setup script. The runtime specified with the using syntax will execute this file. The pre: action always runs by default but you can override this using runs.pre-if.
Note

runs.pre is not supported for local actions.

In this example, the pre: action runs a script called setup.js:
runs:
  using: 'node20'
  pre: 'setup.js'
  main: 'index.js'
  post: 'cleanup.js'

runs.pre-if
Optional Allows you to define conditions for the pre: action execution. The pre: action will only run if the conditions in pre-if are met. If not set, then pre-if defaults to always(). In pre-if, status check functions evaluate against the job's status, not the action's own status.
Note that the step context is unavailable, as no steps have run yet.
In this example, cleanup.js only runs on Linux-based runners:
  pre: 'cleanup.js'
  pre-if: runner.os == 'linux'

runs.post
Optional Allows you to run a script at the end of a job, once the main: action has completed. For example, you can use post: to terminate certain processes or remove unneeded files. The runtime specified with the using syntax will execute this file.
In this example, the post: action runs a script called cleanup.js:
runs:
  using: 'node20'
  main: 'index.js'
  post: 'cleanup.js'

The post: action always runs by default but you can override this using post-if.
runs.post-if
Optional Allows you to define conditions for the post: action execution. The post: action will only run if the conditions in post-if are met. If not set, then post-if defaults to always(). In post-if, status check functions evaluate against the job's status, not the action's own status.
For example, this cleanup.js will only run on Linux-based runners:
  post: 'cleanup.js'
  post-if: runner.os == 'linux'

runs for composite actions
Required Configures the path to the composite action.
runs.using for composite actions
Required You must set this value to 'composite'.
runs.steps
Required The steps that you plan to run in this action. These can be either run steps or uses steps.
runs.steps[*].run
Optional The command you want to run. This can be inline or a script in your action repository:
runs:
  using: "composite"
  steps:
    - run: ${{ github.action_path }}/test/script.sh
      shell: bash

Alternatively, you can use $GITHUB_ACTION_PATH:
runs:
  using: "composite"
  steps:
    - run: $GITHUB_ACTION_PATH/script.sh
      shell: bash

For more information, see Accessing contextual information about workflow runs.
runs.steps[*].shell
Optional The shell where you want to run the command. You can use any of the shells listed in Workflow syntax for GitHub Actions. Required if run is set.
runs.steps[*].if
Optional You can use the if conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional.
When you use expressions in an if conditional, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if conditional as an expression. However, this exception does not apply everywhere.
You must always use the ${{ }} expression syntax or escape with '', "", or () when the expression starts with !, since ! is reserved notation in YAML format. For example:
if: ${{ ! startsWith(github.ref, 'refs/tags/') }}

For more information, see Evaluate expressions in workflows and actions.
Example: Using contexts
This step only runs when the event type is a pull_request and the event action is unassigned.
steps:
  - run: echo This event is a pull request that had an assignee removed.
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}

Example: Using status check functions
The my backup step only runs when the previous step of a composite action fails. For more information, see Evaluate expressions in workflows and actions.
steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0

runs.steps[*].name
Optional The name of the composite step.
runs.steps[*].id
Optional A unique identifier for the step. You can use the id to reference the step in contexts. For more information, see Accessing contextual information about workflow runs.
runs.steps[*].env
Optional Sets a map of environment variables for only that step. If you want to modify the environment variable stored in the workflow, use echo "{name}={value}" >> $GITHUB_ENV in a composite step.
runs.steps[*].working-directory
Optional Specifies the working directory where the command is run.
runs.steps[*].uses
Optional Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image.
We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag number. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update.

Using the commit SHA of a released action version is the safest for stability and security.
Using the specific major action version allows you to receive critical fixes and security patches while still maintaining compatibility. It also assures that your workflow should still work.
Using the default branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break.

Some actions require inputs that you must set using the with keyword. Review the action's README file to determine the inputs required.
runs:
  using: "composite"
  steps:
    # Reference a specific commit
    - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
    # Reference the major version of a release
    - uses: actions/checkout@v4
    # Reference a specific version
    - uses: actions/checkout@v4.2.0
    # Reference a branch
    - uses: actions/checkout@main
    # References a subdirectory in a public GitHub repository at a specific branch, ref, or SHA
    - uses: actions/aws/ec2@main
    # References a local action
    - uses: ./.github/actions/my-action
    # References a docker public registry action
    - uses: docker://gcr.io/cloud-builders/gradle
    # Reference a docker image published on docker hub
    - uses: docker://alpine:3.8

runs.steps[*].with
Optional A map of the input parameters defined by the action. Each input parameter is a key/value pair. For more information, see Example: Specifying inputs.
runs:
  using: "composite"
  steps:
    - name: My first step
      uses: actions/hello_world@main
      with:
        first_name: Mona
        middle_name: The
        last_name: Octocat

runs.steps[*].continue-on-error
Optional Prevents the action from failing when a step fails. Set to true to allow the action to pass when this step fails.
runs for Docker container actions
Required Configures the image used for the Docker container action.
Example: Using a Dockerfile in your repository
runs:
  using: 'docker'
  image: 'Dockerfile'

Example: Using public Docker registry container
runs:
  using: 'docker'
  image: 'docker://debian:stretch-slim'

runs.using for Docker container actions
Required You must set this value to 'docker'.
runs.pre-entrypoint
Optional Allows you to run a script before the entrypoint action begins. For example, you can use pre-entrypoint: to run a prerequisite setup script. GitHub Actions uses docker run to launch this action, and runs the script inside a new container that uses the same base image. This means that the runtime state is different from the main entrypoint container, and any states you require must be accessed in either the workspace, HOME, or as a STATE_ variable. The pre-entrypoint: action always runs by default but you can override this using runs.pre-if.
The runtime specified with the using syntax will execute this file.
In this example, the pre-entrypoint: action runs a script called setup.sh:
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  pre-entrypoint: 'setup.sh'
  entrypoint: 'main.sh'

runs.image
Required The Docker image to use as the container to run the action. The value can be the Docker base image name, a local Dockerfile in your repository, or a public image in Docker Hub or another registry. To reference a Dockerfile local to your repository, the file must be named Dockerfile and you must use a path relative to your action metadata file. The docker application will execute this file.
runs.env
Optional Specifies a key/value map of environment variables to set in the container environment.
runs.entrypoint
Optional Overrides the Docker ENTRYPOINT in the Dockerfile, or sets it if one wasn't already specified. Use entrypoint when the Dockerfile does not specify an ENTRYPOINT or you want to override the ENTRYPOINT instruction. If you omit entrypoint, the commands you specify in the Docker ENTRYPOINT instruction will execute. The Docker ENTRYPOINT instruction has a shell form and exec form. The Docker ENTRYPOINT documentation recommends using the exec form of the ENTRYPOINT instruction.
For more information about how the entrypoint executes, see Dockerfile support for GitHub Actions.
runs.post-entrypoint
Optional Allows you to run a cleanup script once the runs.entrypoint action has completed. GitHub Actions uses docker run to launch this action. Because GitHub Actions runs the script inside a new container using the same base image, the runtime state is different from the main entrypoint container. You can access any state you need in either the workspace, HOME, or as a STATE_ variable. The post-entrypoint: action always runs by default but you can override this using runs.post-if.
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - 'bzz'
  entrypoint: 'main.sh'
  post-entrypoint: 'cleanup.sh'

runs.args
Optional An array of strings that define the inputs for a Docker container. Inputs can include hardcoded strings. GitHub passes the args to the container's ENTRYPOINT when the container starts up.
The args are used in place of the CMD instruction in a Dockerfile. If you use CMD in your Dockerfile, use the guidelines ordered by preference:

Document required arguments in the action's README and omit them from the CMD instruction.
Use defaults that allow using the action without specifying any args.
If the action exposes a --help flag, or something similar, use that to make your action self-documenting.

If you need to pass environment variables into an action, make sure your action runs a command shell to perform variable substitution. For example, if your entrypoint attribute is set to "sh -c", args will be run in a command shell. Alternatively, if your Dockerfile uses an ENTRYPOINT to run the same command ("sh -c"), args will execute in a command shell.
For more information about using the CMD instruction with GitHub Actions, see Dockerfile support for GitHub Actions.
Example: Defining arguments for the Docker container
runs:
  using: 'docker'
  image: 'Dockerfile'
  args:
    - ${{ inputs.greeting }}
    - 'foo'
    - 'bar'

branding
Optional You can use a color and Feather icon to create a badge to personalize and distinguish your action. Badges are shown next to your action name in GitHub Marketplace.
Example: Configuring branding for an action
branding:
  icon: 'award'
  color: 'green'

branding.color
The background color of the badge. Can be one of: white, black, yellow, blue, green, orange, red, purple, or gray-dark.
branding.icon
The name of the v4.28.0 Feather icon to use.
Omitted icons
Brand icons, and all the following icons, are omitted.

coffee
columns
divide-circle
divide-square
divide
frown
hexagon
key
meh
mouse-pointer
smile
tool
x-octagon

Exhaustive list of all currently supported icons

activity
airplay
alert-circle
alert-octagon
alert-triangle
align-center
align-justify
align-left
align-right
anchor
aperture
archive
arrow-down-circle
arrow-down-left
arrow-down-right
arrow-down
arrow-left-circle
arrow-left
arrow-right-circle
arrow-right
arrow-up-circle
arrow-up-left
arrow-up-right
arrow-up
at-sign
award
bar-chart-2
bar-chart
battery-charging
battery
bell-off
bell
bluetooth
bold
book-open
book
bookmark
box
briefcase
calendar
camera-off
camera
cast
check-circle
check-square
check
chevron-down
chevron-left
chevron-right
chevron-up
chevrons-down
chevrons-left
chevrons-right
chevrons-up
circle
clipboard
clock
cloud-drizzle
cloud-lightning
cloud-off
cloud-rain
cloud-snow
cloud
code
command
compass
copy
corner-down-left
corner-down-right
corner-left-down
corner-left-up
corner-right-down
corner-right-up
corner-up-left
corner-up-right
cpu
credit-card
crop
crosshair
database
delete
disc
dollar-sign
download-cloud
download
droplet
edit-2
edit-3
edit
external-link
eye-off
eye
fast-forward
feather
file-minus
file-plus
file-text
file
film
filter
flag
folder-minus
folder-plus
folder
gift
git-branch
git-commit
git-merge
git-pull-request
globe
grid
hard-drive
hash
headphones
heart
help-circle
home
image
inbox
info
italic
layers
layout
life-buoy
link-2
link
list
loader
lock
log-in
log-out
mail
map-pin
map
maximize-2
maximize
menu
message-circle
message-square
mic-off
mic
minimize-2
minimize
minus-circle
minus-square
minus
monitor
moon
more-horizontal
more-vertical
move
music
navigation-2
navigation
octagon
package
paperclip
pause-circle
pause
percent
phone-call
phone-forwarded
phone-incoming
phone-missed
phone-off
phone-outgoing
phone
pie-chart
play-circle
play
plus-circle
plus-square
plus
pocket
power
printer
radio
refresh-ccw
refresh-cw
repeat
rewind
rotate-ccw
rotate-cw
rss
save
scissors
search
send
server
settings
share-2
share
shield-off
shield
shopping-bag
shopping-cart
shuffle
sidebar
skip-back
skip-forward
slash
sliders
smartphone
speaker
square
star
stop-circle
sun
sunrise
sunset
table
tablet
tag
target
terminal
thermometer
thumbs-down
thumbs-up
toggle-left
toggle-right
trash-2
trash
trending-down
trending-up
triangle
truck
tv
type
umbrella
underline
unlock
upload-cloud
upload
user-check
user-minus
user-plus
user-x
user
users
video-off
video
voicemail
volume-1
volume-2
volume-x
volume
watch
wifi-off
wifi
wind
x-circle
x-square
x
zap-off
zap
zoom-in
zoom-out

Changing the metadata file name
While the actions metadata file supports both YAML formats, changing the metadata file name (from action.yml to action.yaml or vice versa) between releases will affect previous release versions that have been published to GitHub Marketplace. Changing the file name will hide all release versions associated with the previous file name from GitHub Marketplace. Previous release versions will still be accessible to users through the source repository.
When releasing new versions of actions, only versions released after the metadata file name change will have the GitHub Marketplace tag and will show up on GitHub Marketplace\n\n\n\nGitHub Actions/Share automations/Create actions/Dockerfile supportDockerfile support for GitHub ActionsWhen creating a Dockerfile for a Docker container action, you should be aware of how some Docker instructions interact with GitHub Actions and an action's metadata file.In this articleAbout Dockerfile instructionsDockerfile instructions and overridesSupported Linux capabilitiesAbout Dockerfile instructions
A Dockerfile contains instructions and arguments that define the contents and startup behavior of a Docker container. For more information about the instructions Docker supports, see Dockerfile reference in the Docker documentation.
Dockerfile instructions and overrides
Some Docker instructions interact with GitHub Actions, and an action's metadata file can override some Docker instructions. Ensure that you are familiar with how your Dockerfile interacts with GitHub Actions to prevent any unexpected behavior.
USER
Docker actions must be run by the default Docker user (root). Do not use the USER instruction in your Dockerfile, because you won't be able to access the GITHUB_WORKSPACE directory. For more information, see Store information in variables and USER reference in the Docker documentation.
FROM
The first instruction in the Dockerfile must be FROM, which selects a Docker base image. For more information, see the FROM reference in the Docker documentation.
These are some best practices when setting the FROM argument:

It's recommended to use official Docker images. For example, python or ruby.
Use a version tag if it exists, preferably with a major version. For example, use node:10 instead of node:latest.
It's recommended to use Docker images based on the Debian operating system.

WORKDIR
GitHub sets the working directory path in the GITHUB_WORKSPACE environment variable. It's recommended to not use the WORKDIR instruction in your Dockerfile. Before the action executes, GitHub will mount the GITHUB_WORKSPACE directory on top of anything that was at that location in the Docker image and set GITHUB_WORKSPACE as the working directory. For more information, see Store information in variables and the WORKDIR reference in the Docker documentation.
ENTRYPOINT
If you define entrypoint in an action's metadata file, it will override the ENTRYPOINT defined in the Dockerfile. For more information, see Metadata syntax for GitHub Actions.
The Docker ENTRYPOINT instruction has a shell form and exec form. The Docker ENTRYPOINT documentation recommends using the exec form of the ENTRYPOINT instruction. For more information about exec and shell form, see the ENTRYPOINT reference in the Docker documentation.
You should not use WORKDIR to specify your entrypoint in your Dockerfile. Instead, you should use an absolute path. For more information, see WORKDIR.
If you configure your container to use the exec form of the ENTRYPOINT instruction, the args configured in the action's metadata file won't run in a command shell. If the action's args contain an environment variable, the variable will not be substituted. For example, using the following exec format will not print the value stored in $GITHUB_SHA, but will instead print "$GITHUB_SHA".
ENTRYPOINT ["echo $GITHUB_SHA"]

If you want variable substitution, then either use the shell form or execute a shell directly. For example, using the following exec format, you can execute a shell to print the value stored in the GITHUB_SHA environment variable.
ENTRYPOINT ["sh", "-c", "echo $GITHUB_SHA"]

To supply args defined in the action's metadata file to a Docker container that uses the exec form in the ENTRYPOINT, we recommend creating a shell script called entrypoint.sh that you call from the ENTRYPOINT instruction:
Example Dockerfile
# Container image that runs your code
FROM debian:9.5-slim

# Copies your code file from your action repository to the filesystem path `/` of the container
COPY entrypoint.sh /entrypoint.sh

# Executes `entrypoint.sh` when the Docker container starts up
ENTRYPOINT ["/entrypoint.sh"]

Example entrypoint.sh file
Using the example Dockerfile above, GitHub will send the args configured in the action's metadata file as arguments to entrypoint.sh. Add the #!/bin/sh shebang at the top of the entrypoint.sh file to explicitly use the system's POSIX-compliant shell.
#!/bin/sh

# `$#` expands to the number of arguments and `$@` expands to the supplied `args`
printf '%d args:' "$#"
printf " '%s'" "$@"
printf '\n'

Your code must be executable. Make sure the entrypoint.sh file has execute permissions before using it in a workflow. You can modify the permission from your terminal using this command:
chmod +x entrypoint.sh

When an ENTRYPOINT shell script is not executable, you'll receive an error similar to this:
Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused "exec: \"/entrypoint.sh\": permission denied": unknown

CMD
If you define args in the action's metadata file, args will override the CMD instruction specified in the Dockerfile. For more information, see Metadata syntax for GitHub Actions.
If you use CMD in your Dockerfile, follow these guidelines:

Document required arguments in the action's README and omit them from the CMD instruction.
Use defaults that allow using the action without specifying any args.
If the action exposes a --help flag, or something similar, use that to make your action self-documenting.

Supported Linux capabilities
GitHub Actions supports the default Linux capabilities that Docker supports. Capabilities can't be added or removed. For more information about the default Linux capabilities that Docker supports, see Linux kernel capabilities in the Docker documentation. To learn more about Linux capabilities, see Overview of Linux capabilities in the Linux man-pages.\n\n\n\nGitHub Actions/Share automations/Create actions/Set exit codesSetting exit codes for actionsYou can use exit codes to set the status of an action. GitHub displays statuses to indicate passing or failing actions.In this articleAbout exit codesSetting a failure exit code in a JavaScript actionSetting a failure exit code in a Docker container actionAbout exit codes
GitHub uses the exit code to set the action's check run status, which can be success or failure.




















Exit statusCheck run statusDescription0successThe action completed successfully and other tasks that depend on it can begin.Nonzero value (any integer but 0)failureAny other exit code indicates the action failed. When an action fails, all concurrent actions are canceled and future actions are skipped. The check run and check suite both get a failure status.
Setting a failure exit code in a JavaScript action
If you are creating a JavaScript action, you can use the actions toolkit @actions/core package to log a message and set a failure exit code. For example:
try {
  // something
} catch (error) {
  core.setFailed(error.message);
}

For more information, see Creating a JavaScript action.
Setting a failure exit code in a Docker container action
If you are creating a Docker container action, you can set a failure exit code in your entrypoint.sh script. For example:
if <condition> ; then
  echo "Game over!"
  exit 1
fi

For more information, see Creating a Docker container action.\n\n\n\nGitHub Actions/Share automations/Create actions/Release and maintain actionsReleasing and maintaining actionsYou can leverage automation and open source best practices to release and maintain actions.In this articleIntroductionDeveloping and releasing actionsWorking with the communityFurther readingIntroduction
After you create an action, you'll want to continue releasing new features while working with community contributions. This tutorial describes an example process you can follow to release and maintain actions in open source. The example:

Leverages GitHub Actions for continuous integration, dependency updates, release management, and task automation.
Provides confidence through automated tests and build badges.
Indicates how the action can be used, ideally as part of a broader workflow.
Signal what type of community contributions you welcome. (For example, issues, pull requests, or vulnerability reports.)

For an applied example of this process, see actions/javascript-action.
Developing and releasing actions
In this section, we discuss an example process for developing and releasing actions and show how to use GitHub Actions to automate the process.
About JavaScript actions
JavaScript actions are Node.js repositories with metadata. However, JavaScript actions have additional properties compared to traditional Node.js projects:


Dependent packages are committed alongside the code, typically in a compiled and minified form. This means that automated builds and secure community contributions are important.


Tagged releases can be published directly to GitHub Marketplace and consumed by workflows across GitHub.


Many actions make use of GitHub's APIs and third party APIs, so we encourage robust end-to-end testing.


Setting up GitHub Actions workflows
To support the developer process in the next section, add two GitHub Actions workflows to your repository:

Add a workflow that triggers when a commit is pushed to a feature branch or to main or when a pull request is created. Configure the workflow to run your unit and integration tests. For an example, see this workflow.
Add a workflow that triggers when a release is published or edited. Configure the workflow to ensure semantic tags are in place. You can use an action like JasonEtco/build-and-tag-action to compile and bundle the JavaScript and metadata file and force push semantic major, minor, and patch tags. For more information about semantic tags, see About semantic versioning.

Example developer process
Here is an example process that you can follow to automatically run tests, create a release and publish to GitHub Marketplace, and publish your action.


Do feature work in branches per GitHub flow. For more information, see GitHub flow.

Whenever a commit is pushed to the feature branch, your testing workflow will automatically run the tests.



Create pull requests to the main branch to initiate discussion and review, merging when ready.


When a pull request is opened, either from a branch or a fork, your testing workflow will again run the tests, this time with the merge commit.


Note: for security reasons, workflows triggered by pull_request from forks have restricted GITHUB_TOKEN permissions and do not have access to secrets. If your tests or other workflows triggered upon pull request require access to secrets, consider using a different event like a manual trigger or a pull_request_target. For more information, see Events that trigger workflows.




Create a semantically tagged release.  You may also publish to GitHub Marketplace with a simple checkbox.  For more information, see Managing releases in a repository and Publishing actions in GitHub Marketplace.


When a release is published or edited, your release workflow will automatically take care of compilation and adjusting tags.


We recommend creating releases using semantically versioned tags – for example, v1.1.3 – and keeping major (v1) and minor (v1.1) tags current to the latest appropriate commit. For more information, see About custom actions and About semantic versioning.




Results
Unlike some other automated release management strategies, this process intentionally does not commit dependencies to the main branch, only to the tagged release commits. By doing so, you encourage users of your action to reference named tags or shas, and you help ensure the security of third party pull requests by doing the build yourself during a release.
Using semantic releases means that the users of your actions can pin their workflows to a version and know that they might continue to receive the latest stable, non-breaking features, depending on their comfort level.
Working with the community
GitHub provides tools and guides to help you work with the open source community. Here are a few tools we recommend setting up for healthy bidirectional communication. By providing the following signals to the community, you encourage others to use, modify, and contribute to your action:

Maintain a README with plenty of usage examples and guidance. For more information, see About READMEs.
Include a workflow status badge in your README file. For more information, see Adding a workflow status badge. Also visit shields.io to learn about other badges that you can add.
Add community health files like CODE_OF_CONDUCT, CONTRIBUTING, and SECURITY. For more information, see Creating a default community health file.
Keep issues current by utilizing actions like actions/stale.
Use GitHub's security features to communicate about vulnerabilities and how to fix them. For more information, see Using GitHub's security features to secure your use of GitHub Actions.

Further reading
Examples where similar patterns are employed include:

github/super-linter
octokit/request-action
actions/javascript-action\n\n\n\nGitHub Actions/Share automations/Create actions/Publish in GitHub MarketplacePublishing actions in GitHub MarketplaceYou can publish actions in GitHub Marketplace and share actions you've created with the GitHub community.In this articleAbout publishing actionsPublishing an actionRemoving an action from GitHub MarketplaceTransferring an action repositoryAbout badges in GitHub MarketplaceYou must accept the terms of service to publish actions in GitHub Marketplace.
About publishing actions
Before you can publish an action, you'll need to create an action in your repository. For more information, see Sharing automations.
When you plan to publish your action to GitHub Marketplace, you'll need to ensure that the repository only includes the metadata file, code, and files necessary for the action. Creating a single repository for the action allows you to tag, release, and package the code in a single unit. GitHub also uses the action's metadata on your GitHub Marketplace page.
Actions are published to GitHub Marketplace immediately and aren't reviewed by GitHub as long as they meet these requirements:

The action must be in a public repository.
Each repository must contain a single action metadata file (action.yml or action.yaml) at the root.

Repositories may include other actions metadata files in sub-folders, but they will not be automatically listed in the marketplace.


Each repository must not contain any workflow files.
The name in the action's metadata file must be unique.

The name cannot match an existing action name published on GitHub Marketplace.
The name cannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. For example, only the GitHub organization can publish an action named github.
The name cannot match an existing GitHub Marketplace category.
GitHub reserves the names of GitHub features.



Publishing an action
You can add the action you've created to GitHub Marketplace by tagging it as a new release and publishing it.
To draft a new release and publish the action to GitHub Marketplace, follow these instructions:


On GitHub, navigate to the main page of the repository.


Navigate to the action metadata file in your repository (action.yml), and you'll see a banner to publish the action to GitHub Marketplace. Click Draft a release.


Under "Release Action", select Publish this Action to the GitHub Marketplace.
Note

The "Publish" checkbox is disabled if the account that owns the repository has not yet accepted the GitHub Marketplace Developer Agreement. If you own the repository or are an organization owner, click the link to "accept the GitHub Marketplace Developer Agreement", then accept the agreement. If there is no link, send the organization owner a link to this "Release Action" page and ask them to accept the agreement.



If the labels in your metadata file contain any problems, you will see an error message or a warning message. Address them by updating your metadata file. Once complete, you will see an "Everything looks good!" message.


Select the Primary Category dropdown menu and click a category that will help people find your action in GitHub Marketplace.


Optionally, select the Another Category dropdown menu and click a secondary category.


In the tag field, type a version for your action. This helps people know what changes or features the release includes. People will see the version in the action's dedicated GitHub Marketplace page.


In the title field, type a release title.


Complete all other fields and click Publish release. Publishing requires you to use two-factor authentication. For more information, see Configuring two-factor authentication.


Removing an action from GitHub Marketplace
To remove a published action from GitHub Marketplace, you'll need to update each published release. Perform the following steps for each release of the action you've published to GitHub Marketplace.


On GitHub, navigate to the main page of the repository.


To the right of the list of files, click Releases.



Next to the release you want to edit, click .



Select Publish this action to the GitHub Marketplace to remove the check from the box.


Click Update release at the bottom of the page.


Transferring an action repository
You can transfer an action repository to another user or organization. For more information, see Transferring a repository.
When a repository admin transfers an action repository, GitHub automatically creates a redirect from the previous URL to the new URL, meaning workflows that use the affected action do not need to be updated.
Actions published on GitHub Marketplace are linked to a repository by their unique name identifier, meaning you can publish new releases of an action from the transferred repository under the same GitHub Marketplace listing. If an action repository is deleted, the GitHub Marketplace listing is also deleted, and the unique name identifier becomes available.
Note

The "Verified" badge seen on an organization's GitHub profile is different from the verified creator badge on GitHub Marketplace. If you transfer an action repository, the GitHub Marketplace listing will lose the verified creator badge unless the new owner is also a verified creator.

About badges in GitHub Marketplace
Actions with the , or verified creator badge, indicate that GitHub has verified the creator of the action as a partner organization. Partners can email partnerships@github.com to request the verified creator badge.\n\n\n\nGitHub Actions/Share automations/Create actions/CLI setup actionDeveloping a third party CLI actionLearn how to develop an action to set up a CLI on GitHub Actions runners.In this articleIntroductionPrerequisitesExampleFurther readingIntroduction
You can write an action to provide a way for users to access your servers via a configured CLI environment on GitHub Actions runners.
Your action should:

Make it simple for users to specify the version of the CLI to install
Support multiple operating systems
Run in an efficient fashion to minimize run-time and associated costs
Work across GitHub-hosted and self-hosted runners
Leverage community tooling when possible

This article will demonstrate how to write an action that retrieves a specific version of your CLI, installs it, adds it to the path, and (optionally) caches it. This type of action (an action that sets up a tool) is often named setup-$TOOL.
Prerequisites
You should have an understanding of how to write a custom action. For more information, see About custom actions. For a more detailed guide on how to write a custom action, see Creating a JavaScript action.
Example
The following script demonstrates how you can get a user-specified version as input, download and extract the specific version of your CLI, then add the CLI to the path.
GitHub provides actions/toolkit, which is a set of packages that helps you create actions. This example uses the actions/core and actions/tool-cache packages.
JavaScriptconst core = require('@actions/core');
const tc = require('@actions/tool-cache');

async function setup() {
  // Get version of tool to be installed
  const version = core.getInput('version');

  // Download the specific version of the tool, e.g. as a tarball
  const pathToTarball = await tc.downloadTool(getDownloadURL());

  // Extract the tarball onto the runner
  const pathToCLI = await tc.extractTar(pathToTarball);

  // Expose the tool by adding it to the PATH
  core.addPath(pathToCLI)
}

module.exports = setup
const core = require('@actions/core');
const tc = require('@actions/tool-cache');

async function setup() {
  // Get version of tool to be installed
  const version = core.getInput('version');

  // Download the specific version of the tool, e.g. as a tarball
  const pathToTarball = await tc.downloadTool(getDownloadURL());

  // Extract the tarball onto the runner
  const pathToCLI = await tc.extractTar(pathToTarball);

  // Expose the tool by adding it to the PATH
  core.addPath(pathToCLI)
}

module.exports = setup

To use this script, replace getDownloadURL with a function that downloads your CLI. You will also need to create an actions metadata file (action.yml) that accepts a version input and that runs this script. For full details about how to create an action, see Creating a JavaScript action.
Further reading
This pattern is employed in several actions. For more examples, see:

ruby/setup-ruby
google-github-actions/setup-gcloud
hashicorp/setup-terraform\n\n\n\nGitHub Actions/Share automations/Reuse workflowsReusing workflowsLearn how to avoid duplication when creating a workflow by reusing existing workflows.In this articleOverviewAccess to reusable workflowsUsing runnersLimitationsCreating a reusable workflowCalling a reusable workflowNesting reusable workflowsUsing outputs from a reusable workflowMonitoring which workflows are being usedRe-running workflows and jobs with reusable workflowsNext stepsOverview
Rather than copying and pasting from one workflow to another, you can make workflows reusable. You and anyone with access to the reusable workflow can then call the reusable workflow from another workflow.
Reusing workflows avoids duplication. This makes workflows easier to maintain and allows you to create new workflows more quickly by building on the work of others, just as you do with actions. Workflow reuse also promotes best practice by helping you to use workflows that are well designed, have already been tested, and have been proven to be effective. Your organization can build up a library of reusable workflows that can be centrally maintained.
The diagram below shows an in-progress workflow run that uses a reusable workflow.

After each of three build jobs on the left of the diagram completes successfully, a dependent job called "Deploy" is run.
The "Deploy" job calls a reusable workflow that contains three jobs: "Staging", "Review", and "Production."
The "Production" deployment job only runs after the "Staging" job has completed successfully.
When a job targets an environment, the workflow run displays a progress bar that shows the number of steps in the job. In the diagram below, the "Production" job contains 8 steps, with step 6 currently being processed.
Using a reusable workflow to run deployment jobs allows you to run those jobs for each build without duplicating code in workflows.


A workflow that uses another workflow is referred to as a "caller" workflow. The reusable workflow is a "called" workflow. One caller workflow can use multiple called workflows. Each called workflow is referenced in a single line. The result is that the caller workflow file may contain just a few lines of YAML, but may perform a large number of tasks when it's run. When you reuse a workflow, the entire called workflow is used, just as if it was part of the caller workflow.
If you reuse a workflow from a different repository, any actions in the called workflow run as if they were part of the caller workflow. For example, if the called workflow uses actions/checkout, the action checks out the contents of the repository that hosts the caller workflow, not the called workflow.
When a reusable workflow is triggered by a caller workflow, the github context is always associated with the caller workflow. The called workflow is automatically granted access to github.token and secrets.GITHUB_TOKEN. For more information about the github context, see Accessing contextual information about workflow runs.
You can view the reused workflows referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see “About the dependency graph.”
Reusable workflows and composite actions
Reusable workflows and composite actions both help you to avoid duplication. Whereas reusable workflows allow you to reuse an entire workflow, with multiple jobs and steps, composite actions combine multiple steps that you can then run within a job step, just like any other action. For more information, see Avoiding duplication.
Reusable workflows and workflow templates
Workflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When people create a new workflow, they can choose a workflow template and some or all of the work of writing the workflow will be done for them. Within a workflow template, you can also reference reusable workflows to make it easy for people to benefit from reusing centrally managed workflow code. If you use a commit SHA when referencing the reusable workflow, you can ensure that everyone who reuses that workflow will always be using the same YAML code. However, if you reference a reusable workflow by a tag or branch, be sure that you can trust that version of the workflow. For more information, see Security hardening for GitHub Actions.
For more information, see Creating workflow templates for your organization.
Access to reusable workflows
A reusable workflow can be used by another workflow if any of the following is true:

Both workflows are in the same repository.
The called workflow is stored in a public repository, and your organization allows you to use public reusable workflows.
The called workflow is stored in a private repository and the settings for that repository allow it to be accessed. For more information, see Sharing actions and workflows with your organization and Sharing actions and workflows from your private repository.

The following table shows the accessibility of reusable workflows to a caller workflow, depending on the visibility of the host repository.





















Caller repositoryAccessible workflows repositoriesprivateprivate and publicpublicpublic
The Actions permissions on the callers repository's Actions settings page must be configured to allow the use of actions and reusable workflows - see Managing GitHub Actions settings for a repository.
For private repositories, the Access policy on the Actions settings page of the called workflow's repository must be explicitly configured to allow access from repositories containing caller workflows - see Managing GitHub Actions settings for a repository.
Note

To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail.

Using runners
Using GitHub-hosted runners
The assignment of GitHub-hosted runners is always evaluated using only the caller's context. Billing for GitHub-hosted runners is always associated with the caller. The caller workflow cannot use GitHub-hosted runners from the called repository. For more information, see Using GitHub-hosted runners.
Using self-hosted runners
Called workflows that are owned by the same user or organization as the caller workflow can access self-hosted runners from the caller's context. This means that a called workflow can access self-hosted runners that are:

In the caller repository
In the caller repository's organization, provided that the runner has been made available to the caller repository

Limitations


You can connect up to four levels of workflows. For more information, see Nesting reusable workflows.


You can call a maximum of 20 unique reusable workflows from a single workflow file. This limit includes any trees of nested reusable workflows that may be called starting from your top-level caller workflow file.
For example, top-level-caller-workflow.yml → called-workflow-1.yml → called-workflow-2.yml counts as 2 reusable workflows.


Any environment variables set in an env context defined at the workflow level in the caller workflow are not propagated to the called workflow. For more information, see Store information in variables and Accessing contextual information about workflow runs.


Similarly, environment variables set in the env context, defined in the called workflow, are not accessible in the env context of the caller workflow. Instead, you must use outputs of the reusable workflow. For more information, see Using outputs from a reusable workflow.


To reuse variables in multiple workflows, set them at the organization, repository, or environment levels and reference them using the vars context. For more information see Store information in variables and Accessing contextual information about workflow runs.


Reusable workflows are called directly within a job, and not from within a job step. You cannot, therefore, use GITHUB_ENV to pass values to job steps in the caller workflow.


Creating a reusable workflow
Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the .github/workflows directory of a repository. Subdirectories of the workflows directory are not supported.
For a workflow to be reusable, the values for on must include workflow_call:
on:
  workflow_call:

Using inputs and secrets in a reusable workflow
You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow.


In the reusable workflow, use the inputs and secrets keywords to define inputs or secrets that will be passed from a caller workflow.
on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      personal_access_token:
        required: true

For details of the syntax for defining inputs and secrets, see on.workflow_call.inputs and on.workflow_call.secrets.


In the reusable workflow, reference the input or secret that you defined in the on key in the previous step.
Note

If the secrets are inherited by using secrets: inherit in the calling workflow, you can reference them even if they are not explicitly defined in the on key. For more information, see Workflow syntax for GitHub Actions.

jobs:
  reusable_workflow_job:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.personal_access_token }}
        configuration-path: ${{ inputs.config-path }}

In the example above, personal_access_token is a secret that's defined at the repository or organization level.
Warning

Environment secrets cannot be passed from the caller workflow as on.workflow_call does not support the environment keyword. If you include environment in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see Managing environments for deployment and Workflow syntax for GitHub Actions.



Pass the input or secret from the caller workflow.
To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).
jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}

Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.
jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit



Example reusable workflow
This reusable workflow file named workflow-B.yml (we'll refer to this later in the example caller workflow) takes an input string and a secret from the caller workflow and uses them in an action.
YAMLname: Reusable workflow example

on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      token:
        required: true

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.token }}
        configuration-path: ${{ inputs.config-path }}
name: Reusable workflow example

on:
  workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      token:
        required: true

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.token }}
        configuration-path: ${{ inputs.config-path }}

Calling a reusable workflow
You call a reusable workflow by using the uses keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps.
jobs.<job_id>.uses
You reference reusable workflow files using one of the following syntaxes:

{owner}/{repo}/.github/workflows/{filename}@{ref} for reusable workflows in public and private repositories.
./.github/workflows/{filename} for reusable workflows in the same repository.

In the first option, {ref} can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions.
If you use the second syntax option (without {owner}/{repo} and @{ref}) the called workflow is from the same commit as the caller workflow. Ref prefixes such as refs/heads and refs/tags are not allowed. You cannot use contexts or expressions in this keyword.
You can call multiple workflows, referencing each in a separate job.
jobs:
  call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
  call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
  call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1

Passing inputs and secrets to a reusable workflow
To pass named inputs to a called workflow, use the with keyword in a job. Use the secrets keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).
jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}

Workflows that call reusable workflows in the same organization or enterprise can use the inherit keyword to implicitly pass the secrets.
jobs:
  call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit

Using a matrix strategy with a reusable workflow
Jobs using the matrix strategy can call a reusable workflow.
A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, see Running variations of jobs in a workflow.
This example job below calls a reusable workflow and references the matrix context by defining the variable target with the values [dev, stage, prod]. It will run three jobs, one for each value in the variable.
YAMLjobs:
  ReuseableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}
jobs:
  ReuseableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}

Supported keywords for jobs that call a reusable workflow
When you call a reusable workflow, you can only use the following keywords in the job containing the call:


jobs.<job_id>.name


jobs.<job_id>.uses


jobs.<job_id>.with


jobs.<job_id>.with.<input_id>


jobs.<job_id>.secrets


jobs.<job_id>.secrets.<secret_id>


jobs.<job_id>.secrets.inherit


jobs.<job_id>.strategy


jobs.<job_id>.needs


jobs.<job_id>.if


jobs.<job_id>.concurrency


jobs.<job_id>.permissions
Note


If jobs.<job_id>.permissions is not specified in the calling job, the called workflow will have the default permissions for the GITHUB_TOKEN. For more information, see Automatic token authentication.
The GITHUB_TOKEN permissions passed from the caller workflow can be only downgraded (not elevated) by the called workflow.
If you use jobs.<job_id>.concurrency.cancel-in-progress: true, don't use the same value for jobs.<job_id>.concurrency.group in the called and caller workflows as this will cause the workflow that's already running to be cancelled. A called workflow uses the name of its caller workflow in ${{ github.workflow }}, so using this context as the value of jobs.<job_id>.concurrency.group in both caller and called workflows will cause the caller workflow to be cancelled when the called workflow runs.




Example caller workflow
This workflow file calls two workflow files. The second of these, workflow-B.yml (shown in the example reusable workflow), is passed an input (config-path) and a secret (token).
YAMLname: Call a reusable workflow

on:
  pull_request:
    branches:
      - main

jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1

  call-workflow-passing-data:
    permissions:
      contents: read
      pull-requests: write
    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}
name: Call a reusable workflow

on:
  pull_request:
    branches:
      - main

jobs:
  call-workflow:
    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1

  call-workflow-passing-data:
    permissions:
      contents: read
      pull-requests: write
    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}

Nesting reusable workflows
You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: caller-workflow.yml → called-workflow-1.yml → called-workflow-2.yml → called-workflow-3.yml. Loops in the workflow tree are not permitted.
From within a reusable workflow you can call another reusable workflow.
YAMLname: Reusable workflow

on:
  workflow_call:

jobs:
  call-another-reusable:
    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1
name: Reusable workflow

on:
  workflow_call:

jobs:
  call-another-reusable:
    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1

Passing secrets to nested workflows
You can use jobs.<job_id>.secrets in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use jobs.<job_id>.secrets.inherit to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section Reusing workflows above, and the reference article Workflow syntax for GitHub Actions. Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C.
In the following example, workflow A passes all of its secrets to workflow B, by using the inherit keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.
jobs:
  workflowA-calls-workflowB:
    uses: octo-org/example-repo/.github/workflows/B.yml@main
    secrets: inherit # pass all secrets

jobs:
  workflowB-calls-workflowC:
    uses: different-org/example-repo/.github/workflows/C.yml@main
    secrets:
      repo-token: ${{ secrets.personal_access_token }} # pass just this secret

Access and permissions
A workflow that contains nested reusable workflows will fail if any of the nested workflows is inaccessible to the initial caller workflow. For more information, see Reusing workflows.
GITHUB_TOKEN permissions can only be the same or more restrictive in nested workflows. For example, in the workflow chain A > B > C, if workflow A has package: read token permission, then B and C cannot have package: write permission. For more information, see Automatic token authentication.
For information on how to use the API to determine which workflow files were involved in a particular workflow run, see Monitoring which workflows are being used.
Using outputs from a reusable workflow
A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow.
If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow.
The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: "hello" and "world." In the outputs section of the job, we map these step outputs to job outputs called: output1 and output2. In the on.workflow_call.outputs section we then define two outputs for the workflow itself, one called firstword which we map to output1, and one called secondword which we map to output2.
The value must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below.
For more information, see Passing information between jobs and Workflow syntax for GitHub Actions.
YAMLname: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: "The first output string"
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: "The second output string"
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo "firstword=hello" >> $GITHUB_OUTPUT
      - id: step2
        run: echo "secondword=world" >> $GITHUB_OUTPUT
name: Reusable workflow

on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: "The first output string"
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: "The second output string"
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
  example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo "firstword=hello" >> $GITHUB_OUTPUT
      - id: step2
        run: echo "secondword=world" >> $GITHUB_OUTPUT

We can now use the outputs in the caller workflow, in the same way you would use the outputs from a job within the same workflow. We reference the outputs using the names defined at the workflow level in the reusable workflow: firstword and secondword. In this workflow, job1 calls the reusable workflow and job2 prints the outputs from the reusable workflow ("hello world") to standard output in the workflow log.
YAMLname: Call a reusable workflow and use its outputs

on:
  workflow_dispatch:

jobs:
  job1:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}
name: Call a reusable workflow and use its outputs

on:
  workflow_dispatch:

jobs:
  job1:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1

  job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}

For more information on using job outputs, see Workflow syntax for GitHub Actions. If you want to share something other than a variable (e.g. a build artifact) between workflows, see Storing and sharing data from a workflow.
Monitoring which workflows are being used
Organizations that use GitHub Enterprise Cloud can interact with the audit log via the GitHub REST API to monitor which workflows are being used. For more information, see the GitHub Enterprise Cloud documentation.
Re-running workflows and jobs with reusable workflows
Reusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, see Reusing workflows.
When you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:

Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, see Re-running workflows and jobs.
Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, see Re-running workflows and jobs. For more information about re-running a specific job in a workflow, see Re-running workflows and jobs.

Next steps
To continue learning about GitHub Actions, see Events that trigger workflows.\n\n\n\nGitHub Actions/Share automations/Create workflow templatesCreating workflow templates for your organizationLearn how you can create workflow templates to help people in your team add new workflows more easily.In this articleOverviewCreating a workflow templateNext stepsOverview
Workflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization.
GitHub provides ready-to-use workflow templates for the following high level categories:

Deployment (CD). For more information, see About continuous deployment with GitHub Actions.


Security. For more information, see Configuring advanced setup for code scanning.


Continuous Integration (CI). For more information, see About continuous integration with GitHub Actions.
Automation. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository.

Note

Because workflow templates require a public .github repository, they are not available for Enterprise Managed Users.

Creating a workflow template
Workflow templates can be created by users with write access to the organization's public .github repository. These can then be used by organization members who have permission to create workflows.
Workflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see the GitHub Enterprise Cloud documentation.
Note

To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, see Reusing workflows.

This procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow.


If it doesn't already exist, create a new public repository named .github in your organization.


Create a directory named workflow-templates.


Create your new workflow file inside the workflow-templates directory.
If you need to refer to a repository's default branch, you can use the $default-branch placeholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch.
For example, this file named octo-organization-ci.yml demonstrates a basic workflow.
YAMLname: Octo Organization CI

on:
  push:
    branches: [ $default-branch ]
  pull_request:
    branches: [ $default-branch ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Run a one-line script
        run: echo Hello from Octo Organization
name: Octo Organization CI

on:
  push:
    branches: [ $default-branch ]
  pull_request:
    branches: [ $default-branch ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Run a one-line script
        run: echo Hello from Octo Organization



Create a metadata file inside the workflow-templates directory. The metadata file must have the same name as the workflow file, but instead of the .yml extension, it must be appended with .properties.json. For example, this file named octo-organization-ci.properties.json contains the metadata for a workflow file named octo-organization-ci.yml:
JSON{
    "name": "Octo Organization Workflow",
    "description": "Octo Organization CI workflow template.",
    "iconName": "example-icon",
    "categories": [
        "Go"
    ],
    "filePatterns": [
        "package.json$",
        "^Dockerfile",
        ".*\\.md$"
    ]
}
{
    "name": "Octo Organization Workflow",
    "description": "Octo Organization CI workflow template.",
    "iconName": "example-icon",
    "categories": [
        "Go"
    ],
    "filePatterns": [
        "package.json$",
        "^Dockerfile",
        ".*\\.md$"
    ]
}



name - Required. The name of the workflow. This is displayed in the list of available workflows.


description - Required. The description of the workflow. This is displayed in the list of available workflows.


iconName - Optional. Specifies an icon for the workflow that is displayed in the list of workflows. iconName can one of the following types:

An SVG file that is stored in the workflow-templates directory. To reference a file, the value must be the file name without the file extension. For example, an SVG file named example-icon.svg is referenced as example-icon.
An icon from GitHub's set of Octicons. To reference an octicon, the value must be octicon <icon name>. For example, octicon smiley.



categories - Optional. Defines the categories that the workflow is shown under. You can use category names from the following lists:

General category names from the starter-workflows repository.
Linguist languages from the list in the linguist repository.
Supported tech stacks from the list in the starter-workflows repository.



filePatterns - Optional. Allows the workflow to be used if the user's repository has a file in its root directory that matches a defined regular expression.




To add another workflow template, add your files to the same workflow-templates directory.
Next steps
To continue learning about GitHub Actions, see Using workflow templates.\n\n\n\nGitHub Actions/Share automations/Share from your private repositorySharing actions and workflows from your private repositoryYou can share an action or reusable workflow without publishing them publicly.In this articleAbout GitHub Actions access to private repositoriesSharing actions and workflows from your private repositoryFurther readingAbout GitHub Actions access to private repositories
You can share actions and reusable workflows from your private repository, without making them public, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.
Any actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization or user. Actions and reusable workflows stored in private repositories cannot be used in public repositories.
Warning


If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.
To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.


Sharing actions and workflows from your private repository

Store the action or reusable workflow in a private repository. For more information, see About repositories.
Configure the repository to allow access to workflows in other private repositories. For more information, see Managing GitHub Actions settings for a repository.

Further reading

Reusing workflows\n\n\n\nGitHub Actions/Share automations/Share with your organizationSharing actions and workflows with your organizationYou can share an action or reusable workflow with your organization without publishing the action or workflow publicly.In this articleAbout GitHub Actions access to private repositoriesSharing actions and workflows with your organizationFurther readingAbout GitHub Actions access to private repositories
You can share actions and reusable workflows within your organization, without publishing them publicly, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.
Any actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization. Actions and reusable workflows stored in private repositories cannot be used in public repositories.
Warning


If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.
To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.


Sharing actions and workflows with your organization

Store the action or reusable workflow in a private repository. For more information, see About repositories.
Configure the repository to allow access to workflows in other private repositories. For more information, see Managing GitHub Actions settings for a repository.

Further reading

Reusing workflows\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/About monitoringAbout monitoring workflowsYou can use the tools in GitHub Actions to monitor your workflows, metrics, and self-hosted runners.In this articleMonitoring your workflowsMonitoring GitHub Actions metricsMonitoring self-hosted runnersMonitoring your workflows
Monitoring your current jobs in your organization or enterprise
To identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, see Monitoring your current jobs.
Using the visualization graph
Every workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows. For example:

For more information, see Using the visualization graph.
Adding a workflow status badge
A status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the README.md file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the branch and event query parameters in the URL.

For more information, see Adding a workflow status badge.
Viewing job execution time
To identify how long a job took to run, you can view its execution time. For more information, see Viewing job execution time.
Viewing workflow run history
You can view the status of each job and step in a workflow. For more information, see Viewing workflow run history.
Monitoring GitHub Actions metrics
To analyze the efficiency and reliability of your workflows using metrics, see Viewing GitHub Actions metrics.
Monitoring self-hosted runners
If you use self-hosted runners, you can view their activity and diagnose common issues.
For more information, see Monitoring and troubleshooting self-hosted runners.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/Notifications for workflow runsNotifications for workflow runsYou can subscribe to notifications about workflow runs that you trigger.If you enable email or web notifications for GitHub Actions, you'll receive a notification when any workflow runs that you've triggered have completed. The notification will include the workflow run's status (including successful, failed, neutral, and canceled runs). You can also choose to receive a notification only when a workflow run has failed. For more information about enabling or disabling notifications, see About notifications.
Notifications for scheduled workflows are sent to the user who initially created the workflow. If a different user updates the cron syntax in the workflow file, subsequent notifications will be sent to that user instead. If a scheduled workflow is disabled and then re-enabled, notifications will be sent to the user who re-enabled the workflow rather than the user who last modified the cron syntax.
You can also see the status of workflow runs on a repository's Actions tab. For more information, see Managing workflow runs and deployments.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/Visualization graphUsing the visualization graphEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows.

On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


The graph displays each job in the workflow. An icon to the left of the job name indicates the status of the job. Lines between jobs indicate dependencies.



To view a job's log, click the job.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/Workflow run historyViewing workflow run historyYou can view logs for each run of a workflow. Logs include the status for each job and step in a workflow.Tool navigationGitHub CLIWeb browserIn this articleViewing recent workflow runsViewing details for a specific workflow runRead access to the repository is required to perform these steps.



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.




Note

To learn more about GitHub CLI, see About GitHub CLI.

Viewing recent workflow runs
To list the recent workflow runs, use the run list subcommand.
gh run list

To specify the maximum number of runs to return, you can use the -L or --limit flag . The default is 10.
gh run list --limit 5

To only return runs for the specified workflow, you can use the -w or --workflow flag. Replace workflow with either the workflow name, workflow ID, or workflow file name. For example, "Link Checker", 1234567, or "link-check-test.yml".
gh run list --workflow WORKFLOW

Viewing details for a specific workflow run
To display details for a specific workflow run, use the run view subcommand. Replace run-id with the ID of the run that you want to view. If you don't specify a run-id, GitHub CLI returns an interactive menu for you to choose a recent run.
gh run view RUN_ID

To include job steps in the output, use the -v or --verbose flag.
gh run view RUN_ID --verbose

To view details for a specific job in the run, use the -j or --job flag. Replace job-id with the ID of the job that you want to view.
gh run view --job JOB_ID

To view the full log for a job, use the --log flag.
gh run view --job JOB_ID --log

Use the --exit-status flag to exit with a non-zero status if the run failed. For example:
gh run view 0451 --exit-status && echo "run pending or passed"\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/View job execution timeViewing job execution timeYou can view the execution time of a job, including the billable minutes that a job accrued.Billable job execution minutes are only shown for jobs run on private repositories that use GitHub-hosted runners and are rounded up to the next minute. There are no billable minutes when using GitHub Actions in public repositories or for jobs run on self-hosted runners.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


Under the job summary, you can view the job's execution time.


To view details about the billable job execution time, in the left sidebar under "Run details", click  Usage.
Note

The billable time shown does not include any minute multipliers. To view your total GitHub Actions usage, including minute multipliers, see Viewing your GitHub Actions usage.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/Add a status badgeAdding a workflow status badgeYou can display a status badge in your repository to indicate the status of your workflows.In this articleUsing the UIUsing the workflow file nameUsing the branch parameterUsing the event parameterNote

Workflow badges in a private repository are not accessible externally, so you won't be able to embed them or link to them from an external site.

A status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the README.md file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the branch and event query parameters in the URL.

To add a workflow status badge to your README.md file, first find the URL for the status badge you would like to display. Then you can use Markdown to display the badge as an image in your README.md file. For more information about image markup in Markdown, see Basic writing and formatting syntax.
Using the UI
You can create a workflow status badge directly on the UI using the workflow file name, branch parameter, and event parameter.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



On the right side of the page, next to the "Filter workflow runs" field, click  to display a dropdown menu and click Create status badge.


Optionally, select a branch if you want to display the status badge for a branch different from the default branch.


Optionally, select the event that will trigger the workflow.


Click  Copy status badge Markdown.


Copy the Markdown into your README.md file.


Using the workflow file name
You can build the URL for a workflow status badge using the name of the workflow file:
https://github.com/OWNER/REPOSITORY/actions/workflows/WORKFLOW-FILE/badge.svg

To display the workflow status badge in your README.md file, use the Markdown markup for embedding images. For more information about image markup in Markdown, see Basic writing and formatting syntax.
For example, add the following Markdown to your README.md file to add a status badge for a workflow with the file path .github/workflows/main.yml. The OWNER of the repository is the github organization and the REPOSITORY name is docs.
![example workflow](https://github.com/github/docs/actions/workflows/main.yml/badge.svg)

Using the branch parameter
To display the status of a workflow run for a specific branch, add ?branch=BRANCH-NAME to the end of the status badge URL.
For example, add the following Markdown to your README.md file to display a status badge for a branch with the name feature-1.
![example branch parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?branch=feature-1)

Using the event parameter
To display the status of workflow runs triggered by the push event, add ?event=push to the end of the status badge URL.
For example, add the following Markdown to your README.md file to display a badge with the status of workflow runs triggered by the push event, which will show the status of the build for the current state of that branch.
![example event parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?event=push)\n\n\n\nGitHub Actions/Monitor & troubleshoot/Monitor/Workflow run logsUsing workflow run logsYou can view, search, and download the logs for each job in a workflow run.In this articleViewing logs to diagnose failuresSearching logsDownloading logsDeleting logsViewing logs with GitHub CLIYou can see whether a workflow run is in progress or complete from the workflow run page. You must be logged in to a GitHub account to view workflow run information, including for public repositories. For more information, see Access permissions on GitHub.
If the run is complete, you can see whether the result was a success, failure, canceled, or neutral. If the run failed, you can view and search the build logs to diagnose the failure and re-run the workflow. You can also view billable job execution minutes, or download logs and build artifacts.
GitHub Actions use the Checks API to output statuses, results, and logs for a workflow. GitHub creates a new check suite for each workflow run. The check suite contains a check run for each job in the workflow, and each job includes steps. GitHub Actions are run as a step in a workflow. For more information about the Checks API, see REST API endpoints for checks.
Note

Ensure that you only commit valid workflow files to your repository. If .github/workflows contains an invalid workflow file, GitHub Actions generates a failed workflow run for every new commit.

Viewing logs to diagnose failures
If your workflow run fails, you can see which step caused the failure and review the failed step's build logs to troubleshoot. You can see the time it took for each step to run. You can also copy a permalink to a specific line in the log file to share with your team. Read access to the repository is required to perform these steps.
In addition to the steps configured in the workflow file, GitHub adds two additional steps to each job to set up and complete the job's execution. These steps are logged in the workflow run with the names "Set up job" and "Complete job".
For jobs run on GitHub-hosted runners, "Set up job" records details of the runner image, and includes a link to the list of preinstalled tools that were present on the runner machine.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


Under Jobs or in the visualization graph, click the job you want to see.


Any failed steps are automatically expanded to display the results.


Optionally, to get a link to a specific line in the logs, click on the step's line number. You can then copy the link from the address bar of your web browser.



Searching logs
You can search the build logs for a particular step. When you search logs, only expanded steps are included in the results. Read access to the repository is required to perform these steps.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


Under Jobs or in the visualization graph, click the job you want to see.


In the upper-right corner of the log output, in the Search logs search box, type a search query.


Downloading logs
You can download the log files from your workflow run. You can also download a workflow's artifacts. For more information, see Storing and sharing data from a workflow. Read access to the repository is required to perform these steps.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


Under Jobs or in the visualization graph, click the job you want to see.


In the upper right corner of the log, select the  dropdown menu, then click Download log archive.



Note

When you download the log archive for a workflow that was partially re-run, the archive only includes the jobs that were re-run. To get a complete set of logs for jobs that were run from a workflow, you must download the log archives for the previous run attempts that ran the other jobs.

Deleting logs
You can delete the log files from your workflow runs through the GitHub web interface or programmatically. Write access to the repository is required to perform these steps.
Deleting logs via the GitHub web interface


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, click the workflow you want to see.



From the list of workflow runs, click the name of the run to see the workflow run summary.


In the upper-right corner, select the  dropdown menu, then click Delete all logs.



Review the confirmation prompt.


After deleting logs, the Delete all logs button is removed to indicate that no log files remain in the workflow run.
Deleting logs programmatically
You can use the following script to automatically delete all logs for a workflow. This can be a useful way to clean up logs for multiple workflow runs.
To run the example script below:


Copy the code example and save it to a file called delete-logs.sh.


Grant it the execute permission with chmod +x delete-logs.sh.


Run the following command, where REPOSITORY_NAME is the name of your repository and WORKFLOW_NAME is the file name of your workflow.
Shell./delete-logs.sh REPOSITORY_NAME WORKFLOW_NAME
./delete-logs.sh REPOSITORY_NAME WORKFLOW_NAME

For example, to delete all of the logs in the monalisa/octocat repository for the .github/workflows/ci.yaml workflow, you would run ./delete-logs.sh monalisa/octocat ci.yaml.


Example script
Bash#!/usr/bin/env bash

# Delete all logs for a given workflow
# Usage: delete-logs.sh <repository> <workflow-name>

set -oe pipefail

REPOSITORY=$1
WORKFLOW_NAME=$2

# Validate arguments
if [[ -z "$REPOSITORY" ]]; then
  echo "Repository is required"
  exit 1
fi

if [[ -z "$WORKFLOW_NAME" ]]; then
  echo "Workflow name is required"
  exit 1
fi

echo "Getting all completed runs for workflow $WORKFLOW_NAME in $REPOSITORY"

RUNS=$(
  gh api \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "/repos/$REPOSITORY/actions/workflows/$WORKFLOW_NAME/runs" \
    --paginate \
    --jq '.workflow_runs[] | select(.conclusion != "") | .id'
)

echo "Found $(echo "$RUNS" | wc -l) completed runs for workflow $WORKFLOW_NAME"

# Delete logs for each run
for RUN in $RUNS; do
  echo "Deleting logs for run $RUN"
  gh api \
    --silent \
    --method DELETE \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "/repos/$REPOSITORY/actions/runs/$RUN/logs" || echo "Failed to delete logs for run $RUN"

  # Sleep for 100ms to avoid rate limiting
  sleep 0.1
done
#!/usr/bin/env bash

# Delete all logs for a given workflow
# Usage: delete-logs.sh <repository> <workflow-name>

set -oe pipefail

REPOSITORY=$1
WORKFLOW_NAME=$2

# Validate arguments
if [[ -z "$REPOSITORY" ]]; then
  echo "Repository is required"
  exit 1
fi

if [[ -z "$WORKFLOW_NAME" ]]; then
  echo "Workflow name is required"
  exit 1
fi

echo "Getting all completed runs for workflow $WORKFLOW_NAME in $REPOSITORY"

RUNS=$(
  gh api \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "/repos/$REPOSITORY/actions/workflows/$WORKFLOW_NAME/runs" \
    --paginate \
    --jq '.workflow_runs[] | select(.conclusion != "") | .id'
)

echo "Found $(echo "$RUNS" | wc -l) completed runs for workflow $WORKFLOW_NAME"

# Delete logs for each run
for RUN in $RUNS; do
  echo "Deleting logs for run $RUN"
  gh api \
    --silent \
    --method DELETE \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: 2022-11-28" \
    "/repos/$REPOSITORY/actions/runs/$RUN/logs" || echo "Failed to delete logs for run $RUN"

  # Sleep for 100ms to avoid rate limiting
  sleep 0.1
done

Viewing logs with GitHub CLI
Note

To learn more about GitHub CLI, see About GitHub CLI.

To view the log for a specific job, use the run view subcommand. Replace run-id with the ID of run that you want to view logs for. GitHub CLI returns an interactive menu for you to choose a job from the run. If you don't specify run-id, GitHub CLI returns an interactive menu for you to choose a recent run, and then returns another interactive menu for you to choose a job from the run.
gh run view RUN_ID --log

You can also use the --job flag to specify a job ID. Replace job-id with the ID of the job that you want to view logs for.
gh run view --job JOB_ID --log

You can use grep to search the log. For example, this command will return all log entries that contain the word error.
gh run view --job JOB_ID --log | grep error

To filter the logs for any failed steps, use --log-failed instead of --log.
gh run view --job JOB_ID --log-failed\n\n\n\nGitHub Actions/Monitor & troubleshoot/Troubleshoot/About troubleshootingAbout troubleshooting workflowsYou can use the tools in GitHub Actions to debug your workflows.In this articleTroubleshooting your workflowsTroubleshooting GitHub Actions inefficienciesTroubleshooting self-hosted runnersTroubleshooting your workflows
There are several ways you can troubleshoot failed workflow runs.
Using GitHub Copilot
If a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error. See Using Copilot to troubleshoot workflows.
Using workflow run logs
Each workflow run generates activity logs that you can view, search, and download. For more information, see Using workflow run logs.
Enabling debug logging
If the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging. For more information, see Enabling debug logging.
Canceling a workflow
If you attempt to cancel a workflow and the cancellation doesn't succeed, make sure you aren't using the always expression. The always expression causes a workflow step to run even when the workflow is canceled, which results in a hanging cancellation. For more information, see Evaluate expressions in workflows and actions.
Troubleshooting GitHub Actions inefficiencies
To analyze the inefficiencies and reliability of your workflows using metrics, see Viewing GitHub Actions metrics.
Troubleshooting self-hosted runners
If you use self-hosted runners, you can view their activity and diagnose common issues.
For more information, see Monitoring and troubleshooting self-hosted runners.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Troubleshoot/Use CopilotUsing Copilot to troubleshoot workflowsYou can use GitHub Copilot to help resolve failed workflow runs.Who can use this feature?This feature is available for users on all GitHub Copilot subscription tiers.If a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error.
To open a chat about a failed workflow run, you can either:

Next to the failed check in the merge box, click , then click  Explain error.
In the merge box, click on the failed check. At the top of the workflow run summary page, click  Explain error.

This opens a chat window with GitHub Copilot, where it will provide instructions to resolve the issue.
Note
 If you are on a GitHub Copilot Free subscription, this will count towards your monthly chat message limit.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Troubleshoot/Enable debug loggingEnabling debug loggingIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging.In this articleEnabling runner diagnostic loggingEnabling step debug loggingThese extra logs are enabled by setting secrets or variables in the repository containing the workflow, so the same permissions requirements will apply:

To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have admin access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.
To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have admin access. For more information on environments, see Managing environments for deployment.
Organization owners can create secrets or variables at the organization level.

For more information on setting secrets and variables, see Using secrets in GitHub Actions and Store information in variables.
Additionally, anyone who has access to run a workflow can enable runner diagnostic logging and step debug logging for a workflow re-run. For more information, see Re-running workflows and jobs.
Enabling runner diagnostic logging
Runner diagnostic logging provides additional log files that contain information about how a runner is executing a job. Two extra log files are added to the log archive:

The runner process log, which includes information about coordinating and setting up runners to execute jobs.
The worker process log, which logs the execution of a job.


To enable runner diagnostic logging, set the following secret or variable in the repository that contains the workflow: ACTIONS_RUNNER_DEBUG to true. If both the secret and variable are set, the value of the secret takes precedence over the variable.
To download runner diagnostic logs, download the log archive of the workflow run. The runner diagnostic logs are contained in the runner-diagnostic-logs folder. For more information on downloading logs, see Using workflow run logs.

Enabling step debug logging
Step debug logging increases the verbosity of a job's logs during and after a job's execution.

To enable step debug logging, set the following secret or variable in the repository that contains the workflow: ACTIONS_STEP_DEBUG to true. If both the secret and variable are set, the value of the secret takes precedence over the variable.
After setting the secret or variable, more debug events are shown in the step logs. For more information, see Using workflow run logs.\n\n\n\nGitHub Actions/Monitor & troubleshoot/Troubleshoot/Working with GitHub SupportWorking with Support for GitHub ActionsLearn how GitHub Support can assist with GitHub ActionsIn this articleProviding diagnostic and troubleshooting informationScope of supportYou can contact GitHub Support for assistance with GitHub Actions.
Providing diagnostic and troubleshooting information
The contents of private and internal repositories are not visible to GitHub Support, so GitHub Support may request additional information to understand the complete context of your inquiry and reproduce any unexpected behavior. You can accelerate the resolution of your inquiry by providing this information when you initially raise a ticket with GitHub Support.
Some information that GitHub Support will request can include, but is not limited to, the following:


The URL of the workflow run.
For example: https://github.com/ORG/REPO/actions/runs/0123456789


The workflow .yml file(s) attached to the ticket as .txt files. For more information about workflows, see About workflows.


A copy of your workflow run logs for an example workflow run failure. For more information about workflow run logs, see Using workflow run logs.


If you are running this workflow on a self-hosted runner, self-hosted runner logs which can be found under the _diag folder within the runner. For more information about self-hosted runners, see Monitoring and troubleshooting self-hosted runners.
Self-hosted runner log file names are be formatted: Runner_YYYY####-xxxxxx-utc.log and Worker_YYYY####-xxxxxx-utc.log.


Note

Attach files to your support ticket by changing the file's extension to .txt or .zip. If you include textual data such as log or workflow file snippets inline in your ticket, ensure they are formatted correctly as Markdown code blocks. For more information about proper Markdown formatting, see Basic writing and formatting syntax.
If the information you provide is unreadable due to the loss of formatting by improper Markdown syntax, GitHub Support may request that resubmit the information either as an attachment or with the correct Markdown formatting.

Warning

Ensure all files and text provided to GitHub Support have been properly redacted to remove sensitive information such as tokens and other secrets.

Ephemeral Runner Application Log Files
GitHub Support may request the runner application log files from ephemeral runners. GitHub expects and recommends that you have implemented a mechanism to forward and preserve the runner application log files from self-hosted ephemeral runners. For more information about runner application log files and troubleshooting self-hosted runners, see Monitoring and troubleshooting self-hosted runners.
Actions Runner Controller
If you are using Actions Runner Controller (ARC), GitHub Support may ask you to submit the complete logs for the controller, listeners, and runner pods. For more information about collecting Actions Runner Controller's logs, see Troubleshooting Actions Runner Controller errors.
For more information about the scope of support for Actions Runner Controller, see About support for Actions Runner Controller.
CodeQL and GitHub Actions
If you are requesting assistance with a CodeQL analysis workflow, GitHub Support may request a copy of the CodeQL debugging artifacts. For more information about debugging artifacts for a CodeQL analysis workflow, see Logs are not detailed enough.
To provide the debugging artifacts to GitHub Support, please download the CodeQL debugging artifacts from a sample workflow run and attach it to your ticket as a .zip file. For more information on downloading workflow artifacts, see Downloading workflow artifacts.
If the CodeQL debugging artifacts .zip file is too large to upload to the ticket, please advise GitHub Support, and we will work with you to determine the next steps.
Scope of support
If your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:

Third party integrations, such as Jira
CI/CD, such as Jenkins
Writing scripts
Configuration of external authentication systems, such as SAML identity providers
Open source projects
Writing or debugging new queries for CodeQL
Cloud provider configurations, such as virtual network setup, custom firewall, or proxy rules
Container orchestration, such as Kubernetes setup, or networking
Detailed assistance with workflows and data management
Preview features. Public preview and private preview features are out of GitHub Support's scope.

For detailed assistance with workflows and data management, consult GitHub Expert Services, which offer specialized support to help you optimize your use of the platform.
If you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.\n\n\n\nGitHub Actions/GitHub-hosted runners/About GitHub-hosted runners/About GitHub-hosted runnersAbout GitHub-hosted runnersGitHub offers hosted virtual machines to run workflows. The virtual machine contains an environment of tools, packages, and settings available for GitHub Actions to use.In this articleOverview of GitHub-hosted runnersUsing a GitHub-hosted runnerViewing available runners for a repositorySupported runners and hardware resourcesRunner ImagesCloud hosts used by GitHub-hosted runnersWorkflow continuityAdministrative privilegesIP addressesCommunication requirements for GitHub-hosted runnersThe etc/hosts fileFile systemsFurther readingOverview of GitHub-hosted runners
Runners are the machines that execute jobs in a GitHub Actions workflow. For example, a runner can clone your repository locally, install testing software, and then run commands that evaluate your code.
GitHub provides runners that you can use to run your jobs, or you can host your own runners. Each GitHub-hosted runner is a new virtual machine (VM) hosted by GitHub with the runner application and other tools preinstalled, and is available with Ubuntu Linux, Windows, or macOS operating systems. When you use a GitHub-hosted runner, machine maintenance and upgrades are taken care of for you.
You can choose one of the standard GitHub-hosted runner options or, if you are on the GitHub Team or GitHub Enterprise Cloud plan, you can provision a runner with more cores, or a runner that's powered by a GPU processor. These machines are referred to as "larger runner." For more information, see About larger runners.
Using GitHub-hosted runners requires network access with at least 70 kilobits per second upload and download speeds.
Using a GitHub-hosted runner
To use a GitHub-hosted runner, create a job and use runs-on to specify the type of runner that will process the job, such as ubuntu-latest, windows-latest, or macos-latest. For the full list of runner types, see About GitHub-hosted runners. If you have repo: write access to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, see Viewing available runners for a repository.
When the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned.
The following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners.

The following example workflow has two jobs, named Run-npm-on-Ubuntu and Run-PSScriptAnalyzer-on-Windows. When this workflow is triggered, GitHub provisions a new virtual machine for each job.

The job named Run-npm-on-Ubuntu is executed on a Linux VM, because the job's runs-on: specifies ubuntu-latest.
The job named Run-PSScriptAnalyzer-on-Windows is executed on a Windows VM, because the job's runs-on: specifies windows-latest.

YAMLname: Run commands on different operating systems
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  Run-npm-on-Ubuntu:
    name: Run npm on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm help

  Run-PSScriptAnalyzer-on-Windows:
    name: Run PSScriptAnalyzer on Windows
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install PSScriptAnalyzer module
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module PSScriptAnalyzer -ErrorAction Stop
      - name: Get list of rules
        shell: pwsh
        run: |
          Get-ScriptAnalyzerRule
name: Run commands on different operating systems
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  Run-npm-on-Ubuntu:
    name: Run npm on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm help

  Run-PSScriptAnalyzer-on-Windows:
    name: Run PSScriptAnalyzer on Windows
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install PSScriptAnalyzer module
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module PSScriptAnalyzer -ErrorAction Stop
      - name: Get list of rules
        shell: pwsh
        run: |
          Get-ScriptAnalyzerRule

While the job runs, the logs and output can be viewed in the GitHub UI:

The GitHub Actions runner application is open source. You can contribute and file issues in the runner repository.
Viewing available runners for a repository
If you have repo: write access to a repository, you can view a list of the runners available to the repository.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, under the "Management" section, click  Runners.


Review the list of available GitHub-hosted runners for the repository.


Optionally, to copy a runner's label to use it in a workflow, click  to the right of the runner, then click Copy label.


Note

Enterprise and organization owners can create runners from this page. To create a new runner, click New runner at the top right of the list of runners to add runners to the repository.
For more information, see Managing larger runners and Adding self-hosted runners.

Supported runners and hardware resources
Ranges of GitHub-hosted runners are available for use in public and private repositories.
For lists of available runners, see:

Standard runners for public repositories
Standard runners for private repositories

GitHub-hosted Linux runners support hardware acceleration for Android SDK tools, which makes running Android tests much faster and consumes fewer minutes. For more information on Android hardware acceleration, see Configure hardware acceleration for the Android Emulator in the Android Developers documentation.
Note

The -latest runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.

Warning

Beta and Deprecated Images are provided "as-is", "with all faults" and "as available" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.

Standard GitHub-hosted runners for public repositories
For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.


  
    
      Virtual Machine
      Processor (CPU)
      Memory (RAM)
      Storage (SSD)
      Architecture
      Workflow label
    
  
  
    
      Linux
      4
      16 GB
      14 GB
       x64 
      
        ubuntu-latest,
        ubuntu-24.04,
        ubuntu-22.04,
        ubuntu-20.04
      
    
    
      Windows
      4
      16 GB
      14 GB
       x64 
      
        windows-latest,
         windows-2025,
        windows-2022,
        windows-2019
      
    
    
      Linux [Public preview]
      4
      16 GB
      14 GB
       arm64 
      
        ubuntu-24.04-arm,
        ubuntu-22.04-arm
      
    
    
      Windows [Public preview]
      4
      16 GB
      14 GB
      arm64
      
        windows-11-arm
      
    
    
      macOS
      4
      14 GB
      14 GB
       Intel 
      
        macos-13
      
    
    
      macOS
      3 (M1)
      7 GB
      14 GB
       arm64 
      
        macos-latest,
        macos-14,
        macos-15
      
    
  
Note
 The arm64 Linux and Windows runners are in public preview and subject to change.

Standard GitHub-hosted runners for  private repositories
For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions.

  
    
      Virtual Machine
      Processor (CPU)
      Memory (RAM)
      Storage (SSD)
      Architecture
      Workflow label
    
  
  
    
      Linux
      2
      7 GB
      14 GB
       x64 
      
        ubuntu-latest,
        ubuntu-24.04,
        ubuntu-22.04,
        ubuntu-20.04
      
    
    
      Windows
      2
      7 GB
      14 GB
       x64 
      
        windows-latest,
        windows-2025,
        windows-2022,
        windows-2019
      
    
    
      macOS
      4
      14 GB
      14 GB
       Intel 
      
        macos-13
      
    
    
      macOS
      3 (M1)
      7 GB
      14 GB
       arm64 
      
        macos-latest,
        macos-14,
        macos-15
      
    
  

Workflow logs list the runner used to run a job. For more information, see Viewing workflow run history.
Limitations for arm64 macOS runners

All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.
Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.
Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.
The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically 4203018E-580F-C1B5-9525-B745CECA79EB. If you are building and signing on the same host you plan to test the build on, you can sign with a development provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.

Larger runners
Customers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the standard GitHub-hosted runners. These machines are referred to as "larger runner." They offer the following advanced features:

More RAM, CPU, and disk space
Static IP addresses
Azure private networking
The ability to group runners
Autoscaling to support concurrent workflows
GPU-powered runners

These larger runners are hosted by GitHub and have the runner application and other tools preinstalled.
For more information, see Using larger runners.
Runner Images
GitHub maintains our own set of VM images for our standard hosted runners. This includes the images for macOS, x64 linux and Windows images. The list of images and their included tools are managed in the actions/runner-images repository. Our arm64 images are partner images, and those are managed in the actions/partner-runner-images repository.
Preinstalled software for GitHub-owned images
The software tools included in our GitHub-owned images are updated weekly. The update process takes several days, and the list of preinstalled software on the main branch is updated after the whole deployment ends.
Workflow logs include a link to the preinstalled tools on the exact runner. To find this information in the workflow log, expand the Set up job section. Under that section, expand the Runner Image section. The link following Included Software will describe the preinstalled tools on the runner that ran the workflow.
For more information, see Viewing workflow run history.
GitHub-hosted runners include the operating system's default built-in tools, in addition to the packages listed in the above references. For example, Ubuntu and macOS runners include grep, find, and which, among other default tools.
You can also view a software bill of materials (SBOM) for each build of the Windows and Ubuntu runner images. For more information, see Security hardening for GitHub Actions.
Using preinstalled software
We recommend using actions to interact with the software installed on runners. This approach has several benefits:

Usually, actions provide more flexible functionality like version selection, ability to pass arguments, and parameters
It ensures the tool versions used in your workflow will remain the same regardless of software updates

If there is a tool that you'd like to request, please open an issue at actions/runner-images. This repository also contains announcements about all major software updates on runners.
Installing additional software
You can install additional software on GitHub-hosted runners. For more information, see Customizing GitHub-hosted runners.
Cloud hosts used by GitHub-hosted runners
GitHub hosts Linux and Windows runners on virtual machines in Microsoft Azure with the GitHub Actions runner application installed. The GitHub-hosted runner application is a fork of the Azure Pipelines Agent. Inbound ICMP packets are blocked for all Azure virtual machines, so ping or traceroute commands might not work. GitHub hosts macOS runners in Azure data centers.
Workflow continuity
If GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.
In addition, if the workflow run has been successfully queued, but has not been processed by a GitHub-hosted runner within 45 minutes, then the queued workflow run is discarded.
Administrative privileges
The Linux and macOS virtual machines both run using passwordless sudo. When you need to execute commands or install tools that require more privileges than the current user, you can use sudo without needing to provide a password. For more information, see the Sudo Manual.
Windows virtual machines are configured to run as administrators with User Account Control (UAC) disabled. For more information, see How User Account Control works in the Windows documentation.
IP addresses
To get a list of IP address ranges that GitHub Actions uses for GitHub-hosted runners, you can use the GitHub REST API. For more information, see the actions key in the response of the GET /meta endpoint. For more information, see REST API endpoints for meta data.
Windows and Ubuntu runners are hosted in Azure and subsequently have the same IP address ranges as the Azure datacenters. macOS runners are hosted in GitHub's own macOS cloud.
Since there are so many IP address ranges for GitHub-hosted runners, we do not recommend that you use these as allowlists for your internal resources. Instead, we recommend you use larger runners with a static IP address range, or self-hosted runners. For more information, see Using larger runners or About self-hosted runners.
The list of GitHub Actions IP addresses returned by the API is updated once a week.
Communication requirements for GitHub-hosted runners
A GitHub-hosted runner must establish connections to GitHub-owned endpoints to perform essential communication operations. In addition, your runner may require access to additional networks that you specify or utilize within an action.
To ensure proper communications for GitHub-hosted runners between networks within your configuration, ensure that the following communications are allowed.
Note

Some of the domains listed are configured using CNAME records. Some firewalls might require you to add rules recursively for all CNAME records. Note that the CNAME records might change in the future, and that only the domains listed will remain constant.

Needed for essential operations:
Shellgithub.com
api.github.com
*.actions.githubusercontent.com
github.com
api.github.com
*.actions.githubusercontent.com

Needed for downloading actions:
Shellcodeload.github.com
pkg.actions.githubusercontent.com
codeload.github.com
pkg.actions.githubusercontent.com

Needed for publishing immutable actions:
Shellghcr.io
ghcr.io

Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches:
Shellresults-receiver.actions.githubusercontent.com
*.blob.core.windows.net
results-receiver.actions.githubusercontent.com
*.blob.core.windows.net

Needed for runner version updates:
Shellobjects.githubusercontent.com
objects-origin.githubusercontent.com
github-releases.githubusercontent.com
github-registry-files.githubusercontent.com
objects.githubusercontent.com
objects-origin.githubusercontent.com
github-releases.githubusercontent.com
github-registry-files.githubusercontent.com

Needed for retrieving OIDC tokens:
Shell*.actions.githubusercontent.com
*.actions.githubusercontent.com

Needed for downloading or publishing packages or containers to GitHub Packages:
Shell*.pkg.github.com
pkg-containers.githubusercontent.com
ghcr.io
*.pkg.github.com
pkg-containers.githubusercontent.com
ghcr.io

Needed for Git Large File Storage
Shellgithub-cloud.githubusercontent.com
github-cloud.s3.amazonaws.com
github-cloud.githubusercontent.com
github-cloud.s3.amazonaws.com

Needed for jobs for Dependabot updates
Shelldependabot-actions.githubapp.com
dependabot-actions.githubapp.com

The etc/hosts file
GitHub-hosted runners are provisioned with an etc/hosts file that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk.
File systems
GitHub executes actions and shell commands in specific directories on the virtual machine. The file paths on virtual machines are not static. Use the environment variables GitHub provides to construct file paths for the home, workspace, and workflow directories.

























DirectoryEnvironment variableDescriptionhomeHOMEContains user-related data. For example, this directory could contain credentials from a login attempt.workspaceGITHUB_WORKSPACEActions and shell commands execute in this directory. An action can modify the contents of this directory, which subsequent actions can access.workflow/event.jsonGITHUB_EVENT_PATHThe POST payload of the webhook event that triggered the workflow. GitHub rewrites this each time an action executes to isolate file content between actions.
For a list of the environment variables GitHub creates for each workflow, see Store information in variables.
Docker container filesystem
Actions that run in Docker containers have static directories under the /github path. However, we strongly recommend using the default environment variables to construct file paths in Docker containers.
GitHub reserves the /github path prefix and creates three directories for actions.

/github/home
/github/workspace - Note: GitHub Actions must be run by the default Docker user (root). Ensure your Dockerfile does not set the USER instruction, otherwise you will not be able to access GITHUB_WORKSPACE.
/github/workflow

Further reading

Managing billing for GitHub Actions
You can use a matrix strategy to run your jobs on multiple images. For more information, see Running variations of jobs in a workflow.\n\n\n\nGitHub Actions/GitHub-hosted runners/About GitHub-hosted runners/Monitor current jobsMonitoring your current jobsMonitor how GitHub-hosted runners are processing jobs in your organization or enterprise, and identify any related constraints.In this articleViewing active jobs in your organization or enterpriseViewing queued jobs in your organization or enterpriseViewing active jobs in your organization or enterprise
You can get a list of all jobs currently running on GitHub-hosted runners in your organization or enterprise.


Navigate to the main page of the organization or repository.


Click  Settings.


In the left sidebar, click Actions, then click Runners.


In the "Runners" table, click the entry for GitHub-hosted runners. This entry will only be present if you're using GitHub-hosted runners.


Review the "Active jobs" section, which contains a list of all jobs currently running on GitHub-hosted runners.


Viewing queued jobs in your organization or enterprise
GitHub-hosted runners allow you to run jobs concurrently, and the maximum number of concurrent jobs will vary depending on your plan. If you reach the maximum number of concurrent jobs, any new jobs will start to enter a queue. To find out more about the number of concurrent jobs available to your plan, see Usage limits, billing, and administration.
The following procedure demonstrates how to check the maximum number of concurrent jobs you can run.


Navigate to the main page of the organization or repository.


Click  Settings.


In the left sidebar, click Actions, then click Runners.


In the "Runners" table, click the entry for GitHub-hosted runners. This entry will only be present if you're using GitHub-hosted runners.


Review the "All jobs usage" section, which lists the number of active jobs and the maximum number of jobs you can run.\n\n\n\nGitHub Actions/GitHub-hosted runners/About GitHub-hosted runners/Customize runnersCustomizing GitHub-hosted runnersYou can install additional software on GitHub-hosted runners as a part of your workflow.In this articleInstalling software on Ubuntu runnersInstalling software on macOS runnersInstalling software on Windows runnersIf you require additional software packages on GitHub-hosted runners, you can create a job that installs the packages as part of your workflow.
To see which packages are already installed by default, see Using GitHub-hosted runners.
This guide demonstrates how to create a job that installs additional software on a GitHub-hosted runner.
Installing software on Ubuntu runners
The following example demonstrates how to install an apt package as part of a job.
name: Build on Ubuntu
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install jq tool
        run: |
          sudo apt-get update
          sudo apt-get install jq

Note

Always run sudo apt-get update before installing a package. In case the apt index is stale, this command fetches and re-indexes any available packages, which helps prevent package installation failures.

Installing software on macOS runners
The following example demonstrates how to install Brew packages and casks as part of a job.
name: Build on macOS
on: push

jobs:
  build:
    runs-on: macos-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
      - name: Install GitHub CLI
        run: |
          brew update
          brew install gh
      - name: Install Microsoft Edge
        run: |
          brew update
          brew install --cask microsoft-edge

Installing software on Windows runners
The following example demonstrates how to use Chocolatey to install the GitHub CLI as part of a job.
name: Build on Windows
on: push
jobs:
  build:
    runs-on: windows-latest
    steps:
      - run: choco install gh
      - run: gh version\n\n\n\nGitHub Actions/GitHub-hosted runners/Using larger runners/About larger runnersAbout larger runnersGitHub offers runners with advanced features to support more customized use cases.Who can use this feature?Larger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.In this articleOverview of larger runnersMachine sizes for larger runnersAbout runner groupsArchitectural overview of larger runnersAutoscaling larger runnersAssigning static IP addresses to larger runnersNetworking for larger runnersOverview of larger runners
Customers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the standard GitHub-hosted runners. These machines are referred to as "larger runner." They offer the following advanced features:

More RAM, CPU, and disk space
Static IP addresses
Azure private networking
The ability to group runners
Autoscaling to support concurrent workflows
GPU-powered runners

These larger runners are hosted by GitHub and have the runner application and other tools preinstalled.
GitHub offers larger runners with macOS, Ubuntu, or Windows operating systems, and different features and sizes are available depending on which operating system you use. For more information, see Additional features for larger runners.
About Ubuntu and Windows larger runners
Larger runners with Ubuntu or Windows operating systems are configured in your organization or enterprise. When you add a larger runner, you are defining a type of machine from a selection of available hardware specifications and operating system images. GitHub will then create multiple instances of this runner that scale up and down to match the job demands of your organization, based on the autoscaling limits you define. For more information, see Managing larger runners.
Ubuntu and Windows larger runners offer autoscaling capabilities and the ability to assign the runners static IP addresses from a specific range. They can also be managed using runner groups, which enables you to control access to the larger runners. For more information, see Additional features for larger runners.
About macOS larger runners
Larger runners with a macOS operating system are used by updating the YAML workflow label to the desired runner image. To run your workflows on a macOS larger runner, update the runs-on key to use one of the GitHub-defined macOS larger runner labels. No additional configuration is required. For more information, see Running jobs on larger runners.
The following machines sizes are available for macOS larger runners.





























Runner SizeArchitectureProcessor (CPU)Memory (RAM)Storage (SSD)Workflow labelLargeIntel1230 GB14 GBmacos-latest-large, macos-13-large, macos-14-large [latest], macos-15-large [Public preview]XLargearm64 (M1)6 (+ 8 GPU hardware acceleration)14 GB14 GBmacos-latest-xlarge, macos-13-xlarge , macos-14-xlarge [latest], macos-15-xlarge [Public preview]
Limitations for macOS larger runners

All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.
Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.
Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.
The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically 4203018E-580F-C1B5-9525-B745CECA79EB. If you are building and signing on the same host you plan to test the build on, you can sign with a development provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.

Additional features for larger runners
Compared to standard GitHub-hosted runners, larger runners have additional features, and their availability varies depending on the larger runner's operating system.




































UbuntuWindowsmacOSStatic IP addressesAzure private networkingAutoscalingRunner groups

These features can enhance your CI/CD pipelines in the following ways.

Assigning larger runners static IP addresses from a specific range enables you to use this range to configure a firewall allowlist. For more information, see Networking for larger runners.
Autoscaling enables larger runners to scale up to a maximum limit set by you, so your workflows can run concurrently. For more information, see Autoscaling larger runners.
Runner groups allow you to control access to larger runners for your organizations, repositories, and workflows. For more information, see Controlling access to larger runners.

Runner images
Larger runners run on virtual machines (VMs), and GitHub installs a virtual hard disk (VHD) on this machine during the VM creation process. You can choose from different VM images to install on your runners.
GitHub-owned images: These images are maintained by GitHub and are available for Linux x64, Windows x64, and macOS (x64 and arm) runners. For more information on these images and a full list of included tools for each runner operating system, see the GitHub Actions Runner Images repository.
Partner Images: Partner images are not managed by GitHub and are pulled from the Azure Marketplace. See below for resources on where to find more information and to report issues for partner images.

Base Windows 11 desktop image.
NVIDIA GPU-Optimized VMI
Data Science Virtual Machine - Windows 2019.
arm64 images: actions/partner-runner-images repository.

Understanding billing
Note

Larger runners are not eligible for the use of included minutes on private repositories. For both private and public repositories, when larger runners are in use, they will always be billed at the per-minute rate.

Compared to standard GitHub-hosted runners, larger runners are billed differently. Larger runners are only billed at the per-minute rate for the amount of time workflows are executed on them. There is no cost associated with creating a larger runner that is not being used by a workflow. For more information, see About billing for GitHub Actions.
Machine sizes for larger runners
You can choose from several specifications for larger runners.
Specifications for general larger runners


















































































CPUMemory (RAM)Storage (SSD)ArchitectureOperating system (OS)614 GB14 GBarm64macOS1230 GB14 GBx64macOS28 GB75 GBx64, arm64Ubuntu416 GB150 GBx64, arm64Ubuntu, Windows832 GB300 GBx64, arm64Ubuntu, Windows1664 GB600 GBx64, arm64Ubuntu, Windows32128 GB1200 GBx64, arm64Ubuntu, Windows64208 GB2040 GBarm64Ubuntu, Windows64256 GB2040 GBx64Ubuntu, Windows96384 GB2040 GBx64Ubuntu, Windows
Note
 The 4-vCPU Windows runner only works with the Windows Server 2025 or the Base Windows 11 Desktop image.

Specifications for GPU larger runners























CPUGPUGPU cardMemory (RAM)GPU memory (VRAM)Storage (SSD)Operating system (OS)41Tesla T428 GB16 GB176 GBUbuntu, Windows
About runner groups
Note

Only larger runners with Linux or Windows operating systems can be assigned to runner groups.

Runner groups enable administrators to control access to runners at the organization and enterprise levels. With runner groups, you can collect sets of runners and create a security boundary around them. You can then decide which organizations or repositories are permitted to run jobs on those sets of machines. During the larger runner deployment process, the runner can be added to an existing group, otherwise it will join a default group. You can create a group by following the steps in Controlling access to larger runners.
Architectural overview of larger runners
Note

This architecture diagram only applies to larger runners with Linux or Windows operating systems.

Larger runners are managed at the organization level, where they are arranged into groups that can contain multiple instances of the runner. They can also be created at the enterprise level and shared with organizations in the hierarchy. Once you've created a group, you can then add a runner to the group and update your workflows to target either the group name or the label assigned to the larger runner. You can also control which repositories are permitted to send jobs to the group for processing. For more information about groups, see Controlling access to larger runners.
In the following diagram, a class of hosted runner named ubuntu-20.04-16core has been defined with customized hardware and operating system configuration.


Instances of this runner are automatically created and added to a group called grp-ubuntu-20.04-16core.
The runners have been assigned the label ubuntu-20.04-16core.
Workflow jobs use the ubuntu-20.04-16core label in their runs-on key to indicate the type of runner they need to execute the job.
GitHub Actions checks the runner group to see if your repository is authorized to send jobs to the runner.
The job runs on the next available instance of the ubuntu-20.04-16core runner.

Autoscaling larger runners
Note

Autoscaling is only available for larger runners with Linux or Windows operating systems.

Larger runners can automatically scale to suit your needs. You can provision machines to run a specified maximum number of jobs when jobs are submitted for processing. Each machine only handles one job at a time, so these settings effectively determine the number of jobs that can be run concurrently.
You can configure the maximum job concurrency, which allows you to control your costs by setting the maximum parallel number of jobs that can be run using this set. A higher value here can help avoid workflows being blocked due to parallelism. For more information on how to set limits, see Managing larger runners. For more information on the maximum auto-scaling limits for GitHub-hosted runners, see Usage limits, billing, and administration.
Assigning static IP addresses to larger runners
You can assign static IP addresses only to larger runners that use Linux or Windows operating systems.
Static IP addresses assigned are all usable and are not in CIDR notation.
Private networking for GitHub-hosted runners does not support static IP addresses for larger runners. For more information about private networking for GitHub-hosted runners, see About Azure private networking for GitHub-hosted runners in your enterprise.
Networking for larger runners
By default, larger runners receive a dynamic IP address that changes for each job run. Optionally, GitHub Enterprise Cloud customers can configure their larger runners to receive static IP addresses from GitHub's IP address pool. For more information, see About GitHub's IP addresses.
When enabled, instances of the larger runner will receive IP addresses from specific ranges that are unique to the runner, allowing you to use the ranges to configure a firewall allowlist. You can use up to 10 larger runners with static IP address ranges in total across all your larger runners. For more information, see Managing larger runners.
If you would like to use more than 10 larger runners with static IP address ranges, please contact us through the GitHub Support portal.
Note

If runners are unused for more than 30 days, their IP address ranges are automatically removed and cannot be recovered.\n\n\n\nGitHub Actions/GitHub-hosted runners/Using larger runners/Manage larger runnersManaging larger runnersYou can configure larger runners for your organization or enterprise.Who can use this feature?Larger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans. Enterprise or organization owners can manage larger runners.In this articleAdding a larger runner to an organizationAllowing repositories to access larger runnersChanging the name of a larger runnerChanging the size of a larger runnerChanging the image of a larger runnerConfiguring autoscaling for larger runnersCreating static IP addresses for larger runnersNote


The information and instructions in this article only apply to larger runners with Linux and Windows operating systems.


Adding a larger runner to an organization
Organization owners can add a larger runner to an organization control which repositories can use it. When you create a new runner for an organization, by default, all repositories in the organization have access to the runner. To limit which repositories can use the runner, assign it to a runner group with access to specific repositories. For more information, see Allowing repositories to access larger runners.
You can choose an operating system and a hardware configuration from the list of available options. When new instances of this runner are deployed through autoscaling, they'll use the same operating system and hardware configuration you've defined here.
New runners are automatically assigned to the default group, or you can choose which group the runners must join during the runner creation process. In addition, you can modify the runner's group membership after you've registered the runner. For more information, see Controlling access to larger runners.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


Click New runner, then click  New GitHub-hosted runner.


Complete the required details to configure your new runner:


Name: Enter a name for your new runner. For easier identification, this should indicate its hardware and operating configuration, such as ubuntu-20.04-16core.


Platform: Choose a platform from the available options. Once you've selected a platform, you will be able to choose a specific image.


Image: Choose an image from the available options. Once you've selected an image, you will be able to choose a specific size.

GitHub-owned: For images managed by GitHub, select an image under this tab.
Partner: For images managed by a partner, select an image under this tab. ex: Base Windows 11 desktop, GPU-optimized, and arm64 images are located under this tab.



Size: Choose a hardware configuration from the list of available options. The available sizes depend on the image that you selected in a previous step. For GPU runners, select a size under the GPU-powered tab.


Maximum concurrency: Choose the maximum number of jobs that can be active at any time.


Runner group: Choose the group that your runner will be a member of. This group will host multiple instances of your runner, as they scale up and down to suit demand.


Note

The names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named code-scanning. For more information on code scanning with larger runners, see Configuring larger runners for default setup.



Click Create runner.


To allow repositories to access your larger runners, add them to the list of repositories that can use it. For more information, see Allowing repositories to access larger runners.


Allowing repositories to access larger runners
Repositories are granted access to larger runners through runner groups. Enterprise administrators can choose which organizations are granted access to enterprise-level runner groups, and organization owners control repository-level access to all larger runners.
Organization owners can use and configure enterprise-level runner groups for the repositories in their organization, or they can create organization-level runner groups to control access.

For enterprise-level runner groups: By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.
For organization-level runner groups: By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access.

Once a repository has access to larger runners, the larger runners can be added to workflow files. For more information, see Running jobs on larger runners.

Navigate to the main page of the organization where your runner groups are located.
Click  Settings.
In the left sidebar, click  Actions, then click Runner groups.
Select a runner group from either list on the page. Organization-level runner groups are listed at the top of the page, and enterprise-level runner groups are listed under "Shared by the Enterprise."
On the runner group page, under "Repository access," select All repositories or Selected repositories. If you choose to grant access to specific repositories, click , then select the repositories you would like to grant access to from the list.

Warning

If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.
For more information, see Controlling access to larger runners.

Changing the name of a larger runner
Note

The names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named code-scanning. For more information on code scanning with larger runners, see Configuring larger runners for default setup.



On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, select the runner you would like to edit.


Enter a new name for the runner in the text field under "Name."


Click Save.


Changing the size of a larger runner


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, select the runner you would like to edit.


Select a new size for the runner from the list of available options under "Size." The available sizes depend on the image that is installed on the runner.


Click Save.


Changing the image of a larger runner


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, select the runner you would like to edit.


Select a new image for the runner from the list of available options under "Image." The available images are limited to GitHub-owned images.


Click Save.


Configuring autoscaling for larger runners
You can control the maximum number of jobs allowed to run concurrently for specific runner sets. Setting this field to a higher value can help prevent workflows being blocked due to parallelism.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, select the runner you would like to edit.


In the "Auto-scaling" section, under "Maximum Job Concurrency," enter the maximum number of jobs you would like to allow to run at the same time.


Click Save.


Creating static IP addresses for larger runners
Note

To use static IP addresses, your organization must use GitHub Enterprise Cloud. For more information about how you can try GitHub Enterprise Cloud for free, see Setting up a trial of GitHub Enterprise Cloud.

You can enable static IP addresses for larger runners. When you do this, the larger runners are assigned static IP address ranges. All IP addresses in the range assigned are usable and not in CIDR notation. By default, you can configure up to 10 different larger runners with IP ranges for your account. If you would like to use more than 10 larger runners with static IP address ranges, please contact us through the GitHub Support portal.
The number of available IP addresses in the assigned ranges does not restrict number of concurrent jobs specified for autoscaling. Within a runner pool, there is a load balancer which allows for high reuse of the IP addresses in the assigned ranges. This ensures your workflows can run concurrently at scale while each machine is assigned a static IP address.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, select the runner you would like to edit.


To assign static IP addresses to the runner, under "Networking," check Assign unique & static public IP address ranges for this runner.


Click Save.\n\n\n\nGitHub Actions/GitHub-hosted runners/Using larger runners/Control access to larger runnersControlling access to larger runnersYou can use policies to limit access to larger runners that have been added to an organization or enterprise.Who can use this feature?Larger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.In this articleAbout runner groupsCreating a runner group for an organizationChanging which repositories can access a runner groupConfiguring private network access for larger runnersChanging the name of a runner groupMoving a runner to a groupRemoving a runner groupNote

The information and instructions in this article only apply to larger runners with Linux and Windows operating systems.

About runner groups
To control access to runners at the organization level, organizations using the GitHub Team plan can use runner groups. Runner groups are used to collect sets of runners and create a security boundary around them.
When you grant access to a runner group, you can see the runner group listed in the organization's runner settings. Optionally, you can assign additional granular repository access policies to the runner group.
When new runners are created, they are automatically assigned to the default group unless otherwise specified. Runners can only be in one group at a time. You can move runners from one runner group to another. For more information, see Moving a runner to a group.
For information on how to route jobs to runners in a specific group, see Choosing the runner for a job.
Managing access to your runners
Note

Before your workflows can send jobs to larger runners, you must first configure permissions for the runner group. See the following sections for more information.

Runner groups are used to control which repositories can run jobs on your larger runners. You must manage access to the group from each level of the management hierarchy, depending on where you've defined the larger runner:

Runners at the enterprise level: By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.
Runners at the organization level: By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access.

For example, the following diagram has a runner group named grp-ubuntu-20.04-16core at the enterprise level. Before the repository named octo-repo can use the runners in the group, you must first configure the group at the enterprise level to allow access to the octo-org organization. You must then configure the group at the organization level to allow access to octo-repo.

Creating a runner group for an organization
Warning

If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.

Note

When creating a runner group, you must choose a policy that defines which repositories have access to the runner group. To change which repositories and workflows can access the runner group, organization owners can set a policy for the organization. For more information, see Enforcing policies for GitHub Actions in your enterprise.

All organizations have a single default runner group. Organization owners using the GitHub Team plan can create additional organization-level runner groups.
If no group is specified during the registration process, runners are automatically added to the default group. You can later move the runner from the default group to a custom group. For more information, see Moving a runner to a group.
For information about how to create a runner group with the REST API, see REST API endpoints for GitHub Actions.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runner groups.


In the "Runner groups" section, click New runner group.


Enter a name for your runner group.


Assign a policy for repository access.
You can configure a runner group to be accessible to a specific list of repositories, or to all repositories in the organization. By default, only private repositories can access runners in a runner group, but you can override this. This setting can't be overridden if configuring an organization's runner group that was shared by an enterprise.


Click Create group to create the group and apply the policy.


Changing which repositories can access a runner group
Warning

If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.

For runner groups in an organization, you can change what repositories in the organization can access a runner group.


Navigate to the main page of the organization where your runner groups are located.


Click  Settings.


In the left sidebar, click  Actions, then click Runner groups.


In the list of groups, click the runner group you'd like to configure.


Under "Repository access," use the dropdown menu to click Selected repositories.

To the right of the dropdown menu, click .
In the popup, use the checkboxes to select repositories that can access this runner group.



Click Save group.


Configuring private network access for larger runners
You can use GitHub-hosted runners in an Azure VNET. This enables you to use GitHub-managed infrastructure for CI/CD while providing you with full control over the networking policies of your runners. For more information about Azure VNET, see What is Azure Virtual Network? in the Azure documentation.
If you have configured your organization to connect to an Azure VNET, you can give runner groups access to the virtual network. For more information, see About private networking with GitHub-hosted runners.
Changing the name of a runner group

Navigate to the main page of the organization where your runner groups are located.
Click  Settings.
In the left sidebar, click  Actions, then click Runner groups.
In the list of groups, click the runner group you'd like to configure.
Enter the new runner group name in the text field under "Group name."
Click Save.

Moving a runner to a group
If you don't specify a runner group during the registration process, your new runners are automatically assigned to the default group, and can then be moved to another group.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the "Runners" list, click the runner that you want to configure.


Select the Runner group drop-down.


In "Move runner to group", choose a destination group for the runner.


Removing a runner group
In order to remove a runner group, you must first move or remove all of the runners from the group.

Navigate to the main page of the organization where your runner groups are located.
Click  Settings.
In the left sidebar, click  Actions, then click Runner groups.
In the list of groups, to the right of the group you want to delete, click .
To remove the group, click Remove group.
Review the confirmation prompts, and click Remove this runner group.\n\n\n\nGitHub Actions/GitHub-hosted runners/Using larger runners/Run jobs on larger runnersRunning jobs on larger runnersYou can speed up your workflows by configuring them to run on larger runners.Who can use this feature?Larger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.Platform navigationMacWindowsLinuxIn this articleRunning jobs on your runnerAvailable macOS larger runnersViewing available runners for a repositoryUsing groups to control where jobs are runUsing groups to control where jobs are runUsing labels to control where jobs are runUsing labels to control where jobs are runTargeting macOS larger runners in a workflowUsing labels and groups to control where jobs are runUsing labels and groups to control where jobs are runTroubleshooting larger runnersRunning jobs on your runner

Once your runner type has been defined, you can update your workflow YAML files to send jobs to your newly created runner instances for processing. You can use runner groups or labels to define where your jobs run.
Note

Larger runners are automatically assigned a default label that corresponds to the runner name. You cannot add custom labels to larger runners, but you can use the default labels or the runner's group to send jobs to specific types of runners.

Only owner or administrator accounts can see the runner settings. Non-administrative users can contact the organization owner to find out which runners are enabled. Your organization owner can create new runners and runner groups, as well as configure permissions to specify which repositories can access a runner group. For more information, see Managing larger runners.


Once your runner type has been defined, you can update your workflow YAML files to send jobs to your newly created runner instances for processing. You can use runner groups or labels to define where your jobs run.
Note

Larger runners are automatically assigned a default label that corresponds to the runner name. You cannot add custom labels to larger runners, but you can use the default labels or the runner's group to send jobs to specific types of runners.

Only owner or administrator accounts can see the runner settings. Non-administrative users can contact the organization owner to find out which runners are enabled. Your organization owner can create new runners and runner groups, as well as configure permissions to specify which repositories can access a runner group. For more information, see Managing larger runners.


Once your runner type has been defined, you can update your workflow YAML files to send jobs to runner instances for processing. To run jobs on macOS larger runners, update the runs-on key in your workflow YAML files to use one of the GitHub-defined labels for macOS runners. For more information, see Available macOS larger runners.


Available macOS larger runners
Use the labels in the table below to run your workflows on the corresponding macOS larger runner.





























Runner SizeArchitectureProcessor (CPU)Memory (RAM)Storage (SSD)Workflow labelLargeIntel1230 GB14 GBmacos-latest-large, macos-13-large, macos-14-large [latest], macos-15-large [Public preview]XLargearm64 (M1)6 (+ 8 GPU hardware acceleration)14 GB14 GBmacos-latest-xlarge, macos-13-xlarge , macos-14-xlarge [latest], macos-15-xlarge [Public preview]
Note

For macOS larger runners, the -latest runner label uses the macOS 12 runner image. For macOS Xlarge, the -latest runner label uses the macOS 13 runner image


Viewing available runners for a repository
If you have repo: write access to a repository, you can view a list of the runners available to the repository.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, under the "Management" section, click  Runners.


Review the list of available runners for the repository.


Optionally, to copy a runner's label to use it in a workflow, click  to the right of the runner, then click Copy label.


Note

Enterprise and organization owners can create runners from this page. To create a new runner, click New runner at the top right of the list of runners to add runners to the repository.
For more information, see Managing larger runners and Adding self-hosted runners.


Using groups to control where jobs are run
In this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v



Using groups to control where jobs are run
In this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v



Using labels to control where jobs are run
You can implicitly pass a label to the runs-on key by using the syntax runs-on: LABEL. Alternatively, you can use the labels key, as shown in the example below.
In this example, the runs-on key sends the job to any available runner that has been assigned the ubuntu-20.04-16core label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

Anyone with write access to an Actions-enabled repository can find out the labels for the runners that are available in that repository. See Running jobs on larger runners.


Using labels to control where jobs are run
You can implicitly pass a label to the runs-on key by using the syntax runs-on: LABEL. Alternatively, you can use the labels key, as shown in the example below.
In this example, the runs-on key sends the job to any available runner that has been assigned the windows-2022-16core label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      labels: windows-2022-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

Anyone with write access to an Actions-enabled repository can find out the labels for the runners that are available in that repository. See Running jobs on larger runners.


Targeting macOS larger runners in a workflow
To run your workflows on macOS larger runners, set the value of the runs-on key to a label associated with a macOS larger runner. For a list of macOS larger runner labels, see Available macOS larger runners.
In this example, the workflow uses a label that is associated with macOS XL runners. The runs-on key sends the job to any available runner with a matching label:
name: learn-github-actions-testing
on: [push]
jobs:
  build:
    runs-on: macos-13-xlarge
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: swift build
      - name: Run tests
        run: swift test



Using labels and groups to control where jobs are run
When you combine groups and labels, the runner must meet both requirements to be eligible to run the job.
In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v



Using labels and groups to control where jobs are run
When you combine groups and labels, the runner must meet both requirements to be eligible to run the job.
In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v


Troubleshooting larger runners

If you notice the jobs that target your larger runners are delayed or not running, there are several factors that may be causing this.

Concurrency settings: You may have reached your maximum concurrency limit. If you would like to enable more jobs to run in parallel, you can update your autoscaling settings to a larger number. For more information, see Managing larger runners.
Repository permissions: Ensure you have the appropriate repository permissions enabled for your larger runners. By default, enterprise runners are not available at the repository level and must be manually enabled by an organization administrator. For more information, see Managing larger runners.
Billing information: You must have a valid credit card on file in order to use larger runners. After adding a credit card to your account, it can take up to 10 minutes to enable the use of your larger runners. For more information, see Adding or editing a payment method.
Spending limit: Your GitHub Actions spending limit must be set to a value greater than zero. For more information, see Managing your spending limit for GitHub Actions.
Fair use policy: GitHub has a fair use policy that begins to throttle jobs based on several factors, such as how many jobs you are running or how many jobs are running across the entirety of GitHub Actions.
Job queue to assign time: Job queue to assign time refers to the time between a job request and GitHub assigning a VM to execute the job. Standard GitHub-hosted runners utilizing prescribed YAML workflow labels (such as ubuntu-latest) are always in a "warm" state. With larger runners, a warm machine may not be ready to pick up a job on first request as the pools for these machines are smaller. As a result, GitHub may need to create a new VM, which increases the queue to assign time. Once a runner is in use, VMs are readily for subsequent workflow runs, reducing the queue to assign time for future workflow runs over the next 24 hours.



If you notice the jobs that target your larger runners are delayed or not running, there are several factors that may be causing this.

Concurrency settings: You may have reached your maximum concurrency limit. If you would like to enable more jobs to run in parallel, you can update your autoscaling settings to a larger number. For more information, see Managing larger runners.
Repository permissions: Ensure you have the appropriate repository permissions enabled for your larger runners. By default, enterprise runners are not available at the repository level and must be manually enabled by an organization administrator. For more information, see Managing larger runners.
Billing information: You must have a valid credit card on file in order to use larger runners. After adding a credit card to your account, it can take up to 10 minutes to enable the use of your larger runners. For more information, see Adding or editing a payment method.
Spending limit: Your GitHub Actions spending limit must be set to a value greater than zero. For more information, see Managing your spending limit for GitHub Actions.
Fair use policy: GitHub has a fair use policy that begins to throttle jobs based on several factors, such as how many jobs you are running or how many jobs are running across the entirety of GitHub Actions.
Job queue to assign time: Job queue to assign time refers to the time between a job request and GitHub assigning a VM to execute the job. Standard GitHub-hosted runners utilizing prescribed YAML workflow labels (such as ubuntu-latest) are always in a "warm" state. With larger runners, a warm machine may not be ready to pick up a job on first request as the pools for these machines are smaller. As a result, GitHub may need to create a new VM, which increases the queue to assign time. Once a runner is in use, VMs are readily for subsequent workflow runs, reducing the queue to assign time for future workflow runs over the next 24 hours.



Because macOS arm64 does not support Node 12, macOS larger runners automatically use Node 16 to execute any JavaScript action written for Node 12. Some community actions may not be compatible with Node 16. If you use an action that requires a different Node version, you may need to manually install a specific version at runtime.
Note

ARM-powered runners are currently in public preview and are subject to change.\n\n\n\nGitHub Actions/GitHub-hosted runners/Private networking/About private networkingAbout private networking with GitHub-hosted runnersYou can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.In this articleAbout GitHub-hosted runners networkingUsing an API Gateway with OIDCUsing WireGuard to create a network overlayUsing an Azure Virtual Network (VNET)About GitHub-hosted runners networking
By default, GitHub-hosted runners have access to the public internet. However, you may also want these runners to access resources on your private network, such as a package registry, a secret manager, or other on-premise services.
GitHub-hosted runners are shared across all GitHub customers. However with private networking, you can configure hosted runners to be exclusively used to connect to your private network and resources while they are running your workflows.
There are a few different approaches you could take to configure this access, each with different advantages and disadvantages.
Using an API Gateway with OIDC
With GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For more information, see Using an API gateway with OIDC.
Using WireGuard to create a network overlay
If you don't want to maintain separate infrastructure for an API Gateway, you can create an overlay network between your runner and a service in your private network, by running WireGuard in both places. For more information, see Using WireGuard to create a network overlay.
Using an Azure Virtual Network (VNET)
You can use GitHub-hosted runners in an Azure VNET. This enables you to use GitHub-managed infrastructure for CI/CD while providing you with full control over the networking policies of your runners. For more information about Azure VNET, see What is Azure Virtual Network? in the Azure documentation.
Organization owners using the GitHub Team plan can configure Azure private networking for GitHub-hosted runners at the organization level. For more information, see About Azure private networking for GitHub-hosted runners in your organization.\n\n\n\nGitHub Actions/GitHub-hosted runners/Private networking/Using OIDCUsing an API gateway with OIDCYou can use OpenID Connect (OIDC) tokens to authenticate your workflow.Using an API gateway with OIDC
With GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For example, you could run an API gateway on the edge of your private network that authenticates incoming requests with the OIDC token and then makes API requests on behalf of your workflow in your private network.
The following diagram gives an overview of this solution's architecture:

It's important that you verify not just that the OIDC token came from GitHub Actions, but that it came specifically from your expected workflows, so that other GitHub Actions users aren't able to access services in your private network. You can use OIDC claims to create these conditions. For more information, see About security hardening with OpenID Connect.
The main disadvantages of this approach are that you must implement the API gateway to make requests on your behalf, and you must run the gateway on the edge of your network.
The following advantages apply.

You don't need to configure any firewalls, or modify the routing of your private network.
The API gateway is stateless and scales horizontally to handle high availability and high throughput.

For more information, see a reference implementation of an API Gateway in the github/actions-oidc-gateway repository. This implementation requires customization for your use case and is not ready-to-run as-is). For more information, see About security hardening with OpenID Connect.\n\n\n\nGitHub Actions/GitHub-hosted runners/Private networking/Using WireGuardUsing WireGuard to create a network overlayYou can create an overlay network between your runner and a service in your private network.In this articleUsing WireGuard to create a network overlayExample: Configuring WireGuardUsing WireGuard to create a network overlay
If you don't want to maintain separate infrastructure for an API Gateway, you can create an overlay network between your runner and a service in your private network, by running WireGuard in both places.
There are various disadvantages to this approach:

To reach WireGuard running on your private service, you will need a well-known IP address and port that your workflow can reference: this can either be a public IP address and port, a port mapping on a network gateway, or a service that dynamically updates DNS.
WireGuard doesn't handle NAT traversal out of the box, so you'll need to identify a way to provide this service.
This connection is one-to-one, so if you need high availability or high throughput you'll need to build that on top of WireGuard.
You'll need to generate and securely store keys for both the runner and your private service. WireGuard uses UDP, so your network must support UDP traffic.

There are some advantages too, as you can run WireGuard on an existing server so you don't have to maintain separate infrastructure, and it's well supported on GitHub-hosted runners.
Example: Configuring WireGuard
This example workflow configures WireGuard to connect to a private service.
For this example, the WireGuard instance running in the private network has this configuration:

Overlay network IP address of 192.168.1.1
Public IP address and port of 1.2.3.4:56789
Public key examplepubkey1234...

The WireGuard instance in the GitHub Actions runner has this configuration:

Overlay network IP address of 192.168.1.2
Private key stores as an GitHub Actions secret under WIREGUARD_PRIVATE_KEY

name: WireGuard example

on:
  workflow_dispatch:

jobs:
  wireguard_example:
    runs-on: ubuntu-latest
    steps:
      - run: sudo apt install wireguard

      - run: echo "${{ secrets.WIREGUARD_PRIVATE_KEY }}" > privatekey

      - run: sudo ip link add dev wg0 type wireguard

      - run: sudo ip address add dev wg0 192.168.1.2 peer 192.168.1.1

      - run: sudo wg set wg0 listen-port 48123 private-key privatekey peer examplepubkey1234... allowed-ips 0.0.0.0/0 endpoint 1.2.3.4:56789

      - run: sudo ip link set up dev wg0

      - run: curl -vvv http://192.168.1.1

For more information, see WireGuard's Quick Start, as well as Using secrets in GitHub Actions for how to securely store keys.
Using Tailscale to create a network overlay
Tailscale is a commercial product built on top of WireGuard. This option is very similar to WireGuard, except Tailscale is more of a complete product experience instead of an open source component.
Its disadvantages are similar to WireGuard: The connection is one-to-one, so you might need to do additional work for high availability or high throughput. You still need to generate and securely store keys. The protocol is still UDP, so your network must support UDP traffic.
However, there are some advantages over WireGuard: NAT traversal is built-in, so you don't need to expose a port to the public internet. It is by far the quickest of these options to get up and running, since Tailscale provides an GitHub Actions workflow with a single step to connect to the overlay network.
For more information, see the Tailscale GitHub Action, as well as Using secrets in GitHub Actions for how to securely store keys.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/About self-hosted runnersAbout self-hosted runnersYou can host your own runners and customize the environment used to run jobs in your GitHub Actions workflows.In this articleAbout self-hosted runnersFurther readingAbout self-hosted runners
A self-hosted runner is a system that you deploy and manage to execute jobs from GitHub Actions on GitHub.
Self-hosted runners:

Give you more control of hardware, operating system, and software tools than GitHub-hosted runners provide.
Are free to use with GitHub Actions, but you are responsible for the cost of maintaining your runner machines.
Let you create custom hardware configurations that meet your needs with processing power or memory to run larger jobs, install software available on your local network.
Receive automatic updates for the self-hosted runner application only, though you may disable automatic updates of the runner.
Can use cloud services or local machines that you already pay for.
Don't need to have a clean instance for every job execution.
Can be physical, virtual, in a container, on-premises, or in a cloud.

You can use self-hosted runners anywhere in the management hierarchy. Repository-level runners are dedicated to a single repository, while organization-level runners can process jobs for multiple repositories in an organization. Organization owners can choose which repositories are allowed to create repository-level self-hosted runners. See Disabling or limiting GitHub Actions for your organization. Finally, enterprise-level runners can be assigned to multiple organizations in an enterprise account.
Requirements for self-hosted runner machines
You can use any machine as a self-hosted runner as long at it meets these requirements:

You can install and run the self-hosted runner application on the machine.
The machine can communicate with GitHub Actions.
The machine has enough hardware resources for the type of workflows you plan to run. The self-hosted runner application itself only requires minimal resources.
If you want to run workflows that use Docker container actions or service containers, you must use a Linux machine and Docker must be installed.

Further reading

Security hardening for GitHub Actions
Adding self-hosted runners
Using self-hosted runners in a workflow
Autoscaling with self-hosted runners
Supported architectures and operating systems for self-hosted runners
Communicating with self-hosted runners\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Self-hosted runner communicationCommunicating with self-hosted runnersYour self-hosted runners can communicate with GitHubA self-hosted runner connects to GitHub to receive job assignments and to download new versions of the runner application. The self-hosted runner uses an HTTPS long poll that opens a connection to GitHub for 50 seconds, and if no response is received, it then times out and creates a new long poll. The application must be running on the machine to accept and run GitHub Actions jobs.
The GitHub Actions runner application is open source. You can contribute and file issues in the runner repository.  When a new version is released, the runner application automatically updates itself when a job is assigned to the runner, or within a week of release if the runner hasn't been assigned any jobs.
A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.
The connection between self-hosted runners and GitHub is over HTTPS (port 443).
Since the self-hosted runner opens a connection to GitHub, you do not need to allow GitHub to make inbound connections to your self-hosted runner.
You must ensure that the machine has the appropriate network access with at least 70 kilobits per second upload and download speed to communicate with the GitHub hosts listed below. Some hosts are required for essential runner operations, while other hosts are only required for certain functionality.
You can use the REST API to get meta information about GitHub, including the IP addresses of GitHub services. See REST API endpoints for meta data.
Note

Some of the domains listed are configured using CNAME records. Some firewalls might require you to add rules recursively for all CNAME records. Note that the CNAME records might change in the future, and that only the domains listed will remain constant.

Needed for essential operations:
Shellgithub.com
api.github.com
*.actions.githubusercontent.com
github.com
api.github.com
*.actions.githubusercontent.com

Needed for downloading actions:
Shellcodeload.github.com
pkg.actions.githubusercontent.com
codeload.github.com
pkg.actions.githubusercontent.com

Needed for publishing immutable actions:
Shellghcr.io
ghcr.io

Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches:
Shellresults-receiver.actions.githubusercontent.com
*.blob.core.windows.net
results-receiver.actions.githubusercontent.com
*.blob.core.windows.net

Needed for runner version updates:
Shellobjects.githubusercontent.com
objects-origin.githubusercontent.com
github-releases.githubusercontent.com
github-registry-files.githubusercontent.com
objects.githubusercontent.com
objects-origin.githubusercontent.com
github-releases.githubusercontent.com
github-registry-files.githubusercontent.com

Needed for retrieving OIDC tokens:
Shell*.actions.githubusercontent.com
*.actions.githubusercontent.com

Needed for downloading or publishing packages or containers to GitHub Packages:
Shell*.pkg.github.com
pkg-containers.githubusercontent.com
ghcr.io
*.pkg.github.com
pkg-containers.githubusercontent.com
ghcr.io

Needed for Git Large File Storage
Shellgithub-cloud.githubusercontent.com
github-cloud.s3.amazonaws.com
github-cloud.githubusercontent.com
github-cloud.s3.amazonaws.com

Needed for jobs for Dependabot updates
Shelldependabot-actions.githubapp.com
dependabot-actions.githubapp.com

In addition, your workflow may require access to other network resources.
If you use an IP address allow list for your GitHub organization or enterprise account, you must add your self-hosted runner's IP address to the allow list. See Managing allowed IP addresses for your organization or Enforcing policies for security settings in your enterprise in the GitHub Enterprise Cloud documentation.
Further reading

Using a proxy server with self-hosted runners
Monitoring and troubleshooting self-hosted runners\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Supported platformsSupported architectures and operating systems for self-hosted runnersThe following processor architectures and operating systems are supported for the self-hosted runner application.In this articleLinuxWindowsmacOSSupported processor architecturesLinux

Red Hat Enterprise Linux 8 or later
CentOS 8 or later
Oracle Linux 8 or later
Fedora 29 or later
Debian 10 or later
Ubuntu 20.04 or later
Linux Mint 20 or later
openSUSE 15.2 or later
SUSE Enterprise Linux (SLES) 15 SP2 or later

Windows

Windows 10 64-bit
Windows 11 64-bit
Windows Server 2016 64-bit
Windows Server 2019 64-bit
Windows Server 2022 64-bit

macOS

macOS 11.0 (Big Sur) or later

Supported processor architectures

x64 - Linux, macOS, Windows.
ARM64 - Linux, macOS, Windows (currently in public preview).
ARM32 - Linux.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Usage limitsUsage limits for self-hosted runnersThere are some limits on GitHub Actions usage when using self-hosted runners. These limits are subject to change.
Job execution time - Each job in a workflow can run for up to 5 days of execution time. If a job reaches this limit, the job is terminated and fails to complete.


Workflow run time - Each workflow run is limited to 35 days. If a workflow run reaches this limit, the workflow run is cancelled. This period includes execution duration, and time spent on waiting and approval.
Job queue time - Each job for self-hosted runners that has been queued for at least 24 hours will be canceled. The actual time in queue can reach up to 48 hours before cancellation occurs. If a self-hosted runner does not start executing the job within this limit, the job is terminated and fails to complete.
API requests - You can execute up to 1,000 requests to the GitHub API in an hour across all actions within a repository. If requests are exceeded, additional API calls will fail which might cause jobs to fail.
Job matrix - A job matrix can generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.
Workflow run queue - No more than 500 workflow runs can be queued in a 10 second interval per repository. If a workflow run reaches this limit, the workflow run is terminated and fails to complete.
Registering self-hosted runners - You can have a maximum of 10,000 self-hosted runners in one runner group. If this limit is reached, adding a new runner will not be possible.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Add self-hosted runnersAdding self-hosted runnersYou can add a self-hosted runner to a repository, an organization, or an enterprise.In this articlePrerequisitesAdding a self-hosted runner to a repositoryAdding a self-hosted runner to an organizationAdding a self-hosted runner to an enterpriseYou can add a self-hosted runner to a repository, an organization, or an enterprise.
If you are an organization or enterprise administrator, you might want to add your self-hosted runners at the organization or enterprise level. This approach makes the runner available to multiple repositories in your organization or enterprise, and also lets you to manage your runners in one place.
Warning

We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.
For more information, see Security hardening for GitHub Actions.

You can set up automation to scale the number of self-hosted runners. For more information, see Autoscaling with self-hosted runners.
You can register ephemeral runners that perform a single job before the registration is cleaned up by using just-in-time runner registration. For more information, see Security hardening for GitHub Actions.
Prerequisites

You must have access to the machine you will use as a self-hosted runner in your environment.

Adding a self-hosted runner to a repository
You can add self-hosted runners to a single repository. To add a self-hosted runner to a user repository, you must be the repository owner. For an organization repository, you must be an organization owner or have admin access to the repository.
For information about how to add a self-hosted runner with the REST API, see REST API endpoints for self-hosted runners.
Note

Organization owners can choose which repositories are allowed to create repository-level self-hosted runners.
For more information, see Disabling or limiting GitHub Actions for your organization.



On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


Click New self-hosted runner.


Select the operating system image and architecture of your self-hosted runner machine.



You will see instructions showing you how to download the runner application and install it on your self-hosted runner machine.
Open a shell on your self-hosted runner machine and run each shell command in the order shown.
Note

On Windows, if you want to install the self-hosted runner application as a service, you must open a shell with administrator privileges. We also recommend that you use C:\actions-runner as the directory for the self-hosted runner application so that Windows system accounts can access the runner directory.

The instructions walk you through completing these tasks:

Downloading and extracting the self-hosted runner application.
Running the config script to configure the self-hosted runner application and register it with GitHub Actions. The config script requires the destination URL and an automatically-generated time-limited token to authenticate the request. The token expires after one hour.

On Windows, the config script also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, see Configuring the self-hosted runner application as a service.


Running the self-hosted runner application to connect the machine to GitHub Actions.



Checking that your self-hosted runner was successfully added
After completing the steps to add a self-hosted runner, the runner and its status are now listed under "Runners".
The self-hosted runner application must be active for the runner to accept jobs. When the runner application is connected to GitHub and ready to receive jobs, you will see the following message on the machine's terminal.
√ Connected to GitHub

2019-10-24 05:45:56Z: Listening for Jobs

For more information, see Monitoring and troubleshooting self-hosted runners.
Adding a self-hosted runner to an organization
You can add self-hosted runners at the organization level, where they can be used to process jobs for multiple repositories in an organization. To add a self-hosted runner to an organization, you must be an organization owner. For information about how to add a self-hosted runner with the REST API, see REST API endpoints for self-hosted runners.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


Click New runner, then click New self-hosted runner.


Select the operating system image and architecture of your self-hosted runner machine.



You will see instructions showing you how to download the runner application and install it on your self-hosted runner machine.
Open a shell on your self-hosted runner machine and run each shell command in the order shown.
Note

On Windows, if you want to install the self-hosted runner application as a service, you must open a shell with administrator privileges. We also recommend that you use C:\actions-runner as the directory for the self-hosted runner application so that Windows system accounts can access the runner directory.

The instructions walk you through completing these tasks:

Downloading and extracting the self-hosted runner application.
Running the config script to configure the self-hosted runner application and register it with GitHub Actions. The config script requires the destination URL and an automatically-generated time-limited token to authenticate the request. The token expires after one hour.

On Windows, the config script also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, see Configuring the self-hosted runner application as a service.


Running the self-hosted runner application to connect the machine to GitHub Actions.



Checking that your self-hosted runner was successfully added
After completing the steps to add a self-hosted runner, the runner and its status are now listed under "Runners".
The self-hosted runner application must be active for the runner to accept jobs. When the runner application is connected to GitHub and ready to receive jobs, you will see the following message on the machine's terminal.
√ Connected to GitHub

2019-10-24 05:45:56Z: Listening for Jobs

For more information, see Monitoring and troubleshooting self-hosted runners.
Note

For security reasons, public repositories can't use runners in a runner group by default, but you can override this in the runner group's settings. For more information, see Managing access to self-hosted runners using groups.

Adding a self-hosted runner to an enterprise
If you use GitHub Enterprise Cloud, you can add self-hosted runners to an enterprise, where they can be assigned to multiple organizations. The organization owner can control which repositories can use it. For more information, see the GitHub Enterprise Cloud documentation.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Autoscale self-hosted runnersAutoscaling with self-hosted runnersYou can automatically scale your self-hosted runners in response to webhook events.In this articleAbout autoscalingSupported autoscaling solutionsUsing ephemeral runners for autoscalingControlling runner software updates on self-hosted runnersUsing webhooks for autoscalingAuthentication requirementsAbout autoscaling
You can automatically increase or decrease the number of self-hosted runners in your environment in response to the webhook events you receive with a particular label. For example, you can create automation that adds a new self-hosted runner each time you receive a workflow_job webhook event with the queued activity, which notifies you that a new job is ready for processing. The webhook payload includes label data, so you can identify the type of runner the job is requesting. Once the job has finished, you can then create automation that removes the runner in response to the workflow_job completed activity.
Supported autoscaling solutions
GitHub-hosted runners inherently autoscale based on your needs. GitHub-hosted runners can be a low-maintenance and cost-effective alternative to developing or implementing autoscaling solutions. For more information, see About GitHub-hosted runners.
The actions/actions-runner-controller (ARC) project is a Kubernetes-based runner autoscaler. GitHub recommends ARC if the team deploying it has expert Kubernetes knowledge and experience.
For more information, see About Actions Runner Controller and About support for Actions Runner Controller.
Using ephemeral runners for autoscaling
GitHub recommends implementing autoscaling with ephemeral self-hosted runners; autoscaling with persistent self-hosted runners is not recommended. In certain cases, GitHub cannot guarantee that jobs are not assigned to persistent runners while they are shut down. With ephemeral runners, this can be guaranteed because GitHub only assigns one job to a runner.
This approach allows you to manage your runners as ephemeral systems, since you can use automation to provide a clean environment for each job. This helps limit the exposure of any sensitive resources from previous jobs, and also helps mitigate the risk of a compromised runner receiving new jobs.
Warning
The runner application log files for ephemeral runners must be forwarded to an external log storage solution for troubleshooting and diagnostic purposes. While it is not required for ephemeral runners to be deployed, GitHub recommends ensuring runner logs are forwarded and preserved externally before deploying an ephemeral runner autoscaling solution in a production environment. For more information, see Monitoring and troubleshooting self-hosted runners.

To add an ephemeral runner to your environment, include the --ephemeral parameter when registering your runner using config.sh. For example:
./config.sh --url https://github.com/octo-org --token example-token --ephemeral

The GitHub Actions service will then automatically de-register the runner after it has processed one job. You can then create your own automation that wipes the runner after it has been de-registered.
Note

If a job is labeled for a certain type of runner, but none matching that type are available, the job does not immediately fail at the time of queueing. Instead, the job will remain queued until the 24 hour timeout period expires.

Alternatively, you can create ephemeral, just-in-time runners using the REST API. For more information, see REST API endpoints for self-hosted runners.
Controlling runner software updates on self-hosted runners
By default, self-hosted runners will automatically perform a software update whenever a new version of the runner software is available. If you use ephemeral runners in containers then this can lead to repeated software updates when a new runner version is released. Turning off automatic updates allows you to update the runner version on the container image directly on your own schedule.
To turn off automatic software updates and install software updates yourself, specify the --disableupdate flag when registering your runner using config.sh. For example:
./config.sh --url https://github.com/YOUR-ORGANIZATION --token EXAMPLE-TOKEN --disableupdate

If you disable automatic updates, you must still update your runner version regularly. New functionality in GitHub Actions requires changes in both the GitHub Actions service and the runner software. The runner may not be able to correctly process jobs that take advantage of new features in GitHub Actions without a software update.
If you disable automatic updates, you will be required to update your runner version within 30 days of a new version being made available. You may want to subscribe to notifications for releases in the actions/runner repository. For more information, see Configuring notifications.
For instructions on how to install the latest runner version, see the installation instructions for the latest release.
Warning
 Any updates released for the software, including major, minor or patch releases, are considered as an available update. If you do not perform a software update within 30 days, the GitHub Actions service will not queue jobs to your runner. In addition, if a critical security update is required, the GitHub Actions service will not queue jobs to your runner until it has been updated.

Using webhooks for autoscaling
You can create your own autoscaling environment by using payloads received from the workflow_job webhook. This webhook is available at the repository, organization, and enterprise levels, and the payload for this event contains an action key that corresponds to the stages of a workflow job's life-cycle; for example when jobs are queued, in_progress, and completed. You must then create your own scaling automation in response to these webhook payloads.

For more information about the workflow_job webhook, see Webhook events and payloads.
To learn how to work with webhooks, see Webhooks documentation.

Authentication requirements
You can register and delete repository and organization self-hosted runners using the API. To authenticate to the API, your autoscaling implementation can use an access token or a GitHub app.
Your access token will require the following scope:

For private repositories, use an access token with the repo scope.
For public repositories, use an access token with the public_repo scope.
For organizations, use an access token with the admin:org scope.

To authenticate using a GitHub App, it must be assigned the following permissions:

For repositories, assign the administration permission.
For organizations, assign the organization_self_hosted_runners permission.

You can register and delete enterprise self-hosted runners using the API. To authenticate to the API, your autoscaling implementation can use an access token.
Your access token will require the manage_runners:enterprise scope.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Run a script before or after a jobRunning scripts before or after a jobScripts can automatically execute on a self-hosted runner, directly before or after a job.In this articleAbout pre- and post-job scriptsWriting the scriptsTriggering the scriptsTroubleshootingAbout pre- and post-job scripts
You can automatically execute scripts on a self-hosted runner, either before a job runs, or after a job finishes running. You could use these scripts to support the job's requirements, such as building or tearing down a runner environment, or cleaning out directories. You could also use these scripts to track telemetry of how your runners are used.
The custom scripts are automatically triggered when a specific environment variable is set on the runner; the environment variable must contain the absolute path to the script. For more information, see Triggering the scripts below.
The following scripting languages are supported:

Bash: Uses bash and can fallback to sh. Executes by running -e {pathtofile}.
PowerShell: Uses pwsh and can fallback to powershell. Executes by running -command \". '{pathtofile}'\".

Writing the scripts
Your custom scripts can use the following features:

Variables: Scripts have access to the default variables. The full webhook event payload can be found in GITHUB_EVENT_PATH. For more information, see Store information in variables.
Workflow commands: Scripts can use workflow commands. For more information, see Workflow commands for GitHub Actions. Scripts can also use environment files. For more information, see Environment files.

Your script files must use a file extension for the relevant language, such as .sh or .ps1, in order to run successfully.
Note

Avoid using your scripts to output sensitive information to the console, as anyone with read access to the repository might be able to see the output in the UI logs.

Handling exit codes
For pre-job scripts, exit code 0 indicates that the script completed successfully, and the job will then proceed to run. If there is any other exit code, the job will not run and will be marked as failed. To see the results of your pre-job scripts, check the logs for Set up runner entries. For more information on checking the logs, see Using workflow run logs.
The continue-on-error setting is not supported for use by these scripts.
Triggering the scripts
The custom scripts must be located on the runner, but should not be stored in the actions-runner application directory. The scripts are executed in the security context of the service account that's running the runner service.
Note

The triggered scripts are processed synchronously, so they will block job execution while they are running.

The scripts are automatically executed when the runner has the following environment variables containing an absolute path to the script:

ACTIONS_RUNNER_HOOK_JOB_STARTED: The script defined in this environment variable is triggered when a job has been assigned to a runner, but before the job starts running.
ACTIONS_RUNNER_HOOK_JOB_COMPLETED: The script defined in this environment variable is triggered at the end of the job, after all the steps defined in the workflow have run.

To set these environment variables, you can either add them to the operating system, or add them to a file named .env within the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). Note that any change to the .env file will require restarting the runner.
For example, the following .env entry will have the runner automatically run a script, saved as /opt/runner/cleanup_script.sh on the runner machine, before each job runs:
ACTIONS_RUNNER_HOOK_JOB_STARTED=/opt/runner/cleanup_script.sh

Note

The script defined in ACTIONS_RUNNER_HOOK_JOB_COMPLETED is executed at the end of the job, before the job completes. This makes it unsuitable for use cases that may interrupt a runner, such as deleting the runner machine as part of an autoscaling implementation.

Troubleshooting
Permission denied
If you get a "permission denied" error when you attempt to run a script, make sure that the script is executable. For example, in a terminal on Linux or macOS you can use the following command to make a file executable.
chmod +x PATH/TO/FILE

For information about using workflows to run scripts, see Adding scripts to your workflow.
No timeout setting
There is currently no timeout setting available for scripts executed by ACTIONS_RUNNER_HOOK_JOB_STARTED or ACTIONS_RUNNER_HOOK_JOB_COMPLETED. As a result, you could consider adding timeout handling to your script.
Reviewing the workflow run log
To confirm whether your scripts are executing, you can review the logs for that job. The scripts will be listed within separate steps for either Set up runner or Complete runner, depending on which environment variable is triggering the script. For more information on checking the logs, see Using workflow run logs.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Customize containers used by jobsCustomizing the containers used by jobsYou can customize how your self-hosted runner invokes a container for a job.In this articleAbout container customizationContainer customization commandsGenerating the customization scriptTriggering the customization scriptTroubleshootingNote

This feature is currently in public preview and is subject to change.

About container customization
GitHub Actions allows you to run a job within a container, using the container: statement in your workflow file. For more information, see Running jobs in a container. To process container-based jobs, the self-hosted runner creates a container for each job.
GitHub Actions supports commands that let you customize the way your containers are created by the self-hosted runner. For example, you can use these commands to manage the containers through Kubernetes or Podman, and you can also customize the docker run or docker create commands used to invoke the container. The customization commands are run by a script, which is automatically triggered when a specific environment variable is set on the runner. For more information, see Triggering the customization script below.
This customization is only available for Linux-based self-hosted runners, and root user access is not required.
Container customization commands
GitHub Actions includes the following commands for container customization:

prepare_job: Called when a job is started.
cleanup_job: Called at the end of a job.
run_container_step: Called once for each container action in the job.
run_script_step: Runs any step that is not a container action.

Each of these customization commands must be defined in its own JSON file. The file name must match the command name, with the extension .json. For example, the prepare_job command is defined in prepare_job.json. These JSON files will then be run together on the self-hosted runner, as part of the main index.js script. This process is described in more detail in Generating the customization script.
These commands also include configuration arguments, explained below in more detail.
prepare_job
The prepare_job command is called when a job is started. GitHub Actions passes in any job or service containers the job has. This command will be called if you have any service or job containers in the job.
GitHub Actions assumes that you will do the following tasks in the prepare_job command:

Prune anything from previous jobs, if needed.
Create a network, if needed.
Pull the job and service containers.
Start the job container.
Start the service containers.
Write to the response file any information that GitHub Actions will need:

Required: State whether the container is an alpine linux container (using the isAlpine boolean).
Optional: Any context fields you want to set on the job context, otherwise they will be unavailable for users to use. For more information, see Accessing contextual information about workflow runs.


Return 0 when the health checks have succeeded and the job/service containers are started.

Arguments for prepare_job

jobContainer: Optional. An object containing information about the specified job container.

image: Required. A string containing the Docker image.
workingDirectory: Required. A string containing the absolute path of the working directory.
createOptions: Optional. The optional create options specified in the YAML. For more information, see Running jobs in a container.
environmentVariables: Optional. Sets a map of key environment variables.
userMountVolumes: Optional. An array of user mount volumes set in the YAML. For more information, see Running jobs in a container.

sourceVolumePath: Required. The source path to the volume that will be mounted into the Docker container.
targetVolumePath: Required. The target path to the volume that will be mounted into the Docker container.
readOnly: Required. Determines whether or not the mount should be read-only.


systemMountVolumes: Required. An array of mounts to mount into the container, same fields as above.

sourceVolumePath: Required. The source path to the volume that will be mounted into the Docker container.
targetVolumePath: Required. The target path to the volume that will be mounted into the Docker container.
readOnly: Required. Determines whether or not the mount should be read-only.


registry Optional. The Docker registry credentials for a private container registry.

username: Optional. The username of the registry account.
password: Optional. The password to the registry account.
serverUrl: Optional. The registry URL.


portMappings: Optional. A key value hash of source:target ports to map into the container.


services: Optional. An array of service containers to spin up.

contextName: Required. The name of the service in the Job context.
image: Required. A string containing the Docker image.
createOptions: Optional. The optional create options specified in the YAML. For more information, see Running jobs in a container.
environmentVariables: Optional. Sets a map of key environment variables.
userMountVolumes: Optional. An array of mounts to mount into the container, same fields as above.

sourceVolumePath: Required. The source path to the volume that will be mounted into the Docker container.
targetVolumePath: Required. The target path to the volume that will be mounted into the Docker container.
readOnly: Required. Determines whether or not the mount should be read-only.


registry Optional. The Docker registry credentials for the private container registry.

username: Optional. The username of the registry account.
password: Optional. The password to the registry account.
serverUrl: Optional. The registry URL.


portMappings: Optional. A key value hash of source:target ports to map into the container.



Example input for prepare_job
JSON{
  "command": "prepare_job",
  "responseFile": "/users/octocat/runner/_work/{guid}.json",
  "state": {},
  "args": {
    "jobContainer": {
      "image": "node:18"
      "workingDirectory": "/__w/octocat-test2/octocat-test2",
      "createOptions": "--cpus 1",
      "environmentVariables": {
        "NODE_ENV": "development"
      },
      "userMountVolumes": [
        {
          "sourceVolumePath": "my_docker_volume",
          "targetVolumePath": "/volume_mount",
          "readOnly": false
        }
      ],
      "systemMountVolumes": [
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work",
          "targetVolumePath": "/__w",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/externals",
          "targetVolumePath": "/__e",
          "readOnly": true
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp",
          "targetVolumePath": "/__w/_temp",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_actions",
          "targetVolumePath": "/__w/_actions",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_tool",
          "targetVolumePath": "/__w/_tool",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_home",
          "targetVolumePath": "/github/home",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_workflow",
          "targetVolumePath": "/github/workflow",
          "readOnly": false
        }
      ],
      "registry": {
        "username": "octocat",
        "password": "examplePassword",
        "serverUrl": "https://index.docker.io/v1"
      },
      "portMappings": { "80": "801" }
    },
    "services": [
      {
        "contextName": "redis",
        "image": "redis",
        "createOptions": "--cpus 1",
        "environmentVariables": {},
        "userMountVolumes": [],
        "portMappings": { "80": "801" },
        "registry": {
          "username": "octocat",
          "password": "examplePassword",
          "serverUrl": "https://index.docker.io/v1"
        }
      }
    ]
  }
}
{
  "command": "prepare_job",
  "responseFile": "/users/octocat/runner/_work/{guid}.json",
  "state": {},
  "args": {
    "jobContainer": {
      "image": "node:18"
      "workingDirectory": "/__w/octocat-test2/octocat-test2",
      "createOptions": "--cpus 1",
      "environmentVariables": {
        "NODE_ENV": "development"
      },
      "userMountVolumes": [
        {
          "sourceVolumePath": "my_docker_volume",
          "targetVolumePath": "/volume_mount",
          "readOnly": false
        }
      ],
      "systemMountVolumes": [
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work",
          "targetVolumePath": "/__w",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/externals",
          "targetVolumePath": "/__e",
          "readOnly": true
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp",
          "targetVolumePath": "/__w/_temp",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_actions",
          "targetVolumePath": "/__w/_actions",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_tool",
          "targetVolumePath": "/__w/_tool",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_home",
          "targetVolumePath": "/github/home",
          "readOnly": false
        },
        {
          "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_workflow",
          "targetVolumePath": "/github/workflow",
          "readOnly": false
        }
      ],
      "registry": {
        "username": "octocat",
        "password": "examplePassword",
        "serverUrl": "https://index.docker.io/v1"
      },
      "portMappings": { "80": "801" }
    },
    "services": [
      {
        "contextName": "redis",
        "image": "redis",
        "createOptions": "--cpus 1",
        "environmentVariables": {},
        "userMountVolumes": [],
        "portMappings": { "80": "801" },
        "registry": {
          "username": "octocat",
          "password": "examplePassword",
          "serverUrl": "https://index.docker.io/v1"
        }
      }
    ]
  }
}

Example output for prepare_job
This example output is the contents of the responseFile defined in the input above.
JSON{
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "context": {
    "container": {
      "id": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
      "network": "example_network_53269bd575972817b43f7733536b200c"
    },
    "services": {
      "redis": {
        "id": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105",
        "ports": {
          "8080": "8080"
        },
        "network": "example_network_53269bd575972817b43f7733536b200c"
      }
    },
    "isAlpine": true
  }
}
{
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "context": {
    "container": {
      "id": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
      "network": "example_network_53269bd575972817b43f7733536b200c"
    },
    "services": {
      "redis": {
        "id": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105",
        "ports": {
          "8080": "8080"
        },
        "network": "example_network_53269bd575972817b43f7733536b200c"
      }
    },
    "isAlpine": true
  }
}

cleanup_job
The cleanup_job command is called at the end of a job. GitHub Actions assumes that you will do the following tasks in the cleanup_job command:

Stop any running service or job containers (or the equivalent pod).
Stop the network (if one exists).
Delete any job or service containers (or the equivalent pod).
Delete the network (if one exists).
Cleanup anything else that was created for the job.

Arguments for cleanup_job
No arguments are provided for cleanup_job.
Example input for cleanup_job
JSON{
  "command": "cleanup_job",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {}
}
{
  "command": "cleanup_job",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {}
}

Example output for cleanup_job
No output is expected for cleanup_job.
run_container_step
The run_container_step command is called once for each container action in your job. GitHub Actions assumes that you will do the following tasks in the run_container_step command:

Pull or build the required container (or fail if you cannot).
Run the container action and return the exit code of the container.
Stream any step logs output to stdout and stderr.
Cleanup the container after it executes.

Arguments for run_container_step

image: Optional. A string containing the docker image. Otherwise a dockerfile must be provided.
dockerfile: Optional. A string containing the path to the dockerfile, otherwise an image must be provided.
entryPointArgs: Optional. A list containing the entry point args.
entryPoint: Optional. The container entry point to use if the default image entrypoint should be overwritten.
workingDirectory: Required. A string containing the absolute path of the working directory.
createOptions: Optional. The optional create options specified in the YAML. For more information, see Running jobs in a container.
environmentVariables: Optional. Sets a map of key environment variables.
prependPath: Optional. An array of additional paths to prepend to the $PATH variable.
userMountVolumes: Optional. an array of user mount volumes set in the YAML. For more information, see Running jobs in a container.

sourceVolumePath: Required. The source path to the volume that will be mounted into the Docker container.
targetVolumePath: Required. The target path to the volume that will be mounted into the Docker container.
readOnly: Required. Determines whether or not the mount should be read-only.


systemMountVolumes: Required. An array of mounts to mount into the container, using the same fields as above.

sourceVolumePath: Required. The source path to the volume that will be mounted into the Docker container.
targetVolumePath: Required. The target path to the volume that will be mounted into the Docker container.
readOnly: Required. Determines whether or not the mount should be read-only.


registry Optional. The Docker registry credentials for a private container registry.

username: Optional. The username of the registry account.
password: Optional. The password to the registry account.
serverUrl: Optional. The registry URL.


portMappings: Optional. A key value hash of the source:target ports to map into the container.

Example input for image
If you're using a Docker image, you can specify the image name in the "image": parameter.
JSON{
  "command": "run_container_step",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {
    "image": "node:18",
    "dockerfile": null,
    "entryPointArgs": ["-f", "/dev/null"],
    "entryPoint": "tail",
    "workingDirectory": "/__w/octocat-test2/octocat-test2",
    "createOptions": "--cpus 1",
    "environmentVariables": {
      "NODE_ENV": "development"
    },
    "prependPath": ["/foo/bar", "bar/foo"],
    "userMountVolumes": [
      {
        "sourceVolumePath": "my_docker_volume",
        "targetVolumePath": "/volume_mount",
        "readOnly": false
      }
    ],
    "systemMountVolumes": [
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work",
        "targetVolumePath": "/__w",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/externals",
        "targetVolumePath": "/__e",
        "readOnly": true
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp",
        "targetVolumePath": "/__w/_temp",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_actions",
        "targetVolumePath": "/__w/_actions",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_tool",
        "targetVolumePath": "/__w/_tool",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_home",
        "targetVolumePath": "/github/home",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_workflow",
        "targetVolumePath": "/github/workflow",
        "readOnly": false
      }
    ],
    "registry": null,
    "portMappings": { "80": "801" }
  }
}
{
  "command": "run_container_step",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {
    "image": "node:18",
    "dockerfile": null,
    "entryPointArgs": ["-f", "/dev/null"],
    "entryPoint": "tail",
    "workingDirectory": "/__w/octocat-test2/octocat-test2",
    "createOptions": "--cpus 1",
    "environmentVariables": {
      "NODE_ENV": "development"
    },
    "prependPath": ["/foo/bar", "bar/foo"],
    "userMountVolumes": [
      {
        "sourceVolumePath": "my_docker_volume",
        "targetVolumePath": "/volume_mount",
        "readOnly": false
      }
    ],
    "systemMountVolumes": [
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work",
        "targetVolumePath": "/__w",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/externals",
        "targetVolumePath": "/__e",
        "readOnly": true
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp",
        "targetVolumePath": "/__w/_temp",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_actions",
        "targetVolumePath": "/__w/_actions",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_tool",
        "targetVolumePath": "/__w/_tool",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_home",
        "targetVolumePath": "/github/home",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_workflow",
        "targetVolumePath": "/github/workflow",
        "readOnly": false
      }
    ],
    "registry": null,
    "portMappings": { "80": "801" }
  }
}

Example input for Dockerfile
If your container is defined by a Dockerfile, this example demonstrates how to specify the path to a Dockerfile in your input, using the "dockerfile": parameter.
JSON{
  "command": "run_container_step",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "services": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {
    "image": null,
    "dockerfile": "/__w/_actions/foo/dockerfile",
    "entryPointArgs": ["hello world"],
    "entryPoint": "echo",
    "workingDirectory": "/__w/octocat-test2/octocat-test2",
    "createOptions": "--cpus 1",
    "environmentVariables": {
      "NODE_ENV": "development"
    },
    "prependPath": ["/foo/bar", "bar/foo"],
    "userMountVolumes": [
      {
        "sourceVolumePath": "my_docker_volume",
        "targetVolumePath": "/volume_mount",
        "readOnly": false
      }
    ],
    "systemMountVolumes": [
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work",
        "targetVolumePath": "/__w",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/externals",
        "targetVolumePath": "/__e",
        "readOnly": true
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp",
        "targetVolumePath": "/__w/_temp",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_actions",
        "targetVolumePath": "/__w/_actions",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_tool",
        "targetVolumePath": "/__w/_tool",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_home",
        "targetVolumePath": "/github/home",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_workflow",
        "targetVolumePath": "/github/workflow",
        "readOnly": false
      }
    ],
    "registry": null,
    "portMappings": { "80": "801" }
  }
}
{
  "command": "run_container_step",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "services": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {
    "image": null,
    "dockerfile": "/__w/_actions/foo/dockerfile",
    "entryPointArgs": ["hello world"],
    "entryPoint": "echo",
    "workingDirectory": "/__w/octocat-test2/octocat-test2",
    "createOptions": "--cpus 1",
    "environmentVariables": {
      "NODE_ENV": "development"
    },
    "prependPath": ["/foo/bar", "bar/foo"],
    "userMountVolumes": [
      {
        "sourceVolumePath": "my_docker_volume",
        "targetVolumePath": "/volume_mount",
        "readOnly": false
      }
    ],
    "systemMountVolumes": [
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work",
        "targetVolumePath": "/__w",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/externals",
        "targetVolumePath": "/__e",
        "readOnly": true
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp",
        "targetVolumePath": "/__w/_temp",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_actions",
        "targetVolumePath": "/__w/_actions",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_tool",
        "targetVolumePath": "/__w/_tool",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_home",
        "targetVolumePath": "/github/home",
        "readOnly": false
      },
      {
        "sourceVolumePath": "/home/octocat/git/runner/_layout/_work/_temp/_github_workflow",
        "targetVolumePath": "/github/workflow",
        "readOnly": false
      }
    ],
    "registry": null,
    "portMappings": { "80": "801" }
  }
}

Example output for run_container_step
No output is expected for run_container_step.
run_script_step
GitHub Actions assumes that you will do the following tasks:

Invoke the provided script inside the job container and return the exit code.
Stream any step log output to stdout and stderr.

Arguments for run_script_step

entryPointArgs: Optional. A list containing the entry point arguments.
entryPoint: Optional. The container entry point to use if the default image entrypoint should be overwritten.
prependPath: Optional. An array of additional paths to prepend to the $PATH variable.
workingDirectory: Required. A string containing the absolute path of the working directory.
environmentVariables: Optional. Sets a map of key environment variables.

Example input for run_script_step
JSON{
  "command": "run_script_step",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {
    "entryPointArgs": ["-e", "/runner/temp/example.sh"],
    "entryPoint": "bash",
    "environmentVariables": {
      "NODE_ENV": "development"
    },
    "prependPath": ["/foo/bar", "bar/foo"],
    "workingDirectory": "/__w/octocat-test2/octocat-test2"
  }
}
{
  "command": "run_script_step",
  "responseFile": null,
  "state": {
    "network": "example_network_53269bd575972817b43f7733536b200c",
    "jobContainer": "82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480",
    "serviceContainers": {
      "redis": "60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105"
    }
  },
  "args": {
    "entryPointArgs": ["-e", "/runner/temp/example.sh"],
    "entryPoint": "bash",
    "environmentVariables": {
      "NODE_ENV": "development"
    },
    "prependPath": ["/foo/bar", "bar/foo"],
    "workingDirectory": "/__w/octocat-test2/octocat-test2"
  }
}

Example output for run_script_step
No output is expected for run_script_step.
Generating the customization script
GitHub has created an example repository that demonstrates how to generate customization scripts for Docker and Kubernetes.
Note

The resulting scripts are available for testing purposes, and you will need to determine whether they are appropriate for your requirements.



Clone the actions/runner-container-hooks repository to your self-hosted runner.


The examples/ directory contains some existing customization commands, each with its own JSON file. You can review these examples and use them as a starting point for your own customization commands.

prepare_job.json
run_script_step.json
run_container_step.json



Build the npm packages. These commands generate the index.js files inside packages/docker/dist and packages/k8s/dist.
npm install && npm run bootstrap && npm run build-all



When the resulting index.js is triggered by GitHub Actions, it will run the customization commands defined in the JSON files. To trigger the index.js, you will need to add it your ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER environment variable, as described in the next section.
Triggering the customization script
The custom script must be located on the runner, but should not be stored in the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). The scripts are executed in the security context of the service account that's running the runner service.
Note

The triggered script is processed synchronously, so it will block job execution while running.

The script is automatically executed when the runner has the following environment variable containing an absolute path to the script:

ACTIONS_RUNNER_CONTAINER_HOOKS: The script defined in this environment variable is triggered when a job has been assigned to a runner, but before the job starts running.

To set this environment variable, you can either add it to the operating system, or add it to a file named .env within the self-hosted runner application directory. For example, the following .env entry will have the runner automatically run the script at /Users/octocat/runner/index.js before each container-based job runs:
ACTIONS_RUNNER_CONTAINER_HOOKS=/Users/octocat/runner/index.js

If you want to ensure that your job always runs inside a container, and subsequently always applies your container customizations, you can set the ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER variable on the self hosted runner to true. This will fail jobs that do not specify a job container.
Troubleshooting
No timeout setting
There is currently no timeout setting available for the script executed by ACTIONS_RUNNER_CONTAINER_HOOKS. As a result, you could consider adding timeout handling to your script.
Reviewing the workflow run log
To confirm whether your scripts are executing, you can review the logs for that job. For more information on checking the logs, see Using workflow run logs.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Run the runner app as a serviceConfiguring the self-hosted runner application as a serviceYou can configure the self-hosted runner application as a service to automatically start the runner application when the machine starts.Platform navigationMacWindowsLinuxIn this articleInstalling the serviceInstalling the serviceStarting the serviceChecking the status of the serviceStopping the serviceUninstalling the serviceCustomizing the self-hosted runner serviceCustomizing the self-hosted runner service
Note

You must add a runner to GitHub before you can configure the self-hosted runner application as a service.
For more information, see Adding self-hosted runners.

For Linux systems that use systemd, you can use the svc.sh script that is created after successfully adding the runner to install and manage using the application as a service.
On the runner machine, open a shell in the directory where you installed the self-hosted runner application. Use the commands below to install and manage the self-hosted runner service.


Note

Configuring the self-hosted runner application as a service on Windows is part of the application configuration process. If you have already configured the self-hosted runner application but did not choose to configure it as a service, you must remove the runner from GitHub and re-configure the application. When you re-configure the application, choose the option to configure the application as a service.
For more information, see Removing self-hosted runners and Adding self-hosted runners.

You can manage the runner service in the Windows Services application, or you can use PowerShell to run the commands below.


Note

You must add a runner to GitHub before you can configure the self-hosted runner application as a service.
For more information, see Adding self-hosted runners.

On the runner machine, open a shell in the directory where you installed the self-hosted runner application. Use the commands below to install and manage the self-hosted runner service.


Installing the service


Stop the self-hosted runner application if it is currently running.


Install the service with the following command:
sudo ./svc.sh install



Alternatively, the command takes an optional user argument to install the service as a different user.
./svc.sh install USERNAME





Installing the service


Stop the self-hosted runner application if it is currently running.


Install the service with the following command:
./svc.sh install




Starting the service
Start the service with the following command:

sudo ./svc.sh start



Start-Service "actions.runner.*"



./svc.sh start


Checking the status of the service
Check the status of the service with the following command:

sudo ./svc.sh status



Get-Service "actions.runner.*"



./svc.sh status


For more information on viewing the status of your self-hosted runner, see Monitoring and troubleshooting self-hosted runners.
Stopping the service
Stop the service with the following command:

sudo ./svc.sh stop



Stop-Service "actions.runner.*"



./svc.sh stop


Uninstalling the service


Stop the service if it is currently running.


Uninstall the service with the following command:
 
sudo ./svc.sh uninstall

 
 
Remove-Service "actions.runner.*"

 
 
./svc.sh uninstall

 



Customizing the self-hosted runner service
If you don't want to use the above default systemd service configuration, you can create a customized service or use whichever service mechanism you prefer. Consider using the serviced template at actions-runner/bin/actions.runner.service.template as a reference. If you use a customized service, the self-hosted runner service must always be invoked using the runsvc.sh entry point.


Customizing the self-hosted runner service
If you don't want to use the above default launchd service configuration, you can create a customized service or use whichever service mechanism you prefer. Consider using the plist template at actions-runner/bin/actions.runner.plist.template as a reference. If you use a customized service, the self-hosted runner service must always be invoked using the runsvc.sh entry point.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Proxy serversUsing a proxy server with self-hosted runnersYou can configure self-hosted runners to use a proxy server to communicate with GitHub.In this articleConfiguring a proxy server using environment variablesUsing a .env file to set the proxy configurationSetting proxy configuration for Docker containersConfiguring a proxy server using environment variables
If you need a self-hosted runner to communicate via a proxy server, the self-hosted runner application uses proxy configurations set in the following environment variables:

https_proxy: Proxy URL for HTTPS traffic. You can also include basic authentication credentials, if required. For example:

http://proxy.local
http://192.168.1.1:8080
http://username:password@proxy.local


http_proxy: Proxy URL for HTTP traffic. You can also include basic authentication credentials, if required. For example:

http://proxy.local
http://192.168.1.1:8080
http://username:password@proxy.local


no_proxy: Comma separated list of hosts that should not use a proxy. Only hostnames are allowed in no_proxy, you cannot use IP addresses. For example:

example.com
example.com,myserver.local:443,example.org



The proxy environment variables are read when the self-hosted runner application starts, so you must set the environment variables before configuring or starting the self-hosted runner application. If your proxy configuration changes, you must restart the self-hosted runner application.
Note

To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using.

On Windows machines, the proxy environment variable names are case insensitive. On Linux and macOS machines, we recommend that you use all lowercase environment variables. If you have an environment variable in both lowercase and uppercase on Linux or macOS, for example https_proxy and HTTPS_PROXY, the self-hosted runner application uses the lowercase environment variable.
The connection between self-hosted runners and GitHub is over HTTPS (port 443).
Using a .env file to set the proxy configuration
If setting environment variables is not practical, you can set the proxy configuration variables in a file named .env in the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). For example, this might be necessary if you want to configure the runner application as a service under a system account. When the runner application starts, it reads the variables set in .env for the proxy configuration.
Example .env proxy configuration
https_proxy=http://proxy.local:8080
no_proxy=example.com,myserver.local:443

Setting proxy configuration for Docker containers
If you use Docker container actions or service containers in your workflows, you might also need to configure Docker to use your proxy server in addition to setting the above environment variables.
For information on the required Docker configuration, see Configure Docker to use a proxy server in the Docker documentation.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Label runnersUsing labels with self-hosted runnersYou can use labels to organize your self-hosted runners based on their characteristics.In this articleCreating a custom labelAssigning a label to a self-hosted runnerRemoving a custom label from a self-hosted runnerProgrammatically assign labelsFor information on how to use labels to route jobs to specific types of self-hosted runners, see Using self-hosted runners in a workflow. You can also route jobs to runners in a specific group. For more information, see Choosing the runner for a job.
A self-hosted runner can be located in either your repository, organization, or enterprise account settings on GitHub. To manage a self-hosted runner, you must have the following permissions, depending on where the self-hosted runner was added:

User repository: You must be the repository owner.
Organization: You must be an organization owner.
Organization repository: You must be an organization owner, or have admin access to the repository.

Note

Actions Runner Controller does not support multiple labels, to find out more please read our Actions Runner Controller documentation

Creating a custom label
You can create custom labels for runners at the repository and organization levels.

Creating a custom label for a repository runner
Creating a custom label for an organization runner

Note

Labels are case-insensitive.

Creating a custom label for a repository runner

Navigate to the main page of the repository where your self-hosted runner group is registered.
Click  Settings.
In the left sidebar, click  Actions, then click Runners.
In the list of runners, click on the name of the runner you'd like to configure.
In the "Labels" section, click .
In the "Find or create a label" field, type the name of your new label and click Create new label. The custom label is created and assigned to the self-hosted runner. Custom labels can be removed from self-hosted runners, but they currently can't be manually deleted. Any unused labels that are not assigned to a runner will be automatically deleted within 24 hours.

Creating a custom label for an organization runner

Navigate to the main page of the organization where your self-hosted runner group is registered.
Click  Settings.
In the left sidebar, click  Actions, then click Runners.
In the list of runners, click on the name of the runner you'd like to configure.
In the "Labels" section, click .
In the "Find or create a label" field, type the name of your new label and click Create new label. The custom label is created and assigned to the self-hosted runner. Custom labels can be removed from self-hosted runners, but they currently can't be manually deleted. Any unused labels that are not assigned to a runner will be automatically deleted within 24 hours.

Assigning a label to a self-hosted runner
You can assign labels to self-hosted runners at the repository and organization levels.

Assigning a label to a repository runner
Assigning a label to an organization runner

Assigning a label to a repository runner

Navigate to the main page of the repository where your self-hosted runner group is registered.
Click  Settings.
In the left sidebar, click  Actions, then click Runners.
In the "Labels" section, click .
To assign a label to your self-hosted runner, in the "Find or create a label" field, click the label.

Assigning a label to an organization runner

Navigate to the main page of the organization where your self-hosted runner group is registered.
Click  Settings.
In the left sidebar, click  Actions, then click Runners.
In the "Labels" section, click .
To assign a label to your self-hosted runner, in the "Find or create a label" field, click the label.

Removing a custom label from a self-hosted runner
You can remove custom labels from self-hosted runners at the repository and organization levels.

Removing a custom label from a repository runner
Removing a custom label from an organization runner

Removing a custom label from a repository runner

Navigate to the main page of the repository where your self-hosted runner group is registered.
Click  Settings.
In the left sidebar, click  Actions, then click Runners.
In the "Labels" section, click .
In the "Find or create a label" field, assigned labels are marked with the  icon. Click on a marked label to unassign it from your self-hosted runner.

Removing a custom label from an organization runner

Navigate to the main page of the organization where your self-hosted runner group is registered.
Click  Settings.
In the left sidebar, click  Actions, then click Runners.
In the "Labels" section, click .
In the "Find or create a label" field, assigned labels are marked with the  icon. Click on a marked label to unassign it from your self-hosted runner.

Programmatically assign labels
You can programmatically assign labels to a self-hosted runner after the runner is created, or during its initial configuration.


To programmatically assign labels to an existing self-hosted runner, you must use the REST API. For more information, see REST API endpoints for self-hosted runners.


To programmatically assign labels to a self-hosted runner during the initial runner configuration, you can pass label names to the config script using the labels parameter.
Note

You cannot use the config script to assign labels to an existing self-hosted runner.

For example, this command assigns a label named gpu when configuring a new self-hosted runner:
./config.sh --url <REPOSITORY_URL> --token <REGISTRATION_TOKEN> --labels gpu

The label is created if it does not already exist. You can also use this approach to assign the default labels to runners, such as x64 or linux. When default labels are assigned using the configuration script, GitHub Actions accepts them as given and does not validate that the runner is actually using that operating system or architecture.
You can use comma separation to assign multiple labels. For example:
./config.sh --url <REPOSITORY_URL> --token <REGISTRATION_TOKEN> --labels gpu,x64,linux

Note

If you replace an existing runner, then you must reassign any custom labels.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Use runners in a workflowUsing self-hosted runners in a workflowTo use self-hosted runners in a workflow, you can use labels or groups to specify the runner for a job.In this articleAbout self-hosted runner labelsAbout self-hosted runner groupsViewing available runners for a repositoryUsing default labels to route jobsUsing custom labels to route jobsUsing groups to route jobsUsing labels and groups to route jobsRouting precedence for self-hosted runnersWorkflow run continuityYou can target self-hosted runners for use in a workflow based on the labels assigned to the runners, or their group membership, or a combination of these.
Important
Runner Scale Sets do not support multiple labels, only the name of the runner can be used in place of a label. See Deploying runner scale sets with Actions Runner Controller.

About self-hosted runner labels
Labels allow you to send workflow jobs to specific types of self-hosted runners, based on their shared characteristics. For example, if your job requires a particular hardware component or software package, you can assign a custom label to a runner and then configure your job to only execute on runners with that label.
To specify a self-hosted runner for your job, configure runs-on in your workflow file with self-hosted runner labels.
Self-hosted runners may have the self-hosted label. When setting up a self-hosted runner, by default we will include the label self-hosted. You may pass in the --no-default-labels flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with self-hosted (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.
Note that Actions Runner Controller does not support multiple labels and does not support the self-hosted label.
For information on creating custom and default labels, see Using labels with self-hosted runners.
About self-hosted runner groups
For self-hosted runners defined at the organization level, you can group your runners with shared characteristics into a single runner group and then configure your job to target the runner group.
To specify a self-hosted runner group for your job, configure runs-on.group in your workflow file.
For information on creating and managing runner groups, see Managing access to self-hosted runners using groups.
Viewing available runners for a repository
If you have repo: write access to a repository, you can view a list of the runners available to the repository.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Actions.



In the left sidebar, under the "Management" section, click  Runners.


Click the Self hosted tab at the top of the list of runners.


Review the list of available self-hosted runners for the repository. This list includes both self-hosted runners and runner scale sets created with Actions Runner Controller. For more information, see About Actions Runner Controller.


Optionally, to copy a runner's label to use it in a workflow, click  to the right of the runner, then click Copy label.


Note

Enterprise and organization owners can create runners from this page. To create a new runner, click New runner at the top right of the list of runners to add runners to the repository.
For more information, see Managing larger runners and Adding self-hosted runners.

Using default labels to route jobs
A self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform:

self-hosted: Default label applied to self-hosted runners.
linux, windows, or macOS: Applied depending on operating system.
x64, ARM, or ARM64: Applied depending on hardware architecture.

You can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:
runs-on: [self-hosted, linux, ARM64]


self-hosted - Run this job on a self-hosted runner.
linux - Only use a Linux-based runner.
ARM64 - Only use a runner based on ARM64 hardware.

To create individual self-hosted runners without the default labels, pass the --no-default-labels flag when you create the runner. Actions Runner Controller does not support multiple labels.
Using custom labels to route jobs
You can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled.
For example, if you have a job that requires a specific type of graphics hardware, you can create a custom label called gpu and assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job.
This example shows a job that combines default and custom labels:
runs-on: [self-hosted, linux, x64, gpu]


self-hosted - Run this job on a self-hosted runner.
linux - Only use a Linux-based runner.
x64 - Only use a runner based on x64 hardware.
gpu - This custom label has been manually assigned to self-hosted runners with the GPU hardware installed.

These labels operate cumulatively, so a self-hosted runner must have all four labels to be eligible to process the job.
Using groups to route jobs
In this example, Ubuntu runners have been added to a group called ubuntu-runners. The runs-on key sends the job to any available runner in the ubuntu-runners group:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on: 
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

Using labels and groups to route jobs
When you combine groups and labels, the runner must meet both requirements to be eligible to run the job.
In this example, a runner group called ubuntu-runners is populated with Ubuntu runners, which have also been assigned the label ubuntu-20.04-16core. The runs-on key combines group and labels so that the job is routed to any available runner within the group that also has a matching label:
name: learn-github-actions
on: [push]
jobs:
  check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

Routing precedence for self-hosted runners
When routing a job to a self-hosted runner, GitHub looks for a runner that matches the job's runs-on labels and groups:

If GitHub finds an online and idle runner that matches the job's runs-on labels and groups, the job is then assigned and sent to the runner.

If the runner doesn't pick up the assigned job within 60 seconds, the job is re-queued so that a new runner can accept it.


If GitHub doesn't find an online and idle runner that matches the job's runs-on labels and groups, then the job will remain queued until a runner comes online.
If the job remains queued for more than 24 hours, the job will fail.

Workflow run continuity
If GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Manage access with runner groupsManaging access to self-hosted runners using groupsYou can use policies to limit access to self-hosted runners that have been added to an organization.Who can use this feature?Enterprise accounts, organizations owned by enterprise accounts, and organizations using GitHub Team or GitHub Free plans can create and manage additional runner groups using self-hosted runners.In this articleAbout runner groupsCreating a self-hosted runner group for an organizationChanging which repositories can access a runner groupChanging the name of a runner groupAutomatically adding a self-hosted runner to a groupMoving a self-hosted runner to a groupRemoving a self-hosted runner groupAbout runner groups
To control access to runners at the organization level, organizations using the GitHub Team plan can use runner groups. Runner groups are used to collect sets of runners and create a security boundary around them.
When you grant access to a runner group, you can see the runner group listed in the organization's runner settings. Optionally, you can assign additional granular repository access policies to the runner group.
When new runners are created, they are automatically assigned to the default group unless otherwise specified. Runners can only be in one group at a time. You can move runners from one runner group to another. For more information, see Moving a runner to a group.
For information on how to route jobs to runners in a specific group, see Choosing the runner for a job.
Creating a self-hosted runner group for an organization
Warning

We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.
For more information, see Security hardening for GitHub Actions.

Note

When creating a runner group, you must choose a policy that defines which repositories have access to the runner group. To change which repositories and workflows can access the runner group, organization owners can set a policy for the organization. For more information, see Enforcing policies for GitHub Actions in your enterprise.

All organizations have a single default runner group. Organization owners using the GitHub Team plan can create additional organization-level runner groups.
If no group is specified during the registration process, runners are automatically added to the default group. You can later move the runner from the default group to a custom group. For more information, see Moving a runner to a group.
For information about how to create a runner group with the REST API, see REST API endpoints for GitHub Actions.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runner groups.


In the "Runner groups" section, click New runner group.


Enter a name for your runner group.


Assign a policy for repository access.
You can configure a runner group to be accessible to a specific list of repositories, or to all repositories in the organization. By default, only private repositories can access runners in a runner group, but you can override this. This setting can't be overridden if configuring an organization's runner group that was shared by an enterprise.


Click Create group to create the group and apply the policy.


Changing which repositories can access a runner group
Warning

We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.
For more information, see Security hardening for GitHub Actions.

For runner groups in an organization, you can change what repositories in the organization can access a runner group.


Navigate to the main page of the organization where your runner groups are located.


Click  Settings.


In the left sidebar, click  Actions, then click Runner groups.


In the list of groups, click the runner group you'd like to configure.


Under "Repository access," use the dropdown menu to click Selected repositories.

To the right of the dropdown menu, click .
In the popup, use the checkboxes to select repositories that can access this runner group.



Click Save group.


Changing the name of a runner group

Navigate to the main page of the organization where your runner groups are located.
Click  Settings.
In the left sidebar, click  Actions, then click Runner groups.
In the list of groups, click the runner group you'd like to configure.
Enter the new runner group name in the text field under "Group name."
Click Save.

Automatically adding a self-hosted runner to a group
You can use the configuration script to automatically add a new runner to a group. For example, this command registers a new runner and uses the --runnergroup parameter to add it to a group named rg-runnergroup.
./config.sh --url $org_or_enterprise_url --token $token --runnergroup rg-runnergroup

The command will fail if the runner group doesn't exist:
Could not find any self-hosted runner group named "rg-runnergroup".


Moving a self-hosted runner to a group
If you don't specify a runner group during the registration process, your new runners are automatically assigned to the default group, and can then be moved to another group.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the "Runners" list, click the runner that you want to configure.


Select the Runner group drop-down.


In "Move runner to group", choose a destination group for the runner.


Removing a self-hosted runner group
In order to remove a runner group, you must first move or remove all of the runners from the group.

Navigate to the main page of the organization where your runner groups are located.
Click  Settings.
In the left sidebar, click  Actions, then click Runner groups.
In the list of groups, to the right of the group you want to delete, click .
To remove the group, click Remove group.
Review the confirmation prompts, and click Remove this runner group.\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Monitor & troubleshootMonitoring and troubleshooting self-hosted runnersYou can monitor your self-hosted runners to view their activity and diagnose common issues.Platform navigationMacWindowsLinuxIn this articleUsing repository-level self-hosted runnersChecking the status of a self-hosted runnerTroubleshooting network connectivityReviewing the self-hosted runner application log filesReviewing a job's log fileUsing journalctl to check the self-hosted runner application serviceUsing launchd to check the self-hosted runner application serviceUsing PowerShell to check the self-hosted runner application serviceMonitoring the automatic update processTroubleshooting containers in self-hosted runnersUsing repository-level self-hosted runners
You may not be able to create a self-hosted runner for an organization-owned repository.
Organization owners can choose which repositories are allowed to create repository-level self-hosted runners.
For more information, see Disabling or limiting GitHub Actions for your organization.
Checking the status of a self-hosted runner
A self-hosted runner can be located in either your repository, organization, or enterprise account settings on GitHub. To manage a self-hosted runner, you must have the following permissions, depending on where the self-hosted runner was added:

User repository: You must be the repository owner.
Organization: You must be an organization owner.
Organization repository: You must be an organization owner, or have admin access to the repository.



In your organization or repository, navigate to the main page and click  Settings.


In the left sidebar, click  Actions, then click Runners.


Under "Runners", you can view a list of registered runners, including the runner's name, labels, and status.
The status can be one of the following:

Idle: The runner is connected to GitHub and is ready to execute jobs.
Active: The runner is currently executing a job.
Offline: The runner is not connected to GitHub. This could be because the machine is offline, the self-hosted runner application is not running on the machine, or the self-hosted runner application cannot communicate with GitHub.



Troubleshooting network connectivity
Checking self-hosted runner network connectivity
You can use the self-hosted runner application's config script with the --check parameter to check that a self-hosted runner can access all required network services on GitHub.
In addition to --check, you must provide two arguments to the script:

--url with the URL to your GitHub repository, organization, or enterprise. For example, --url https://github.com/octo-org/octo-repo.
--pat with the value of a personal access token (classic), which must have the workflow scope, or a fine-grained personal access token with workflows read and write access. For example, --pat ghp_abcd1234. For more information, see Managing your personal access tokens.

For example:

./config.sh --check --url URL --pat ghp_abcd1234



./config.sh --check --url URL --pat ghp_abcd1234



config.cmd --check --url https://github.com/YOUR-ORG/YOUR-REPO --pat GHP_ABCD1234


The script tests each service, and outputs either a PASS or FAIL for each one. If you have any failing checks, you can see more details on the problem in the log file for the check. The log files are located in the _diag directory where you installed the runner application, and the path of the log file for each check is shown in the console output of the script.
If you have any failing checks, you should also verify that your self-hosted runner machine meets all the communication requirements. For more information, see Communicating with self-hosted runners.
Disabling TLS certificate verification
By default, the self-hosted runner application verifies the TLS certificate for GitHub. If you encounter network problems, you may wish to disable TLS certificate verification for testing purposes.
To disable TLS certification verification in the self-hosted runner application, set the GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY environment variable to 1 before configuring and running the self-hosted runner application.

export GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1
./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token
./run.sh



export GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1
./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token
./run.sh



[Environment]::SetEnvironmentVariable('GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY', '1')
./config.cmd --url https://github.com/YOUR-ORG/YOUR-REPO --token
./run.cmd


Warning

Disabling TLS verification is not recommended since TLS provides privacy and data integrity between the self-hosted runner application and GitHub. We recommend that you install the GitHub certificate in the operating system certificate store for your self-hosted runner. For guidance on how to install the GitHub certificate, check with your operating system vendor.

Reviewing the self-hosted runner application log files
You can monitor the status of the self-hosted runner application and its activities. Log files are kept in the _diag directory where you installed the runner application, and a new log is generated each time the application is started. The filename begins with Runner_, and is followed by a UTC timestamp of when the application was started.
Warning

Runner application log files for ephemeral runners must be forwarded and preserved externally for troubleshooting and diagnostic purposes. For more information about ephemeral runners and autoscaling self-hosted runners, see Autoscaling with self-hosted runners.

For detailed logs on workflow job executions, see the next section describing the Worker_ files.
Reviewing a job's log file
The self-hosted runner application creates a detailed log file for each job that it processes. These files are stored in the _diag directory where you installed the runner application, and the filename begins with Worker_.

Using journalctl to check the self-hosted runner application service
For Linux-based self-hosted runners running the application using a service, you can use journalctl to monitor their real-time activity. The default systemd-based service uses the following naming convention: actions.runner.<org>-<repo>.<runnerName>.service. This name is truncated if it exceeds 80 characters, so the preferred way of finding the service's name is by checking the .service file. For example:
$ cat ~/actions-runner/.service
actions.runner.octo-org-octo-repo.runner01.service

If this fails due to the service being installed elsewhere, you can find the service name in the list of running services. For example, on most Linux systems you can use the systemctl command:
$ systemctl --type=service | grep actions.runner
actions.runner.octo-org-octo-repo.hostname.service loaded active running GitHub Actions Runner (octo-org-octo-repo.hostname)

You can use journalctl to monitor the real-time activity of the self-hosted runner:
sudo journalctl -u actions.runner.octo-org-octo-repo.runner01.service -f

In this example output, you can see runner01 start, receive a job named testAction, and then display the resulting status:
Feb 11 14:57:07 runner01 runsvc.sh[962]: Starting Runner listener with startup type: service
Feb 11 14:57:07 runner01 runsvc.sh[962]: Started listener process
Feb 11 14:57:07 runner01 runsvc.sh[962]: Started running service
Feb 11 14:57:16 runner01 runsvc.sh[962]: √ Connected to GitHub
Feb 11 14:57:17 runner01 runsvc.sh[962]: 2020-02-11 14:57:17Z: Listening for Jobs
Feb 11 16:06:54 runner01 runsvc.sh[962]: 2020-02-11 16:06:54Z: Running job: testAction
Feb 11 16:07:10 runner01 runsvc.sh[962]: 2020-02-11 16:07:10Z: Job testAction completed with result: Succeeded

To view the systemd configuration, you can locate the service file here: /etc/systemd/system/actions.runner.<org>-<repo>.<runnerName>.service.
If you want to customize the self-hosted runner application service, do not directly modify this file. Follow the instructions described in Configuring the self-hosted runner application as a service.


Using launchd to check the self-hosted runner application service
For macOS-based self-hosted runners running the application as a service, you can use launchctl to monitor their real-time activity. The default launchd-based service uses the following naming convention: actions.runner.<org>-<repo>.<runnerName>. This name is truncated if it exceeds 80 characters, so the preferred way of finding the service's name is by checking the .service file in the runner directory:
% cat ~/actions-runner/.service
/Users/exampleUsername/Library/LaunchAgents/actions.runner.octo-org-octo-repo.runner01.plist

The svc.sh script uses launchctl to check whether the application is running. For example:
$ ./svc.sh status
status actions.runner.example.runner01:
/Users/exampleUsername/Library/LaunchAgents/actions.runner.example.runner01.plist
Started:
379 0 actions.runner.example.runner01

The resulting output includes the process ID and the name of the application’s launchd service.
To view the launchd configuration, you can locate the service file here: /Users/exampleUsername/Library/LaunchAgents/actions.runner.<repoName>.<runnerName>.service.
If you want to customize the self-hosted runner application service, do not directly modify this file. Follow the instructions described in Configuring the self-hosted runner application as a service.


Using PowerShell to check the self-hosted runner application service
For Windows-based self-hosted runners running the application as a service, you can use PowerShell to monitor their real-time activity. The service uses the naming convention GitHub Actions Runner (<org>-<repo>.<runnerName>). You can also find the service's name by checking the .service file in the runner directory:
PS C:\actions-runner> Get-Content .service
actions.runner.octo-org-octo-repo.runner01.service

You can view the status of the runner in the Windows Services application (services.msc). You can also use PowerShell to check whether the service is running:
PS C:\actions-runner> Get-Service "actions.runner.octo-org-octo-repo.runner01.service" | Select-Object Name, Status
Name                                                  Status
----                                                  ------
actions.runner.octo-org-octo-repo.runner01.service    Running

You can use PowerShell to check the recent activity of the self-hosted runner. In this example output, you can see the application start, receive a job named testAction, and then display the resulting status:
PS C:\actions-runner> Get-EventLog -LogName Application -Source ActionsRunnerService

   Index Time          EntryType   Source                 InstanceID Message
   ----- ----          ---------   ------                 ---------- -------
     136 Mar 17 13:45  Information ActionsRunnerService          100 2020-03-17 13:45:48Z: Job Greeting completed with result: Succeeded
     135 Mar 17 13:45  Information ActionsRunnerService          100 2020-03-17 13:45:34Z: Running job: testAction
     134 Mar 17 13:41  Information ActionsRunnerService          100 2020-03-17 13:41:54Z: Listening for Jobs
     133 Mar 17 13:41  Information ActionsRunnerService          100 û Connected to GitHub
     132 Mar 17 13:41  Information ActionsRunnerService            0 Service started successfully.
     131 Mar 17 13:41  Information ActionsRunnerService          100 Starting Actions Runner listener
     130 Mar 17 13:41  Information ActionsRunnerService          100 Starting Actions Runner Service
     129 Mar 17 13:41  Information ActionsRunnerService          100 create event log trace source for actions-runner service


Monitoring the automatic update process
We recommend that you regularly check the automatic update process, as the self-hosted runner will not be able to process jobs if it falls below a certain version threshold. The self-hosted runner application automatically updates itself, but note that this process does not include any updates to the operating system or other software; you will need to separately manage these updates.
You can view the update activities in the Runner_ log files. For example:
[Feb 12 12:37:07 INFO SelfUpdater] An update is available.

In addition, you can find more information in the SelfUpdate log files located in the _diag directory where you installed the runner application.

Troubleshooting containers in self-hosted runners
Checking that Docker is installed
If your jobs require containers, then the self-hosted runner must be Linux-based and needs to have Docker installed. Check that your self-hosted runner has Docker installed and that the service is running.
You can use systemctl to check the service status:
$ sudo systemctl is-active docker.service
active

If Docker is not installed, then dependent actions will fail with the following errors:
[2020-02-13 16:56:10Z INFO DockerCommandManager] Which: 'docker'
[2020-02-13 16:56:10Z INFO DockerCommandManager] Not found.
[2020-02-13 16:56:10Z ERR  StepsRunner] Caught exception from step: System.IO.FileNotFoundException: File not found: 'docker'

Checking the Docker permissions
If your job fails with the following error:
dial unix /var/run/docker.sock: connect: permission denied

Check that the self-hosted runner's service account has permission to use the Docker service. You can identify this account by checking the configuration of the self-hosted runner in systemd. For example:
$ sudo systemctl show -p User actions.runner.octo-org-octo-repo.runner01.service
User=runner-user


Checking which Docker engine is installed on the runner
If your build fails with the following error:
Error: Input required and not supplied: java-version

Check which Docker engine is installed on your self-hosted runner. To pass the inputs of an action into the Docker container, the runner uses environment variables that might contain dashes as part of their names. The action may not be able to get the inputs if the Docker engine is not a binary executable, but is instead a shell wrapper or a link (for example, a Docker engine installed on Linux using snap). To address this error, configure your self-hosted runner to use a different Docker engine.
To check if your Docker engine was installed using snap, use the which command. In the following example, the Docker engine was installed using snap:
$ which docker
/snap/bin/docker\n\n\n\nGitHub Actions/Self-hosted runners/Manage self-hosted runners/Remove self-hosted runnersRemoving self-hosted runnersYou can permanently remove a self-hosted runner from a repository or organization.In this articleRemoving a runner from a repositoryRemoving a runner from an organizationRemoving a runner from an enterpriseRemoving a runner from a repository
Note


This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop the run application. The runner will remain assigned in an "Offline" state, and won't execute any jobs until you restart the runner using the run application.
A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.
Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed. To remove a JIT runner before automatic removal, you must remove the JIT runner on GitHub.


To remove a self-hosted runner from a user repository you must be the repository owner. Organization owners can remove a runner from a repository in the organization.
We recommend that you also have access to the self-hosted runner machine.
For information about how to remove a self-hosted runner with the REST API, see REST API endpoints for self-hosted runners.
Alternatively, if you don't have access to the repository or organization on GitHub to remove a runner, but you would like to re-use the runner machine, then you can delete the .runner file inside the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). This allows the runner to be registered without having to re-download the self-hosted runner application.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, click on the name of the runner you'd like to configure.


Click Remove.


You will see instructions for removing the self-hosted runner. Complete either of the following steps to remove the runner, depending on whether it is still accessible:


If you have access to the runner machine: Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.
The removal command does the following tasks:

Removes the runner from GitHub.
Removes any self-hosted runner application configuration files on the machine.
Removes any services configured if not running in interactive mode.



If you don't have access to the machine: Click Force remove this runner to force GitHub to remove the runner.




Removing a runner from an organization
Note


This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop the run application. The runner will remain assigned in an "Offline" state, and won't execute any jobs until you restart the runner using the run application.
A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.
Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed. To remove a JIT runner before automatic removal, you must remove the JIT runner on GitHub.


To remove a self-hosted runner from an organization, you must be an organization owner. We recommend that you also have access to the self-hosted runner machine. For information about how to remove a self-hosted runner with the REST API, see REST API endpoints for self-hosted runners.
Alternatively, if you don't have access to the repository or organization on GitHub to remove a runner, but you would like to re-use the runner machine, then you can delete the .runner file inside the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). This allows the runner to be registered without having to re-download the self-hosted runner application.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the left sidebar, click  Actions, then click Runners.


In the list of runners, click on the name of the runner you'd like to configure.


Click Remove.


You will see instructions for removing the self-hosted runner. Complete either of the following steps to remove the runner, depending on whether it is still accessible:


If you have access to the runner machine: Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.
The removal command does the following tasks:

Removes the runner from GitHub.
Removes any self-hosted runner application configuration files on the machine.
Removes any services configured if not running in interactive mode.



If you don't have access to the machine: Click Force remove this runner to force GitHub to remove the runner.




Removing a runner from an enterprise
If you use GitHub Enterprise Cloud, you can also remove runners from an enterprise. For more information, see the GitHub Enterprise Cloud documentation.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/About ARCAbout Actions Runner ControllerYou can host your own runners and customize the environment used to run jobs in your GitHub Actions workflows.In this articleAbout Actions Runner ControllerActions Runner Controller componentsExecuting workflowsScaling runnersSoftware installed in the ARC runner imageAssets and releasesLegal noticeLegal notice
About Actions Runner Controller
Actions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, see Operator pattern in the Kubernetes documentation.
With ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, see Autoscaling with self-hosted runners.
The following diagram illustrates the architecture of ARC's autoscaling runner scaleset mode.
Note

To view the following diagram in a larger size, see the Autoscaling Runner Scale Sets mode documentation in the Actions Runner Controller repository.



Actions Runner Controller is installed using the supplied Helm charts, and the controller manager pod is deployed in the specified namespace. A new AutoScalingRunnerSet resource is deployed via the supplied Helm charts or a customized manifest file. The AutoScalingRunnerSet Controller calls GitHub's APIs to fetch the runner group ID that the runner scale set will belong to.
The AutoScalingRunnerSet Controller calls the APIs one more time to either fetch or create a runner scale set in the GitHub Actions service before creating the Runner ScaleSet Listener resource.
A Runner ScaleSet Listener pod is deployed by the AutoScalingListener Controller. In this pod, the listener application connects to the GitHub Actions Service to authenticate and establish an HTTPS long poll connection. The listener stays idle until it receives a Job Available message from the GitHub Actions Service.
When a workflow run is triggered from a repository, the GitHub Actions Service dispatches individual job runs to the runners or runner scalesets where the runs-on key matches the name of the runner scaleset or labels of self-hosted runners.
When the Runner ScaleSet Listener receives the Job Available message, it checks whether it can scale up to the desired count. If it can, the Runner ScaleSet Listener acknowledges the message.
The Runner ScaleSet Listener uses a Service Account and a Role bound to that account to make an HTTPS call through the Kubernetes APIs to patch the Ephemeral RunnerSet resource with the number of desired replicas count.
The Ephemeral RunnerSet attempts to create new runners and the EphemeralRunner Controller requests a Just-in-Time (JIT) configuration token to register these runners. The controller attempts to create runner pods. If the pod's status is failed, the controller retries up to 5 times. After 24 hours the GitHub Actions Service unassigns the job if no runner accepts it.
Once the runner pod is created, the runner application in the pod uses the JIT configuration token to register itself with the GitHub Actions Service. It then establishes another HTTPS long poll connection to receive the job details it needs to execute.
The GitHub Actions Service acknowledges the runner registration and dispatches the job run details.
Throughout the job run execution, the runner continuously communicates the logs and job run status back to the GitHub Actions Service.
When the runner completes its job successfully, the EphemeralRunner Controller checks with the GitHub Actions Service to see if runner can be deleted. If it can, the Ephemeral RunnerSet deletes the runner.

Actions Runner Controller components
ARC consists of a set of resources, some of which are created specifically for ARC. An ARC deployment applies these resources onto a Kubernetes cluster. Once applied, it creates a set of Pods that contain your self-hosted runners' containers. With ARC, GitHub can treat these runner containers as self-hosted runners and allocate jobs to them as needed.
Each resource that is deployed by ARC is given a name composed of:

An installation name, which is the installation name you specify when you install the Helm chart.
A resource identification suffix, which is a string that identifies the resource type. This value is not configurable.

Note

Different versions of Kubernetes have different length limits for names of resources. The length limit for the resource name is calculated by adding the length of the installation name and the length of the resource identification suffix. If the resource name is longer than the reserved length, you will receive an error.

Resources deployed by gha-runner-scale-set-controller





























































































TemplateResource KindNameReserved LengthDescriptionNotesdeployment.yamlDeploymentINSTALLATION_NAME-gha-rs-controller18The resource running controller-managerThe pods created by this resource have the ReplicaSet suffix and the Pod suffix.serviceaccount.yamlServiceAccountINSTALLATION_NAME-gha-rs-controller18This is created if serviceAccount.create in values.yaml is set to true.The name can be customized in values.yamlmanager_cluster_role.yamlClusterRoleINSTALLATION_NAME-gha-rs-controller18ClusterRole for the controller managerThis is created if the value of flags.watchSingleNamespace is empty.manager_cluster_role_binding.yamlClusterRoleBindingINSTALLATION_NAME-gha-rs-controller18ClusterRoleBinding for the controller managerThis is created if the value of flags.watchSingleNamespace is empty.manager_single_namespace_controller_role.yamlRoleINSTALLATION_NAME-gha-rs-controller-single-namespace35Role for the controller managerThis is created if the value of flags.watchSingleNamespace is set.manager_single_namespace_controller_role_binding.yamlRoleBindingINSTALLATION_NAME-gha-rs-controller-single-namespace35RoleBinding for the controller managerThis is created if the value of flags.watchSingleNamespace is set.manager_single_namespace_watch_role.yamlRoleINSTALLATION_NAME-gha-rs-controller-single-namespace-watch41Role for the controller manager for the namespace configuredThis is created if the value of flags.watchSingleNamespace is set.manager_single_namespace_watch_role_binding.yamlRoleBindingINSTALLATION_NAME-gha-rs-controller-single-namespace-watch41RoleBinding for the controller manager for the namespace configuredThis is created if the value of flags.watchSingleNamespace is set.manager_listener_role.yamlRoleINSTALLATION_NAME-gha-rs-controller-listener26Role for the listenerThis is always created.manager_listener_role_binding.yaml RoleBindingINSTALLATION_NAME-gha-rs-controller-listener26RoleBinding for the listenerThis is always created and binds the listener role with the service account, which is either created by serviceaccount.yaml or configured with values.yaml.
Resources deployed by gha-runner-scale-set





































































TemplateResource KindNameReserved LengthDescriptionNotesautoscalingrunnerset.yamlAutoscalingRunnerSetINSTALLATION_NAME0Top level resource working with scale setsThe name is limited to 45 characters in length.no_permission_service_account.yamlServiceAccountINSTALLATION_NAME-gha-rs-no-permission21Service account mounted to the runner containerThis is created if the container mode is not "kubernetes" and template.spec.serviceAccountName is not specified.githubsecret.yamlSecretINSTALLATION_NAME-gha-rs-github-secret20Secret containing values needed to authenticate to the GitHub APIThis is created if githubConfigSecret is an object. If a string is provided, this secret will not be created.manager_role.yamlRoleINSTALLATION_NAME-gha-rs-manager15Role provided to the manager to be able to reconcile on resources in the autoscaling runner set's namespaceThis is always created.manager_role_binding.yamlRoleBindingINSTALLATION_NAME-gha-rs-manager15Binding manager_role to the manager service account.This is always created.kube_mode_role.yamlRoleINSTALLATION_NAME-gha-rs-kube-mode17Role providing necessary permissions for the hookThis is created when the container mode is set to "kubernetes" and template.spec.serviceAccount is not provided.kube_mode_serviceaccount.yamlServiceAccountINSTALLATION_NAME-gha-rs-kube-mode17Service account bound to the runner pod.This is created when the container mode is set to "kubernetes" and template.spec.serviceAccount is not provided.
About custom resources
ARC consists of several custom resource definitions (CRDs). For more information on custom resources, see Custom Resources in the Kubernetes documentation. You can find the list of custom resource definitions used for ARC in the following API schema definitions.

actions.github.com/v1alpha1
actions.summerwind.net/v1alpha1

Because custom resources are extensions of the Kubernetes API, they won't be available in a default Kubernetes installation. You will need to install these custom resources to use ARC. For more information on installing custom resources, see Quickstart for Actions Runner Controller.
Once the custom resources are installed, you can deploy ARC into your Kubernetes cluster. For information about deploying ARC, see Deploying runner scale sets with Actions Runner Controller.
About the runner container image
GitHub maintains a minimal runner container image. A new image will be published with every runner binaries release. The most recent image will have the runner binaries version and latest as tags.
This image contains the least amount of packages necessary for the container runtime and the runner binaries. To install additional software, you can create your own runner image. You can use ARC's runner image as a base, or use the corresponding setup actions. For instance, actions/setup-java for Java or actions/setup-node for Node.
You can find the definition of ARC's runner image in this Dockerfile and the definition of the base image in this Dockerfile.
Creating your own runner image
You can create your own runner image that meets your requirements. Your runner image must fulfill the following conditions.


Use a base image that can run the self-hosted runner application. For more information, see Managing self-hosted runners.


The runner binary must be placed under /home/runner/ and launched using /home/runner/run.sh.


If you use Kubernetes mode, the runner container hooks must be placed under /home/runner/k8s.


You can use the following example Dockerfile to start creating your own runner image.
DockerfileFROM mcr.microsoft.com/dotnet/runtime-deps:6.0 as build

# Replace value with the latest runner release version
# source: https://github.com/actions/runner/releases
# ex: 2.303.0
ARG RUNNER_VERSION=""
ARG RUNNER_ARCH="x64"
# Replace value with the latest runner-container-hooks release version
# source: https://github.com/actions/runner-container-hooks/releases
# ex: 0.3.1
ARG RUNNER_CONTAINER_HOOKS_VERSION=""

ENV DEBIAN_FRONTEND=noninteractive
ENV RUNNER_MANUALLY_TRAP_SIG=1
ENV ACTIONS_RUNNER_PRINT_LOG_TO_STDOUT=1

RUN apt update -y && apt install curl unzip -y

RUN adduser --disabled-password --gecos "" --uid 1001 runner \
    && groupadd docker --gid 123 \
    && usermod -aG sudo runner \
    && usermod -aG docker runner \
    && echo "%sudo ALL=(ALL:ALL) NOPASSWD:ALL" > /etc/sudoers \
    && echo "Defaults env_keep += \"DEBIAN_FRONTEND\"" >> /etc/sudoers

WORKDIR /home/runner

RUN curl -f -L -o runner.tar.gz https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-${RUNNER_ARCH}-${RUNNER_VERSION}.tar.gz \
    && tar xzf ./runner.tar.gz \
    && rm runner.tar.gz

RUN curl -f -L -o runner-container-hooks.zip https://github.com/actions/runner-container-hooks/releases/download/v${RUNNER_CONTAINER_HOOKS_VERSION}/actions-runner-hooks-k8s-${RUNNER_CONTAINER_HOOKS_VERSION}.zip \
    && unzip ./runner-container-hooks.zip -d ./k8s \
    && rm runner-container-hooks.zip

USER runner
FROM mcr.microsoft.com/dotnet/runtime-deps:6.0 as build

# Replace value with the latest runner release version
# source: https://github.com/actions/runner/releases
# ex: 2.303.0
ARG RUNNER_VERSION=""
ARG RUNNER_ARCH="x64"
# Replace value with the latest runner-container-hooks release version
# source: https://github.com/actions/runner-container-hooks/releases
# ex: 0.3.1
ARG RUNNER_CONTAINER_HOOKS_VERSION=""

ENV DEBIAN_FRONTEND=noninteractive
ENV RUNNER_MANUALLY_TRAP_SIG=1
ENV ACTIONS_RUNNER_PRINT_LOG_TO_STDOUT=1

RUN apt update -y && apt install curl unzip -y

RUN adduser --disabled-password --gecos "" --uid 1001 runner \
    && groupadd docker --gid 123 \
    && usermod -aG sudo runner \
    && usermod -aG docker runner \
    && echo "%sudo ALL=(ALL:ALL) NOPASSWD:ALL" > /etc/sudoers \
    && echo "Defaults env_keep += \"DEBIAN_FRONTEND\"" >> /etc/sudoers

WORKDIR /home/runner

RUN curl -f -L -o runner.tar.gz https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-${RUNNER_ARCH}-${RUNNER_VERSION}.tar.gz \
    && tar xzf ./runner.tar.gz \
    && rm runner.tar.gz

RUN curl -f -L -o runner-container-hooks.zip https://github.com/actions/runner-container-hooks/releases/download/v${RUNNER_CONTAINER_HOOKS_VERSION}/actions-runner-hooks-k8s-${RUNNER_CONTAINER_HOOKS_VERSION}.zip \
    && unzip ./runner-container-hooks.zip -d ./k8s \
    && rm runner-container-hooks.zip

USER runner

Executing workflows
After installation and configuration are complete, you can use ARC to execute workflow runs. A workflow can be created in the same repository that can target a self hosted runner created by ARC. For more information about targeting workflows to run on self-hosted runners, see Using self-hosted runners in a workflow.
Using ARC runners in a workflow
You cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation or by defining the value of the runnerScaleSetName field in your values.yaml file. These are used as the 'single label' to use as your runs-on target. For more information, see Using Actions Runner Controller runners in a workflow.
Scaling runners
You can scale runners statically or dynamically depending on your needs. For more information, see Deploying runner scale sets with Actions Runner Controller.
Software installed in the ARC runner image
The ARC runner image is bundled with the following software:

Runner binaries
Runner container hooks
Docker (required for Docker-in-Docker mode)

For more information, see ARC's runner image Dockerfile in the Actions repository.
Assets and releases
ARC is released as two Helm charts and one container image. The Helm charts are only published as Open Container Initiative (OCI) packages. ARC does not provide tarballs or Helm repositories via GitHub Pages.
You can find the latest releases of ARC's Helm charts and container image on GitHub Packages:

gha-runner-scale-set-controller Helm chart
gha-runner-scale-set Helm chart
gha-runner-scale-set-controller container image

The supported runner image is released as a separate container image, which you can find at actions-runner on GitHub Packages.
Legal notice
Portions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:
Copyright 2019 Moto Ishizawa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/QuickstartQuickstart for Actions Runner ControllerTry out Actions Runner Controller in 5 minutes.In this articleIntroductionPrerequisitesInstalling Actions Runner ControllerConfiguring a runner scale setUsing runner scale setsNext stepsLegal noticeLegal notice
Introduction
Actions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, see Operator pattern in the Kubernetes documentation.
With ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, see Autoscaling with self-hosted runners.
You can set up ARC on Kubernetes using Helm, then create and run a workflow that uses runner scale sets. For more information about runner scale sets, see Deploying runner scale sets with Actions Runner Controller.
Prerequisites
In order to use ARC, ensure you have the following.


A Kubernetes cluster


For a managed cloud environment, you can use AKS. For more information, see Azure Kubernetes Service in the Azure documentation.


For a local setup, you can use minikube or kind. For more information, see minikube start in the minikube documentation and kind in the kind documentation.
Note

OpenShift clusters are currently unsupported.





Helm 3

For more information, see Installing Helm in the Helm documentation.



While it is not required for ARC to be deployed, we recommend ensuring you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners before deploying ARC in production workflows.


Installing Actions Runner Controller


To install the operator and the custom resource definitions (CRDs) in your cluster, do the following.

In your Helm chart, update the NAMESPACE value to the location you want your operator pods to be created. This namespace must allow access to the Kubernetes API server.
Install the Helm chart.

The following example installs the latest version of the chart. To install a specific version, you can pass the --version argument along with the version of the chart you wish to install. You can find the list of releases in the GitHub Container Registry.
BashNAMESPACE="arc-systems"
helm install arc \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controller
NAMESPACE="arc-systems"
helm install arc \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controller

For additional Helm configuration options, see values.yaml in the ARC documentation.


To enable ARC to authenticate to GitHub, generate a personal access token (classic). For more information, see Authenticating to the GitHub API.


Configuring a runner scale set


To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.
When you run the command, keep the following in mind.


Update the INSTALLATION_NAME value carefully. You will use the installation name as the value of runs-on in your workflows. For more information, see Workflow syntax for GitHub Actions.


Update the NAMESPACE value to the location you want the runner pods to be created.


Set GITHUB_CONFIG_URL to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.


This example command installs the latest version of the Helm chart. To install a specific version, you can pass the --version argument with the version of the chart you wish to install. You can find the list of releases in the GitHub Container Registry.
Note


As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.
As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, see Deploying runner scale sets with Actions Runner Controller.


BashINSTALLATION_NAME="arc-runner-set"
NAMESPACE="arc-runners"
GITHUB_CONFIG_URL="https://github.com/<your_enterprise/org/repo>"
GITHUB_PAT="<PAT>"
helm install "${INSTALLATION_NAME}" \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    --set githubConfigUrl="${GITHUB_CONFIG_URL}" \
    --set githubConfigSecret.github_token="${GITHUB_PAT}" \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set
INSTALLATION_NAME="arc-runner-set"
NAMESPACE="arc-runners"
GITHUB_CONFIG_URL="https://github.com/<your_enterprise/org/repo>"
GITHUB_PAT="<PAT>"
helm install "${INSTALLATION_NAME}" \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    --set githubConfigUrl="${GITHUB_CONFIG_URL}" \
    --set githubConfigSecret.github_token="${GITHUB_PAT}" \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set

For additional Helm configuration options, see values.yaml in the ARC documentation.




From your terminal, run the following command to check your installation.
Bashhelm list -A
helm list -A

You should see an output similar to the following.
NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION
arc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0
arc-runner-set  arc-runners     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0



To check the manager pod, run the following command in your terminal.
Bashkubectl get pods -n arc-systems
kubectl get pods -n arc-systems

If everything was installed successfully, the status of the pods shows as Running.
NAME                                                   READY   STATUS    RESTARTS   AGE
arc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s
arc-runner-set-754b578d-listener                       1/1     Running   0          12s



If your installation was not successful, see Troubleshooting Actions Runner Controller errors for troubleshooting information.
Using runner scale sets
Now you will create and run a simple test workflow that uses the runner scale set runners.


In a repository, create a workflow similar to the following example. The runs-on value should match the Helm installation name you used when you installed the autoscaling runner set.
For more information on adding workflows to a repository, see Quickstart for GitHub Actions.
YAMLname: Actions Runner Controller Demo
on:
  workflow_dispatch:

jobs:
  Explore-GitHub-Actions:
    # You need to use the INSTALLATION_NAME from the previous step
    runs-on: arc-runner-set
    steps:
    - run: echo "🎉 This job uses runner scale set runners!"
name: Actions Runner Controller Demo
on:
  workflow_dispatch:

jobs:
  Explore-GitHub-Actions:
    # You need to use the INSTALLATION_NAME from the previous step
    runs-on: arc-runner-set
    steps:
    - run: echo "🎉 This job uses runner scale set runners!"



Once you've added the workflow to your repository, manually trigger the workflow. For more information, see Manually running a workflow.


To view the runner pods being created while the workflow is running, run the following command from your terminal.
Bashkubectl get pods -n arc-runners
kubectl get pods -n arc-runners

A successful output will look similar to the following.
NAMESPACE     NAME                                                  READY   STATUS    RESTARTS      AGE
arc-runners   arc-runner-set-rmrgw-runner-p9p5n                     1/1     Running   0             21s



Next steps
Actions Runner Controller can help you efficiently manage your GitHub Actions runners. Ready to get started? Here are some helpful resources for taking your next steps with ARC:

For detailed authentication information, see Authenticating to the GitHub API.
For help using ARC runners in your workflows, see Using Actions Runner Controller runners in a workflow.
For deployment information, see Deploying runner scale sets with Actions Runner Controller.

Legal notice
Portions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:
Copyright 2019 Moto Ishizawa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/AuthenticatingAuthenticating to the GitHub APILearn how to authenticate to the GitHub API to use Actions Runner Controller with GitHub.In this articleOverviewAuthenticating ARC with a GitHub AppAuthenticating ARC with a personal access token (classic)Legal noticeLegal notice
Overview
You can authenticate Actions Runner Controller (ARC) to the GitHub API by using a GitHub App or by using a personal access token (classic).
Note

You cannot authenticate using a GitHub App for runners at the enterprise level. For more information, see Managing access to self-hosted runners using groups.

Authenticating ARC with a GitHub App


Create a GitHub App that is owned by an organization. For more information, see Registering a GitHub App. Configure the GitHub App as follows.


For "Homepage URL," enter https://github.com/actions/actions-runner-controller.


Under "Permissions," click Repository permissions. Then use the dropdown menus to select the following access permissions.


Administration: Read and write
Note

Administration: Read and write is only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope.



Metadata: Read-only




Under "Permissions," click Organization permissions. Then use the dropdown menus to select the following access permissions.

Self-hosted runners: Read and write





After creating the GitHub App, on the GitHub App's page, note the value for "App ID". You will use this value later.


Under "Private keys", click Generate a private key, and save the .pem file. You will use this key later.


In the menu at the top-left corner of the page, click Install app, and next to your organization, click Install to install the app on your organization.


After confirming the installation permissions on your organization, note the app installation ID. You will use it later. You can find the app installation ID on the app installation page, which has the following URL format:
https://github.com/organizations/ORGANIZATION/settings/installations/INSTALLATION_ID


Register the app ID, installation ID, and the downloaded .pem private key file from the previous steps to Kubernetes as a secret.
To create a Kubernetes secret with the values of your GitHub App, run the following command.
Note

Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.

Bashkubectl create secret generic pre-defined-secret \
   --namespace=arc-runners \
   --from-literal=github_app_id=123456 \
   --from-literal=github_app_installation_id=654321 \
   --from-literal=github_app_private_key='-----BEGIN RSA PRIVATE KEY-----********'
kubectl create secret generic pre-defined-secret \
   --namespace=arc-runners \
   --from-literal=github_app_id=123456 \
   --from-literal=github_app_installation_id=654321 \
   --from-literal=github_app_private_key='-----BEGIN RSA PRIVATE KEY-----********'

Then using the githubConfigSecret property in your copy of the values.yaml file, pass the secret name as a reference.
githubConfigSecret: pre-defined-secret



For additional Helm configuration options, see values.yaml in the ARC repository.
Authenticating ARC with a personal access token (classic)
ARC can use personal access tokens (classic) to register self-hosted runners.


Create a personal access token (classic) with the required scopes. The required scopes are different depending on whether you are registering runners at the repository or organization level. For more information on how to create a personal access token (classic), see Managing your personal access tokens.
The following is the list of required personal access token scopes for ARC runners.

Repository runners: repo
Organization runners: admin:org



To create a Kubernetes secret with the value of your personal access token (classic), use the following command.
Note

Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.

Bashkubectl create secret generic pre-defined-secret \
   --namespace=arc-runners \
   --from-literal=github_token='YOUR-PAT'
kubectl create secret generic pre-defined-secret \
   --namespace=arc-runners \
   --from-literal=github_token='YOUR-PAT'



In your copy of the values.yaml file, pass the secret name as a reference.
githubConfigSecret: pre-defined-secret

For additional Helm configuration options, see values.yaml in the ARC repository.


Legal notice
Portions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:
Copyright 2019 Moto Ishizawa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/Deploying runner scale setsDeploying runner scale sets with Actions Runner ControllerLearn how to deploy runner scale sets with Actions Runner Controller, and use advanced configuration options to tailor Actions Runner Controller to your needs.In this articleAbout runner scale setsDeploying a runner scale setUsing advanced configuration optionsUsing Docker-in-Docker or Kubernetes mode for containersEnabling metricsUpgrading ARCHigh availability and automatic failoverUsing ARC across organizationsLegal noticeLegal notice
About runner scale sets
Runner scale sets is a group of homogeneous runners that can be assigned jobs from GitHub Actions. The number of active runners owned by a runner scale set can be controlled by auto-scaling runner solutions such as Actions Runner Controller (ARC).
You can use runner groups to manage runner scale sets. Similar to self-hosted runners, you can add runner scale sets to existing runner groups. However, runner scale sets can belong to only one runner group at a time and can only have one label assigned to them. For more information on runner groups, see Managing access to self-hosted runners using groups.
To assign jobs to a runner scale set, you must configure your workflow to reference the runner scale set's name. For more information, see Using Actions Runner Controller runners in a workflow.
Deploying a runner scale set
To deploy a runner scale set, you must have ARC up and running. For more information, see Quickstart for Actions Runner Controller.
You can deploy runner scale sets with ARC's Helm charts or by deploying the necessary manifests. Using ARC's Helm charts is the preferred method, especially if you do not have prior experience using ARC.
Note


As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.
As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk.
We recommend running production workloads in isolation. GitHub Actions workflows are designed to run arbitrary code, and using a shared Kubernetes cluster for production workloads could pose a security risk.
Ensure you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners.




To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.
When you run the command, keep the following in mind.


Update the INSTALLATION_NAME value carefully. You will use the installation name as the value of runs-on in your workflows.


Update the NAMESPACE value to the location you want the runner pods to be created.


Set the GITHUB_CONFIG_URL value to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.


This example command installs the latest version of the Helm chart. To install a specific version, you can pass the --version argument with the version of the chart you want to install. You can find the list of releases in the actions-runner-controller repository.
BashINSTALLATION_NAME="arc-runner-set"
NAMESPACE="arc-runners"
GITHUB_CONFIG_URL="https://github.com/<your_enterprise/org/repo>"
GITHUB_PAT="<PAT>"
helm install "${INSTALLATION_NAME}" \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    --set githubConfigUrl="${GITHUB_CONFIG_URL}" \
    --set githubConfigSecret.github_token="${GITHUB_PAT}" \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set
INSTALLATION_NAME="arc-runner-set"
NAMESPACE="arc-runners"
GITHUB_CONFIG_URL="https://github.com/<your_enterprise/org/repo>"
GITHUB_PAT="<PAT>"
helm install "${INSTALLATION_NAME}" \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    --set githubConfigUrl="${GITHUB_CONFIG_URL}" \
    --set githubConfigSecret.github_token="${GITHUB_PAT}" \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set

For additional Helm configuration options, see values.yaml in the ARC repository.




To check your installation, run the following command in your terminal.
Bashhelm list -A
helm list -A

You should see an output similar to the following.
NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION
arc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0
arc-runner-set  arc-systems     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0



To check the manager pod, run the following command in your terminal.
Bashkubectl get pods -n arc-systems
kubectl get pods -n arc-systems

If the installation was successful, the pods will show the Running status.
NAME                                                   READY   STATUS    RESTARTS   AGE
arc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s
arc-runner-set-754b578d-listener                       1/1     Running   0          12s



If your installation was not successful, see Troubleshooting Actions Runner Controller errors for troubleshooting information.
Using advanced configuration options
ARC offers several advanced configuration options.
Configuring the runner scale set name
Note

Runner scale set names are unique within the runner group they belong to. If you want to deploy multiple runner scale sets with the same name, they must belong to different runner groups.

To configure the runner scale set name, you can define an INSTALLATION_NAME or set the value of runnerScaleSetName in your copy of the values.yaml file.
## The name of the runner scale set to create, which defaults to the Helm release name
runnerScaleSetName: "my-runners"

Make sure to pass the values.yaml file in your helm install command. See the Helm Install documentation for more details.
Choosing runner destinations
Runner scale sets can be deployed at the repository, organization, or enterprise levels.
To deploy runner scale sets to a specific level, set the value of githubConfigUrl in your copy of the values.yaml to the URL of your repository, organization, or enterprise.
The following example shows how to configure ARC to add runners to octo-org/octo-repo.
githubConfigUrl: "https://github.com/octo-ent/octo-org/octo-repo"

For additional Helm configuration options, see values.yaml in the ARC repository.
Using a GitHub App for authentication
If you are not using enterprise-level runners, you can use GitHub Apps to authenticate with the GitHub API. For more information, see Authenticating to the GitHub API.
Note

Given the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead.

You can either create a Kubernetes secret, or specify values in your values.yaml file.
Option 1: Create a Kubernetes secret (recommended)
Once you have created your GitHub App, create a Kubernetes secret and pass the reference to that secret in your copy of the values.yaml file.
Note

Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.

kubectl create secret generic pre-defined-secret \
  --namespace=arc-runners \
  --from-literal=github_app_id=123456 \
  --from-literal=github_app_installation_id=654321 \
  --from-file=github_app_private_key=private-key.pem

In your copy of the values.yaml pass the secret name as a reference.
githubConfigSecret: pre-defined-secret

Option 2: Specify values in your values.yaml file
Alternatively, you can specify the values of app_id, installation_id and private_key in your copy of the values.yaml file.
## githubConfigSecret is the Kubernetes secret to use when authenticating with GitHub API.
## You can choose to use a GitHub App or a personal access token (classic)
githubConfigSecret:
  ## GitHub Apps Configuration
  ## IDs must be strings, use quotes
  github_app_id: "123456"
  github_app_installation_id: "654321"
  github_app_private_key: |
    -----BEGIN RSA PRIVATE KEY-----
    ...
    HkVN9...
    ...
    -----END RSA PRIVATE KEY-----

For additional Helm configuration options, see values.yaml in the ARC repository.
Managing access with runner groups
You can use runner groups to control which organizations or repositories have access to your runner scale sets. For more information on runner groups, see Managing access to self-hosted runners using groups.
To add a runner scale set to a runner group, you must already have a runner group created. Then set the runnerGroup property in your copy of the values.yaml file. The following example adds a runner scale set to the Octo-Group runner group.
runnerGroup: "Octo-Group"

For additional Helm configuration options, see values.yaml in the ARC repository.
Configuring an outbound proxy
To force HTTP traffic for the controller and runners to go through your outbound proxy, set the following properties in your Helm chart.
proxy:
  http:
    url: http://proxy.com:1234
    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys
  https:
    url: http://proxy.com:1234
    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys
  noProxy:
    - example.com
    - example.org

ARC supports using anonymous or authenticated proxies. If you use authenticated proxies, you will need to set the credentialSecretRef value to reference a Kubernetes secret. You can create a secret with your proxy credentials with the following command.
Note

Create the secret in the same namespace where the gha-runner-scale-set chart is installed. In this example, the namespace is arc-runners to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.

Bash  kubectl create secret generic proxy-auth \
    --namespace=arc-runners \
    --from-literal=username=proxyUsername \
    --from-literal=password=proxyPassword \
  kubectl create secret generic proxy-auth \
    --namespace=arc-runners \
    --from-literal=username=proxyUsername \
    --from-literal=password=proxyPassword \

For additional Helm configuration options, see values.yaml in the ARC repository.
Setting the maximum and minimum number of runners
The maxRunners and minRunners properties provide you with a range of options to customize your ARC setup.
Note

ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule.

Example: Unbounded number of runners
If you comment out both the maxRunners and minRunners properties, ARC will scale up to the number of jobs assigned to the runner scale set and will scale down to 0 if there aren't any active jobs.
## maxRunners is the max number of runners the auto scaling runner set will scale up to.
# maxRunners: 0

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
# minRunners: 0

Example: Minimum number of runners
You can set the minRunners property to any number and ARC will make sure there is always the specified number of runners active and available to take jobs assigned to the runner scale set at all times.
## maxRunners is the max number of runners the auto scaling runner set will scale up to.
# maxRunners: 0

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 20

Example: Set maximum and minimum number of runners
In this configuration, Actions Runner Controller will scale up to a maximum of 30 runners and will scale down to 20 runners when the jobs are complete.
Note

The value of minRunners can never exceed that of maxRunners, unless maxRunners is commented out.

## maxRunners is the max number of runners the auto scaling runner set will scale up to.
maxRunners: 30

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 20

Example: Jobs queue draining
In certain scenarios you might want to drain the jobs queue to troubleshoot a problem or to perform maintenance on your cluster. If you set both properties to 0, Actions Runner Controller will not create new runner pods when new jobs are available and assigned.
## maxRunners is the max number of runners the auto scaling runner set will scale up to.
maxRunners: 0

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 0

Custom TLS certificates
Note

If you are using a custom runner image that is not based on the Debian distribution, the following instructions will not work.

Some environments require TLS certificates that are signed by a custom certificate authority (CA). Since the custom certificate authority certificates are not bundled with the controller or runner containers, you must inject them into their respective trust stores.
githubServerTLS:
  certificateFrom:
    configMapKeyRef:
      name: config-map-name
      key: ca.crt
  runnerMountPath: /usr/local/share/ca-certificates/

When you do this, ensure you are using the Privacy Enhanced Mail (PEM) format and that the extension of your certificate is .crt. Anything else will be ignored.
The controller executes the following actions.

Creates a github-server-tls-cert volume containing the certificate specified in certificateFrom.
Mounts that volume on path runnerMountPath/<certificate name>.
Sets the NODE_EXTRA_CA_CERTS environment variable to that same path.
Sets the RUNNER_UPDATE_CA_CERTS environment variable to 1 (as of version 2.303.0, this will instruct the runner to reload certificates on the host).

ARC observes values set in the runner pod template and does not overwrite them.
For additional Helm configuration options, see values.yaml in the ARC repository.
Using a private container registry
Warning

This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.
For more information about what GitHub Support can assist with, see About support for Actions Runner Controller.

To use a private container registry, you can copy the controller image and runner image to your private container registry. Then configure the links to those images and set the imagePullPolicy and imagePullSecrets values.
Configuring the controller image
You can update your copy of the values.yaml file and set the image properties as follows.
image:
  repository: "custom-registry.io/gha-runner-scale-set-controller"
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "0.4.0"

imagePullSecrets:
  - name: <registry-secret-name>

The listener container inherits the imagePullPolicy defined for the controller.
Configuring the runner image
You can update your copy of the values.yaml file and set the template.spec properties as follows.
template:
  spec:
    containers:
      - name: runner
        image: "custom-registry.io/actions-runner:latest"
        imagePullPolicy: Always
        command: ["/home/runner/run.sh"]
    imagePullSecrets:
      - name: <registry-secret-name>

For additional Helm configuration options, see values.yaml in the ARC repository.
Updating the pod specification for the runner pod
Warning

This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.
For more information about what GitHub Support can assist with, see About support for Actions Runner Controller.

You can fully customize the PodSpec of the runner pod and the controller will apply the configuration you specify. The following is an example pod specification.
template:
  spec:
    containers:
      - name: runner
        image: ghcr.io/actions/actions-runner:latest
        command: ["/home/runner/run.sh"]
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
        securityContext:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            add:
              - NET_ADMIN

For additional Helm configuration options, see values.yaml in the ARC repository.
Updating the pod specification for the listener pod
Warning

This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.
For more information about what GitHub Support can assist with, see About support for Actions Runner Controller.

You can customize the PodSpec of the listener pod and the controller will apply the configuration you specify. The following is an example pod specification.
Note

It's important to not change the listenerTemplate.spec.containers.name value of the listener container. Otherwise, the configuration you specify will be applied to a new side-car container.

listenerTemplate:
  spec:
    containers:
    # If you change the name of the container, the configuration will not be applied to the listener,
    # and it will be treated as a side-car container.
    - name: listener
      securityContext:
        runAsUser: 1000
      resources:
        limits:
          cpu: "1"
          memory: 1Gi
        requests:
          cpu: "1"
          memory: 1Gi

For additional Helm configuration options, see values.yaml in the ARC repository.
Using Docker-in-Docker or Kubernetes mode for containers
Warning

This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly.
For more information about what GitHub Support can assist with, see About support for Actions Runner Controller.

If you are using container jobs and services or container actions, the containerMode value must be set to dind or kubernetes.

For more information on container jobs and services, see Running jobs in a container.
For more information on container actions, see Creating a Docker container action.

Using Docker-in-Docker mode
Note

The Docker-in-Docker container requires privileged mode. For more information, see Configure a Security Context for a Pod or Container in the Kubernetes documentation.
By default, the dind container uses the docker:dind image, which runs the Docker daemon as root. You can replace this image with docker:dind-rootless as long as you are aware of the known limitations and run the pods with --privileged mode. To learn how to customize the Docker-in-Docker configuration, see Customizing container modes.

Docker-in-Docker mode is a configuration that allows you to run Docker inside a Docker container. In this configuration, for each runner pod created, ARC creates the following containers.

An init container
A runner container
A dind container

To enable Docker-in-Docker mode, set the containerMode.type to dind as follows.
containerMode:
  type: "dind"

The template.spec will be updated to the following default configuration.
template:
  spec:
    initContainers:
      - name: init-dind-externals
        image: ghcr.io/actions/actions-runner:latest
        command:
          ["cp", "-r", "/home/runner/externals/.", "/home/runner/tmpDir/"]
        volumeMounts:
          - name: dind-externals
            mountPath: /home/runner/tmpDir
    containers:
      - name: runner
        image: ghcr.io/actions/actions-runner:latest
        command: ["/home/runner/run.sh"]
        env:
          - name: DOCKER_HOST
            value: unix:///var/run/docker.sock
        volumeMounts:
          - name: work
            mountPath: /home/runner/_work
          - name: dind-sock
            mountPath: /var/run
      - name: dind
        image: docker:dind
        args:
          - dockerd
          - --host=unix:///var/run/docker.sock
          - --group=$(DOCKER_GROUP_GID)
        env:
          - name: DOCKER_GROUP_GID
            value: "123"
        securityContext:
          privileged: true
        volumeMounts:
          - name: work
            mountPath: /home/runner/_work
          - name: dind-sock
            mountPath: /var/run
          - name: dind-externals
            mountPath: /home/runner/externals
    volumes:
      - name: work
        emptyDir: {}
      - name: dind-sock
        emptyDir: {}
      - name: dind-externals
        emptyDir: {}

The values in template.spec are automatically injected and cannot be overridden. If you want to customize this setup, you must unset containerMode.type, then copy this configuration and apply it directly in your copy of the values.yaml file.
For additional Helm configuration options, see values.yaml in the ARC repository.
Using Kubernetes mode
In Kubernetes mode, ARC uses runner container hooks to create a new pod in the same namespace to run the service, container job, or action.
Prerequisites
Kubernetes mode relies on persistent volumes to share job details between the runner pod and the container job pod. For more information, see the Persistent Volumes section in the Kubernetes documentation.
To use Kubernetes mode, you must do the following.

Create persistent volumes available for the runner pods to claim.
Use a solution to automatically provision persistent volumes on demand.

For testing, you can use a solution like OpenEBS.
Configuring Kubernetes mode
To enable Kubernetes mode, set the containerMode.type to kubernetes in your values.yaml file.
containerMode:
  type: "kubernetes"
  kubernetesModeWorkVolumeClaim:
    accessModes: ["ReadWriteOnce"]
    storageClassName: "dynamic-blob-storage"
    resources:
      requests:
        storage: 1Gi

For additional Helm configuration options, see values.yaml in the ARC repository.
Note

When Kubernetes mode is enabled, workflows that are not configured with a container job will fail with an error similar to:
Jobs without a job container are forbidden on this runner, please add a 'container:' to your job or contact your self-hosted runner administrator.

To allow jobs without a job container to run, set ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER to false on your runner container. This instructs the runner to disable this check.
template:
  spec:
    containers:
      - name: runner
        image: ghcr.io/actions/actions-runner:latest
        command: ["/home/runner/run.sh"]
        env:
          - name: ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER
            value: "false"


Customizing container modes
When you set the containerMode in the values.yaml file for the gha-runner-scale-set helm chart, you can use either of the following values:

dind or
kubernetes

Depending on which value you set for the containerMode, a configuration will automatically be injected into the template section of the values.yaml file for the gha-runner-scale-set helm chart.

See the dind configuration.
See the kubernetes configuration.

To customize the spec, comment out or remove containerMode, and append the configuration you want in the template section.
Example: running dind-rootless
Before deciding to run dind-rootless, make sure you are aware of known limitations.
## githubConfigUrl is the GitHub url for where you want to configure runners
## ex: https://github.com/myorg/myrepo or https://github.com/myorg
githubConfigUrl: "https://github.com/actions/actions-runner-controller"

## githubConfigSecret is the k8s secrets to use when auth with GitHub API.
## You can choose to use GitHub App or a PAT token
githubConfigSecret: my-super-safe-secret

## maxRunners is the max number of runners the autoscaling runner set will scale up to.
maxRunners: 5

## minRunners is the min number of idle runners. The target number of runners created will be
## calculated as a sum of minRunners and the number of jobs assigned to the scale set.
minRunners: 0

runnerGroup: "my-custom-runner-group"

## name of the runner scale set to create. Defaults to the helm release name
runnerScaleSetName: "my-awesome-scale-set"

## template is the PodSpec for each runner Pod
## For reference: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec
template:
  spec:
    initContainers:
    - name: init-dind-externals
      image: ghcr.io/actions/actions-runner:latest
      command: ["cp", "-r", "/home/runner/externals/.", "/home/runner/tmpDir/"]
      volumeMounts:
        - name: dind-externals
          mountPath: /home/runner/tmpDir
    - name: init-dind-rootless
      image: docker:dind-rootless
      command:
        - sh
        - -c
        - |
          set -x
          cp -a /etc/. /dind-etc/
          echo 'runner:x:1001:1001:runner:/home/runner:/bin/ash' >> /dind-etc/passwd
          echo 'runner:x:1001:' >> /dind-etc/group
          echo 'runner:100000:65536' >> /dind-etc/subgid
          echo 'runner:100000:65536' >> /dind-etc/subuid
          chmod 755 /dind-etc;
          chmod u=rwx,g=rx+s,o=rx /dind-home
          chown 1001:1001 /dind-home
      securityContext:
        runAsUser: 0
      volumeMounts:
        - mountPath: /dind-etc
          name: dind-etc
        - mountPath: /dind-home
          name: dind-home
    containers:
    - name: runner
      image: ghcr.io/actions/actions-runner:latest
      command: ["/home/runner/run.sh"]
      env:
        - name: DOCKER_HOST
          value: unix:///run/user/1001/docker.sock
      securityContext:
        privileged: true
        runAsUser: 1001
        runAsGroup: 1001
      volumeMounts:
        - name: work
          mountPath: /home/runner/_work
        - name: dind-sock
          mountPath: /run/user/1001
    - name: dind
      image: docker:dind-rootless
      args:
        - dockerd
        - --host=unix:///run/user/1001/docker.sock
      securityContext:
        privileged: true
        runAsUser: 1001
        runAsGroup: 1001
      volumeMounts:
        - name: work
          mountPath: /home/runner/_work
        - name: dind-sock
          mountPath: /run/user/1001
        - name: dind-externals
          mountPath: /home/runner/externals
        - name: dind-etc
          mountPath: /etc
        - name: dind-home
          mountPath: /home/runner
    volumes:
    - name: work
      emptyDir: {}
    - name: dind-externals
      emptyDir: {}
    - name: dind-sock
      emptyDir: {}
    - name: dind-etc
      emptyDir: {}
    - name: dind-home
      emptyDir: {}

Understanding runner-container-hooks
When the runner detects a workflow run that uses a container job, service container, or Docker action, it will call runner-container-hooks to create a new pod. The runner relies on runner-container-hooks to call the Kubernetes APIs and create a new pod in the same namespace as the runner pod. This newly created pod will be used to run the container job, service container, or Docker action. For more information, see the runner-container-hooks repository.
Configuring hook extensions
As of ARC version 0.4.0, runner-container-hooks support hook extensions. You can use these to configure the pod created by runner-container-hooks. For example, you could use a hook extension to set a security context on the pod. Hook extensions allow you to specify a YAML file that is used to update the PodSpec of the pod created by runner-container-hooks.
There are two options to configure hook extensions.

Store in your custom runner image. You can store the PodSpec in a YAML file anywhere in your custom runner image. For more information, see About Actions Runner Controller.
Store in a ConfigMap. You can create a config map with the PodSpec and mount that config map in the runner container. For more information, see ConfigMaps in the Kubernetes documentation.

Note

With both options, you must set the ACTIONS_RUNNER_CONTAINER_HOOK_TEMPLATE environment variable in the runner container spec to point to the path of the YAML file mounted in the runner container.

Example: Using config map to set securityContext
Create a config map in the same namespace as the runner pods. For example:
apiVersion: v1
kind: ConfigMap
metadata:
  name: hook-extension
  namespace: arc-runners
data:
  content: |
    metadata:
      annotations:
        example: "extension"
    spec:
      containers:
        - name: "$job" # Target the job container
          securityContext:
            runAsUser: 1000


The .metadata.labels and metadata.annotations fields will be appended as is, unless their keys are reserved. You cannot override the .metadata.name and metadata.namespace fields.
The majority of the PodSpec fields are applied from the specified template, and will override the values passed from your Helm chart values.yaml file.
If you specify additional volumes they will be appended to the default volumes specified by the runner.
The spec.containers are merged based on the names assigned to them.

If the name of the container is $job:

The spec.containers.name and spec.containers.image fields are ignored.
The spec.containers.env, spec.containers.volumeMounts, and spec.containers.ports fields are appended to the default container spec created by the hook.
The rest of the fields are applied as provided.


If the name of the container is not $job, the fields will be added to the pod definition as they are.



Enabling metrics
Note

Metrics for ARC are available as of version gha-runner-scale-set-0.5.0.

ARC can emit metrics about your runners, your jobs, and time spent on executing your workflows. Metrics can be used to identify congestion, monitor the health of your ARC deployment, visualize usage trends, optimize resource consumption, among many other use cases. Metrics are emitted by the controller-manager and listener pods in Prometheus format. For more information, see Exposition formats in the Prometheus documentation.
To enable metrics for ARC, configure the metrics property in the values.yaml file of the gha-runner-scale-set-controller chart.
The following is an example configuration.
metrics:
  controllerManagerAddr: ":8080"
  listenerAddr: ":8080"
  listenerEndpoint: "/metrics"

Note

If the metrics: object is not provided or is commented out, the following flags will be applied to the controller-manager and listener pods with empty values: --metrics-addr, --listener-metrics-addr, --listener-metrics-endpoint. This will disable metrics for ARC.

Once these properties are configured, your controller-manager and listener pods emit metrics via the listenerEndpoint bound to the ports that you specify in your values.yaml file. In the above example, the endpoint is /metrics and the port is :8080. You can use this endpoint to scrape metrics from your controller-manager and listener pods.
To turn off metrics, update your values.yaml file by removing or commenting out the metrics: object and its properties.
Available metrics for ARC
The following table shows the metrics emitted by the controller-manager and listener pods.
Note

The metrics that the controller-manager emits pertain to the controller runtime and are not owned by GitHub.












































































































OwnerMetricTypeDescriptioncontroller-managergha_controller_pending_ephemeral_runnersgaugeNumber of ephemeral runners in a pending statecontroller-managergha_controller_running_ephemeral_runnersgaugeNumber of ephemeral runners in a running statecontroller-managergha_controller_failed_ephemeral_runnersgaugeNumber of ephemeral runners in a failed statecontroller-managergha_controller_running_listenersgaugeNumber of listeners in a running statelistenergha_assigned_jobsgaugeNumber of jobs assigned to the runner scale setlistenergha_running_jobsgaugeNumber of jobs running or queued to runlistenergha_registered_runnersgaugeNumber of runners registered by the runner scale setlistenergha_busy_runnersgaugeNumber of registered runners currently running a joblistenergha_min_runnersgaugeMinimum number of runners configured for the runner scale setlistenergha_max_runnersgaugeMaximum number of runners configured for the runner scale setlistenergha_desired_runnersgaugeNumber of runners desired (scale up / down target) by the runner scale setlistenergha_idle_runnersgaugeNumber of registered runners not running a joblistenergha_started_jobs_totalcounterTotal number of jobs started since the listener became ready [1]listenergha_completed_jobs_totalcounterTotal number of jobs completed since the listener became ready [1]listenergha_job_startup_duration_secondshistogramNumber of seconds spent waiting for workflow job to get started on the runner owned by the runner scale setlistenergha_job_execution_duration_secondshistogramNumber of seconds spent executing workflow jobs by the runner scale set
[1]: Listener metrics that have the counter type are reset when the listener pod restarts.
Upgrading ARC
Because there is no support for upgrading or deleting CRDs with Helm, it is not possible to use Helm to upgrade ARC. For more information, see Custom Resource Definitions in the Helm documentation. To upgrade ARC to a newer version, you must complete the following steps.

Uninstall all installations of gha-runner-scale-set.
Wait for resources cleanup.
Uninstall ARC.
If there is a change in CRDs from the version you currently have installed, to the upgraded version, remove all CRDs associated with actions.github.com API group.
Reinstall ARC again.

For more information, see Deploying a runner scale set.
If you would like to upgrade ARC but are concerned about downtime, you can deploy ARC in a high availability configuration to ensure runners are always available. For more information, see High availability and automatic failover.
Note

Transitioning from the community supported version of ARC to the GitHub supported version is a substantial architectural change. The GitHub supported version involves a redesign of many components of ARC. It is not a minor software upgrade. For these reasons, we recommend testing the new versions in a staging environment that matches your production environment first. This will ensure stability and reliability of the setup before deploying in production.

Deploying a canary image
You can test features before they are released by using canary releases of the controller-manager container image. Canary images are published with tag format canary-SHORT_SHA. For more information, see gha-runner-scale-set-controller on the Container registry.
Note


You must use Helm charts on your local file system.
You cannot use the released Helm charts.



Update the tag in the gha-runner-scale-set-controller values.yaml file to: canary-SHORT_SHA
Update the field appVersion in the Chart.yaml file for gha-runner-scale-set to: canary-SHORT_SHA
Re-install ARC using the updated Helm chart and values.yaml files.

High availability and automatic failover
ARC can be deployed in a high availability (active-active) configuration. If you have two distinct Kubernetes clusters deployed in separate regions, you can deploy ARC in both clusters and configure runner scale sets to use the same runnerScaleSetName. In order to do this, each runner scale set must be assigned to a distinct runner group. For example, you can have two runner scale sets each named arc-runner-set, as long as one runner scale set belongs to runner-group-A and the other runner scale set belongs to runner-group-B. For information on assigning runner scale sets to runner groups, see Managing access to self-hosted runners using groups.
If both runner scale sets are online, jobs assigned to them will be distributed arbitrarily (assignment race). You cannot configure the job assignment algorithm. If one of the clusters goes down, the runner scale set in the other cluster will continue to acquire jobs normally without any intervention or configuration change.
Using ARC across organizations
A single installation of Actions Runner Controller allows you to configure one or more runner scale sets. These runner scale sets can be registered to a repository, organization, or enterprise. You can also use runner groups to control the permissions boundaries of these runner scale sets.
As a best practice, create a unique namespace for each organization. You could also create a namespace for each runner group or each runner scale set. You can install as many runner scale sets as needed in each namespace. This will provide you the highest levels of isolation and improve your security. You can use GitHub Apps for authentication and define granular permissions for each runner scale set.
Legal notice
Portions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:
Copyright 2019 Moto Ishizawa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/Using ARC in a workflowUsing Actions Runner Controller runners in a workflowYou can use Actions Runner Controller runners in a workflow file.In this articleAbout using ARC runners in a workflow fileUsing runner scale set namesLegal noticeLegal notice
About using ARC runners in a workflow file
To assign jobs to run on a runner scale set, you can specify the name of the scale set as the value for the runs-on key in your GitHub Actions workflow file.
For example, the following configuration for a runner scale set has the INSTALLATION_NAME value set to arc-runner-set.
# Using a Personal Access Token (PAT)
INSTALLATION_NAME="arc-runner-set"
NAMESPACE="arc-runners"
GITHUB_CONFIG_URL="https://github.com/<your_enterprise/org/repo>"
GITHUB_PAT="<PAT>"
helm install "${INSTALLATION_NAME}" \
    --namespace "${NAMESPACE}" \
    --create-namespace \
    --set githubConfigUrl="${GITHUB_CONFIG_URL}" \
    --set githubConfigSecret.github_token="${GITHUB_PAT}" \
    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set

To use this configuration in a workflow, set the value of the runs-on key in your workflow to arc-runner-set, similar to the following example.
jobs:
  job_name:
    runs-on: arc-runner-set

Using runner scale set names
Runner scale set names are unique within the runner group they belong to. To deploy multiple runner scale sets with the same name, they must belong to different runner groups. For more information about specifying runner scale set names, see Deploying runner scale sets with Actions Runner Controller.
You cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation or by defining the value of the runnerScaleSetName field in your values.yaml file. These are used as the 'single label' to use as your runs-on target. For more information, see Deploying runner scale sets with Actions Runner Controller.
Legal notice
Portions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:
Copyright 2019 Moto Ishizawa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/TroubleshootTroubleshooting Actions Runner Controller errorsLearn how to troubleshoot Actions Runner Controller errors.In this articleLoggingResources labelsChecking the logs of the controller and runner set listenerUsing the charts from the master branchTroubleshooting the listener podRunner pods are recreated after a canceled workflow runError: Name must have up to n charactersError: Access to the path /home/runner/_work/_tool is deniedError: failed to get access token for GitHub App auth: 401 UnauthorizedLegal noticeLegal notice
Logging
The Actions Runner Controller (ARC) resources, which include the controller, listener, and runners, write logs to standard output (stdout). We recommend you implement a logging solution to collect and store these logs. Having logs available can help you or GitHub support with troubleshooting and debugging. For more information, see Logging Architecture in the Kubernetes documentation.
Resources labels
Labels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting.
Controller pod
The following labels are applied to the controller pod.
app.kubernetes.io/component=controller-manager
app.kubernetes.io/instance=<controller installation name>
app.kubernetes.io/name=gha-runner-scale-set-controller
app.kubernetes.io/part-of=gha-runner-scale-set-controller
app.kubernetes.io/version=<chart version>

Listener pod
The following labels are applied to listener pods.
actions.github.com/enterprise= # Will be populated if githubConfigUrl is an enterprise URL
actions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL
actions.github.com/repository= # Will be populated if githubConfigUrl is a repository URL
actions.github.com/scale-set-name= # Runners scale set name
actions.github.com/scale-set-namespace= # Runners namespace
app.kubernetes.io/component=runner-scale-set-listener
app.kubernetes.io/part-of=gha-runner-scale-set
app.kubernetes.io/version= # Chart version

Runner pod
The following labels are applied to runner pods.
actions-ephemeral-runner= # True | False
actions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL
actions.github.com/scale-set-name= # Runners scale set name
actions.github.com/scale-set-namespace= # Runners namespace
app.kubernetes.io/component=runner
app.kubernetes.io/part-of=gha-runner-scale-set
app.kubernetes.io/version= # Chart version

Checking the logs of the controller and runner set listener
To check the logs of the controller pod, you can use the following command.
Bashkubectl logs -n <CONTROLLER_NAMESPACE> -l app.kubernetes.io/name=gha-runner-scale-set-controller
kubectl logs -n <CONTROLLER_NAMESPACE> -l app.kubernetes.io/name=gha-runner-scale-set-controller

To check the logs of the runner set listener, you can use the following command.
Bashkubectl logs -n <CONTROLLER_NAMESPACE> -l auto-scaling-runner-set-namespace=arc-systems -l auto-scaling-runner-set-name=arc-runner-set
kubectl logs -n <CONTROLLER_NAMESPACE> -l auto-scaling-runner-set-namespace=arc-systems -l auto-scaling-runner-set-name=arc-runner-set

Using the charts from the master branch
We recommend you use the charts from the latest release instead of the master branch. The master branch is highly unstable, and we cannot guarantee that the charts in the master branch will work at any given time.
Troubleshooting the listener pod
If the controller pod is running, but the listener pod is not, inspect the logs of the controller first and see if there are any errors. If there are no errors and the runner set listener pod is still not running, ensure the controller pod has access to the Kubernetes API server in your cluster.
If you have a proxy configured or you're using a sidecar proxy that's automatically injected, such as Istio, ensure it's configured to allow traffic from the controller container (manager) to the Kubernetes API server.
If you have installed the autoscaling runner set, but the listener pod is not created, verify that the githubConfigSecret you provided is correct and that the githubConfigUrl you provided is accurate. See Authenticating to the GitHub API and Deploying runner scale sets with Actions Runner Controller for more information.
Runner pods are recreated after a canceled workflow run
Once a workflow run is canceled, the following events happen.

The cancellation signal is sent to the runners directly.
The runner application terminates, which also terminates the runner pods.
On the next poll, the cancellation signal is received by the listener.

There might be a slight delay between when the runners receive the signal and when the listener receives the signal. When runner pods start terminating, the listener tries to bring up new runners to match the desired number of runners according to the state it's in. However, when the listener receives the cancellation signal, it will act to reduce the number of runners. Eventually the listener will scale back down to the desired number of runners. In the meantime, you may see extra runners.
Error: Name must have up to n characters
ARC uses the generated names of certain resources as labels for other resources. Because of this requirement, ARC limits resource names to 63 characters.
Because part of the resource name is defined by you, ARC imposes a limit on the number of characters you can use for the installation name and namespace.
Error: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:5:5): Name must have up to 45 characters

Error: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:8:5): Namespace must have up to 63 characters

Error: Access to the path /home/runner/_work/_tool is denied
You may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume.
To fix this, you can do one of the following things.


Use a volume type that supports securityContext.fsGroup. hostPath volumes do not support this property, whereas local volumes and other types of volumes do support it. Update the fsGroup of your runner pod to match the GID of the runner. You can do this by updating the gha-runner-scale-set helm chart values to include the following. Replace VERSION with the version of the actions-runner container image you want to use.
YAMLspec:
    securityContext:
        fsGroup: 123
    containers:
    - name: runner
    image: ghcr.io/actions/actions-runner:latest
    command: ["/home/runner/run.sh"]
spec:
    securityContext:
        fsGroup: 123
    containers:
    - name: runner
    image: ghcr.io/actions/actions-runner:latest
    command: ["/home/runner/run.sh"]



If updating the securityContext of your runner pod is not a viable solution, you can work around the issue by using initContainers to change the mounted volume's ownership, as follows.
YAMLtemplate:
spec:
    initContainers:
    - name: kube-init
    image: ghcr.io/actions/actions-runner:latest
    command: ["sudo", "chown", "-R", "1001:123", "/home/runner/_work"]
    volumeMounts:
        - name: work
        mountPath: /home/runner/_work
    containers:
    - name: runner
    image: ghcr.io/actions/actions-runner:latest
    command: ["/home/runner/run.sh"]
template:
spec:
    initContainers:
    - name: kube-init
    image: ghcr.io/actions/actions-runner:latest
    command: ["sudo", "chown", "-R", "1001:123", "/home/runner/_work"]
    volumeMounts:
        - name: work
        mountPath: /home/runner/_work
    containers:
    - name: runner
    image: ghcr.io/actions/actions-runner:latest
    command: ["/home/runner/run.sh"]



Error: failed to get access token for GitHub App auth: 401 Unauthorized
A 401 Unauthorized error when attempting to obtain an access token for a GitHub App could be a result of a Network Time Protocol (NTP) drift. Ensure that your Kubernetes system is accurately syncing with an NTP server and that there isn't a significant time drift. There is more leeway if your system time is behind GitHub's time, but if the environment is more than a few seconds ahead, 401 errors will occur when using GitHub App.
Legal notice
Portions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:
Copyright 2019 Moto Ishizawa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.\n\n\n\nGitHub Actions/Self-hosted runners/Actions Runner Controller/About Support for ARCAbout support for Actions Runner ControllerWhat to know before you contact GitHub Support for assistance with Actions Runner Controller.In this articleAbout support for Actions Runner Controller VersionsScope of support for Actions Runner ControllerWorking with GitHub Support for Actions Runner ControllerYou can contact GitHub Support for assistance with Actions Runner Controller.
About support for Actions Runner Controller Versions
The Actions Runner Controller (ARC) project was adopted by GitHub to release as a new GitHub product. As a result, there are currently two ARC releases: the legacy community-maintained ARC and GitHub's Autoscaling Runner Sets.
GitHub only supports the latest Autoscaling Runner Sets version of ARC. Support for the legacy ARC is provided by the community in the Actions Runner Controller repository only.
Scope of support for Actions Runner Controller
If your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:

The legacy community-maintained version of ARC
Installing, configuring, or maintaining dependencies
Template spec customization
Container orchestration, such as Kubernetes setup, networking, building images in ARC (DinD), etc.
Applying Kubernetes policies
Managed Kubernetes providers or provider-specific configurations
Runner Container Hooks in conjunction with ARC's kubernetes mode
Installation tooling other than Helm
Storage provisioners and PersistentVolumeClaims (PVCs)
Best practices, such as configuring metrics servers, image caching, etc.

While ARC may be deployed successfully with different tooling and configurations, your support request is possibly out of GitHub Support's scope if ARC has been deployed with:

Installation tooling other than Helm
Service account and/or template spec customization

If you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.
For more information about contacting GitHub Support, see Contacting GitHub Support.
Note


OpenShift clusters are currently unsupported.
ARC is only supported on GitHub Enterprise Server versions 3.9 and greater.


Working with GitHub Support for Actions Runner Controller
GitHub Support may ask questions about your Actions Runner Controller deployment and request that you collect and attach the controller, listener, and runner logs to the support ticket.\n\n\n\n