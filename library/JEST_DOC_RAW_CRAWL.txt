IntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\n\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.6On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nThis is documentation for Jest 29.6, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: 29.6On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.5On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nThis is documentation for Jest 29.5, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: 29.5On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.4On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nThis is documentation for Jest 29.4, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: 29.4On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nSkip to main contentSupport Ukraine 🇺🇦  Help Provide Humanitarian Aid to Ukraine.Jest29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versionsDocsAPIHelpBlogEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文SearchJest VersionsCurrent version (Stable)Latest stable version of Jest29.7DocumentationRelease NotesLatest versionHere you can find the latest unreleased documentation and code.mainDocumentationSource CodePast VersionsHere you can find documentation for previous versions of Jest.29.6Documentation29.5Documentation29.4DocumentationArchived VersionsHere you can find archived documentation for older versions of Jest.29.3Documentation29.2Documentation29.1Documentation29.0Documentation28.xDocumentation27.xDocumentation26.xDocumentation25.xDocumentation24.xDocumentation23.xDocumentation22.xDocumentationDocsGetting StartedGuidesAPI ReferenceCommunityStack OverflowReactifluxTwitterMoreBlogGitHubTwitterLegalPrivacyTermsCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nSupport Ukraine 🇺🇦  Help Provide Humanitarian Aid to Ukraine.\nSupport Ukraine 🇺🇦  Help Provide Humanitarian Aid to Ukraine.\nHelp Provide Humanitarian Aid to Ukraine\nJest29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versionsDocsAPIHelpBlogEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文Search\nJest29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versions\n29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versions\nDocsAPIHelpBlogEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文Search\nEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文\nJest VersionsCurrent version (Stable)Latest stable version of Jest29.7DocumentationRelease NotesLatest versionHere you can find the latest unreleased documentation and code.mainDocumentationSource CodePast VersionsHere you can find documentation for previous versions of Jest.29.6Documentation29.5Documentation29.4DocumentationArchived VersionsHere you can find archived documentation for older versions of Jest.29.3Documentation29.2Documentation29.1Documentation29.0Documentation28.xDocumentation27.xDocumentation26.xDocumentation25.xDocumentation24.xDocumentation23.xDocumentation22.xDocumentation\nJest VersionsCurrent version (Stable)Latest stable version of Jest29.7DocumentationRelease NotesLatest versionHere you can find the latest unreleased documentation and code.mainDocumentationSource CodePast VersionsHere you can find documentation for previous versions of Jest.29.6Documentation29.5Documentation29.4DocumentationArchived VersionsHere you can find archived documentation for older versions of Jest.29.3Documentation29.2Documentation29.1Documentation29.0Documentation28.xDocumentation27.xDocumentation26.xDocumentation25.xDocumentation24.xDocumentation23.xDocumentation22.xDocumentation\nJest VersionsCurrent version (Stable)Latest stable version of Jest29.7DocumentationRelease NotesLatest versionHere you can find the latest unreleased documentation and code.mainDocumentationSource CodePast VersionsHere you can find documentation for previous versions of Jest.29.6Documentation29.5Documentation29.4DocumentationArchived VersionsHere you can find archived documentation for older versions of Jest.29.3Documentation29.2Documentation29.1Documentation29.0Documentation28.xDocumentation27.xDocumentation26.xDocumentation25.xDocumentation24.xDocumentation23.xDocumentation22.xDocumentation\nJest VersionsCurrent version (Stable)Latest stable version of Jest29.7DocumentationRelease NotesLatest versionHere you can find the latest unreleased documentation and code.mainDocumentationSource CodePast VersionsHere you can find documentation for previous versions of Jest.29.6Documentation29.5Documentation29.4DocumentationArchived VersionsHere you can find archived documentation for older versions of Jest.29.3Documentation29.2Documentation29.1Documentation29.0Documentation28.xDocumentation27.xDocumentation26.xDocumentation25.xDocumentation24.xDocumentation23.xDocumentation22.xDocumentation\nJest VersionsCurrent version (Stable)Latest stable version of Jest29.7DocumentationRelease NotesLatest versionHere you can find the latest unreleased documentation and code.mainDocumentationSource CodePast VersionsHere you can find documentation for previous versions of Jest.29.6Documentation29.5Documentation29.4DocumentationArchived VersionsHere you can find archived documentation for older versions of Jest.29.3Documentation29.2Documentation29.1Documentation29.0Documentation28.xDocumentation27.xDocumentation26.xDocumentation25.xDocumentation24.xDocumentation23.xDocumentation22.xDocumentation\nCurrent version (Stable)\nLatest stable version of Jest\nHere you can find the latest unreleased documentation and code.\nHere you can find documentation for previous versions of Jest.\nHere you can find archived documentation for older versions of Jest.\nDocsGetting StartedGuidesAPI ReferenceCommunityStack OverflowReactifluxTwitterMoreBlogGitHubTwitterLegalPrivacyTermsCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nDocsGetting StartedGuidesAPI ReferenceCommunityStack OverflowReactifluxTwitterMoreBlogGitHubTwitterLegalPrivacyTerms\nDocsGetting StartedGuidesAPI Reference\nCommunityStack OverflowReactifluxTwitter\nMoreBlogGitHubTwitter\nCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.\nlist of OpenJS Foundation trademarks\nThe OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie Policy\nThe OpenJS Foundation\n\n\nGlobalsVersion: 29.7On this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work) (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example', ({a, b, expected}) => {  // all arguments are of type `number`});
Otherwise it will require a generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // without the generic argument in this case types would default to `unknown`});Edit this pageLast updated on Jan 15, 2025 by John Vandenberg\n\nGlobalsVersion: 29.7On this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work) (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example', ({a, b, expected}) => {  // all arguments are of type `number`});
Otherwise it will require a generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // without the generic argument in this case types would default to `unknown`});Edit this pageLast updated on Jan 15, 2025 by John VandenbergNextExpectMethodsReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each\n\n\n\nSkip to main contentSupport Ukraine 🇺🇦  Help Provide Humanitarian Aid to Ukraine.Jest29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versionsDocsAPIHelpBlogEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文SearchNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.Browse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.
DocsGetting StartedGuidesAPI ReferenceCommunityStack OverflowReactifluxTwitterMoreBlogGitHubTwitterLegalPrivacyTermsCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nSupport Ukraine 🇺🇦  Help Provide Humanitarian Aid to Ukraine.\nSupport Ukraine 🇺🇦  Help Provide Humanitarian Aid to Ukraine.\nHelp Provide Humanitarian Aid to Ukraine\nJest29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versionsDocsAPIHelpBlogEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文Search\nJest29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versions\n29.7Next29.729.629.529.429.329.229.129.028.x27.x26.x25.x24.x23.x22.xAll versions\nDocsAPIHelpBlogEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文Search\nEnglishEnglish日本語EspañolFrançaisPortuguês (Brasil)RomânăРусскийУкраїнська简体中文\nNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.Browse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.Browse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.Browse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.Browse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.Browse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nNeed help?Jest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.\nJest is worked on by a team of volunteers in their spare time. You can find out ways to talk to community members below.\nBrowse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nBrowse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.
Join the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!
Stay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nBrowse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.\nBrowse the docsFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.\nFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.\nFind what you're looking for in our detailed documentation and guides.

Learn how to get started with Jest.
Troubleshoot problems with Jest.
Learn how to configure Jest.
Look at the full API Reference.\nFind what you're looking for in our detailed documentation and guides.\nLearn how to get started with Jest.\nTroubleshoot problems with Jest.\nLearn how to configure Jest.\nLook at the full API Reference.\nJoin the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!\nJoin the communityAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!\nAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!\nAsk questions and find answers from other Jest users like you.

Join the #testing channel on Reactiflux, a Discord community.
Many members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!\nAsk questions and find answers from other Jest users like you.\nJoin the #testing channel on Reactiflux, a Discord community.\nMany members of the community use Stack Overflow. Read through the existing questions tagged with jestjs or ask your own!\nStay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nStay up to dateFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nFind out what's new with Jest.

Follow Jest on Twitter.
Subscribe to the Jest blog.
Look at the changelog.\nFind out what's new with Jest.\nFollow Jest on Twitter.\nSubscribe to the Jest blog.\nLook at the changelog.\nDocsGetting StartedGuidesAPI ReferenceCommunityStack OverflowReactifluxTwitterMoreBlogGitHubTwitterLegalPrivacyTermsCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nDocsGetting StartedGuidesAPI ReferenceCommunityStack OverflowReactifluxTwitterMoreBlogGitHubTwitterLegalPrivacyTerms\nDocsGetting StartedGuidesAPI Reference\nCommunityStack OverflowReactifluxTwitter\nMoreBlogGitHubTwitter\nCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.
The OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie PolicyBuilt with Docusaurus.\nCopyright OpenJS Foundation and Jest contributors. All rights reserved. The OpenJS Foundation has registered trademarks and uses trademarks.  For a list of trademarks of the OpenJS Foundation, please see our Trademark Policy and Trademark List.  Trademarks and logos not indicated on the list of OpenJS Foundation trademarks are trademarks™ or registered® trademarks of their respective holders. Use of them does not imply any affiliation with or endorsement by them.\nlist of OpenJS Foundation trademarks\nThe OpenJS Foundation | Terms of Use | Privacy Policy | Bylaws | Code of Conduct | Trademark Policy | Trademark List | Cookie Policy\nThe OpenJS Foundation\n\n\nJest 29: Snapshot format changesAugust 25, 2022 · One min readSimen BekkhusJest 29 is here, just a few short months after Jest 28. As mentioned in the Jest 28 blog post, this version contains just a couple of breaking changes, in order to make the upgrade as smooth as possible.Read moreJest joins OpenJS FoundationMay 11, 2022 · One min readRicky Hanlon
Today we're excited to announce that Jest is joining the OpenJS Foundation!
This change transfers ownership of the project from Meta to the Jest Core team via the OpenJS Foundation as an Impact Project. We’re grateful to Meta for creating Jest and all of their support over the years, and we look forward to the future of Jest as a project owned by the Jest community!
Check out the Meta Engineering blog and OpenJS Foundation blog announcements for more info.Jest 28: Shedding weight and improving compatibility 🫶April 25, 2022 · 8 min readSimen BekkhusJest 28 is finally here, and it comes with some long requested features such as support for sharding a test run across multiple machines, package exports and the ability to customize the behavior of fake timers. These are just some personal highlights, and we'll be highlighting more in this blog post.
Additionally, as announced in the Jest 27 blog post last year, we have removed some packages that no longer are used by default from the default installation. As a result the installation size has dropped by about 1/3.Read moreJest 27: New Defaults for Jest, 2021 edition ⏩May 25, 2021 · 7 min readTim SeckingerIn the Jest 26 blog post about a year ago, we announced that after two major releases with few breaking changes, Jest 27 will flip some switches to set better defaults for projects that are new or can migrate smoothly. This gives us the opportunity to remove some packages from the default distribution of Jest 28 and publish them as separately installable and pluggable modules instead. Everyone on the new defaults can benefit from a smaller install size, while people needing these packages can still install them separately.
With the first major change of defaults since the New Defaults for Jest that came with the seminal version 15, Jest 27 is now here, to keep Jest fast, lean, and relevant in the future. We will explain those changes of defaults and other notable breaking changes in this post, but first, let's get into some exciting new features!Read moreJest Website UpgradeMarch 9, 2021 · 2 min readSébastien LorberDocusaurus maintainerWe are excited to present the new Jest website!
The Jest site was upgraded from Docusaurus 1 to Docusaurus 2, and is an early adopter of the newly released Docusaurus 2 i18n support.
So, what's new exactly?Read moreJest 26: Tick TockMay 5, 2020 · 7 min readChristoph NakazawaWhen we started rebuilding Jest five years ago our goal was to provide a batteries-included zero-configuration test runner that is approachable for beginners, extensible for almost all testing use cases and scalable to large projects. One of the instrumental releases was Jest 15 which tied everything together and provided good defaults that allowed people to run Jest often without any setup. However, this approach has a big downside as Jest installs a lot of dependencies into your projects that you may not need.
We are now beginning to address this shortcoming and are working on reducing Jest’s install size while keeping it approachable and extensible. We have made the following breaking changes in Jest 26:Read moreJest 25: 🚀 Laying foundations for the futureJanuary 21, 2020 · 7 min readSimen BekkhusJest 25 is laying the groundwork for many major changes in the future. As such, we kept breaking changes to a minimum, but internal architecture changes may require attention during the upgrade. The main changes are an upgrade of JSDOM from v11 to v15, 10-15% faster test runs, a new diff view for outdated snapshots and dropped Node 6 support.
There has been more than 200 commits since Jest 24.9 by more than 80 different contributors, so as always, take a look at the changelog for a full list of changes.Read moreJest 24: 💅 Refreshing, Polished, TypeScript-friendlyJanuary 25, 2019 · 9 min readSimen BekkhusToday we are happy to announce the next major release of Jest - version 24! It's been 4 months since the last minor release, and 8 months since Jest 23, so this upgrade is a big one, with something for everyone! Highlights include built-in support for TypeScript by upgrading the Jest internals to Babel 7, fixing some long-standing issues with missing console output and performance issues when computing large diffs, and a brand new sparkling website. ✨
For a full list of all changes see the changelog.Read moreSupporting Jest Open SourceJune 27, 2018 · 3 min readRicky HanlonJest is maintained by a community of open source contributors and Facebook employees.
Our open source contributors work on behalf of the community to create new features, fix bugs, and maintain the issue backlog. Facebook employees do the same, focused on the problems specific to Facebook's scale, and run all proposed releases on Facebook's enormous test suite before publishing.
All of us do our part to make testing delightful.
At the Jest Summit we announced the Jest Open Collective. This is our way to help support the efforts of the open source Jest community. To be absolutely clear: Facebook employees cannot benefit from the Jest Open Collective. The collective's sole purpose is to support the open source side of the Jest community.
In this post we'll outline what the Jest Open Collective is, the structure, and the goals we have.Read moreJest 23: 🔥 Blazing Fast Delightful TestingMay 29, 2018 · 7 min readRicky HanlonToday we are excited to announce Jest 23, our largest major release to date! Together with over 100 contributors, we've shipped a ton of features and bug fixes. Thank you to everyone in the community for helping make JavaScript Testing Delightful.
We would also like to welcome both Babel and webpack to the Jest community! After converting from Mocha to Jest 23 Beta, webpack saw their total test suite time reduced 6x from over 13 minutes to 2 minutes 20 seconds. #blazingmeansgood
Here's are some of the Jest 23 highlights and breaking changes.Read more\n\nJest 29: Snapshot format changesAugust 25, 2022 · One min readSimen BekkhusJest 29 is here, just a few short months after Jest 28. As mentioned in the Jest 28 blog post, this version contains just a couple of breaking changes, in order to make the upgrade as smooth as possible.Read moreJest joins OpenJS FoundationMay 11, 2022 · One min readRicky Hanlon
Today we're excited to announce that Jest is joining the OpenJS Foundation!
This change transfers ownership of the project from Meta to the Jest Core team via the OpenJS Foundation as an Impact Project. We’re grateful to Meta for creating Jest and all of their support over the years, and we look forward to the future of Jest as a project owned by the Jest community!
Check out the Meta Engineering blog and OpenJS Foundation blog announcements for more info.Jest 28: Shedding weight and improving compatibility 🫶April 25, 2022 · 8 min readSimen BekkhusJest 28 is finally here, and it comes with some long requested features such as support for sharding a test run across multiple machines, package exports and the ability to customize the behavior of fake timers. These are just some personal highlights, and we'll be highlighting more in this blog post.
Additionally, as announced in the Jest 27 blog post last year, we have removed some packages that no longer are used by default from the default installation. As a result the installation size has dropped by about 1/3.Read moreJest 27: New Defaults for Jest, 2021 edition ⏩May 25, 2021 · 7 min readTim SeckingerIn the Jest 26 blog post about a year ago, we announced that after two major releases with few breaking changes, Jest 27 will flip some switches to set better defaults for projects that are new or can migrate smoothly. This gives us the opportunity to remove some packages from the default distribution of Jest 28 and publish them as separately installable and pluggable modules instead. Everyone on the new defaults can benefit from a smaller install size, while people needing these packages can still install them separately.
With the first major change of defaults since the New Defaults for Jest that came with the seminal version 15, Jest 27 is now here, to keep Jest fast, lean, and relevant in the future. We will explain those changes of defaults and other notable breaking changes in this post, but first, let's get into some exciting new features!Read moreJest Website UpgradeMarch 9, 2021 · 2 min readSébastien LorberDocusaurus maintainerWe are excited to present the new Jest website!
The Jest site was upgraded from Docusaurus 1 to Docusaurus 2, and is an early adopter of the newly released Docusaurus 2 i18n support.
So, what's new exactly?Read moreJest 26: Tick TockMay 5, 2020 · 7 min readChristoph NakazawaWhen we started rebuilding Jest five years ago our goal was to provide a batteries-included zero-configuration test runner that is approachable for beginners, extensible for almost all testing use cases and scalable to large projects. One of the instrumental releases was Jest 15 which tied everything together and provided good defaults that allowed people to run Jest often without any setup. However, this approach has a big downside as Jest installs a lot of dependencies into your projects that you may not need.
We are now beginning to address this shortcoming and are working on reducing Jest’s install size while keeping it approachable and extensible. We have made the following breaking changes in Jest 26:Read moreJest 25: 🚀 Laying foundations for the futureJanuary 21, 2020 · 7 min readSimen BekkhusJest 25 is laying the groundwork for many major changes in the future. As such, we kept breaking changes to a minimum, but internal architecture changes may require attention during the upgrade. The main changes are an upgrade of JSDOM from v11 to v15, 10-15% faster test runs, a new diff view for outdated snapshots and dropped Node 6 support.
There has been more than 200 commits since Jest 24.9 by more than 80 different contributors, so as always, take a look at the changelog for a full list of changes.Read moreJest 24: 💅 Refreshing, Polished, TypeScript-friendlyJanuary 25, 2019 · 9 min readSimen BekkhusToday we are happy to announce the next major release of Jest - version 24! It's been 4 months since the last minor release, and 8 months since Jest 23, so this upgrade is a big one, with something for everyone! Highlights include built-in support for TypeScript by upgrading the Jest internals to Babel 7, fixing some long-standing issues with missing console output and performance issues when computing large diffs, and a brand new sparkling website. ✨
For a full list of all changes see the changelog.Read moreSupporting Jest Open SourceJune 27, 2018 · 3 min readRicky HanlonJest is maintained by a community of open source contributors and Facebook employees.
Our open source contributors work on behalf of the community to create new features, fix bugs, and maintain the issue backlog. Facebook employees do the same, focused on the problems specific to Facebook's scale, and run all proposed releases on Facebook's enormous test suite before publishing.
All of us do our part to make testing delightful.
At the Jest Summit we announced the Jest Open Collective. This is our way to help support the efforts of the open source Jest community. To be absolutely clear: Facebook employees cannot benefit from the Jest Open Collective. The collective's sole purpose is to support the open source side of the Jest community.
In this post we'll outline what the Jest Open Collective is, the structure, and the goals we have.Read moreJest 23: 🔥 Blazing Fast Delightful TestingMay 29, 2018 · 7 min readRicky HanlonToday we are excited to announce Jest 23, our largest major release to date! Together with over 100 contributors, we've shipped a ton of features and bug fixes. Thank you to everyone in the community for helping make JavaScript Testing Delightful.
We would also like to welcome both Babel and webpack to the Jest community! After converting from Mocha to Jest 23 Beta, webpack saw their total test suite time reduced 6x from over 13 minutes to 2 minutes 20 seconds. #blazingmeansgood
Here's are some of the Jest 23 highlights and breaking changes.Read moreOlder entries\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nはじめにはじめましょうVersion: 29.7On this pageはじめましょうお気に入りのパッケージマネージャーを使用して Jest をインストールします。
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
2つの数値を加算する関数のテストを書くことから始めてみましょう。 まずsum.js ファイルを作成します。
function sum(a, b) {  return a + b;}module.exports = sum;
その後、sum.test.js というファイルを作成します。 このファイルに実際のテストが含まれます。
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
package.json に以下を追加します。
{  "scripts": {    "test": "jest"  }}
最後に、yarn test または npm test を実行すると、Jest は以下のメッセージを表示します。
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
あなたは Jest を使用して、最初のテストを書き、うまくいきました!
このテストは expect と、 toBe を使用し、2 つの値が同じかテストしました。 他の Jest でテスト可能なものについては、Using Matcher を参照してください。
コマンドラインからの実行​
Jest は、CLI から様々な便利なオプションを付けて、直接実行できます。 （実行するためには、例えば yarn global add jestまたはnpm install jest --global でインストールし、PATH でグローバルに利用可能になっている必要があります。 ）
ここでは my-test を Jest で実行し、実行後に OS の通知を表示する方法を示します。 そのとき構成ファイルとして config.json を使用します。
jest my-test --notify --config=config.json
コマンドラインから Jest を実行する方法の詳細については、Jest CLI Options を参考にしてください。
追加設定​
基本の設定ファイルを生成する​
次のコマンドを実行すると、Jest はあなたのプロジェクトの構成に基づいたいくつかの質問をし、その回答から短いコメント付きの基本の設定ファイルを生成します。
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Babel を使用する​
Babel を使用するために、yarn で必要な依存関係をインストールしてください。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Node.jsの現在のバージョンをターゲットにするためにBabelを定義するには、babel.config.jsというファイルをプロジェクトのルートに作ってください。
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Babelの設定にJestを認識させるJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. これを避けるには、 transform設定を明示的にリセットして下さい。jest.config.jsmodule.exports = {  transform: {},};
Webpack を使用する​
Jestは webpackでアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 webpack は他のツールよりもユニークで挑戦的な機能を提供しています。 具体的な使い方は webpack guide を参照してください。
Vite を使用する​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Vite が提供するプラグインシステムの仕組みのため、Jest は vite を完全にはサポートしていませんが、vite-jest を使用した動作する第1級の Jest のインテグレーションがいくつか存在します。完全なサポートではないため、 vite-jest の制限も参照してください。 Refer to the vite guide to get started.
Using Parcel​
Jestは parcel-bundleで webpack と同様にアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 Parcelは設定が不要です。 使用を開始するには公式ドキュメントを参照してください。
TypeScript を使用する​
babel 経由で​
Jest は Babel 経由で TypeScript をサポートしています。 まず、 Babelを使用するを確認してください。 次に、@babel/preset-typescript をインストールします。
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
最後に、@babel/preset-typescript を babel.config.js 内のプリセットのリストに追加してください。
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
BabelでTypeScriptを使う場合、いくつかの注意事項があります。 BabelはTypescriptを純粋なトランスパイルによりサポートしているため、Jestはテストの実行時にテストコードの型検査を行いません。 型検査を行いたい場合、代わりに ts-jest を使用するか、TypeScriptコンパイラ のtsc をテストとは別に(またはビルドプロセスの一部として)使用してください。
ts-jest 経由で​
ts-jestはJest用のソースマップをサポートするTypeScriptプリプロセッサです。こちらを使うことで、TypeScriptで書かれたプロジェクトをJestでテストできるようになります。
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}このページを編集\n\nはじめにはじめましょうVersion: 29.7On this pageはじめましょうお気に入りのパッケージマネージャーを使用して Jest をインストールします。
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
2つの数値を加算する関数のテストを書くことから始めてみましょう。 まずsum.js ファイルを作成します。
function sum(a, b) {  return a + b;}module.exports = sum;
その後、sum.test.js というファイルを作成します。 このファイルに実際のテストが含まれます。
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
package.json に以下を追加します。
{  "scripts": {    "test": "jest"  }}
最後に、yarn test または npm test を実行すると、Jest は以下のメッセージを表示します。
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
あなたは Jest を使用して、最初のテストを書き、うまくいきました!
このテストは expect と、 toBe を使用し、2 つの値が同じかテストしました。 他の Jest でテスト可能なものについては、Using Matcher を参照してください。
コマンドラインからの実行​
Jest は、CLI から様々な便利なオプションを付けて、直接実行できます。 （実行するためには、例えば yarn global add jestまたはnpm install jest --global でインストールし、PATH でグローバルに利用可能になっている必要があります。 ）
ここでは my-test を Jest で実行し、実行後に OS の通知を表示する方法を示します。 そのとき構成ファイルとして config.json を使用します。
jest my-test --notify --config=config.json
コマンドラインから Jest を実行する方法の詳細については、Jest CLI Options を参考にしてください。
追加設定​
基本の設定ファイルを生成する​
次のコマンドを実行すると、Jest はあなたのプロジェクトの構成に基づいたいくつかの質問をし、その回答から短いコメント付きの基本の設定ファイルを生成します。
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Babel を使用する​
Babel を使用するために、yarn で必要な依存関係をインストールしてください。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Node.jsの現在のバージョンをターゲットにするためにBabelを定義するには、babel.config.jsというファイルをプロジェクトのルートに作ってください。
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Babelの設定にJestを認識させるJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. これを避けるには、 transform設定を明示的にリセットして下さい。jest.config.jsmodule.exports = {  transform: {},};
Webpack を使用する​
Jestは webpackでアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 webpack は他のツールよりもユニークで挑戦的な機能を提供しています。 具体的な使い方は webpack guide を参照してください。
Vite を使用する​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Vite が提供するプラグインシステムの仕組みのため、Jest は vite を完全にはサポートしていませんが、vite-jest を使用した動作する第1級の Jest のインテグレーションがいくつか存在します。完全なサポートではないため、 vite-jest の制限も参照してください。 Refer to the vite guide to get started.
Using Parcel​
Jestは parcel-bundleで webpack と同様にアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 Parcelは設定が不要です。 使用を開始するには公式ドキュメントを参照してください。
TypeScript を使用する​
babel 経由で​
Jest は Babel 経由で TypeScript をサポートしています。 まず、 Babelを使用するを確認してください。 次に、@babel/preset-typescript をインストールします。
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
最後に、@babel/preset-typescript を babel.config.js 内のプリセットのリストに追加してください。
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
BabelでTypeScriptを使う場合、いくつかの注意事項があります。 BabelはTypescriptを純粋なトランスパイルによりサポートしているため、Jestはテストの実行時にテストコードの型検査を行いません。 型検査を行いたい場合、代わりに ts-jest を使用するか、TypeScriptコンパイラ のtsc をテストとは別に(またはビルドプロセスの一部として)使用してください。
ts-jest 経由で​
ts-jestはJest用のソースマップをサポートするTypeScriptプリプロセッサです。こちらを使うことで、TypeScriptで書かれたプロジェクトをJestでテストできるようになります。
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}このページを編集NextMatcherを使用するコマンドラインからの実行追加設定基本の設定ファイルを生成するBabel を使用するWebpack を使用するVite を使用するUsing ParcelTypeScript を使用するUsing ESLint\n\n\n\nIntroducciónEmpezandoVersion: 29.7On this pageEmpezandoInstale Jest usando su administrador de paquetes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Empecemos escribiendo una prueba para una función hipotética que suma dos números. Primero, crea un archivo suma.js:
function suma(a, b) {  return a + b;}module.exports = suma;
Luego, crea un archivo llamado suma.test.js. Este contendrá nuestra prueba actual:
const suma = require('./suma');test('sumar 1 + 2 es igual a 3', () => {  expect(suma(1, 2)).toBe(3);});
Agrega la siguiente sección a tu package.json:
{  "scripts": {    "test": "jest"  }}
Finalmente, ejecuta yarn test o npm test y Jest imprimirá en la pantalla este mensaje:
PASS  ./suma.test.js✓ sumar 1 + 2 es igual a 3 (5ms)
¡Acabas de escribir tu primera prueba usando Jest!
Esta prueba usa expect y toBe para probar que dos valores son exactamente idénticos. Para aprender sobre otras cosas que Jest puede probar, mira Usando Matchers.
Ejecutando desde la línea de comandos​
Puedes ejecutar Jest directamente desde la CLI (si está disponible globalmente en tu PATH, p.e. con yarn global add jest o npm install jest --global) con varias opciones útiles.
Así es como puedes correr Jest en archivos que coinciden my-test, usando config.json como archivo de configuración y mostrar una notificación nativa del SO después de ejecutarlo:
jest my-test --notify --config=config.json
Si quieres aprender más sobre correr jest a través de la línea de comandos, hecha una mirada a la página de Opciones de Jest CLI.
Configuración Adicional​
Genera un fichero de configuración básico​
Basado en tu proyecto, Jest te hará algunas preguntas y creará un archivo de configuración básica con una corta descripción por cada opción:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale las dependencias requeridas:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configura Babel para tu versión actual de Node creando un fichero babel.config.js en la raíz de tu proyecto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuración ideal para Babel dependerá de tu proyecto. Consulte la documentación de Babel para obtener más detalles.
Haz que tu configuración de Babel sepa que usas JestJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest se instala automáticamente al instalar Jest y transformará automáticamente los archivos si existe una configuración de Babel en su proyecto. Para evitar este comportamiento, puede restablecer explícitamente la opción de configuración de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest puede ser usado en proyectos que usan webpack para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos sobre otras herramientas. Consulta la documentación oficial para comenzar.
Usando Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest puede ser usado en proyectos que usan parcel para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos por sobre otras herramientas. Refer to the official docs to get started.
Usando TypeScript​
Via babel​
Jest soporta TypeScript, a través de Babel. Primero, asegúrate de haber seguido las intrucciones en Usando Babel de arriba. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Luego agrega @babel/preset-typescript a la lista de presets en tu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Existen algunas cosas que debes tener en cuenta cuando uses TypeScript con Babel. Dado que el soporte de TypeScript en Babel se limita a la transpilación, Jest no comprobará los tipos de tus tests cuando éstos se ejecuten. Si lo deseas, puedes utilizar ts-jest o simplemente ejecutar el compilador de TypeScript por separado (como parte del proceso de compilación).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this page\n\nIntroducciónEmpezandoVersion: 29.7On this pageEmpezandoInstale Jest usando su administrador de paquetes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Empecemos escribiendo una prueba para una función hipotética que suma dos números. Primero, crea un archivo suma.js:
function suma(a, b) {  return a + b;}module.exports = suma;
Luego, crea un archivo llamado suma.test.js. Este contendrá nuestra prueba actual:
const suma = require('./suma');test('sumar 1 + 2 es igual a 3', () => {  expect(suma(1, 2)).toBe(3);});
Agrega la siguiente sección a tu package.json:
{  "scripts": {    "test": "jest"  }}
Finalmente, ejecuta yarn test o npm test y Jest imprimirá en la pantalla este mensaje:
PASS  ./suma.test.js✓ sumar 1 + 2 es igual a 3 (5ms)
¡Acabas de escribir tu primera prueba usando Jest!
Esta prueba usa expect y toBe para probar que dos valores son exactamente idénticos. Para aprender sobre otras cosas que Jest puede probar, mira Usando Matchers.
Ejecutando desde la línea de comandos​
Puedes ejecutar Jest directamente desde la CLI (si está disponible globalmente en tu PATH, p.e. con yarn global add jest o npm install jest --global) con varias opciones útiles.
Así es como puedes correr Jest en archivos que coinciden my-test, usando config.json como archivo de configuración y mostrar una notificación nativa del SO después de ejecutarlo:
jest my-test --notify --config=config.json
Si quieres aprender más sobre correr jest a través de la línea de comandos, hecha una mirada a la página de Opciones de Jest CLI.
Configuración Adicional​
Genera un fichero de configuración básico​
Basado en tu proyecto, Jest te hará algunas preguntas y creará un archivo de configuración básica con una corta descripción por cada opción:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale las dependencias requeridas:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configura Babel para tu versión actual de Node creando un fichero babel.config.js en la raíz de tu proyecto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuración ideal para Babel dependerá de tu proyecto. Consulte la documentación de Babel para obtener más detalles.
Haz que tu configuración de Babel sepa que usas JestJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest se instala automáticamente al instalar Jest y transformará automáticamente los archivos si existe una configuración de Babel en su proyecto. Para evitar este comportamiento, puede restablecer explícitamente la opción de configuración de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest puede ser usado en proyectos que usan webpack para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos sobre otras herramientas. Consulta la documentación oficial para comenzar.
Usando Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest puede ser usado en proyectos que usan parcel para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos por sobre otras herramientas. Refer to the official docs to get started.
Usando TypeScript​
Via babel​
Jest soporta TypeScript, a través de Babel. Primero, asegúrate de haber seguido las intrucciones en Usando Babel de arriba. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Luego agrega @babel/preset-typescript a la lista de presets en tu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Existen algunas cosas que debes tener en cuenta cuando uses TypeScript con Babel. Dado que el soporte de TypeScript en Babel se limita a la transpilación, Jest no comprobará los tipos de tus tests cuando éstos se ejecuten. Si lo deseas, puedes utilizar ts-jest o simplemente ejecutar el compilador de TypeScript por separado (como parte del proceso de compilación).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageNextUtilizando ComparadoresEjecutando desde la línea de comandosConfiguración AdicionalGenera un fichero de configuración básicoUsando BabelUsando webpackUsando ViteUsing ParcelUsando TypeScriptUsing ESLint\n\n\n\nIntroductionPremiers pasVersion : 29.7Sur cette pagePremiers pasInstallez Jest en utilisant votre gestionnaire de paquets favori :
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Commençons par écrire un test pour une hypothétique fonction qui additionne deux nombres. Tout d’abord, créez un fichier sum.js :
function sum(a, b) {  return a + b;}module.exports = sum;
Ensuite, créez un fichier nommé sum.test.js. Il s'agit de notre test actuel :
test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Ajoutez la section suivante à votre package.json :
{  "scripts": {    "test": "jest"  }}
Enfin, lancez yarn test ou npm test et Jest affichera ce message :
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Vous venez d'écrire votre premier test avec Jest avec succès !
Ce test utilise expect et toBe pour tester que deux valeurs sont exactement identiques. Pour connaître les autres éléments que Jest peut tester, consultez Utilisation des comparateurs.
Exécution en mode ligne de commande​
Vous pouvez exécuter Jest directement depuis le CLI (si celui-ci est globalement disponible dans votre PATH, par exemple yarn global add jest ou npm install jest --global) avec une variété d'options utiles.
Voici comment exécuter Jest sur des fichiers correspondant à my-test, en utilisant config.json comme fichier de configuration et afficher une notification de l'OS natif après l'exécution :
jest my-test --notify --config=config.json
Si vous souhaitez en apprendre davantage sur l'exécution de jest en mode ligne de commande, consultez la page Options CLI de Jest.
Configuration additionnelle​
Générez un fichier de configuration de base​
Basé sur votre projet, Jest vous posera quelques questions et créera un fichier de configuration de base avec une courte description pour chaque option :
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Utilisez Babel​
Pour utiliser Babel, installez les dépendances requises :
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configurez Babel pour cibler votre version actuelle de Node en créant un fichier babel.config.js à la racine de votre projet :
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuration idéale pour Babel dépendra de votre projet. Consultez la documentation de Babel pour plus de détails.
Faites en sorte que votre configuration Babel soit adaptée à JestJest définira process.env.NODE_ENV avec 'test' s'il n'est pas défini avec quelque chose d'autre. Vous pouvez l'utiliser dans votre configuration pour paramétrer de manière conditionnelle uniquement la compilation nécessaire pour Jest, par exemple.babel.config.jsmodule.exports = api => {  const isTest = api. nv('test');  // Vous pouvez utiliser isTest pour déterminer les presets et les plugins à utiliser.  return {    // ...  };};remarquebabel-jest est automatiquement installé lorsque vous installez Jest et transformera automatiquement les fichiers si une configuration de babel existe dans votre projet. Pour éviter ce résultat, vous pouvez réinitialiser explicitement l'option de configuration transform :jest.config.jsmodule.exports = {  transform: {},};
Utilisez Webpack​
Jest peut être utilisé dans les projets qui utilisent webpack pour gérer les ressources, les styles et la compilation. webpack offre quelques défis singuliers par rapport à d'autres outils. Consultez le guide webpack pour commencer.
Utilisation de Vite​
Jest peut être utilisé dans des projets qui utilisent vite pour servir le code source sur l'ESM natif afin de fournir certains outils frontaux. Vite est un outil subjectif et offre quelques flux de travail prêts à l'emploi. Jest n'est pas entièrement supporté par vite à cause de la façon dont le système de plugins de vite fonctionne, mais il y a quelques exemples fonctionnels pour une intégration de première classe en utilisant vite-jest, comme ce n'est pas entièrement supporté, vous pourriez aussi lire la limitation de vite-jest. Reportez-vous au guide vite pour commencer.
Utilisation de Parcel​
Jest peut être utilisé dans les projets qui utilisent parcel-bundler pour gérer les ressources, les styles et la compilation de manière similaire à webpack. Parcel nécessite aucune configuration. Reportez-vous à la documentation officielle pour commencer.
Utilisez TypeScript​
Via babel​
Jest prend en charge TypeScript, via Babel. Tout d'abord, assurez-vous d'avoir suivi les instructions sur l'utilisation de Babel ci-dessus. Ensuite, installez @babel/preset-typescript :
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Ensuite, ajoutez @babel/preset-typescript à la liste des presets dans votre babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Toutefois, l'utilisation de TypeScript avec Babel présente quelques inconvénients. La prise en charge de TypeScript dans Babel étant purement une transpilation, Jest ne vérifiera pas le typage de vos tests lors de leur exécution. Si vous souhaitez cela, vous pouvez à la place utiliser ts-jest, ou simplement exécuter le compilateur TypeScript tsc séparément (ou dans le prolongement de votre processus de construction).
Via ts-jest​
ts-jest est un préprocesseur TypeScript avec la prise en charge de source map pour Jest qui vous permet d'utiliser Jest pour tester les projets écrits en TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Afin que Jest puisse transpiler TypeScript avec ts-jest, vous aurez besoin de créer un fichier de configuration .
Définitions de type​
Il existe deux façons d'avoir les API globales Jest typées pour les fichiers de test écrits en TypeScript.
Vous pouvez utiliser les définitions de types qui sont livrées avec Jest et seront mises à jour chaque fois que vous mettez à jour Jest. Installez le paquet @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Et importez les API depuis le paquet :
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
astuceConsultez la documentation d'utilisation supplémentaire de describe.each/test.each et des fonctions simulées.
Ou vous pouvez choisir d'installer le paquet @types/jest. Il fournit des types pour les globales Jest sans devoir les importer.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Essayez de faire correspondre les versions de Jest et @types/jest aussi proche que possible. Par exemple, si vous utilisez Jest 27.4.0 alors l'installation 27.4.x de @types/jest est idéal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Modifier cette page\n\nIntroductionPremiers pasVersion : 29.7Sur cette pagePremiers pasInstallez Jest en utilisant votre gestionnaire de paquets favori :
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Commençons par écrire un test pour une hypothétique fonction qui additionne deux nombres. Tout d’abord, créez un fichier sum.js :
function sum(a, b) {  return a + b;}module.exports = sum;
Ensuite, créez un fichier nommé sum.test.js. Il s'agit de notre test actuel :
test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Ajoutez la section suivante à votre package.json :
{  "scripts": {    "test": "jest"  }}
Enfin, lancez yarn test ou npm test et Jest affichera ce message :
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Vous venez d'écrire votre premier test avec Jest avec succès !
Ce test utilise expect et toBe pour tester que deux valeurs sont exactement identiques. Pour connaître les autres éléments que Jest peut tester, consultez Utilisation des comparateurs.
Exécution en mode ligne de commande​
Vous pouvez exécuter Jest directement depuis le CLI (si celui-ci est globalement disponible dans votre PATH, par exemple yarn global add jest ou npm install jest --global) avec une variété d'options utiles.
Voici comment exécuter Jest sur des fichiers correspondant à my-test, en utilisant config.json comme fichier de configuration et afficher une notification de l'OS natif après l'exécution :
jest my-test --notify --config=config.json
Si vous souhaitez en apprendre davantage sur l'exécution de jest en mode ligne de commande, consultez la page Options CLI de Jest.
Configuration additionnelle​
Générez un fichier de configuration de base​
Basé sur votre projet, Jest vous posera quelques questions et créera un fichier de configuration de base avec une courte description pour chaque option :
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Utilisez Babel​
Pour utiliser Babel, installez les dépendances requises :
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configurez Babel pour cibler votre version actuelle de Node en créant un fichier babel.config.js à la racine de votre projet :
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuration idéale pour Babel dépendra de votre projet. Consultez la documentation de Babel pour plus de détails.
Faites en sorte que votre configuration Babel soit adaptée à JestJest définira process.env.NODE_ENV avec 'test' s'il n'est pas défini avec quelque chose d'autre. Vous pouvez l'utiliser dans votre configuration pour paramétrer de manière conditionnelle uniquement la compilation nécessaire pour Jest, par exemple.babel.config.jsmodule.exports = api => {  const isTest = api. nv('test');  // Vous pouvez utiliser isTest pour déterminer les presets et les plugins à utiliser.  return {    // ...  };};remarquebabel-jest est automatiquement installé lorsque vous installez Jest et transformera automatiquement les fichiers si une configuration de babel existe dans votre projet. Pour éviter ce résultat, vous pouvez réinitialiser explicitement l'option de configuration transform :jest.config.jsmodule.exports = {  transform: {},};
Utilisez Webpack​
Jest peut être utilisé dans les projets qui utilisent webpack pour gérer les ressources, les styles et la compilation. webpack offre quelques défis singuliers par rapport à d'autres outils. Consultez le guide webpack pour commencer.
Utilisation de Vite​
Jest peut être utilisé dans des projets qui utilisent vite pour servir le code source sur l'ESM natif afin de fournir certains outils frontaux. Vite est un outil subjectif et offre quelques flux de travail prêts à l'emploi. Jest n'est pas entièrement supporté par vite à cause de la façon dont le système de plugins de vite fonctionne, mais il y a quelques exemples fonctionnels pour une intégration de première classe en utilisant vite-jest, comme ce n'est pas entièrement supporté, vous pourriez aussi lire la limitation de vite-jest. Reportez-vous au guide vite pour commencer.
Utilisation de Parcel​
Jest peut être utilisé dans les projets qui utilisent parcel-bundler pour gérer les ressources, les styles et la compilation de manière similaire à webpack. Parcel nécessite aucune configuration. Reportez-vous à la documentation officielle pour commencer.
Utilisez TypeScript​
Via babel​
Jest prend en charge TypeScript, via Babel. Tout d'abord, assurez-vous d'avoir suivi les instructions sur l'utilisation de Babel ci-dessus. Ensuite, installez @babel/preset-typescript :
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Ensuite, ajoutez @babel/preset-typescript à la liste des presets dans votre babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Toutefois, l'utilisation de TypeScript avec Babel présente quelques inconvénients. La prise en charge de TypeScript dans Babel étant purement une transpilation, Jest ne vérifiera pas le typage de vos tests lors de leur exécution. Si vous souhaitez cela, vous pouvez à la place utiliser ts-jest, ou simplement exécuter le compilateur TypeScript tsc séparément (ou dans le prolongement de votre processus de construction).
Via ts-jest​
ts-jest est un préprocesseur TypeScript avec la prise en charge de source map pour Jest qui vous permet d'utiliser Jest pour tester les projets écrits en TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Afin que Jest puisse transpiler TypeScript avec ts-jest, vous aurez besoin de créer un fichier de configuration .
Définitions de type​
Il existe deux façons d'avoir les API globales Jest typées pour les fichiers de test écrits en TypeScript.
Vous pouvez utiliser les définitions de types qui sont livrées avec Jest et seront mises à jour chaque fois que vous mettez à jour Jest. Installez le paquet @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Et importez les API depuis le paquet :
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
astuceConsultez la documentation d'utilisation supplémentaire de describe.each/test.each et des fonctions simulées.
Ou vous pouvez choisir d'installer le paquet @types/jest. Il fournit des types pour les globales Jest sans devoir les importer.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Essayez de faire correspondre les versions de Jest et @types/jest aussi proche que possible. Par exemple, si vous utilisez Jest 27.4.0 alors l'installation 27.4.x de @types/jest est idéal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Modifier cette pageSuivantUtilisation des comparateursExécution en mode ligne de commandeConfiguration additionnelleGénérez un fichier de configuration de baseUtilisez BabelUtilisez WebpackUtilisation de ViteUtilisation de ParcelUtilisez TypeScriptUsing ESLint\n\n\n\nIntroduçãoIniciandoVersão: 29.7On this pageIniciandoInstale Jest usando seu gerenciador de pacotes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Vamos começar por escrever um teste para uma função hipotética que soma dois números. Primeiro, crie um arquivo sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Em seguida, crie um arquivo chamado sum.test.js. Este irá conter o nosso teste real:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adicione a seguinte seção ao seu package.json:
{  "scripts": {    "test": "jest"  }}
Por fim, execute yarn test ou npm run test e o Jest irá imprimir a seguinte mensagem:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Você escreveu com sucesso seu primeiro teste usando Jest!
Este teste usou expect e toBe para testar que dois valores eram exatamente idênticos. Para saber mais sobre as outras coisas que Jest pode testar, consulte Usando Matchers.
Executando a partir da linha de comando​
Você pode executar Jest diretamente da CLI (se ele estiver disponível globalmente em seu PATH, por exemplo: yarn global add jest ou npm install -g jest) com uma variedade de comandos úteis.
Aqui vemos como executar Jest em arquivos que correspondam ao my-test, usando config.json como um arquivo de configuração e exibir uma notificação nativa no Sistema Operacional após a execução:
jest my-test --notify --config=config.json
Se você gostaria de aprender mais sobre como executar jest através da linha de comando, dê uma olhada na página  Opções de CLI Jest.
Configuração adicional​
Gerando um arquivo de configuração básico​
Com base no seu projeto, o Jest fará algumas perguntas e irá criar um arquivo básico de configuração com uma breve descrição para cada opção:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale as dependências necessárias:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure o Babel para marcar a sua versão atual do Node criando um arquivo babel.config.js na raiz do seu projeto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
A configuração ideal para o Babel dependerá do seu projeto. Veja a documentação do Babel para mais detalhes.
Making your Babel config jest-awareJest definirá process.env.NODE_ENV para 'test' se não estiver definido para outra coisa. Você pode usar isso em sua configuração para configurar condicionalmente apenas a compilação necessária para Jest, por exemplo.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest é instalado automaticamente quando instalar Jest e irá automaticamente transformar arquivos caso uma configuração de babel existir em seu projeto. Para evitar esse comportamento, você pode redefinir explicitamente a opção de configuração de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest pode ser usado em projetos que usam webpack para gerenciar assets, estilos e compilação. webpack oferece alguns desafios únicos em relação à outras ferramentas. Consulte o guia do webpack para começar.
Usando Vite​
Jest pode ser utilizado em projetos que usam vite para servir código-fonte a partir de ESM nativo, fornecendo algumas ferramentas do frontend, vite é uma ferramenta opinativa e oferece alguns workflows diferenciados. Jest não é totalmente suportado pelo vite devido a como o sistema de plugins do vite funciona, mas há alguns exemplos para a integração de primeira classe usando vite-jest. Já que isto não é totalmente suportado, você deve ler também a limitação do vite-jest. Consulte o guia de vite para começar.
Usando Parcel​
Jest pode ser usado em projetos que usam parcel-bundler para gerenciar ativos, estilos, e compilação semelhante ao webpack. Parcel requer configuração zero. Veja a documentação oficial para começar.
Usando TypeScript​
Via babel​
O Jest suporta TypeScript, via Babel. Primeiro certifique-se que você seguir as instruções em usando o Babel acima. Em seguida, instale o @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Então adicione o @babel/preset-typescript à lista de presets em seu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
No entanto, há algumas ressalvas para usar TypeScript com Babel. Como o suporte para TypeScript em Babel é puramente transpilação, Jest não irá checar seus testes enquanto eles são executados. Se você quiser isso, você pode usar ts-jest em vez disso. ou apenas execute o compilador TypeScript tsc separadamente (ou como parte de seu processo de compilação).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Para que Jest interprete TypeScript com ts-jest, talvez você precise criar um arquivo de configuração.
Definições de tipo​
Existem duas maneiras de ter Jest global APIs tipado para arquivos de teste escritos em TypeScript.
Você pode usar as definições de tipo que já vem com o Jest e serão atualizadas a cada vez que você atualizar o Jest. Instale o pacote @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
E importe as APIs de:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipVeja a documentação de uso adicional de describe.each/test.each e funções de simulação (mock, em inglês).
Ou você pode escolher instalar o pacote @types/jest. Ele fornece tipos para os globais do Jest sem necessidade de importá-los.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
informação@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Tente coincidir com versões do Jest e @types/jest o mais próximo possível. Por exemplo, se você estiver usando a versão 27.4.0 do jest, então instalar 27.4.x de @types/jest é ideal.
Usando ESLint​
Jest pode ser usado com o ESLint sem qualquer configuração adicional, desde que você importe os ajudantes globais do Jest (describe, it, etc.) do @jest/globals antes de usá-los em seus arquivos de teste. Isso é necessário para evitar erros no-undef do ESLint, que não conhece sobre os globais do Jest.
Se quiser evitar essas importações, você pode configurar seu ambiente ESLint para suportar esses globais adicionando o ambiente jest:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Ou usar o eslint-plugin-jest que tem um efeito similar:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Editar esta página\n\nIntroduçãoIniciandoVersão: 29.7On this pageIniciandoInstale Jest usando seu gerenciador de pacotes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Vamos começar por escrever um teste para uma função hipotética que soma dois números. Primeiro, crie um arquivo sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Em seguida, crie um arquivo chamado sum.test.js. Este irá conter o nosso teste real:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adicione a seguinte seção ao seu package.json:
{  "scripts": {    "test": "jest"  }}
Por fim, execute yarn test ou npm run test e o Jest irá imprimir a seguinte mensagem:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Você escreveu com sucesso seu primeiro teste usando Jest!
Este teste usou expect e toBe para testar que dois valores eram exatamente idênticos. Para saber mais sobre as outras coisas que Jest pode testar, consulte Usando Matchers.
Executando a partir da linha de comando​
Você pode executar Jest diretamente da CLI (se ele estiver disponível globalmente em seu PATH, por exemplo: yarn global add jest ou npm install -g jest) com uma variedade de comandos úteis.
Aqui vemos como executar Jest em arquivos que correspondam ao my-test, usando config.json como um arquivo de configuração e exibir uma notificação nativa no Sistema Operacional após a execução:
jest my-test --notify --config=config.json
Se você gostaria de aprender mais sobre como executar jest através da linha de comando, dê uma olhada na página  Opções de CLI Jest.
Configuração adicional​
Gerando um arquivo de configuração básico​
Com base no seu projeto, o Jest fará algumas perguntas e irá criar um arquivo básico de configuração com uma breve descrição para cada opção:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale as dependências necessárias:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure o Babel para marcar a sua versão atual do Node criando um arquivo babel.config.js na raiz do seu projeto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
A configuração ideal para o Babel dependerá do seu projeto. Veja a documentação do Babel para mais detalhes.
Making your Babel config jest-awareJest definirá process.env.NODE_ENV para 'test' se não estiver definido para outra coisa. Você pode usar isso em sua configuração para configurar condicionalmente apenas a compilação necessária para Jest, por exemplo.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest é instalado automaticamente quando instalar Jest e irá automaticamente transformar arquivos caso uma configuração de babel existir em seu projeto. Para evitar esse comportamento, você pode redefinir explicitamente a opção de configuração de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest pode ser usado em projetos que usam webpack para gerenciar assets, estilos e compilação. webpack oferece alguns desafios únicos em relação à outras ferramentas. Consulte o guia do webpack para começar.
Usando Vite​
Jest pode ser utilizado em projetos que usam vite para servir código-fonte a partir de ESM nativo, fornecendo algumas ferramentas do frontend, vite é uma ferramenta opinativa e oferece alguns workflows diferenciados. Jest não é totalmente suportado pelo vite devido a como o sistema de plugins do vite funciona, mas há alguns exemplos para a integração de primeira classe usando vite-jest. Já que isto não é totalmente suportado, você deve ler também a limitação do vite-jest. Consulte o guia de vite para começar.
Usando Parcel​
Jest pode ser usado em projetos que usam parcel-bundler para gerenciar ativos, estilos, e compilação semelhante ao webpack. Parcel requer configuração zero. Veja a documentação oficial para começar.
Usando TypeScript​
Via babel​
O Jest suporta TypeScript, via Babel. Primeiro certifique-se que você seguir as instruções em usando o Babel acima. Em seguida, instale o @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Então adicione o @babel/preset-typescript à lista de presets em seu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
No entanto, há algumas ressalvas para usar TypeScript com Babel. Como o suporte para TypeScript em Babel é puramente transpilação, Jest não irá checar seus testes enquanto eles são executados. Se você quiser isso, você pode usar ts-jest em vez disso. ou apenas execute o compilador TypeScript tsc separadamente (ou como parte de seu processo de compilação).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Para que Jest interprete TypeScript com ts-jest, talvez você precise criar um arquivo de configuração.
Definições de tipo​
Existem duas maneiras de ter Jest global APIs tipado para arquivos de teste escritos em TypeScript.
Você pode usar as definições de tipo que já vem com o Jest e serão atualizadas a cada vez que você atualizar o Jest. Instale o pacote @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
E importe as APIs de:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipVeja a documentação de uso adicional de describe.each/test.each e funções de simulação (mock, em inglês).
Ou você pode escolher instalar o pacote @types/jest. Ele fornece tipos para os globais do Jest sem necessidade de importá-los.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
informação@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Tente coincidir com versões do Jest e @types/jest o mais próximo possível. Por exemplo, se você estiver usando a versão 27.4.0 do jest, então instalar 27.4.x de @types/jest é ideal.
Usando ESLint​
Jest pode ser usado com o ESLint sem qualquer configuração adicional, desde que você importe os ajudantes globais do Jest (describe, it, etc.) do @jest/globals antes de usá-los em seus arquivos de teste. Isso é necessário para evitar erros no-undef do ESLint, que não conhece sobre os globais do Jest.
Se quiser evitar essas importações, você pode configurar seu ambiente ESLint para suportar esses globais adicionando o ambiente jest:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Ou usar o eslint-plugin-jest que tem um efeito similar:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Editar esta páginaPróximoUsando MatchersExecutando a partir da linha de comandoConfiguração adicionalGerando um arquivo de configuração básicoUsando BabelUsando webpackUsando ViteUsando ParcelUsando TypeScriptUsando ESLint\n\n\n\nIntroducerePrimii pașiVersion: 29.7On this pagePrimii pașiInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adăugați secțiunea următoare în fișierul vostru package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Tocmai ați scris cu succes primul test folosind Jest!
Testul acesta a folosit expect și toBe pentru a testa dacă două valori sunt identice. Pentru a afla mai multe lucruri pe care Jest le poate testa, vezi Utilizarea regulilor de potrivire.
Rularea din linia de comandă​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Iată cum să executaţi Jest pe fişierele my-test, folosind config.json ca fişier de configurare şi afişarea unei notificări native de sistem după rulare:
jest my-test --notify --config=config.json
Dacă doriţi să aflaţi mai multe despre rularea jest prin linia de comandă, vezi pagina de Opțiuni Jest pentru linia de comandă.
Informații suplimentare​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Folosind Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Pentru a evita acest comportament, aveţi posibilitatea să reiniţializaţi explicit opţiunea de configurare transform:jest.config.jsmodule.exports = {  transform: {},};
Folosind Webpack​
Jest poate fi utilizat în proiecte care folosesc webpack pentru gestionarea fișierelor statice, stiluri şi compilare. webpack oferă unele provocări unice față de alte instrumente. Urmați ghidul webpack pentru a începe.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Folosind TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this page\n\nIntroducerePrimii pașiVersion: 29.7On this pagePrimii pașiInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adăugați secțiunea următoare în fișierul vostru package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Tocmai ați scris cu succes primul test folosind Jest!
Testul acesta a folosit expect și toBe pentru a testa dacă două valori sunt identice. Pentru a afla mai multe lucruri pe care Jest le poate testa, vezi Utilizarea regulilor de potrivire.
Rularea din linia de comandă​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Iată cum să executaţi Jest pe fişierele my-test, folosind config.json ca fişier de configurare şi afişarea unei notificări native de sistem după rulare:
jest my-test --notify --config=config.json
Dacă doriţi să aflaţi mai multe despre rularea jest prin linia de comandă, vezi pagina de Opțiuni Jest pentru linia de comandă.
Informații suplimentare​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Folosind Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Pentru a evita acest comportament, aveţi posibilitatea să reiniţializaţi explicit opţiunea de configurare transform:jest.config.jsmodule.exports = {  transform: {},};
Folosind Webpack​
Jest poate fi utilizat în proiecte care folosesc webpack pentru gestionarea fișierelor statice, stiluri şi compilare. webpack oferă unele provocări unice față de alte instrumente. Urmați ghidul webpack pentru a începe.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Folosind TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageÎnainteUtilizarea regulilor de potrivireRularea din linia de comandăInformații suplimentareGenerate a basic configuration fileFolosind BabelFolosind WebpackUsing ViteUsing ParcelFolosind TypeScriptUsing ESLint\n\n\n\nВведениеНачало работыVersion: 29.7On this pageНачало работыУстановите Jest используя ваш любимый менеджер пакетов:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Для начала напишем тест для функции, которая складывает два числа. Во-первых создайте файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Затем создайте файл с именем sum.test.js. Он будет содержать сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Добавьте следующий раздел в package.json:
{  "scripts": {    "test": "jest"  }}
Наконец, запустите yarn test или npm run test и Jest выведет это сообщение:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Вы только что успешно написали первый тест с использованием Jest!
Данный тест использует expect и toBe для проверки идентичности двух данных значений. Чтобы узнать об остальных вещах, которые можно протестировать с использованием Jest, смотрите использование сопоставлений.
Запуск из командной строки​
Вы можете запустить Jest прямо из командной строки (если он глобально доступен в PATH, например yarn global add jest или npm install jest --global) с множеством полезных опций.
Вот так можно запустить Jest для проверки файлов совпадающих с my-test, используя config.json в качестве файла конфигурации и для отображения нативного уведомления ОС после завершения:
jest my-test --notify --config=config.json
Если вы хотите узнать больше о работе с jest в командной строке, обратите внимание на страницу параметров командной строки Jest.
Дополнительная конфигурация​
Создание базового файла конфигурации​
Исходя из ваших нужд, Jest задаст вам несколько вопросов и создаст базовый файл конфигурации с кратким описанием для каждой опции:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
С использованием Babel​
Для использования с Babel, установите необходимые зависимости через yarn:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Настройте Babel на вашу текущую версию Node Js, создав файл babel.config.js в корне вашего проекта:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Идеальная конфигурация Babel будет зависеть от вашего проекта. Дополнительную информацию см. в документации Babe.l.
Добавление отдельной конфигурации для Babel только на время запуска JestJest автоматически установит для process.env.NODE_ENV значение 'test' если не указано другое. Вы можете использовать эту опцию, чтобы добавить настройки, которые будут использоваться только во время запуска Jest, например:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Для обхода данного поведения, вы можете явно сбросить опцию transform в конфигурации:jest.config.jsmodule.exports = {  transform: {},};
С использованием Webpack​
Jest может использоваться в проектах, использующих webpack для управления ресурсами, стилями и компиляцией. Webpack действительно привносит некоторые особенности, способные создать проблемы программистам, в сравнении с другими инструментами. Обратитесь к разделу руководство по работе с Webpack для начала работы с ним.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest может использоваться в проектах, использующих parcel-bundler для управления изображениями, стилями и компиляцией аналогично webpack Parcel не требует настройки Обратитесь к официальной документации для начала работы.
С использованием TypeScript​
Через babel​
Jest поддерживает TypeScript, через Babel. Сначала убедитесь, что вы следовали инструкциям по настройке Babel выше. Далее установите @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Затем добавьте @babel/preset-typescript в список пресетов в ваш babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Однако, есть несколько подводных камней в использовании TypeScript вместе с Babel. Поскольку TypeScript поддерживается в Babel через транспиляцию, Jest не будет проверять типы ваших тестах когда они запущены. Если вы хотите, то вы можете использовать ts-jest взамен, или просто запустите компилятор TypeScript tsc отдельно (или как часть вашего процесса сборки).
Через ts-jest​
ts-jest это препроцессор TypeScript с поддержкой исходных карт Jest, который позволяет использовать Jest для тестирования проектов, написанных на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Определения типов​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
И импортируйте API из него:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Использование ESLint​
Jest может использоваться с ESLint без дальнейшей конфигурации при импорте Jest global helpers (Описание, это, и т. д.) из @jest/globals перед использованием их в вашем тестовом файле. Это необходимо для того, чтобы избежать ошибок no-undef от ESLint, которые не знают о глобальных системах Jest.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редактировать страницу\n\nВведениеНачало работыVersion: 29.7On this pageНачало работыУстановите Jest используя ваш любимый менеджер пакетов:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Для начала напишем тест для функции, которая складывает два числа. Во-первых создайте файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Затем создайте файл с именем sum.test.js. Он будет содержать сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Добавьте следующий раздел в package.json:
{  "scripts": {    "test": "jest"  }}
Наконец, запустите yarn test или npm run test и Jest выведет это сообщение:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Вы только что успешно написали первый тест с использованием Jest!
Данный тест использует expect и toBe для проверки идентичности двух данных значений. Чтобы узнать об остальных вещах, которые можно протестировать с использованием Jest, смотрите использование сопоставлений.
Запуск из командной строки​
Вы можете запустить Jest прямо из командной строки (если он глобально доступен в PATH, например yarn global add jest или npm install jest --global) с множеством полезных опций.
Вот так можно запустить Jest для проверки файлов совпадающих с my-test, используя config.json в качестве файла конфигурации и для отображения нативного уведомления ОС после завершения:
jest my-test --notify --config=config.json
Если вы хотите узнать больше о работе с jest в командной строке, обратите внимание на страницу параметров командной строки Jest.
Дополнительная конфигурация​
Создание базового файла конфигурации​
Исходя из ваших нужд, Jest задаст вам несколько вопросов и создаст базовый файл конфигурации с кратким описанием для каждой опции:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
С использованием Babel​
Для использования с Babel, установите необходимые зависимости через yarn:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Настройте Babel на вашу текущую версию Node Js, создав файл babel.config.js в корне вашего проекта:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Идеальная конфигурация Babel будет зависеть от вашего проекта. Дополнительную информацию см. в документации Babe.l.
Добавление отдельной конфигурации для Babel только на время запуска JestJest автоматически установит для process.env.NODE_ENV значение 'test' если не указано другое. Вы можете использовать эту опцию, чтобы добавить настройки, которые будут использоваться только во время запуска Jest, например:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Для обхода данного поведения, вы можете явно сбросить опцию transform в конфигурации:jest.config.jsmodule.exports = {  transform: {},};
С использованием Webpack​
Jest может использоваться в проектах, использующих webpack для управления ресурсами, стилями и компиляцией. Webpack действительно привносит некоторые особенности, способные создать проблемы программистам, в сравнении с другими инструментами. Обратитесь к разделу руководство по работе с Webpack для начала работы с ним.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest может использоваться в проектах, использующих parcel-bundler для управления изображениями, стилями и компиляцией аналогично webpack Parcel не требует настройки Обратитесь к официальной документации для начала работы.
С использованием TypeScript​
Через babel​
Jest поддерживает TypeScript, через Babel. Сначала убедитесь, что вы следовали инструкциям по настройке Babel выше. Далее установите @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Затем добавьте @babel/preset-typescript в список пресетов в ваш babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Однако, есть несколько подводных камней в использовании TypeScript вместе с Babel. Поскольку TypeScript поддерживается в Babel через транспиляцию, Jest не будет проверять типы ваших тестах когда они запущены. Если вы хотите, то вы можете использовать ts-jest взамен, или просто запустите компилятор TypeScript tsc отдельно (или как часть вашего процесса сборки).
Через ts-jest​
ts-jest это препроцессор TypeScript с поддержкой исходных карт Jest, который позволяет использовать Jest для тестирования проектов, написанных на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Определения типов​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
И импортируйте API из него:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Использование ESLint​
Jest может использоваться с ESLint без дальнейшей конфигурации при импорте Jest global helpers (Описание, это, и т. д.) из @jest/globals перед использованием их в вашем тестовом файле. Это необходимо для того, чтобы избежать ошибок no-undef от ESLint, которые не знают о глобальных системах Jest.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редактировать страницуДалееИспользование сопоставленийЗапуск из командной строкиДополнительная конфигурацияСоздание базового файла конфигурацииС использованием BabelС использованием WebpackUsing ViteUsing ParcelС использованием TypeScriptИспользование ESLint\n\n\n\nВступПочаток роботиВерсія: 29.7На цій сторінціПочаток роботиВстановіть Jest за допомогою вашого улюбленого менеджера пакетів:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Давайте почнемо з написання тесту для гіпотетичної функції, яка додає два числа. Спочатку створіть файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Далі, створіть файл з назвою sum.test.js. Що буде містити сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Додайте наступну секцію до вашого package.json:
{  "scripts": {    "test": "jest"  }}
Тепер виконайте yarn test або npm test і Jest виведе це повідомлення:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Ви тільки що успішно написали свій перший тест, використовуючи Jest!
Цей тест використовує expect and toBe для перевірки, що два значення абсолютно ідентичні. Щоб дізнатися про інші речі, які Jest може тестувати, перегляньте  Використання Matchers.
Запуск з командного рядка​
Ви можете запустити Jest безпосередньо з командного рядка (якщо він доступний глобально у вашому PATH, наприклад yarn global add jest або npm install jest --global) з широким набором корисних параметрів.
Ось як можна запустити Jest для файлів, назва яких відповідає шаблону my-test, використовуючи config.json як файл конфігурації та з відображенням нативних сповіщень ОС після запуску:
jest my-test --notify --config=config.json
Щоб дізнатися більше про запуск jest з командного рядка, відвідайте сторінку параметри командного рядка Jest.
Додаткові налаштування​
Згенеруйте основний файл конфігурації​
В залежності від вашого проекту, Jest поставить вам кілька питань і створить початковий файл конфігурації з коротким описом кожного налаштування:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Використання Babel​
Щоб використовувати Babel, встановіть необхідні залежності:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Налаштуйте Babel відповідно до вашої версії Node, створивши файл babel.config.js в кореневому каталозі проекту:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Ідеальна конфігурація для Babel буде залежати від вашого проекту. Перегляньте документацію Babel для отримання додаткової інформації.
Налаштування вашої конфігурації Babel для роботи з JestJest встановлює значення 'test' в process.env.NODE_ENV, якщо не вказано інше. Ви можете використовувати це у вашій конфігурації для налаштування тільки тих параметрів компіляції, які потрібні для Jest, наприклад:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest автоматично встановлюється під час встановлення Jest і буде автоматично транслювати файли, якщо конфігурація Babel існує у вашому проєкті. Щоб відключити цю поведінку, ви можете явно очистити конфігураційни параметр transform:jest.config.jsmodule.exports = {  transform: {},};
Використання webpack​
Jest може застосовуватися в проектах, які використовують  webpack для керування ресурсами, стилями та компіляції коду. webpack кидає певні унікальні виклики для використання інших інструментів. Перегляньте посібник по роботі з webpack щоб почати його використовувати.
Використання Vite​
Jest може використовуватись в проєктах, які використовують vite для обслуговування вихідного коду через вбудовані ESM, щоб надати деякі інструменти фронтенду, vite є чудовим інструментом і пропонує деякі вбудовані робочі процеси. Vite не підтримує Jest повністю через особливості роботи своєї системи плагінів, але існують робочі приклади інтеграції jest за допомогою vite-jest. За відсутності повноцінної підтримки, також варто ознайомитись з обмеженнями vite-jest. Для початку роботи, зверніться до посібнику vite.
Використання Parcel​
Jest може використовуватись в проектах, що використовують parсel-bundler для керування ресурсами, стилями та компіляції, подібної до webpack. Parcel вимагає нульову конфігурацію. Зверніться до офіційної документації, щоб розпочати роботу.
Використання TypeScript​
За допомогою Babel​
Jest підтримує TypeScript, за допомогою Babel. По-перше, переконайтеся, що ви дотримувались інструкцій використовуючи Babel вище. Після цього встановіть @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Тоді додайте @babel/preset-typescript до списку пресетів у вашому babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Проте, є деякі застереження щодо використання TypeScript з Babel. Оскільки TypeScript в Babel є суто транспіляцією, Jest не буде перевіряти ваші тести, коли вони будуть запущені. Якщо вам це потрібно, ви можете використовувати ts-jest , або просто запустіть компілятор TypeScript tsc окремо (або до вашої частини процесу збірки).
За допомогою ts-jest​
ts-jest це препроцесор TypeScript з пітримкою source map для Jest, який дозволяє використовувати Jest для тестування проектів, написаних на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Для того, щоб Jest переклав TypeScript за допомогою ts-jest, вам також може знадобитись файл конфігурації.
Визначення типів​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Встановіть @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Та імпортуйте з нього API:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
порадаSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редагувати цю сторінку\n\nВступПочаток роботиВерсія: 29.7На цій сторінціПочаток роботиВстановіть Jest за допомогою вашого улюбленого менеджера пакетів:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Давайте почнемо з написання тесту для гіпотетичної функції, яка додає два числа. Спочатку створіть файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Далі, створіть файл з назвою sum.test.js. Що буде містити сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Додайте наступну секцію до вашого package.json:
{  "scripts": {    "test": "jest"  }}
Тепер виконайте yarn test або npm test і Jest виведе це повідомлення:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Ви тільки що успішно написали свій перший тест, використовуючи Jest!
Цей тест використовує expect and toBe для перевірки, що два значення абсолютно ідентичні. Щоб дізнатися про інші речі, які Jest може тестувати, перегляньте  Використання Matchers.
Запуск з командного рядка​
Ви можете запустити Jest безпосередньо з командного рядка (якщо він доступний глобально у вашому PATH, наприклад yarn global add jest або npm install jest --global) з широким набором корисних параметрів.
Ось як можна запустити Jest для файлів, назва яких відповідає шаблону my-test, використовуючи config.json як файл конфігурації та з відображенням нативних сповіщень ОС після запуску:
jest my-test --notify --config=config.json
Щоб дізнатися більше про запуск jest з командного рядка, відвідайте сторінку параметри командного рядка Jest.
Додаткові налаштування​
Згенеруйте основний файл конфігурації​
В залежності від вашого проекту, Jest поставить вам кілька питань і створить початковий файл конфігурації з коротким описом кожного налаштування:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Використання Babel​
Щоб використовувати Babel, встановіть необхідні залежності:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Налаштуйте Babel відповідно до вашої версії Node, створивши файл babel.config.js в кореневому каталозі проекту:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Ідеальна конфігурація для Babel буде залежати від вашого проекту. Перегляньте документацію Babel для отримання додаткової інформації.
Налаштування вашої конфігурації Babel для роботи з JestJest встановлює значення 'test' в process.env.NODE_ENV, якщо не вказано інше. Ви можете використовувати це у вашій конфігурації для налаштування тільки тих параметрів компіляції, які потрібні для Jest, наприклад:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest автоматично встановлюється під час встановлення Jest і буде автоматично транслювати файли, якщо конфігурація Babel існує у вашому проєкті. Щоб відключити цю поведінку, ви можете явно очистити конфігураційни параметр transform:jest.config.jsmodule.exports = {  transform: {},};
Використання webpack​
Jest може застосовуватися в проектах, які використовують  webpack для керування ресурсами, стилями та компіляції коду. webpack кидає певні унікальні виклики для використання інших інструментів. Перегляньте посібник по роботі з webpack щоб почати його використовувати.
Використання Vite​
Jest може використовуватись в проєктах, які використовують vite для обслуговування вихідного коду через вбудовані ESM, щоб надати деякі інструменти фронтенду, vite є чудовим інструментом і пропонує деякі вбудовані робочі процеси. Vite не підтримує Jest повністю через особливості роботи своєї системи плагінів, але існують робочі приклади інтеграції jest за допомогою vite-jest. За відсутності повноцінної підтримки, також варто ознайомитись з обмеженнями vite-jest. Для початку роботи, зверніться до посібнику vite.
Використання Parcel​
Jest може використовуватись в проектах, що використовують parсel-bundler для керування ресурсами, стилями та компіляції, подібної до webpack. Parcel вимагає нульову конфігурацію. Зверніться до офіційної документації, щоб розпочати роботу.
Використання TypeScript​
За допомогою Babel​
Jest підтримує TypeScript, за допомогою Babel. По-перше, переконайтеся, що ви дотримувались інструкцій використовуючи Babel вище. Після цього встановіть @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Тоді додайте @babel/preset-typescript до списку пресетів у вашому babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Проте, є деякі застереження щодо використання TypeScript з Babel. Оскільки TypeScript в Babel є суто транспіляцією, Jest не буде перевіряти ваші тести, коли вони будуть запущені. Якщо вам це потрібно, ви можете використовувати ts-jest , або просто запустіть компілятор TypeScript tsc окремо (або до вашої частини процесу збірки).
За допомогою ts-jest​
ts-jest це препроцесор TypeScript з пітримкою source map для Jest, який дозволяє використовувати Jest для тестування проектів, написаних на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Для того, щоб Jest переклав TypeScript за допомогою ts-jest, вам також може знадобитись файл конфігурації.
Визначення типів​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Встановіть @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Та імпортуйте з нього API:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
порадаSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редагувати цю сторінкуNextВикористання матчерівЗапуск з командного рядкаДодаткові налаштуванняЗгенеруйте основний файл конфігураціїВикористання BabelВикористання webpackВикористання ViteВикористання ParcelВикористання TypeScriptUsing ESLint\n\n\n\n介绍快速开始版本：29.7在本页快速开始使用你最喜欢的包管理器安装Jest：
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
举个例子，我们先写一个两数相加的函数。 首先，创建 sum.js 文件︰
function sum(a, b) {  return a + b;}module.exports = sum;
然后，创建名为 sum.test.js 的文件。 此文件中将包含我们的实际测试︰
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
随后，将下列配置内容添加到您的 package.json：
{  "scripts": {    "test": "jest"  }}
最后，运行 yarn test 或 npm run test ，Jest将打印下面这个消息：
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
您刚刚完成了您的首个 Jest 测试！
此测试使用 expect 和 toBe 来测试两值是否一致。 要了解 Jest 能进行的更多测试，请参阅使用匹配器章节。
在命令行中运行​
你可以通过命令行直接运行Jest(前提是jest已经处于你的环境变量 PATH中，例如通过 yarn global add jest 或 npm install jest --global安装的Jest) ，并为其指定各种有用的配置项。
这里演示了如何对能匹配到 my-test 的文件运行 Jest、使用config.json 作为一个配置文件、并在运行完成后显示一个原生的操作系统通知。
jest my-test --notify --config=config.json
如果你愿意了解更多关于通过命令行运行 jest 的内容，请继续阅读 Jest CLI 选项 页面。
更多配置​
生成基础配置文件​
基于您的项目，Jest将向您提出几个问题，并将创建一个基本的配置文件，每个选项都有一个简短的说明：
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
使用 Babel​
如果需要使用 Babel，安装所需的依赖。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
可以在工程的根目录下创建一个babel.config.js文件用于配置与你当前Node版本兼容的Babel：
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Jest与Babel的协同若 process.env.NODE_ENV 未设置，Jest将把它设置为 'test' 。你可以用 if语句设置Jest执行的编译配置。例如：babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};备注babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 如果要避免这个行为，你可以显式的重置 transform 配置项：jest.config.jsmodule.exports = {  transform: {},};
使用 webpack​
Jest 可以用于使用 webpack 来管理资源、 样式和编译的项目中。 webpack 与其他工具相比多了一些独特的挑战。 参考 webpack 指南 来开始起步。
使用 Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
使用 Parcel​
Parcel是一个类似于Webpack的零配置管理资源及样式的构建工具。Jest可以在Parcel构建的项目中使用。可以去Parcel官网 尝试一下。   请查看Parcel的 官方文档 进行操作。
使用 TypeScript​
通过 babel实现​
Jest可以通过Babel支持TypeScript。 首先，在项目中正确的使用Babel。 接着，安装 @babel/preset-typescript
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
你需要添加@babel/preset-typescript的预设到babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
不过，在配合使用TypeScript与Babel时，仍然有一些 注意事项 。   因为Babel对Typescrip的支持是纯编译形式（无类型校验），因此Jest在运行测试时不会对它们进行类型检查。  如果需要类型校验，可以改用ts-jest，也可以单独运行TypeScript编译器  tsc （或作为构建过程的一部分）。
通过 ts-jest实现​
ts-jest 是一个支持 sourcemap 的 TypeScript 预处理器，让你使用 TypeScript 编写 Jest 测试项目
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
类型定义​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. 安装 @jest/globals 包：
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
然后从中导入API：
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
提示See the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
信息@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
使用 ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}编辑此页\n\n介绍快速开始版本：29.7在本页快速开始使用你最喜欢的包管理器安装Jest：
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
举个例子，我们先写一个两数相加的函数。 首先，创建 sum.js 文件︰
function sum(a, b) {  return a + b;}module.exports = sum;
然后，创建名为 sum.test.js 的文件。 此文件中将包含我们的实际测试︰
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
随后，将下列配置内容添加到您的 package.json：
{  "scripts": {    "test": "jest"  }}
最后，运行 yarn test 或 npm run test ，Jest将打印下面这个消息：
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
您刚刚完成了您的首个 Jest 测试！
此测试使用 expect 和 toBe 来测试两值是否一致。 要了解 Jest 能进行的更多测试，请参阅使用匹配器章节。
在命令行中运行​
你可以通过命令行直接运行Jest(前提是jest已经处于你的环境变量 PATH中，例如通过 yarn global add jest 或 npm install jest --global安装的Jest) ，并为其指定各种有用的配置项。
这里演示了如何对能匹配到 my-test 的文件运行 Jest、使用config.json 作为一个配置文件、并在运行完成后显示一个原生的操作系统通知。
jest my-test --notify --config=config.json
如果你愿意了解更多关于通过命令行运行 jest 的内容，请继续阅读 Jest CLI 选项 页面。
更多配置​
生成基础配置文件​
基于您的项目，Jest将向您提出几个问题，并将创建一个基本的配置文件，每个选项都有一个简短的说明：
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
使用 Babel​
如果需要使用 Babel，安装所需的依赖。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
可以在工程的根目录下创建一个babel.config.js文件用于配置与你当前Node版本兼容的Babel：
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Jest与Babel的协同若 process.env.NODE_ENV 未设置，Jest将把它设置为 'test' 。你可以用 if语句设置Jest执行的编译配置。例如：babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};备注babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 如果要避免这个行为，你可以显式的重置 transform 配置项：jest.config.jsmodule.exports = {  transform: {},};
使用 webpack​
Jest 可以用于使用 webpack 来管理资源、 样式和编译的项目中。 webpack 与其他工具相比多了一些独特的挑战。 参考 webpack 指南 来开始起步。
使用 Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
使用 Parcel​
Parcel是一个类似于Webpack的零配置管理资源及样式的构建工具。Jest可以在Parcel构建的项目中使用。可以去Parcel官网 尝试一下。   请查看Parcel的 官方文档 进行操作。
使用 TypeScript​
通过 babel实现​
Jest可以通过Babel支持TypeScript。 首先，在项目中正确的使用Babel。 接着，安装 @babel/preset-typescript
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
你需要添加@babel/preset-typescript的预设到babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
不过，在配合使用TypeScript与Babel时，仍然有一些 注意事项 。   因为Babel对Typescrip的支持是纯编译形式（无类型校验），因此Jest在运行测试时不会对它们进行类型检查。  如果需要类型校验，可以改用ts-jest，也可以单独运行TypeScript编译器  tsc （或作为构建过程的一部分）。
通过 ts-jest实现​
ts-jest 是一个支持 sourcemap 的 TypeScript 预处理器，让你使用 TypeScript 编写 Jest 测试项目
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
类型定义​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. 安装 @jest/globals 包：
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
然后从中导入API：
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
提示See the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
信息@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
使用 ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}编辑此页下一个匹配器的使用在命令行中运行更多配置生成基础配置文件使用 Babel使用 webpack使用 Vite使用 Parcel使用 TypeScript使用 ESLint\n\n\n\nIntroductionUsing MatchersVersion: 29.7On this pageUsing MatchersJest uses "matchers" to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the expect API doc.
Common Matchers​
The simplest way to test a value is with exact equality.
test('two plus two is four', () => {  expect(2 + 2).toBe(4);});
In this code, expect(2 + 2) returns an "expectation" object. You typically won't do much with these expectation objects except call matchers on them. In this code, .toBe(4) is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.
toBe uses Object.is to test exact equality. If you want to check the value of an object, use toEqual:
test('object assignment', () => {  const data = {one: 1};  data['two'] = 2;  expect(data).toEqual({one: 1, two: 2});});
toEqual recursively checks every field of an object or array.
tiptoEqual ignores object keys with undefined properties, undefined array items, array sparseness, or object type mismatch. To take these into account use toStrictEqual instead.
You can also test for the opposite of a matcher using not:
test('adding positive numbers is not zero', () => {  for (let a = 1; a < 10; a++) {    for (let b = 1; b < 10; b++) {      expect(a + b).not.toBe(0);    }  }});
Truthiness​
In tests, you sometimes need to distinguish between undefined, null, and false, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.

toBeNull matches only null
toBeUndefined matches only undefined
toBeDefined is the opposite of toBeUndefined
toBeTruthy matches anything that an if statement treats as true
toBeFalsy matches anything that an if statement treats as false

For example:
test('null', () => {  const n = null;  expect(n).toBeNull();  expect(n).toBeDefined();  expect(n).not.toBeUndefined();  expect(n).not.toBeTruthy();  expect(n).toBeFalsy();});test('zero', () => {  const z = 0;  expect(z).not.toBeNull();  expect(z).toBeDefined();  expect(z).not.toBeUndefined();  expect(z).not.toBeTruthy();  expect(z).toBeFalsy();});
You should use the matcher that most precisely corresponds to what you want your code to be doing.
Numbers​
Most ways of comparing numbers have matcher equivalents.
test('two plus two', () => {  const value = 2 + 2;  expect(value).toBeGreaterThan(3);  expect(value).toBeGreaterThanOrEqual(3.5);  expect(value).toBeLessThan(5);  expect(value).toBeLessThanOrEqual(4.5);  // toBe and toEqual are equivalent for numbers  expect(value).toBe(4);  expect(value).toEqual(4);});
For floating point equality, use toBeCloseTo instead of toEqual, because you don't want a test to depend on a tiny rounding error.
test('adding floating point numbers', () => {  const value = 0.1 + 0.2;  //expect(value).toBe(0.3);           This won't work because of rounding error  expect(value).toBeCloseTo(0.3); // This works.});
Strings​
You can check strings against regular expressions with toMatch:
test('there is no I in team', () => {  expect('team').not.toMatch(/I/);});test('but there is a "stop" in Christoph', () => {  expect('Christoph').toMatch(/stop/);});
Arrays and iterables​
You can check if an array or iterable contains a particular item using toContain:
const shoppingList = [  'diapers',  'kleenex',  'trash bags',  'paper towels',  'milk',];test('the shopping list has milk on it', () => {  expect(shoppingList).toContain('milk');  expect(new Set(shoppingList)).toContain('milk');});
Exceptions​
If you want to test whether a particular function throws an error when it's called, use toThrow.
function compileAndroidCode() {  throw new Error('you are using the wrong JDK!');}test('compiling android goes as expected', () => {  expect(() => compileAndroidCode()).toThrow();  expect(() => compileAndroidCode()).toThrow(Error);  // You can also use a string that must be contained in the error message or a regexp  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');  expect(() => compileAndroidCode()).toThrow(/JDK/);  // Or you can match an exact error message using a regexp like below  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass});
tipThe function that throws an exception needs to be invoked within a wrapping function otherwise the toThrow assertion will fail.
And More​
This is just a taste. For a complete list of matchers, check out the reference docs.
Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you test asynchronous code.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nIntroductionUsing MatchersVersion: 29.7On this pageUsing MatchersJest uses "matchers" to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the expect API doc.
Common Matchers​
The simplest way to test a value is with exact equality.
test('two plus two is four', () => {  expect(2 + 2).toBe(4);});
In this code, expect(2 + 2) returns an "expectation" object. You typically won't do much with these expectation objects except call matchers on them. In this code, .toBe(4) is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.
toBe uses Object.is to test exact equality. If you want to check the value of an object, use toEqual:
test('object assignment', () => {  const data = {one: 1};  data['two'] = 2;  expect(data).toEqual({one: 1, two: 2});});
toEqual recursively checks every field of an object or array.
tiptoEqual ignores object keys with undefined properties, undefined array items, array sparseness, or object type mismatch. To take these into account use toStrictEqual instead.
You can also test for the opposite of a matcher using not:
test('adding positive numbers is not zero', () => {  for (let a = 1; a < 10; a++) {    for (let b = 1; b < 10; b++) {      expect(a + b).not.toBe(0);    }  }});
Truthiness​
In tests, you sometimes need to distinguish between undefined, null, and false, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.

toBeNull matches only null
toBeUndefined matches only undefined
toBeDefined is the opposite of toBeUndefined
toBeTruthy matches anything that an if statement treats as true
toBeFalsy matches anything that an if statement treats as false

For example:
test('null', () => {  const n = null;  expect(n).toBeNull();  expect(n).toBeDefined();  expect(n).not.toBeUndefined();  expect(n).not.toBeTruthy();  expect(n).toBeFalsy();});test('zero', () => {  const z = 0;  expect(z).not.toBeNull();  expect(z).toBeDefined();  expect(z).not.toBeUndefined();  expect(z).not.toBeTruthy();  expect(z).toBeFalsy();});
You should use the matcher that most precisely corresponds to what you want your code to be doing.
Numbers​
Most ways of comparing numbers have matcher equivalents.
test('two plus two', () => {  const value = 2 + 2;  expect(value).toBeGreaterThan(3);  expect(value).toBeGreaterThanOrEqual(3.5);  expect(value).toBeLessThan(5);  expect(value).toBeLessThanOrEqual(4.5);  // toBe and toEqual are equivalent for numbers  expect(value).toBe(4);  expect(value).toEqual(4);});
For floating point equality, use toBeCloseTo instead of toEqual, because you don't want a test to depend on a tiny rounding error.
test('adding floating point numbers', () => {  const value = 0.1 + 0.2;  //expect(value).toBe(0.3);           This won't work because of rounding error  expect(value).toBeCloseTo(0.3); // This works.});
Strings​
You can check strings against regular expressions with toMatch:
test('there is no I in team', () => {  expect('team').not.toMatch(/I/);});test('but there is a "stop" in Christoph', () => {  expect('Christoph').toMatch(/stop/);});
Arrays and iterables​
You can check if an array or iterable contains a particular item using toContain:
const shoppingList = [  'diapers',  'kleenex',  'trash bags',  'paper towels',  'milk',];test('the shopping list has milk on it', () => {  expect(shoppingList).toContain('milk');  expect(new Set(shoppingList)).toContain('milk');});
Exceptions​
If you want to test whether a particular function throws an error when it's called, use toThrow.
function compileAndroidCode() {  throw new Error('you are using the wrong JDK!');}test('compiling android goes as expected', () => {  expect(() => compileAndroidCode()).toThrow();  expect(() => compileAndroidCode()).toThrow(Error);  // You can also use a string that must be contained in the error message or a regexp  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');  expect(() => compileAndroidCode()).toThrow(/JDK/);  // Or you can match an exact error message using a regexp like below  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass});
tipThe function that throws an exception needs to be invoked within a wrapping function otherwise the toThrow assertion will fail.
And More​
This is just a taste. For a complete list of matchers, check out the reference docs.
Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you test asynchronous code.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousGetting StartedNextTesting Asynchronous CodeCommon MatchersTruthinessNumbersStringsArrays and iterablesExceptionsAnd More\n\n\n\nIntroductionTesting Asynchronous CodeVersion: 29.7On this pageTesting Asynchronous CodeIt's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.
Promises​
Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail.
For example, let's say that fetchData returns a promise that is supposed to resolve to the string 'peanut butter'. We could test it with:
test('the data is peanut butter', () => {  return fetchData().then(data => {    expect(data).toBe('peanut butter');  });});
Async/Await​
Alternatively, you can use async and await in your tests. To write an async test, use the async keyword in front of the function passed to test. For example, the same fetchData scenario can be tested with:
test('the data is peanut butter', async () => {  const data = await fetchData();  expect(data).toBe('peanut butter');});test('the fetch fails with an error', async () => {  expect.assertions(1);  try {    await fetchData();  } catch (error) {    expect(error).toMatch('error');  }});
You can combine async and await with .resolves or .rejects.
test('the data is peanut butter', async () => {  await expect(fetchData()).resolves.toBe('peanut butter');});test('the fetch fails with an error', async () => {  await expect(fetchData()).rejects.toMatch('error');});
In these cases, async and await are effectively syntactic sugar for the same logic as the promises example uses.
cautionBe sure to return (or await) the promise - if you omit the return/await statement, your test will complete before the promise returned from fetchData resolves or rejects.
If you expect a promise to be rejected, use the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test.
test('the fetch fails with an error', () => {  expect.assertions(1);  return fetchData().catch(error => expect(error).toMatch('error'));});
Callbacks​
If you don't use promises, you can use callbacks. For example, let's say that fetchData, instead of returning a promise, expects a callback, i.e. fetches some data and calls callback(null, data) when it is complete. You want to test that this returned data is the string 'peanut butter'.
By default, Jest tests complete once they reach the end of their execution. That means this test will not work as intended:
// Don't do this!test('the data is peanut butter', () => {  function callback(error, data) {    if (error) {      throw error;    }    expect(data).toBe('peanut butter');  }  fetchData(callback);});
The problem is that the test will complete as soon as fetchData completes, before ever calling the callback.
There is an alternate form of test that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called done. Jest will wait until the done callback is called before finishing the test.
test('the data is peanut butter', done => {  function callback(error, data) {    if (error) {      done(error);      return;    }    try {      expect(data).toBe('peanut butter');      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});
If done() is never called, the test will fail (with timeout error), which is what you want to happen.
If the expect statement fails, it throws an error and done() is not called. If we want to see in the test log why it failed, we have to wrap expect in a try block and pass the error in the catch block to done. Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).
cautionJest will throw an error, if the same test function is passed a done() callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests.
.resolves / .rejects​
You can also use the .resolves matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.
test('the data is peanut butter', () => {  return expect(fetchData()).resolves.toBe('peanut butter');});
Be sure to return the assertion—if you omit this return statement, your test will complete before the promise returned from fetchData is resolved and then() has a chance to execute the callback.
If you expect a promise to be rejected, use the .rejects matcher. It works analogically to the .resolves matcher. If the promise is fulfilled, the test will automatically fail.
test('the fetch fails with an error', () => {  return expect(fetchData()).rejects.toMatch('error');});
None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.Edit this pageLast updated on Dec 30, 2023 by Simen Bekkhus\n\nIntroductionTesting Asynchronous CodeVersion: 29.7On this pageTesting Asynchronous CodeIt's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.
Promises​
Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail.
For example, let's say that fetchData returns a promise that is supposed to resolve to the string 'peanut butter'. We could test it with:
test('the data is peanut butter', () => {  return fetchData().then(data => {    expect(data).toBe('peanut butter');  });});
Async/Await​
Alternatively, you can use async and await in your tests. To write an async test, use the async keyword in front of the function passed to test. For example, the same fetchData scenario can be tested with:
test('the data is peanut butter', async () => {  const data = await fetchData();  expect(data).toBe('peanut butter');});test('the fetch fails with an error', async () => {  expect.assertions(1);  try {    await fetchData();  } catch (error) {    expect(error).toMatch('error');  }});
You can combine async and await with .resolves or .rejects.
test('the data is peanut butter', async () => {  await expect(fetchData()).resolves.toBe('peanut butter');});test('the fetch fails with an error', async () => {  await expect(fetchData()).rejects.toMatch('error');});
In these cases, async and await are effectively syntactic sugar for the same logic as the promises example uses.
cautionBe sure to return (or await) the promise - if you omit the return/await statement, your test will complete before the promise returned from fetchData resolves or rejects.
If you expect a promise to be rejected, use the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test.
test('the fetch fails with an error', () => {  expect.assertions(1);  return fetchData().catch(error => expect(error).toMatch('error'));});
Callbacks​
If you don't use promises, you can use callbacks. For example, let's say that fetchData, instead of returning a promise, expects a callback, i.e. fetches some data and calls callback(null, data) when it is complete. You want to test that this returned data is the string 'peanut butter'.
By default, Jest tests complete once they reach the end of their execution. That means this test will not work as intended:
// Don't do this!test('the data is peanut butter', () => {  function callback(error, data) {    if (error) {      throw error;    }    expect(data).toBe('peanut butter');  }  fetchData(callback);});
The problem is that the test will complete as soon as fetchData completes, before ever calling the callback.
There is an alternate form of test that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called done. Jest will wait until the done callback is called before finishing the test.
test('the data is peanut butter', done => {  function callback(error, data) {    if (error) {      done(error);      return;    }    try {      expect(data).toBe('peanut butter');      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});
If done() is never called, the test will fail (with timeout error), which is what you want to happen.
If the expect statement fails, it throws an error and done() is not called. If we want to see in the test log why it failed, we have to wrap expect in a try block and pass the error in the catch block to done. Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).
cautionJest will throw an error, if the same test function is passed a done() callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests.
.resolves / .rejects​
You can also use the .resolves matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.
test('the data is peanut butter', () => {  return expect(fetchData()).resolves.toBe('peanut butter');});
Be sure to return the assertion—if you omit this return statement, your test will complete before the promise returned from fetchData is resolved and then() has a chance to execute the callback.
If you expect a promise to be rejected, use the .rejects matcher. It works analogically to the .resolves matcher. If the promise is fulfilled, the test will automatically fail.
test('the fetch fails with an error', () => {  return expect(fetchData()).rejects.toMatch('error');});
None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.Edit this pageLast updated on Dec 30, 2023 by Simen BekkhusPreviousUsing MatchersNextSetup and TeardownPromisesAsync/AwaitCallbacks.resolves / .rejects\n\n\n\nIntroductionSetup and TeardownVersion: 29.7On this pageSetup and TeardownOften while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.
Repeating Setup​
If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach hooks.
For example, let's say that several tests interact with a database of cities. You have a method initializeCityDatabase() that must be called before each of these tests, and a method clearCityDatabase() that must be called after each of these tests. You can do this with:
beforeEach(() => {  initializeCityDatabase();});afterEach(() => {  clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
beforeEach and afterEach can handle asynchronous code in the same ways that tests can handle asynchronous code - they can either take a done parameter or return a promise. For example, if initializeCityDatabase() returned a promise that resolved when the database was initialized, we would want to return that promise:
beforeEach(() => {  return initializeCityDatabase();});
One-Time Setup​
In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides beforeAll and afterAll hooks to handle this situation.
For example, if both initializeCityDatabase() and clearCityDatabase() returned promises, and the city database could be reused between tests, we could change our test code to:
beforeAll(() => {  return initializeCityDatabase();});afterAll(() => {  return clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
Scoping​
The top level before* and after* hooks apply to every test in a file. The hooks declared inside a describe block apply only to the tests within that describe block.
For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:
// Applies to all tests in this filebeforeEach(() => {  return initializeCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});describe('matching cities to foods', () => {  // Applies only to tests in this describe block  beforeEach(() => {    return initializeFoodDatabase();  });  test('Vienna <3 veal', () => {    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);  });  test('San Juan <3 plantains', () => {    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);  });});
Note that the top-level beforeEach is executed before the beforeEach inside the describe block. It may help to illustrate the order of execution of all hooks.
beforeAll(() => console.log('1 - beforeAll'));afterAll(() => console.log('1 - afterAll'));beforeEach(() => console.log('1 - beforeEach'));afterEach(() => console.log('1 - afterEach'));test('', () => console.log('1 - test'));describe('Scoped / Nested block', () => {  beforeAll(() => console.log('2 - beforeAll'));  afterAll(() => console.log('2 - afterAll'));  beforeEach(() => console.log('2 - beforeEach'));  afterEach(() => console.log('2 - afterEach'));  test('', () => console.log('2 - test'));});// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll
Order of Execution​
Jest executes all describe handlers in a test file before it executes any of the actual tests. This is another reason to do setup and teardown inside before* and after* handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.
Consider the following illustrative test file and output:
describe('describe outer', () => {  console.log('describe outer-a');  describe('describe inner 1', () => {    console.log('describe inner 1');    test('test 1', () => console.log('test 1'));  });  console.log('describe outer-b');  test('test 2', () => console.log('test 2'));  describe('describe inner 2', () => {    console.log('describe inner 2');    test('test 3', () => console.log('test 3'));  });  console.log('describe outer-c');});// describe outer-a// describe inner 1// describe outer-b// describe inner 2// describe outer-c// test 1// test 2// test 3
Just like the describe and test blocks Jest calls the before* and after* hooks in the order of declaration. Note that the after* hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:
beforeEach(() => console.log('connection setup'));beforeEach(() => console.log('database setup'));afterEach(() => console.log('database teardown'));afterEach(() => console.log('connection teardown'));test('test 1', () => console.log('test 1'));describe('extra', () => {  beforeEach(() => console.log('extra database setup'));  afterEach(() => console.log('extra database teardown'));  test('test 2', () => console.log('test 2'));});// connection setup// database setup// test 1// database teardown// connection teardown// connection setup// database setup// extra database setup// test 2// extra database teardown// database teardown// connection teardown
noteIf you are using jasmine2 test runner, take into account that it calls the after* hooks in the reverse order of declaration. To have identical output, the above example should be altered like this:  beforeEach(() => console.log('connection setup'));+ afterEach(() => console.log('connection teardown'));  beforeEach(() => console.log('database setup'));+ afterEach(() => console.log('database teardown'));- afterEach(() => console.log('database teardown'));- afterEach(() => console.log('connection teardown'));  // ...
General Advice​
If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that test command to a test.only:
test.only('this will be the only test that runs', () => {  expect(true).toBe(false);});test('this test will not run', () => {  expect('A').toBe('A');});
If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you're not sure whether some shared state is being modified, you can also try a beforeEach that logs data.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nIntroductionSetup and TeardownVersion: 29.7On this pageSetup and TeardownOften while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.
Repeating Setup​
If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach hooks.
For example, let's say that several tests interact with a database of cities. You have a method initializeCityDatabase() that must be called before each of these tests, and a method clearCityDatabase() that must be called after each of these tests. You can do this with:
beforeEach(() => {  initializeCityDatabase();});afterEach(() => {  clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
beforeEach and afterEach can handle asynchronous code in the same ways that tests can handle asynchronous code - they can either take a done parameter or return a promise. For example, if initializeCityDatabase() returned a promise that resolved when the database was initialized, we would want to return that promise:
beforeEach(() => {  return initializeCityDatabase();});
One-Time Setup​
In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides beforeAll and afterAll hooks to handle this situation.
For example, if both initializeCityDatabase() and clearCityDatabase() returned promises, and the city database could be reused between tests, we could change our test code to:
beforeAll(() => {  return initializeCityDatabase();});afterAll(() => {  return clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
Scoping​
The top level before* and after* hooks apply to every test in a file. The hooks declared inside a describe block apply only to the tests within that describe block.
For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:
// Applies to all tests in this filebeforeEach(() => {  return initializeCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});describe('matching cities to foods', () => {  // Applies only to tests in this describe block  beforeEach(() => {    return initializeFoodDatabase();  });  test('Vienna <3 veal', () => {    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);  });  test('San Juan <3 plantains', () => {    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);  });});
Note that the top-level beforeEach is executed before the beforeEach inside the describe block. It may help to illustrate the order of execution of all hooks.
beforeAll(() => console.log('1 - beforeAll'));afterAll(() => console.log('1 - afterAll'));beforeEach(() => console.log('1 - beforeEach'));afterEach(() => console.log('1 - afterEach'));test('', () => console.log('1 - test'));describe('Scoped / Nested block', () => {  beforeAll(() => console.log('2 - beforeAll'));  afterAll(() => console.log('2 - afterAll'));  beforeEach(() => console.log('2 - beforeEach'));  afterEach(() => console.log('2 - afterEach'));  test('', () => console.log('2 - test'));});// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll
Order of Execution​
Jest executes all describe handlers in a test file before it executes any of the actual tests. This is another reason to do setup and teardown inside before* and after* handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.
Consider the following illustrative test file and output:
describe('describe outer', () => {  console.log('describe outer-a');  describe('describe inner 1', () => {    console.log('describe inner 1');    test('test 1', () => console.log('test 1'));  });  console.log('describe outer-b');  test('test 2', () => console.log('test 2'));  describe('describe inner 2', () => {    console.log('describe inner 2');    test('test 3', () => console.log('test 3'));  });  console.log('describe outer-c');});// describe outer-a// describe inner 1// describe outer-b// describe inner 2// describe outer-c// test 1// test 2// test 3
Just like the describe and test blocks Jest calls the before* and after* hooks in the order of declaration. Note that the after* hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:
beforeEach(() => console.log('connection setup'));beforeEach(() => console.log('database setup'));afterEach(() => console.log('database teardown'));afterEach(() => console.log('connection teardown'));test('test 1', () => console.log('test 1'));describe('extra', () => {  beforeEach(() => console.log('extra database setup'));  afterEach(() => console.log('extra database teardown'));  test('test 2', () => console.log('test 2'));});// connection setup// database setup// test 1// database teardown// connection teardown// connection setup// database setup// extra database setup// test 2// extra database teardown// database teardown// connection teardown
noteIf you are using jasmine2 test runner, take into account that it calls the after* hooks in the reverse order of declaration. To have identical output, the above example should be altered like this:  beforeEach(() => console.log('connection setup'));+ afterEach(() => console.log('connection teardown'));  beforeEach(() => console.log('database setup'));+ afterEach(() => console.log('database teardown'));- afterEach(() => console.log('database teardown'));- afterEach(() => console.log('connection teardown'));  // ...
General Advice​
If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that test command to a test.only:
test.only('this will be the only test that runs', () => {  expect(true).toBe(false);});test('this test will not run', () => {  expect('A').toBe('A');});
If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you're not sure whether some shared state is being modified, you can also try a beforeEach that logs data.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousTesting Asynchronous CodeNextMock FunctionsRepeating SetupOne-Time SetupScopingOrder of ExecutionGeneral Advice\n\n\n\nIntroductionMock FunctionsVersion: 29.7On this pageMock FunctionsMock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with new, and allowing test-time configuration of return values.
There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a manual mock to override a module dependency.
Using a mock function​
Let's imagine we're testing an implementation of a function forEach, which invokes a callback for each item in a supplied array.
forEach.jsexport function forEach(items, callback) {  for (const item of items) {    callback(item);  }}
To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.
forEach.test.jsconst forEach = require('./forEach');const mockCallback = jest.fn(x => 42 + x);test('forEach mock function', () => {  forEach([0, 1], mockCallback);  // The mock function was called twice  expect(mockCallback.mock.calls).toHaveLength(2);  // The first argument of the first call to the function was 0  expect(mockCallback.mock.calls[0][0]).toBe(0);  // The first argument of the second call to the function was 1  expect(mockCallback.mock.calls[1][0]).toBe(1);  // The return value of the first call to the function was 42  expect(mockCallback.mock.results[0].value).toBe(42);});
.mock property​
All mock functions have this special .mock property, which is where data about how the function has been called and what the function returned is kept. The .mock property also tracks the value of this for each call, so it is possible to inspect this as well:
const myMock1 = jest.fn();const a = new myMock1();console.log(myMock1.mock.instances);// > [ <a> ]const myMock2 = jest.fn();const b = {};const bound = myMock2.bind(b);bound();console.log(myMock2.mock.contexts);// > [ <b> ]
These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:
// The function was called exactly onceexpect(someMockFunction.mock.calls).toHaveLength(1);// The first arg of the first call to the function was 'first arg'expect(someMockFunction.mock.calls[0][0]).toBe('first arg');// The second arg of the first call to the function was 'second arg'expect(someMockFunction.mock.calls[0][1]).toBe('second arg');// The return value of the first call to the function was 'return value'expect(someMockFunction.mock.results[0].value).toBe('return value');// The function was called with a certain `this` context: the `element` object.expect(someMockFunction.mock.contexts[0]).toBe(element);// This function was instantiated exactly twiceexpect(someMockFunction.mock.instances.length).toBe(2);// The object returned by the first instantiation of this function// had a `name` property whose value was set to 'test'expect(someMockFunction.mock.instances[0].name).toBe('test');// The first argument of the last call to the function was 'test'expect(someMockFunction.mock.lastCall[0]).toBe('test');
Mock Return Values​
Mock functions can also be used to inject test values into your code during a test:
const myMock = jest.fn();console.log(myMock());// > undefinedmyMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());// > 10, 'x', true, true
Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.
const filterTestFn = jest.fn();// Make the mock return `true` for the first call,// and `false` for the second callfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [11, 12].filter(num => filterTestFn(num));console.log(result);// > [11]console.log(filterTestFn.mock.calls[0][0]); // 11console.log(filterTestFn.mock.calls[1][0]); // 12
Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.
Mocking Modules​
Suppose we have a class that fetches users from our API. The class uses axios to call the API then returns the data attribute which contains all the users:
users.jsimport axios from 'axios';class Users {  static all() {    return axios.get('/users.json').then(resp => resp.data);  }}export default Users;
Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the jest.mock(...) function to automatically mock the axios module.
Once we mock the module we can provide a mockResolvedValue for .get that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.
users.test.jsimport axios from 'axios';import Users from './users';jest.mock('axios');test('should fetch users', () => {  const users = [{name: 'Bob'}];  const resp = {data: users};  axios.get.mockResolvedValue(resp);  // or you could use the following depending on your use case:  // axios.get.mockImplementation(() => Promise.resolve(resp))  return Users.all().then(data => expect(data).toEqual(users));});
Mocking Partials​
Subsets of a module can be mocked and the rest of the module can keep their actual implementation:
foo-bar-baz.jsexport const foo = 'foo';export const bar = () => 'bar';export default () => 'baz';
//test.jsimport defaultExport, {bar, foo} from '../foo-bar-baz';jest.mock('../foo-bar-baz', () => {  const originalModule = jest.requireActual('../foo-bar-baz');  //Mock the default export and named export 'foo'  return {    __esModule: true,    ...originalModule,    default: jest.fn(() => 'mocked baz'),    foo: 'mocked foo',  };});test('should do a partial mock', () => {  const defaultExportResult = defaultExport();  expect(defaultExportResult).toBe('mocked baz');  expect(defaultExport).toHaveBeenCalled();  expect(foo).toBe('mocked foo');  expect(bar()).toBe('bar');});
Mock Implementations​
Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with jest.fn or the mockImplementationOnce method on mock functions.
const myMockFn = jest.fn(cb => cb(null, true));myMockFn((err, val) => console.log(val));// > true
The mockImplementation method is useful when you need to define the default implementation of a mock function that is created from another module:
foo.jsmodule.exports = function () {  // some implementation;};
test.jsjest.mock('../foo'); // this happens automatically with automockingconst foo = require('../foo');// foo is a mock functionfoo.mockImplementation(() => 42);foo();// > 42
When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the mockImplementationOnce method:
const myMockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));myMockFn((err, val) => console.log(val));// > truemyMockFn((err, val) => console.log(val));// > false
When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with jest.fn (if it is defined):
const myMockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());// > 'first call', 'second call', 'default', 'default'
For cases where we have methods that are typically chained (and thus always need to return this), we have a sugary API to simplify this in the form of a .mockReturnThis() function that also sits on all mocks:
const myObj = {  myMethod: jest.fn().mockReturnThis(),};// is the same asconst otherObj = {  myMethod: jest.fn(function () {    return this;  }),};
Mock Names​
You can optionally provide a name for your mock functions, which will be displayed instead of 'jest.fn()' in the test error output. Use .mockName() if you want to be able to quickly identify the mock function reporting an error in your test output.
const myMockFn = jest  .fn()  .mockReturnValue('default')  .mockImplementation(scalar => 42 + scalar)  .mockName('add42');
Custom Matchers​
Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:
// The mock function was called at least onceexpect(mockFunc).toHaveBeenCalled();// The mock function was called at least once with the specified argsexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2);// The last call to the mock function was called with the specified argsexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);// All calls and the name of the mock is written as a snapshotexpect(mockFunc).toMatchSnapshot();
These matchers are sugar for common forms of inspecting the .mock property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:
// The mock function was called at least onceexpect(mockFunc.mock.calls.length).toBeGreaterThan(0);// The mock function was called at least once with the specified argsexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);// The last call to the mock function was called with the specified argsexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([  arg1,  arg2,]);// The first arg of the last call to the mock function was `42`// (note that there is no sugar helper for this specific of an assertion)expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// A snapshot will check that a mock was invoked the same number of times,// in the same order, with the same arguments. It will also assert on the name.expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);expect(mockFunc.getMockName()).toBe('a mock name');
For a complete list of matchers, check out the reference docs.Edit this pageLast updated on Dec 29, 2023 by Simen Bekkhus\n\nIntroductionMock FunctionsVersion: 29.7On this pageMock FunctionsMock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with new, and allowing test-time configuration of return values.
There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a manual mock to override a module dependency.
Using a mock function​
Let's imagine we're testing an implementation of a function forEach, which invokes a callback for each item in a supplied array.
forEach.jsexport function forEach(items, callback) {  for (const item of items) {    callback(item);  }}
To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.
forEach.test.jsconst forEach = require('./forEach');const mockCallback = jest.fn(x => 42 + x);test('forEach mock function', () => {  forEach([0, 1], mockCallback);  // The mock function was called twice  expect(mockCallback.mock.calls).toHaveLength(2);  // The first argument of the first call to the function was 0  expect(mockCallback.mock.calls[0][0]).toBe(0);  // The first argument of the second call to the function was 1  expect(mockCallback.mock.calls[1][0]).toBe(1);  // The return value of the first call to the function was 42  expect(mockCallback.mock.results[0].value).toBe(42);});
.mock property​
All mock functions have this special .mock property, which is where data about how the function has been called and what the function returned is kept. The .mock property also tracks the value of this for each call, so it is possible to inspect this as well:
const myMock1 = jest.fn();const a = new myMock1();console.log(myMock1.mock.instances);// > [ <a> ]const myMock2 = jest.fn();const b = {};const bound = myMock2.bind(b);bound();console.log(myMock2.mock.contexts);// > [ <b> ]
These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:
// The function was called exactly onceexpect(someMockFunction.mock.calls).toHaveLength(1);// The first arg of the first call to the function was 'first arg'expect(someMockFunction.mock.calls[0][0]).toBe('first arg');// The second arg of the first call to the function was 'second arg'expect(someMockFunction.mock.calls[0][1]).toBe('second arg');// The return value of the first call to the function was 'return value'expect(someMockFunction.mock.results[0].value).toBe('return value');// The function was called with a certain `this` context: the `element` object.expect(someMockFunction.mock.contexts[0]).toBe(element);// This function was instantiated exactly twiceexpect(someMockFunction.mock.instances.length).toBe(2);// The object returned by the first instantiation of this function// had a `name` property whose value was set to 'test'expect(someMockFunction.mock.instances[0].name).toBe('test');// The first argument of the last call to the function was 'test'expect(someMockFunction.mock.lastCall[0]).toBe('test');
Mock Return Values​
Mock functions can also be used to inject test values into your code during a test:
const myMock = jest.fn();console.log(myMock());// > undefinedmyMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());// > 10, 'x', true, true
Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.
const filterTestFn = jest.fn();// Make the mock return `true` for the first call,// and `false` for the second callfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [11, 12].filter(num => filterTestFn(num));console.log(result);// > [11]console.log(filterTestFn.mock.calls[0][0]); // 11console.log(filterTestFn.mock.calls[1][0]); // 12
Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.
Mocking Modules​
Suppose we have a class that fetches users from our API. The class uses axios to call the API then returns the data attribute which contains all the users:
users.jsimport axios from 'axios';class Users {  static all() {    return axios.get('/users.json').then(resp => resp.data);  }}export default Users;
Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the jest.mock(...) function to automatically mock the axios module.
Once we mock the module we can provide a mockResolvedValue for .get that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.
users.test.jsimport axios from 'axios';import Users from './users';jest.mock('axios');test('should fetch users', () => {  const users = [{name: 'Bob'}];  const resp = {data: users};  axios.get.mockResolvedValue(resp);  // or you could use the following depending on your use case:  // axios.get.mockImplementation(() => Promise.resolve(resp))  return Users.all().then(data => expect(data).toEqual(users));});
Mocking Partials​
Subsets of a module can be mocked and the rest of the module can keep their actual implementation:
foo-bar-baz.jsexport const foo = 'foo';export const bar = () => 'bar';export default () => 'baz';
//test.jsimport defaultExport, {bar, foo} from '../foo-bar-baz';jest.mock('../foo-bar-baz', () => {  const originalModule = jest.requireActual('../foo-bar-baz');  //Mock the default export and named export 'foo'  return {    __esModule: true,    ...originalModule,    default: jest.fn(() => 'mocked baz'),    foo: 'mocked foo',  };});test('should do a partial mock', () => {  const defaultExportResult = defaultExport();  expect(defaultExportResult).toBe('mocked baz');  expect(defaultExport).toHaveBeenCalled();  expect(foo).toBe('mocked foo');  expect(bar()).toBe('bar');});
Mock Implementations​
Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with jest.fn or the mockImplementationOnce method on mock functions.
const myMockFn = jest.fn(cb => cb(null, true));myMockFn((err, val) => console.log(val));// > true
The mockImplementation method is useful when you need to define the default implementation of a mock function that is created from another module:
foo.jsmodule.exports = function () {  // some implementation;};
test.jsjest.mock('../foo'); // this happens automatically with automockingconst foo = require('../foo');// foo is a mock functionfoo.mockImplementation(() => 42);foo();// > 42
When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the mockImplementationOnce method:
const myMockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));myMockFn((err, val) => console.log(val));// > truemyMockFn((err, val) => console.log(val));// > false
When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with jest.fn (if it is defined):
const myMockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());// > 'first call', 'second call', 'default', 'default'
For cases where we have methods that are typically chained (and thus always need to return this), we have a sugary API to simplify this in the form of a .mockReturnThis() function that also sits on all mocks:
const myObj = {  myMethod: jest.fn().mockReturnThis(),};// is the same asconst otherObj = {  myMethod: jest.fn(function () {    return this;  }),};
Mock Names​
You can optionally provide a name for your mock functions, which will be displayed instead of 'jest.fn()' in the test error output. Use .mockName() if you want to be able to quickly identify the mock function reporting an error in your test output.
const myMockFn = jest  .fn()  .mockReturnValue('default')  .mockImplementation(scalar => 42 + scalar)  .mockName('add42');
Custom Matchers​
Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:
// The mock function was called at least onceexpect(mockFunc).toHaveBeenCalled();// The mock function was called at least once with the specified argsexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2);// The last call to the mock function was called with the specified argsexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);// All calls and the name of the mock is written as a snapshotexpect(mockFunc).toMatchSnapshot();
These matchers are sugar for common forms of inspecting the .mock property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:
// The mock function was called at least onceexpect(mockFunc.mock.calls.length).toBeGreaterThan(0);// The mock function was called at least once with the specified argsexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);// The last call to the mock function was called with the specified argsexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([  arg1,  arg2,]);// The first arg of the last call to the mock function was `42`// (note that there is no sugar helper for this specific of an assertion)expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// A snapshot will check that a mock was invoked the same number of times,// in the same order, with the same arguments. It will also assert on the name.expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);expect(mockFunc.getMockName()).toBe('a mock name');
For a complete list of matchers, check out the reference docs.Edit this pageLast updated on Dec 29, 2023 by Simen BekkhusPreviousSetup and TeardownNextJest PlatformUsing a mock function.mock propertyMock Return ValuesMocking ModulesMocking PartialsMock ImplementationsMock NamesCustom Matchers\n\n\n\nIntroductionJest PlatformVersion: 29.7On this pageJest PlatformYou can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:
jest-changed-files​
Tool for identifying modified files in a git/hg repository. Exports two functions:

getChangedFilesForRoots returns a promise that resolves to an object with the changed files and repos.
findRepos returns a promise that resolves to a set of repositories contained in the specified path.

Example​
const {getChangedFilesForRoots} = require('jest-changed-files');// print the set of modified files since last commit in the current repogetChangedFilesForRoots(['./'], {  lastCommit: true,}).then(result => console.log(result.changedFiles));
You can read more about jest-changed-files in the readme file.
jest-diff​
Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a "pretty-printed" string illustrating the difference between the two arguments.
Example​
const {diff} = require('jest-diff');const a = {a: {b: {c: 5}}};const b = {a: {b: {c: 6}}};const result = diff(a, b);// print diffconsole.log(result);
jest-docblock​
Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.
Example​
const {parseWithComments} = require('jest-docblock');const code = `/** * This is a sample * * @flow */ console.log('Hello World!');`;const parsed = parseWithComments(code);// prints an object with two attributes: comments and pragmas.console.log(parsed);
You can read more about jest-docblock in the readme file.
jest-get-type​
Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.
Example​
const {getType} = require('jest-get-type');const array = [1, 2, 3];const nullValue = null;const undefinedValue = undefined;// prints 'array'console.log(getType(array));// prints 'null'console.log(getType(nullValue));// prints 'undefined'console.log(getType(undefinedValue));
jest-validate​
Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:

hasDeprecationWarnings, a boolean indicating whether the submitted configuration has deprecation warnings,
isValid, a boolean indicating whether the configuration is correct or not.

Example​
const {validate} = require('jest-validate');const configByUser = {  transform: '<rootDir>/node_modules/my-custom-transform',};const result = validate(configByUser, {  comment: '  Documentation: http://custom-docs.com',  exampleConfig: {transform: '<rootDir>/node_modules/babel-jest'},});console.log(result);
You can read more about jest-validate in the readme file.
jest-worker​
Module used for parallelization of tasks. Exports a class JestWorker that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.
Example​
heavy-task.jsmodule.exports = {  myHeavyTask: args => {    // long running CPU intensive task.  },};
main.jsasync function main() {  const worker = new Worker(require.resolve('./heavy-task.js'));  // run 2 tasks in parallel with different arguments  const results = await Promise.all([    worker.myHeavyTask({foo: 'bar'}),    worker.myHeavyTask({bar: 'foo'}),  ]);  console.log(results);}main();
You can read more about jest-worker in the readme file.
pretty-format​
Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.
Example​
const {format: prettyFormat} = require('pretty-format');const val = {object: {}};val.circularReference = val;val[Symbol('foo')] = 'foo';val.map = new Map([['prop', 'value']]);val.array = [-0, Infinity, NaN];console.log(prettyFormat(val));
You can read more about pretty-format in the readme file.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nIntroductionJest PlatformVersion: 29.7On this pageJest PlatformYou can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:
jest-changed-files​
Tool for identifying modified files in a git/hg repository. Exports two functions:

getChangedFilesForRoots returns a promise that resolves to an object with the changed files and repos.
findRepos returns a promise that resolves to a set of repositories contained in the specified path.

Example​
const {getChangedFilesForRoots} = require('jest-changed-files');// print the set of modified files since last commit in the current repogetChangedFilesForRoots(['./'], {  lastCommit: true,}).then(result => console.log(result.changedFiles));
You can read more about jest-changed-files in the readme file.
jest-diff​
Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a "pretty-printed" string illustrating the difference between the two arguments.
Example​
const {diff} = require('jest-diff');const a = {a: {b: {c: 5}}};const b = {a: {b: {c: 6}}};const result = diff(a, b);// print diffconsole.log(result);
jest-docblock​
Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.
Example​
const {parseWithComments} = require('jest-docblock');const code = `/** * This is a sample * * @flow */ console.log('Hello World!');`;const parsed = parseWithComments(code);// prints an object with two attributes: comments and pragmas.console.log(parsed);
You can read more about jest-docblock in the readme file.
jest-get-type​
Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.
Example​
const {getType} = require('jest-get-type');const array = [1, 2, 3];const nullValue = null;const undefinedValue = undefined;// prints 'array'console.log(getType(array));// prints 'null'console.log(getType(nullValue));// prints 'undefined'console.log(getType(undefinedValue));
jest-validate​
Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:

hasDeprecationWarnings, a boolean indicating whether the submitted configuration has deprecation warnings,
isValid, a boolean indicating whether the configuration is correct or not.

Example​
const {validate} = require('jest-validate');const configByUser = {  transform: '<rootDir>/node_modules/my-custom-transform',};const result = validate(configByUser, {  comment: '  Documentation: http://custom-docs.com',  exampleConfig: {transform: '<rootDir>/node_modules/babel-jest'},});console.log(result);
You can read more about jest-validate in the readme file.
jest-worker​
Module used for parallelization of tasks. Exports a class JestWorker that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.
Example​
heavy-task.jsmodule.exports = {  myHeavyTask: args => {    // long running CPU intensive task.  },};
main.jsasync function main() {  const worker = new Worker(require.resolve('./heavy-task.js'));  // run 2 tasks in parallel with different arguments  const results = await Promise.all([    worker.myHeavyTask({foo: 'bar'}),    worker.myHeavyTask({bar: 'foo'}),  ]);  console.log(results);}main();
You can read more about jest-worker in the readme file.
pretty-format​
Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.
Example​
const {format: prettyFormat} = require('pretty-format');const val = {object: {}};val.circularReference = val;val[Symbol('foo')] = 'foo';val.map = new Map([['prop', 'value']]);val.array = [-0, Infinity, NaN];console.log(prettyFormat(val));
You can read more about pretty-format in the readme file.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousMock FunctionsNextJest Communityjest-changed-filesExamplejest-diffExamplejest-docblockExamplejest-get-typeExamplejest-validateExamplejest-workerExamplepretty-formatExample\n\n\n\nIntroductionJest CommunityVersion: 29.7On this pageJest CommunityThe community around Jest is working hard to make the testing experience even greater.
jest-community is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:

vscode-jest
jest-extended
eslint-plugin-jest
awesome-jest

Community projects under one organization are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.
Awesome Jest​
The jest-community org maintains an awesome-jest list of great projects and resources related to Jest.
If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (send a PR here) or if you would like to transfer your project to the jest-community org reach out to one of the owners of the org.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nIntroductionJest CommunityVersion: 29.7On this pageJest CommunityThe community around Jest is working hard to make the testing experience even greater.
jest-community is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:

vscode-jest
jest-extended
eslint-plugin-jest
awesome-jest

Community projects under one organization are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.
Awesome Jest​
The jest-community org maintains an awesome-jest list of great projects and resources related to Jest.
If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (send a PR here) or if you would like to transfer your project to the jest-community org reach out to one of the owners of the org.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousJest PlatformNextMore ResourcesAwesome Jest\n\n\n\nIntroductionMore ResourcesVersion: 29.7On this pageMore ResourcesBy now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.
Browse the docs​

Learn about Snapshot Testing, Mock Functions, and more in our in-depth guides.
Migrate your existing tests to Jest by following our migration guide.
Learn how to configure Jest.
Look at the full API Reference.
Troubleshoot problems with Jest.

Learn by example​
You will find a number of example test cases in the examples folder on GitHub. You can also learn from the excellent tests used by the React, Relay, and React Native projects.
Join the community​
Ask questions and find answers from other Jest users like you. Reactiflux is a Discord chat where a lot of Jest discussion happens. Check out the #testing channel.
Follow the Jest Twitter account and blog to find out what's happening in the world of Jest.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nIntroductionMore ResourcesVersion: 29.7On this pageMore ResourcesBy now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.
Browse the docs​

Learn about Snapshot Testing, Mock Functions, and more in our in-depth guides.
Migrate your existing tests to Jest by following our migration guide.
Learn how to configure Jest.
Look at the full API Reference.
Troubleshoot problems with Jest.

Learn by example​
You will find a number of example test cases in the examples folder on GitHub. You can also learn from the excellent tests used by the React, Relay, and React Native projects.
Join the community​
Ask questions and find answers from other Jest users like you. Reactiflux is a Discord chat where a lot of Jest discussion happens. Check out the #testing channel.
Follow the Jest Twitter account and blog to find out what's happening in the world of Jest.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousJest CommunityNextSnapshot TestingBrowse the docsLearn by exampleJoin the community\n\n\n\nGuidesSnapshot TestingVersion: 29.7On this pageSnapshot TestingSnapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.
A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.
Snapshot Testing with Jest​
A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this example test for a Link component:
import renderer from 'react-test-renderer';import Link from '../Link';it('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.facebook.com">Facebook</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
The first time this test is run, Jest creates a snapshot file that looks like this:
exports[`renders correctly 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses pretty-format to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the <Link> component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.
noteThe snapshot is directly scoped to the data you render – in our example the <Link> component with page prop passed to it. This implies that even if any other file has missing props (say, App.js) in the <Link> component, it will still pass the test as the test doesn't know the usage of <Link> component and it's scoped only to the Link.js. Also, rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.
infoMore information on how snapshot testing works and why we built it can be found on the release blog post. We recommend reading this blog post to get a good sense of when you should use snapshot testing. We also recommend watching this egghead video on Snapshot Testing with Jest.
Updating Snapshots​
It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.
One such situation can arise if we intentionally change the address the Link component in our example is pointing to.
// Updated test case with a Link to a different addressit('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.instagram.com">Instagram</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
In that case, Jest will print this output:

Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.
To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:
jest --updateSnapshot
Go ahead and accept the changes by running the above command. You may also use the equivalent single-character -u flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.
If you'd like to limit which snapshot test cases get re-generated, you can pass an additional --testNamePattern flag to re-record snapshots only for those tests that match the pattern.
You can try out this functionality by cloning the snapshot example, modifying the Link component, and running Jest.
Interactive Snapshot Mode​
Failed snapshots can also be updated interactively in watch mode:

Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.
From here you can choose to update that snapshot or skip to the next:

Once you're finished, Jest will give you a summary before returning back to watch mode:

Inline Snapshots​
Inline snapshots behave identically to external snapshots (.snap files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.
Example:
First, you write a test, calling .toMatchInlineSnapshot() with no arguments:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot();});
The next time you run Jest, tree will be evaluated, and a snapshot will be written as an argument to toMatchInlineSnapshot:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot(`    <a      className="normal"      href="https://example.com"      onMouseEnter={[Function]}      onMouseLeave={[Function]}    >      Example Site    </a>  `);});
That's all there is to it! You can even update the snapshots with --updateSnapshot or using the u key in --watch mode.
By default, Jest handles the writing of snapshots into your source code. However, if you're using prettier in your project, Jest will detect this and delegate the work to prettier instead (including honoring your configuration).
Property Matchers​
Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:
it('will fail every time', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot();});// Snapshotexports[`will fail every time 1`] = `{  "createdAt": 2018-05-19T23:36:09.816Z,  "id": 3,  "name": "LeBron James",}`;
For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:
it('will check the matchers and pass', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    id: expect.any(Number),  });});// Snapshotexports[`will check the matchers and pass 1`] = `{  "createdAt": Any<Date>,  "id": Any<Number>,  "name": "LeBron James",}`;
Any given value that is not a matcher will be checked exactly and saved to the snapshot:
it('will check the values and pass', () => {  const user = {    createdAt: new Date(),    name: 'Bond... James Bond',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    name: 'Bond... James Bond',  });});// Snapshotexports[`will check the values and pass 1`] = `{  "createdAt": Any<Date>,  "name": 'Bond... James Bond',}`;
tipIf the case concerns a string not an object then you need to replace random part of that string on your own before testing the snapshot.
You can use for that e.g. replace() and regular expressions.const randomNumber = Math.round(Math.random() * 100);const stringWithRandomData = `<div id="${randomNumber}">Lorem ipsum</div>`;const stringWithConstantData = stringWithRandomData.replace(/id="\d+"/, 123);expect(stringWithConstantData).toMatchSnapshot();Other ways this can be done is using the snapshot serializer or mocking the library responsible for generating the random part of the code you're snapshotting.
Best Practices​
Snapshots are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.
1. Treat snapshots as code​
Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.
Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.
As mentioned previously, Jest uses pretty-format to make snapshots human-readable, but you may find it useful to introduce additional tools, like eslint-plugin-jest with its no-large-snapshots option, or snapshot-diff with its component snapshot comparison feature, to promote committing short, focused assertions.
The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.
2. Tests should be deterministic​
Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.
For example, if you have a Clock component that uses Date.now(), the snapshot generated from this component will be different every time the test case is run. In this case we can mock the Date.now() method to return a consistent value every time the test is run:
Date.now = jest.fn(() => 1_482_363_367_071);
Now, every time the snapshot test case runs, Date.now() will return 1482363367071 consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.
3. Use descriptive snapshot names​
Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.
For example, compare:
exports[`<UserName /> should handle some test case`] = `null`;exports[`<UserName /> should handle some other test case`] = `<div>  Alan Turing</div>`;
To:
exports[`<UserName /> should render null`] = `null`;exports[`<UserName /> should render Alan Turing`] = `<div>  Alan Turing</div>`;
Since the latter describes exactly what's expected in the output, it's more clear to see when it's wrong:
exports[`<UserName /> should render null`] = `<div>  Alan Turing</div>`;exports[`<UserName /> should render Alan Turing`] = `null`;
Frequently Asked Questions​
Are snapshots written automatically on Continuous Integration (CI) systems?​
No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing --updateSnapshot. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.
Should snapshot files be committed?​
Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.
Does snapshot testing only work with React components?​
React and React Native components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of snapshotting CLI output in the Jest repo.
What's the difference between snapshot testing and visual regression testing?​
Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the Jest blog.
Does snapshot testing replace unit testing?​
Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.
What is the performance of snapshot testing regarding speed and size of the generated files?​
Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the toMatchSnapshot matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.
How do I resolve conflicts within snapshot files?​
Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.
Is it possible to apply test-driven development principles with snapshot testing?​
Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.
Does code coverage work with snapshot testing?​
Yes, as well as with any other test.Edit this pageLast updated on Sep 25, 2023 by Simen Bekkhus\n\nGuidesSnapshot TestingVersion: 29.7On this pageSnapshot TestingSnapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.
A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.
Snapshot Testing with Jest​
A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this example test for a Link component:
import renderer from 'react-test-renderer';import Link from '../Link';it('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.facebook.com">Facebook</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
The first time this test is run, Jest creates a snapshot file that looks like this:
exports[`renders correctly 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses pretty-format to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the <Link> component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.
noteThe snapshot is directly scoped to the data you render – in our example the <Link> component with page prop passed to it. This implies that even if any other file has missing props (say, App.js) in the <Link> component, it will still pass the test as the test doesn't know the usage of <Link> component and it's scoped only to the Link.js. Also, rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.
infoMore information on how snapshot testing works and why we built it can be found on the release blog post. We recommend reading this blog post to get a good sense of when you should use snapshot testing. We also recommend watching this egghead video on Snapshot Testing with Jest.
Updating Snapshots​
It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.
One such situation can arise if we intentionally change the address the Link component in our example is pointing to.
// Updated test case with a Link to a different addressit('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.instagram.com">Instagram</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
In that case, Jest will print this output:

Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.
To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:
jest --updateSnapshot
Go ahead and accept the changes by running the above command. You may also use the equivalent single-character -u flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.
If you'd like to limit which snapshot test cases get re-generated, you can pass an additional --testNamePattern flag to re-record snapshots only for those tests that match the pattern.
You can try out this functionality by cloning the snapshot example, modifying the Link component, and running Jest.
Interactive Snapshot Mode​
Failed snapshots can also be updated interactively in watch mode:

Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.
From here you can choose to update that snapshot or skip to the next:

Once you're finished, Jest will give you a summary before returning back to watch mode:

Inline Snapshots​
Inline snapshots behave identically to external snapshots (.snap files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.
Example:
First, you write a test, calling .toMatchInlineSnapshot() with no arguments:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot();});
The next time you run Jest, tree will be evaluated, and a snapshot will be written as an argument to toMatchInlineSnapshot:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot(`    <a      className="normal"      href="https://example.com"      onMouseEnter={[Function]}      onMouseLeave={[Function]}    >      Example Site    </a>  `);});
That's all there is to it! You can even update the snapshots with --updateSnapshot or using the u key in --watch mode.
By default, Jest handles the writing of snapshots into your source code. However, if you're using prettier in your project, Jest will detect this and delegate the work to prettier instead (including honoring your configuration).
Property Matchers​
Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:
it('will fail every time', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot();});// Snapshotexports[`will fail every time 1`] = `{  "createdAt": 2018-05-19T23:36:09.816Z,  "id": 3,  "name": "LeBron James",}`;
For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:
it('will check the matchers and pass', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    id: expect.any(Number),  });});// Snapshotexports[`will check the matchers and pass 1`] = `{  "createdAt": Any<Date>,  "id": Any<Number>,  "name": "LeBron James",}`;
Any given value that is not a matcher will be checked exactly and saved to the snapshot:
it('will check the values and pass', () => {  const user = {    createdAt: new Date(),    name: 'Bond... James Bond',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    name: 'Bond... James Bond',  });});// Snapshotexports[`will check the values and pass 1`] = `{  "createdAt": Any<Date>,  "name": 'Bond... James Bond',}`;
tipIf the case concerns a string not an object then you need to replace random part of that string on your own before testing the snapshot.
You can use for that e.g. replace() and regular expressions.const randomNumber = Math.round(Math.random() * 100);const stringWithRandomData = `<div id="${randomNumber}">Lorem ipsum</div>`;const stringWithConstantData = stringWithRandomData.replace(/id="\d+"/, 123);expect(stringWithConstantData).toMatchSnapshot();Other ways this can be done is using the snapshot serializer or mocking the library responsible for generating the random part of the code you're snapshotting.
Best Practices​
Snapshots are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.
1. Treat snapshots as code​
Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.
Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.
As mentioned previously, Jest uses pretty-format to make snapshots human-readable, but you may find it useful to introduce additional tools, like eslint-plugin-jest with its no-large-snapshots option, or snapshot-diff with its component snapshot comparison feature, to promote committing short, focused assertions.
The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.
2. Tests should be deterministic​
Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.
For example, if you have a Clock component that uses Date.now(), the snapshot generated from this component will be different every time the test case is run. In this case we can mock the Date.now() method to return a consistent value every time the test is run:
Date.now = jest.fn(() => 1_482_363_367_071);
Now, every time the snapshot test case runs, Date.now() will return 1482363367071 consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.
3. Use descriptive snapshot names​
Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.
For example, compare:
exports[`<UserName /> should handle some test case`] = `null`;exports[`<UserName /> should handle some other test case`] = `<div>  Alan Turing</div>`;
To:
exports[`<UserName /> should render null`] = `null`;exports[`<UserName /> should render Alan Turing`] = `<div>  Alan Turing</div>`;
Since the latter describes exactly what's expected in the output, it's more clear to see when it's wrong:
exports[`<UserName /> should render null`] = `<div>  Alan Turing</div>`;exports[`<UserName /> should render Alan Turing`] = `null`;
Frequently Asked Questions​
Are snapshots written automatically on Continuous Integration (CI) systems?​
No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing --updateSnapshot. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.
Should snapshot files be committed?​
Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.
Does snapshot testing only work with React components?​
React and React Native components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of snapshotting CLI output in the Jest repo.
What's the difference between snapshot testing and visual regression testing?​
Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the Jest blog.
Does snapshot testing replace unit testing?​
Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.
What is the performance of snapshot testing regarding speed and size of the generated files?​
Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the toMatchSnapshot matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.
How do I resolve conflicts within snapshot files?​
Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.
Is it possible to apply test-driven development principles with snapshot testing?​
Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.
Does code coverage work with snapshot testing?​
Yes, as well as with any other test.Edit this pageLast updated on Sep 25, 2023 by Simen BekkhusPreviousMore ResourcesNextAn Async ExampleSnapshot Testing with JestUpdating SnapshotsInteractive Snapshot ModeInline SnapshotsProperty MatchersBest Practices1. Treat snapshots as code2. Tests should be deterministic3. Use descriptive snapshot namesFrequently Asked QuestionsAre snapshots written automatically on Continuous Integration (CI) systems?Should snapshot files be committed?Does snapshot testing only work with React components?What's the difference between snapshot testing and visual regression testing?Does snapshot testing replace unit testing?What is the performance of snapshot testing regarding speed and size of the generated files?How do I resolve conflicts within snapshot files?Is it possible to apply test-driven development principles with snapshot testing?Does code coverage work with snapshot testing?\n\n\n\nFramework GuidesTesting React AppsVersion: 29.7On this pageTesting React AppsAt Facebook, we use Jest to test React applications.
Setup​
Setup with Create React App​
If you are new to React, we recommend using Create React App. It is ready to use and ships with Jest! You will only need to add react-test-renderer for rendering snapshots.
Run
npmYarnpnpmnpm install --save-dev react-test-rendereryarn add --dev react-test-rendererpnpm add --save-dev react-test-renderer
Setup without Create React App​
If you have an existing application you'll need to install a few packages to make everything work well together. We are using the babel-jest package and the react babel preset to transform our code inside of the test environment. Also see using babel.
Run
npmYarnpnpmnpm install --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendereryarn add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendererpnpm add --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer
Your package.json should look something like this (where <current-version> is the actual latest version number for the package). Please add the scripts and jest configuration entries:
{  "dependencies": {    "react": "<current-version>",    "react-dom": "<current-version>"  },  "devDependencies": {    "@babel/preset-env": "<current-version>",    "@babel/preset-react": "<current-version>",    "babel-jest": "<current-version>",    "jest": "<current-version>",    "react-test-renderer": "<current-version>"  },  "scripts": {    "test": "jest"  }}
babel.config.jsmodule.exports = {  presets: [    '@babel/preset-env',    ['@babel/preset-react', {runtime: 'automatic'}],  ],};
And you're good to go!
Snapshot Testing​
Let's create a snapshot test for a Link component that renders hyperlinks:
Link.jsimport {useState} from 'react';const STATUS = {  HOVERED: 'hovered',  NORMAL: 'normal',};export default function Link({page, children}) {  const [status, setStatus] = useState(STATUS.NORMAL);  const onMouseEnter = () => {    setStatus(STATUS.HOVERED);  };  const onMouseLeave = () => {    setStatus(STATUS.NORMAL);  };  return (    <a      className={status}      href={page || '#'}      onMouseEnter={onMouseEnter}      onMouseLeave={onMouseLeave}    >      {children}    </a>  );}
noteExamples are using Function components, but Class components can be tested in the same way. See React: Function and Class Components. Reminders that with Class components, we expect Jest to be used to test props and not methods directly.
Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:
Link.test.jsimport renderer from 'react-test-renderer';import Link from '../Link';it('changes the class when hovered', () => {  const component = renderer.create(    <Link page="http://www.facebook.com">Facebook</Link>,  );  let tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseEnter();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseLeave();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();});
When you run yarn test or jest, this will produce an output file like this:
__tests__/__snapshots__/Link.test.js.snapexports[`changes the class when hovered 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 2`] = `<a  className="hovered"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 3`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with jest -u to overwrite the existing snapshot.
The code for this example is available at examples/snapshot.
Snapshot Testing with Mocks, Enzyme and React 16+​
There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:
jest.mock('../SomeDirectory/SomeComponent', () => 'SomeComponent');
Then you will see warnings in the console:
Warning: <SomeComponent /> is using uppercase HTML. Always use lowercase HTML tags in React.# Or:Warning: The tag <SomeComponent> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.
React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:

Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:
jest.mock('./SomeComponent', () => () => 'SomeComponent');

Render as a custom element. DOM "custom elements" aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.
jest.mock('./Widget', () => () => <mock-widget />);

Use react-test-renderer. The test renderer doesn't care about element types and will happily accept e.g. SomeComponent. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.
Disable warnings all together (should be done in your jest setup file):
jest.mock('fbjs/lib/warning', () => require('fbjs/lib/emptyFunction'));
This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.

DOM Testing​
If you'd like to assert, and manipulate your rendered components you can use @testing-library/react, Enzyme, or React's TestUtils. The following example use @testing-library/react.
@testing-library/react​
npmYarnpnpmnpm install --save-dev @testing-library/reactyarn add --dev @testing-library/reactpnpm add --save-dev @testing-library/react
Let's implement a checkbox which swaps between two labels:
CheckboxWithLabel.jsimport {useState} from 'react';export default function CheckboxWithLabel({labelOn, labelOff}) {  const [isChecked, setIsChecked] = useState(false);  const onChange = () => {    setIsChecked(!isChecked);  };  return (    <label>      <input type="checkbox" checked={isChecked} onChange={onChange} />      {isChecked ? labelOn : labelOff}    </label>  );}
__tests__/CheckboxWithLabel-test.jsimport {cleanup, fireEvent, render} from '@testing-library/react';import CheckboxWithLabel from '../CheckboxWithLabel';// Note: running cleanup afterEach is done automatically for you in @testing-library/[email protected] or higher// unmount and cleanup DOM after the test is finished.afterEach(cleanup);it('CheckboxWithLabel changes the text after click', () => {  const {queryByLabelText, getByLabelText} = render(    <CheckboxWithLabel labelOn="On" labelOff="Off" />,  );  expect(queryByLabelText(/off/i)).toBeTruthy();  fireEvent.click(getByLabelText(/off/i));  expect(queryByLabelText(/on/i)).toBeTruthy();});
The code for this example is available at examples/react-testing-library.
Custom transformers​
If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using @babel/core:
custom-transformer.js'use strict';const {transform} = require('@babel/core');const jestPreset = require('babel-preset-jest');module.exports = {  process(src, filename) {    const result = transform(src, {      filename,      presets: [jestPreset],    });    return result || src;  },};
Don't forget to install the @babel/core and babel-preset-jest packages for this example to work.
To make this work with Jest you need to update your Jest configuration with this: "transform": {"\\.js$": "path/to/custom-transformer.js"}.
If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:
const babelJest = require('babel-jest');module.exports = babelJest.createTransformer({  presets: ['my-custom-preset'],});
See dedicated docs for more details.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nFramework GuidesTesting React AppsVersion: 29.7On this pageTesting React AppsAt Facebook, we use Jest to test React applications.
Setup​
Setup with Create React App​
If you are new to React, we recommend using Create React App. It is ready to use and ships with Jest! You will only need to add react-test-renderer for rendering snapshots.
Run
npmYarnpnpmnpm install --save-dev react-test-rendereryarn add --dev react-test-rendererpnpm add --save-dev react-test-renderer
Setup without Create React App​
If you have an existing application you'll need to install a few packages to make everything work well together. We are using the babel-jest package and the react babel preset to transform our code inside of the test environment. Also see using babel.
Run
npmYarnpnpmnpm install --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendereryarn add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendererpnpm add --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer
Your package.json should look something like this (where <current-version> is the actual latest version number for the package). Please add the scripts and jest configuration entries:
{  "dependencies": {    "react": "<current-version>",    "react-dom": "<current-version>"  },  "devDependencies": {    "@babel/preset-env": "<current-version>",    "@babel/preset-react": "<current-version>",    "babel-jest": "<current-version>",    "jest": "<current-version>",    "react-test-renderer": "<current-version>"  },  "scripts": {    "test": "jest"  }}
babel.config.jsmodule.exports = {  presets: [    '@babel/preset-env',    ['@babel/preset-react', {runtime: 'automatic'}],  ],};
And you're good to go!
Snapshot Testing​
Let's create a snapshot test for a Link component that renders hyperlinks:
Link.jsimport {useState} from 'react';const STATUS = {  HOVERED: 'hovered',  NORMAL: 'normal',};export default function Link({page, children}) {  const [status, setStatus] = useState(STATUS.NORMAL);  const onMouseEnter = () => {    setStatus(STATUS.HOVERED);  };  const onMouseLeave = () => {    setStatus(STATUS.NORMAL);  };  return (    <a      className={status}      href={page || '#'}      onMouseEnter={onMouseEnter}      onMouseLeave={onMouseLeave}    >      {children}    </a>  );}
noteExamples are using Function components, but Class components can be tested in the same way. See React: Function and Class Components. Reminders that with Class components, we expect Jest to be used to test props and not methods directly.
Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:
Link.test.jsimport renderer from 'react-test-renderer';import Link from '../Link';it('changes the class when hovered', () => {  const component = renderer.create(    <Link page="http://www.facebook.com">Facebook</Link>,  );  let tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseEnter();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseLeave();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();});
When you run yarn test or jest, this will produce an output file like this:
__tests__/__snapshots__/Link.test.js.snapexports[`changes the class when hovered 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 2`] = `<a  className="hovered"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 3`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with jest -u to overwrite the existing snapshot.
The code for this example is available at examples/snapshot.
Snapshot Testing with Mocks, Enzyme and React 16+​
There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:
jest.mock('../SomeDirectory/SomeComponent', () => 'SomeComponent');
Then you will see warnings in the console:
Warning: <SomeComponent /> is using uppercase HTML. Always use lowercase HTML tags in React.# Or:Warning: The tag <SomeComponent> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.
React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:

Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:
jest.mock('./SomeComponent', () => () => 'SomeComponent');

Render as a custom element. DOM "custom elements" aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.
jest.mock('./Widget', () => () => <mock-widget />);

Use react-test-renderer. The test renderer doesn't care about element types and will happily accept e.g. SomeComponent. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.
Disable warnings all together (should be done in your jest setup file):
jest.mock('fbjs/lib/warning', () => require('fbjs/lib/emptyFunction'));
This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.

DOM Testing​
If you'd like to assert, and manipulate your rendered components you can use @testing-library/react, Enzyme, or React's TestUtils. The following example use @testing-library/react.
@testing-library/react​
npmYarnpnpmnpm install --save-dev @testing-library/reactyarn add --dev @testing-library/reactpnpm add --save-dev @testing-library/react
Let's implement a checkbox which swaps between two labels:
CheckboxWithLabel.jsimport {useState} from 'react';export default function CheckboxWithLabel({labelOn, labelOff}) {  const [isChecked, setIsChecked] = useState(false);  const onChange = () => {    setIsChecked(!isChecked);  };  return (    <label>      <input type="checkbox" checked={isChecked} onChange={onChange} />      {isChecked ? labelOn : labelOff}    </label>  );}
__tests__/CheckboxWithLabel-test.jsimport {cleanup, fireEvent, render} from '@testing-library/react';import CheckboxWithLabel from '../CheckboxWithLabel';// Note: running cleanup afterEach is done automatically for you in @testing-library/[email protected] or higher// unmount and cleanup DOM after the test is finished.afterEach(cleanup);it('CheckboxWithLabel changes the text after click', () => {  const {queryByLabelText, getByLabelText} = render(    <CheckboxWithLabel labelOn="On" labelOff="Off" />,  );  expect(queryByLabelText(/off/i)).toBeTruthy();  fireEvent.click(getByLabelText(/off/i));  expect(queryByLabelText(/on/i)).toBeTruthy();});
The code for this example is available at examples/react-testing-library.
Custom transformers​
If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using @babel/core:
custom-transformer.js'use strict';const {transform} = require('@babel/core');const jestPreset = require('babel-preset-jest');module.exports = {  process(src, filename) {    const result = transform(src, {      filename,      presets: [jestPreset],    });    return result || src;  },};
Don't forget to install the @babel/core and babel-preset-jest packages for this example to work.
To make this work with Jest you need to update your Jest configuration with this: "transform": {"\\.js$": "path/to/custom-transformer.js"}.
If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:
const babelJest = require('babel-jest');module.exports = babelJest.createTransformer({  presets: ['my-custom-preset'],});
See dedicated docs for more details.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousArchitectureNextTesting React Native AppsSetupSetup with Create React AppSetup without Create React AppSnapshot TestingDOM TestingCustom transformers\n\n\n\nUpgrade GuidesFrom v28 to v29Version: 29.7On this pageFrom v28 to v29Upgrading Jest from v28 to v29? This guide aims to help refactoring your configuration and tests.
infoSee changelog for the full list of changes.
noteUpgrading from an older version? You can see the upgrade guide from v27 to v28 here.
Compatibility​
The supported Node versions are 14.15, 16.10, 18.0 and above.
Snapshot format​
As announced in the Jest 28 blog post, Jest 29 has changed the default snapshot formatting to {escapeString: false, printBasicPrototype: false}.
If you want to keep the old behavior, you can set the snapshotFormat property to:
+ snapshotFormat: {+   escapeString: true,+   printBasicPrototype: true+ }
JSDOM upgrade​
jest-environment-jsdom has upgraded jsdom from v19 to v20.
infoIf you use jest-environment-jsdom, the minimum TypeScript version is set to 4.5.
Notably, jsdom@20 includes support for crypto.getRandomValues(), which means packages like uuid and nanoid, which doesn't work properly in Jest@28, can work without extra polyfills.
pretty-format​
ConvertAnsi plugin is removed from pretty-format package in favour of jest-serializer-ansi-escapes.
jest-mock​
Exports of Mocked* utility types from jest-mock package have changed. MaybeMockedDeep and MaybeMocked now are exported as Mocked and MockedShallow respectively; only deep mocked variants of MockedClass, MockedFunction and MockedObject are exposed.
TypeScript​

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.mocked()​
The jest.mocked() helper method now wraps types of deep members of passed object by default. If you have used the method with true as the second argument, remove it to avoid type errors:
- const mockedObject = jest.mocked(someObject, true);+ const mockedObject = jest.mocked(someObject);
To have the old shallow mocked behavior, pass {shallow: true} as the second argument:
- const mockedObject = jest.mocked(someObject);+ const mockedObject = jest.mocked(someObject, {shallow: true});Edit this pageLast updated on Sep 23, 2023 by Michael Knight\n\nUpgrade GuidesFrom v28 to v29Version: 29.7On this pageFrom v28 to v29Upgrading Jest from v28 to v29? This guide aims to help refactoring your configuration and tests.
infoSee changelog for the full list of changes.
noteUpgrading from an older version? You can see the upgrade guide from v27 to v28 here.
Compatibility​
The supported Node versions are 14.15, 16.10, 18.0 and above.
Snapshot format​
As announced in the Jest 28 blog post, Jest 29 has changed the default snapshot formatting to {escapeString: false, printBasicPrototype: false}.
If you want to keep the old behavior, you can set the snapshotFormat property to:
+ snapshotFormat: {+   escapeString: true,+   printBasicPrototype: true+ }
JSDOM upgrade​
jest-environment-jsdom has upgraded jsdom from v19 to v20.
infoIf you use jest-environment-jsdom, the minimum TypeScript version is set to 4.5.
Notably, jsdom@20 includes support for crypto.getRandomValues(), which means packages like uuid and nanoid, which doesn't work properly in Jest@28, can work without extra polyfills.
pretty-format​
ConvertAnsi plugin is removed from pretty-format package in favour of jest-serializer-ansi-escapes.
jest-mock​
Exports of Mocked* utility types from jest-mock package have changed. MaybeMockedDeep and MaybeMocked now are exported as Mocked and MockedShallow respectively; only deep mocked variants of MockedClass, MockedFunction and MockedObject are exposed.
TypeScript​

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.mocked()​
The jest.mocked() helper method now wraps types of deep members of passed object by default. If you have used the method with true as the second argument, remove it to avoid type errors:
- const mockedObject = jest.mocked(someObject, true);+ const mockedObject = jest.mocked(someObject);
To have the old shallow mocked behavior, pass {shallow: true} as the second argument:
- const mockedObject = jest.mocked(someObject);+ const mockedObject = jest.mocked(someObject, {shallow: true});Edit this pageLast updated on Sep 23, 2023 by Michael KnightPreviousTesting Web FrameworksCompatibilitySnapshot formatJSDOM upgradepretty-formatjest-mockTypeScriptjest.mocked()\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nJest CLI OptionsVersion: 29.7On this pageJest CLI OptionsThe jest command line runner has a number of useful options. You can run jest --help to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's Configuration options can also be specified through the CLI.
Here is a brief overview:
Running from the command line​
Run all tests (default):
jest
Run only the tests that were specified with a pattern or filename:
jest my-test #orjest path/to/my-test.js
Run tests related to changed files based on hg/git (uncommitted files):
jest -o
Run tests related to path/to/fileA.js and path/to/fileB.js:
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
Run tests that match this spec name (match against the name in describe or test, basically).
jest -t name-of-spec
Run watch mode:
jest --watch #runs jest -o by defaultjest --watchAll #runs all tests
Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.
Using with package manager​
If you run Jest via your package manager, you can still pass the command line arguments directly as Jest arguments.
Instead of:
jest -u -t="ColorPicker"
you can use:
npmYarnpnpmnpm test -- -u -t="ColorPicker"yarn test -u -t="ColorPicker"pnpm test -u -t="ColorPicker"
Camelcase & dashed args support​
Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:
jest --collect-coveragejest --collectCoverage
Arguments can also be mixed:
jest --update-snapshot --detectOpenHandles
Options​
noteCLI options take precedence over values from the Configuration.

Camelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--init--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPattern=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--watch--watchAll--watchman--workerThreads

Reference​
jest <regexForTestFiles>​
When you run jest with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: jest "my.*(complex)?pattern". On Windows, you will need to use / as a path separator or escape \ as \\.
--bail[=<n>]​
Alias: -b. Exit the test suite immediately upon n number of failing test suite. Defaults to 1.
--cache​
Whether to use the cache. Defaults to true. Disable the cache using --no-cache.
cautionThe cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.
If you want to inspect the cache, use --showConfig and look at the cacheDirectory value. If you need to clear the cache, use --clearCache.
--changedFilesWithAncestor​
Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to --onlyChanged.
--changedSince​
Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to --onlyChanged.
--ci​
When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with --updateSnapshot.
--clearCache​
Deletes the Jest cache directory and then exits without running tests. Will delete cacheDirectory if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling jest --showConfig.
cautionClearing the cache will reduce performance.
--clearMocks​
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
--collectCoverageFrom=<glob>​
A glob pattern relative to rootDir matching the files that coverage info needs to be collected from.
--colors​
Forces test results output highlighting even if stdout is not a TTY.
noteAlternatively you can set the environment variable FORCE_COLOR=true to forcefully enable or FORCE_COLOR=false to disable colorized output. The use of FORCE_COLOR overrides all other color support checks.
--config=<path>​
Alias: -c. The path to a Jest config file specifying how to find and execute tests. If no rootDir is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.
--coverage[=<boolean>]​
Alias: --collectCoverage. Indicates that test coverage information should be collected and reported in the output. Optionally pass <boolean> to override option set in configuration.
--coverageDirectory=<path>​
The directory where Jest should output its coverage files.
--coverageProvider=<provider>​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
--debug​
Print debugging info about your Jest config.
--detectOpenHandles​
Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use --forceExit in order for Jest to exit to potentially track down the reason. This implies --runInBand, making tests run serially. Implemented using async_hooks. This option has a significant performance penalty and should only be used for debugging.
--env=<environment>​
The test environment used for all tests. This can point to any file or node module. Examples: jsdom, node or path/to/my-environment.js.
--errorOnDeprecated​
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--expand​
Alias: -e. Use this flag to show full diffs and errors instead of a patch.
--filter=<file>​
Path to a module exporting a filtering function. This asynchronous function receives a list of test paths which can be manipulated to exclude tests from running by returning an object with shape { filtered: Array<{ test: string }> }. Especially useful when used in conjunction with a testing infrastructure to filter known broken tests, e.g.
my-filter.jsmodule.exports = testPaths => {  const allowedPaths = testPaths    .filter(filteringFunction)    .map(test => ({test})); // [{ test: "path1.spec.js" }, { test: "path2.spec.js" }, etc]  return {    filtered: allowedPaths,  };};
--findRelatedTests <spaceSeparatedListOfSourceFiles>​
Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with --coverage to include a test coverage for the source files, no duplicate --collectCoverageFrom arguments needed.
--forceExit​
Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up.
cautionThis feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use --detectOpenHandles to help track it down.
--help​
Show the help information, similar to this page.
--ignoreProjects <project1> ... <projectN>​
Ignore the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--init​
Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a jest.config.js file with a short description for each option.
--injectGlobals​
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
--json​
Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
--lastCommit​
Run all tests affected by file changes in the last commit made. Behaves similarly to --onlyChanged.
--listTests​
Lists all test files that Jest will run given the arguments, and exits.
--logHeapUsage​
Logs the heap usage after every test. Useful to debug memory leaks. Use together with --runInBand and --expose-gc in node.
--maxConcurrency=<num>​
Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use test.concurrent.
--maxWorkers=<num>|<string>​
Alias: -w. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration: --maxWorkers=50%
--noStackTrace​
Disables stack trace in test results output.
--notify​
Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.
--onlyChanged​
Alias: -o. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).
--onlyFailures​
Alias: -f. Run tests that failed in the previous execution.
--openHandlesTimeout=<milliseconds>​
When --detectOpenHandles and --forceExit are disabled, Jest will print a warning if the process has not exited cleanly after this number of milliseconds. A value of 0 disables the warning. Defaults to 1000.
--outputFile=<filename>​
Write test results to a file when the --json option is also specified. The returned JSON structure is documented in testResultsProcessor.
--passWithNoTests​
Allows the test suite to pass when no files are found.
--projects <path1> ... <pathN>​
Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the projects configuration option.
noteIf configuration files are found in the specified paths, all projects specified within those configuration files will be run.
--randomize​
Shuffle the order of the tests within a file. The shuffling is based on the seed. See --seed=<num> for more info.
Seed value is displayed when this option is set. Equivalent to setting the CLI option --showSeed.
jest --randomize --seed 1234
noteThis option is only supported using the default jest-circus test runner.
--reporters​
Run tests with specified reporters. Reporter options are not available via CLI. Example with multiple reporters:
jest --reporters="default" --reporters="jest-junit"
--resetMocks​
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--restoreMocks​
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--roots​
A list of paths to directories that Jest should use to search for files in.
--runInBand​
Alias: -i. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.
--runTestsByPath​
Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file.
For example, given the following file structure:
__tests__└── t1.test.js # test└── t2.test.js # test
When ran with a pattern, no test is found:
jest --runTestsByPath __tests__/t
Output:
No tests found
However, passing an exact path will execute only the given test:
jest --runTestsByPath __tests__/t1.test.js
Output:
PASS __tests__/t1.test.js
tipThe default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files.
--seed=<num>​
Sets a seed value that can be retrieved in a test file via jest.getSeed(). The seed value must be between -0x80000000 and 0x7fffffff inclusive (-2147483648 (-(2 ** 31)) and 2147483647 (2 ** 31 - 1) in decimal).
jest --seed=1324
tipIf this option is not specified Jest will randomly generate the value. You can use the --showSeed flag to print the seed in the test report summary.Jest uses the seed internally for shuffling the order in which test suites are run. If the --randomize option is used, the seed is also used for shuffling the order of tests within each describe block. When dealing with flaky tests, rerunning with the same seed might help reproduce the failure.
--selectProjects <project1> ... <projectN>​
Run the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--setupFilesAfterEnv <path1> ... <pathN>​
A list of paths to modules that run some code to configure or to set up the testing framework before each test. Beware that files imported by the setup scripts will not be mocked during testing.
--shard​
The test suite shard to execute in a format of (?<shardIndex>\d+)/(?<shardCount>\d+).
shardIndex describes which shard to select while shardCount controls the number of shards the suite should be split into.
shardIndex and shardCount have to be 1-based, positive numbers, and shardIndex has to be lower than or equal to shardCount.
When shard is specified the configured testSequencer has to implement a shard method.
For example, to split the suite into three shards, each running one third of the tests:
jest --shard=1/3jest --shard=2/3jest --shard=3/3
--showConfig​
Print your Jest config and then exits.
--showSeed​
Prints the seed value in the test report summary. See --seed=<num> for the details.
Can also be set in configuration. See showSeed.
--silent​
Prevent tests from printing messages through the console.
--testEnvironmentOptions=<json string>​
A JSON string with options that will be passed to the testEnvironment. The relevant options depend on the environment.
--testLocationInResults​
Adds a location field to test results. Useful if you want to report the location of a test in a reporter.
noteIn the resulting object column is 0-indexed while line is not.{  "column": 4,  "line": 5}
--testMatch glob1 ... globN​
The glob patterns Jest uses to detect test files. Please refer to the testMatch configuration for details.
--testNamePattern=<regex>​
Alias: -t. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like 'GET /api/posts with auth', then you can use jest -t=auth.
tipThe regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.
--testPathIgnorePatterns=<regex>|[array]​
A single or array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to --testPathPattern, it will only run those tests with a path that does not match with the provided regexp expressions.
To pass as an array use escaped parentheses and space delimited regexps such as \(/node_modules/ /tests/e2e/\). Alternatively, you can omit parentheses by combining regexps into a single regexp like /node_modules/|/tests/e2e/. These two examples are equivalent.
--testPathPattern=<regex>​
A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use / as a path separator or escape \ as \\.
--testRunner=<path>​
Lets you specify a custom test runner.
--testSequencer=<path>​
Lets you specify a custom test sequencer. Please refer to the testSequencer configuration for details.
--testTimeout=<number>​
Default timeout of a test in milliseconds. Default value: 5000.
--updateSnapshot​
Alias: -u. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with --testNamePattern to re-record snapshots.
--useStderr​
Divert all output to stderr.
--verbose​
Display individual test results with the test suite hierarchy.
--version​
Alias: -v. Print the version and exit.
--watch​
Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the --watchAll option instead.
tipUse --no-watch (or --watch=false) to explicitly disable the watch mode if it was enabled using --watch. In most CI environments, this is automatically handled for you.
--watchAll​
Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the --watch option.
tipUse --no-watchAll (or --watchAll=false) to explicitly disable the watch mode if it was enabled using --watchAll. In most CI environments, this is automatically handled for you.
--watchman​
Whether to use watchman for file crawling. Defaults to true. Disable using --no-watchman.
--workerThreads​
Whether to use worker threads for parallelization. Child processes are used by default.
cautionThis is experimental feature. See the workerThreads configuration option for more details.Edit this pageLast updated on Sep 26, 2024 by Jörn Zaefferer\n\nJest CLI OptionsVersion: 29.7On this pageJest CLI OptionsThe jest command line runner has a number of useful options. You can run jest --help to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's Configuration options can also be specified through the CLI.
Here is a brief overview:
Running from the command line​
Run all tests (default):
jest
Run only the tests that were specified with a pattern or filename:
jest my-test #orjest path/to/my-test.js
Run tests related to changed files based on hg/git (uncommitted files):
jest -o
Run tests related to path/to/fileA.js and path/to/fileB.js:
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
Run tests that match this spec name (match against the name in describe or test, basically).
jest -t name-of-spec
Run watch mode:
jest --watch #runs jest -o by defaultjest --watchAll #runs all tests
Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.
Using with package manager​
If you run Jest via your package manager, you can still pass the command line arguments directly as Jest arguments.
Instead of:
jest -u -t="ColorPicker"
you can use:
npmYarnpnpmnpm test -- -u -t="ColorPicker"yarn test -u -t="ColorPicker"pnpm test -u -t="ColorPicker"
Camelcase & dashed args support​
Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:
jest --collect-coveragejest --collectCoverage
Arguments can also be mixed:
jest --update-snapshot --detectOpenHandles
Options​
noteCLI options take precedence over values from the Configuration.

Camelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--init--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPattern=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--watch--watchAll--watchman--workerThreads

Reference​
jest <regexForTestFiles>​
When you run jest with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: jest "my.*(complex)?pattern". On Windows, you will need to use / as a path separator or escape \ as \\.
--bail[=<n>]​
Alias: -b. Exit the test suite immediately upon n number of failing test suite. Defaults to 1.
--cache​
Whether to use the cache. Defaults to true. Disable the cache using --no-cache.
cautionThe cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.
If you want to inspect the cache, use --showConfig and look at the cacheDirectory value. If you need to clear the cache, use --clearCache.
--changedFilesWithAncestor​
Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to --onlyChanged.
--changedSince​
Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to --onlyChanged.
--ci​
When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with --updateSnapshot.
--clearCache​
Deletes the Jest cache directory and then exits without running tests. Will delete cacheDirectory if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling jest --showConfig.
cautionClearing the cache will reduce performance.
--clearMocks​
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
--collectCoverageFrom=<glob>​
A glob pattern relative to rootDir matching the files that coverage info needs to be collected from.
--colors​
Forces test results output highlighting even if stdout is not a TTY.
noteAlternatively you can set the environment variable FORCE_COLOR=true to forcefully enable or FORCE_COLOR=false to disable colorized output. The use of FORCE_COLOR overrides all other color support checks.
--config=<path>​
Alias: -c. The path to a Jest config file specifying how to find and execute tests. If no rootDir is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.
--coverage[=<boolean>]​
Alias: --collectCoverage. Indicates that test coverage information should be collected and reported in the output. Optionally pass <boolean> to override option set in configuration.
--coverageDirectory=<path>​
The directory where Jest should output its coverage files.
--coverageProvider=<provider>​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
--debug​
Print debugging info about your Jest config.
--detectOpenHandles​
Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use --forceExit in order for Jest to exit to potentially track down the reason. This implies --runInBand, making tests run serially. Implemented using async_hooks. This option has a significant performance penalty and should only be used for debugging.
--env=<environment>​
The test environment used for all tests. This can point to any file or node module. Examples: jsdom, node or path/to/my-environment.js.
--errorOnDeprecated​
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--expand​
Alias: -e. Use this flag to show full diffs and errors instead of a patch.
--filter=<file>​
Path to a module exporting a filtering function. This asynchronous function receives a list of test paths which can be manipulated to exclude tests from running by returning an object with shape { filtered: Array<{ test: string }> }. Especially useful when used in conjunction with a testing infrastructure to filter known broken tests, e.g.
my-filter.jsmodule.exports = testPaths => {  const allowedPaths = testPaths    .filter(filteringFunction)    .map(test => ({test})); // [{ test: "path1.spec.js" }, { test: "path2.spec.js" }, etc]  return {    filtered: allowedPaths,  };};
--findRelatedTests <spaceSeparatedListOfSourceFiles>​
Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with --coverage to include a test coverage for the source files, no duplicate --collectCoverageFrom arguments needed.
--forceExit​
Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up.
cautionThis feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use --detectOpenHandles to help track it down.
--help​
Show the help information, similar to this page.
--ignoreProjects <project1> ... <projectN>​
Ignore the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--init​
Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a jest.config.js file with a short description for each option.
--injectGlobals​
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
--json​
Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
--lastCommit​
Run all tests affected by file changes in the last commit made. Behaves similarly to --onlyChanged.
--listTests​
Lists all test files that Jest will run given the arguments, and exits.
--logHeapUsage​
Logs the heap usage after every test. Useful to debug memory leaks. Use together with --runInBand and --expose-gc in node.
--maxConcurrency=<num>​
Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use test.concurrent.
--maxWorkers=<num>|<string>​
Alias: -w. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration: --maxWorkers=50%
--noStackTrace​
Disables stack trace in test results output.
--notify​
Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.
--onlyChanged​
Alias: -o. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).
--onlyFailures​
Alias: -f. Run tests that failed in the previous execution.
--openHandlesTimeout=<milliseconds>​
When --detectOpenHandles and --forceExit are disabled, Jest will print a warning if the process has not exited cleanly after this number of milliseconds. A value of 0 disables the warning. Defaults to 1000.
--outputFile=<filename>​
Write test results to a file when the --json option is also specified. The returned JSON structure is documented in testResultsProcessor.
--passWithNoTests​
Allows the test suite to pass when no files are found.
--projects <path1> ... <pathN>​
Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the projects configuration option.
noteIf configuration files are found in the specified paths, all projects specified within those configuration files will be run.
--randomize​
Shuffle the order of the tests within a file. The shuffling is based on the seed. See --seed=<num> for more info.
Seed value is displayed when this option is set. Equivalent to setting the CLI option --showSeed.
jest --randomize --seed 1234
noteThis option is only supported using the default jest-circus test runner.
--reporters​
Run tests with specified reporters. Reporter options are not available via CLI. Example with multiple reporters:
jest --reporters="default" --reporters="jest-junit"
--resetMocks​
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--restoreMocks​
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--roots​
A list of paths to directories that Jest should use to search for files in.
--runInBand​
Alias: -i. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.
--runTestsByPath​
Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file.
For example, given the following file structure:
__tests__└── t1.test.js # test└── t2.test.js # test
When ran with a pattern, no test is found:
jest --runTestsByPath __tests__/t
Output:
No tests found
However, passing an exact path will execute only the given test:
jest --runTestsByPath __tests__/t1.test.js
Output:
PASS __tests__/t1.test.js
tipThe default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files.
--seed=<num>​
Sets a seed value that can be retrieved in a test file via jest.getSeed(). The seed value must be between -0x80000000 and 0x7fffffff inclusive (-2147483648 (-(2 ** 31)) and 2147483647 (2 ** 31 - 1) in decimal).
jest --seed=1324
tipIf this option is not specified Jest will randomly generate the value. You can use the --showSeed flag to print the seed in the test report summary.Jest uses the seed internally for shuffling the order in which test suites are run. If the --randomize option is used, the seed is also used for shuffling the order of tests within each describe block. When dealing with flaky tests, rerunning with the same seed might help reproduce the failure.
--selectProjects <project1> ... <projectN>​
Run the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--setupFilesAfterEnv <path1> ... <pathN>​
A list of paths to modules that run some code to configure or to set up the testing framework before each test. Beware that files imported by the setup scripts will not be mocked during testing.
--shard​
The test suite shard to execute in a format of (?<shardIndex>\d+)/(?<shardCount>\d+).
shardIndex describes which shard to select while shardCount controls the number of shards the suite should be split into.
shardIndex and shardCount have to be 1-based, positive numbers, and shardIndex has to be lower than or equal to shardCount.
When shard is specified the configured testSequencer has to implement a shard method.
For example, to split the suite into three shards, each running one third of the tests:
jest --shard=1/3jest --shard=2/3jest --shard=3/3
--showConfig​
Print your Jest config and then exits.
--showSeed​
Prints the seed value in the test report summary. See --seed=<num> for the details.
Can also be set in configuration. See showSeed.
--silent​
Prevent tests from printing messages through the console.
--testEnvironmentOptions=<json string>​
A JSON string with options that will be passed to the testEnvironment. The relevant options depend on the environment.
--testLocationInResults​
Adds a location field to test results. Useful if you want to report the location of a test in a reporter.
noteIn the resulting object column is 0-indexed while line is not.{  "column": 4,  "line": 5}
--testMatch glob1 ... globN​
The glob patterns Jest uses to detect test files. Please refer to the testMatch configuration for details.
--testNamePattern=<regex>​
Alias: -t. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like 'GET /api/posts with auth', then you can use jest -t=auth.
tipThe regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.
--testPathIgnorePatterns=<regex>|[array]​
A single or array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to --testPathPattern, it will only run those tests with a path that does not match with the provided regexp expressions.
To pass as an array use escaped parentheses and space delimited regexps such as \(/node_modules/ /tests/e2e/\). Alternatively, you can omit parentheses by combining regexps into a single regexp like /node_modules/|/tests/e2e/. These two examples are equivalent.
--testPathPattern=<regex>​
A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use / as a path separator or escape \ as \\.
--testRunner=<path>​
Lets you specify a custom test runner.
--testSequencer=<path>​
Lets you specify a custom test sequencer. Please refer to the testSequencer configuration for details.
--testTimeout=<number>​
Default timeout of a test in milliseconds. Default value: 5000.
--updateSnapshot​
Alias: -u. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with --testNamePattern to re-record snapshots.
--useStderr​
Divert all output to stderr.
--verbose​
Display individual test results with the test suite hierarchy.
--version​
Alias: -v. Print the version and exit.
--watch​
Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the --watchAll option instead.
tipUse --no-watch (or --watch=false) to explicitly disable the watch mode if it was enabled using --watch. In most CI environments, this is automatically handled for you.
--watchAll​
Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the --watch option.
tipUse --no-watchAll (or --watchAll=false) to explicitly disable the watch mode if it was enabled using --watchAll. In most CI environments, this is automatically handled for you.
--watchman​
Whether to use watchman for file crawling. Defaults to true. Disable using --no-watchman.
--workerThreads​
Whether to use worker threads for parallelization. Child processes are used by default.
cautionThis is experimental feature. See the workerThreads configuration option for more details.Edit this pageLast updated on Sep 26, 2024 by Jörn ZaeffererPreviousConfiguring JestNextEnvironment VariablesRunning from the command lineUsing with package managerCamelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--init--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPattern=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--watch--watchAll--watchman--workerThreads\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nGuidesUsing with webpackVersion: 29.7On this pageUsing with webpackJest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.
A webpack example​
Let's start with a common sort of webpack config file and translate it to a Jest setup.
webpack.config.jsmodule.exports = {  module: {    rules: [      {        test: /\.jsx?$/,        exclude: ['node_modules'],        use: ['babel-loader'],      },      {        test: /\.css$/,        use: ['style-loader', 'css-loader'],      },      {        test: /\.gif$/,        type: 'asset/inline',      },      {        test: /\.(ttf|eot|svg)$/,        type: 'asset/resource',      },    ],  },  resolve: {    alias: {      config$: './configs/app-config.js',      react: './vendor/react-master',    },    extensions: ['.js', '.jsx'],    modules: [      'node_modules',      'bower_components',      'shared',      '/shared/vendor/modules',    ],  },};
If you have JavaScript files that are transformed by Babel, you can enable support for Babel by installing the babel-jest plugin. Non-Babel JavaScript transformations can be handled with Jest's transform config option.
Handling Static Assets​
Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.
jest.config.jsmodule.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',  },};
And the mock files themselves:
__mocks__/styleMock.jsmodule.exports = {};
__mocks__/fileMock.jsmodule.exports = 'test-file-stub';
Mocking CSS Modules​
You can use an ES6 Proxy to mock CSS Modules:
npmYarnpnpmnpm install --save-dev identity-obj-proxyyarn add --dev identity-obj-proxypnpm add --save-dev identity-obj-proxy
Then all your className lookups on the styles object will be returned as-is (e.g., styles.foobar === 'foobar'). This is pretty handy for React Snapshot Testing.
jest.config.js (for CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': 'identity-obj-proxy',  },};
If moduleNameMapper cannot fulfill your requirements, you can use Jest's transform config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that require('logo.jpg'); returns 'logo') can be written as:
fileTransformer.jsconst path = require('path');module.exports = {  process(sourceText, sourcePath, options) {    return {      code: `module.exports = ${JSON.stringify(path.basename(sourcePath))};`,    };  },};
jest.config.js (for custom transformers and CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(css|less)$': 'identity-obj-proxy',  },  transform: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/fileTransformer.js',  },};
We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.
tipRemember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors:"transform": {  "\\.[jt]sx?$": "babel-jest",  "\\.css$": "some-css-transformer",}
Configuring Jest to find our files​
Now that Jest knows how to process our files, we need to tell it how to find them. For webpack's modules, and extensions options there are direct analogs in Jest's moduleDirectories and moduleFileExtensions options.
jest.config.jsmodule.exports = {  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
note<rootDir> is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your package.json is located unless you specify a custom rootDir option in your configuration.
Similarly, Jest's counterpart for Webpack's resolve.roots (an alternative to setting NODE_PATH) is modulePaths.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
And finally, we have to handle the webpack alias. For that, we can make use of the moduleNameMapper option again.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',    '^react(.*)$': '<rootDir>/vendor/react-master$1',    '^config$': '<rootDir>/configs/app-config.js',  },};
That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.
tipFor more complex webpack configurations, you may also want to investigate projects such as: babel-plugin-webpack-loaders.
Using with webpack​
In addition to installing babel-jest as described earlier, you'll need to add @babel/preset-env like so:
npmYarnpnpmnpm install --save-dev @babel/preset-envyarn add --dev @babel/preset-envpnpm add --save-dev @babel/preset-env
Then, you'll want to configure Babel as follows:
.babelrc{  "presets": ["@babel/preset-env"]}
tipJest caches files to speed up test execution. If you updated .babelrc and Jest is not working as expected, try clearing the cache by running jest --clearCache.
tipIf you use dynamic imports (import('some-file.js').then(module => ...)), you need to enable the dynamic-import-node plugin..babelrc{  "presets": [["env", {"modules": false}]],  "plugins": ["syntax-dynamic-import"],  "env": {    "test": {      "plugins": ["dynamic-import-node"]    }  }}
For an example of how to use Jest with webpack with React, you can view one here.Edit this pageLast updated on Sep 12, 2023 by Simen Bekkhus\n\nGuidesUsing with webpackVersion: 29.7On this pageUsing with webpackJest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.
A webpack example​
Let's start with a common sort of webpack config file and translate it to a Jest setup.
webpack.config.jsmodule.exports = {  module: {    rules: [      {        test: /\.jsx?$/,        exclude: ['node_modules'],        use: ['babel-loader'],      },      {        test: /\.css$/,        use: ['style-loader', 'css-loader'],      },      {        test: /\.gif$/,        type: 'asset/inline',      },      {        test: /\.(ttf|eot|svg)$/,        type: 'asset/resource',      },    ],  },  resolve: {    alias: {      config$: './configs/app-config.js',      react: './vendor/react-master',    },    extensions: ['.js', '.jsx'],    modules: [      'node_modules',      'bower_components',      'shared',      '/shared/vendor/modules',    ],  },};
If you have JavaScript files that are transformed by Babel, you can enable support for Babel by installing the babel-jest plugin. Non-Babel JavaScript transformations can be handled with Jest's transform config option.
Handling Static Assets​
Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.
jest.config.jsmodule.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',  },};
And the mock files themselves:
__mocks__/styleMock.jsmodule.exports = {};
__mocks__/fileMock.jsmodule.exports = 'test-file-stub';
Mocking CSS Modules​
You can use an ES6 Proxy to mock CSS Modules:
npmYarnpnpmnpm install --save-dev identity-obj-proxyyarn add --dev identity-obj-proxypnpm add --save-dev identity-obj-proxy
Then all your className lookups on the styles object will be returned as-is (e.g., styles.foobar === 'foobar'). This is pretty handy for React Snapshot Testing.
jest.config.js (for CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': 'identity-obj-proxy',  },};
If moduleNameMapper cannot fulfill your requirements, you can use Jest's transform config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that require('logo.jpg'); returns 'logo') can be written as:
fileTransformer.jsconst path = require('path');module.exports = {  process(sourceText, sourcePath, options) {    return {      code: `module.exports = ${JSON.stringify(path.basename(sourcePath))};`,    };  },};
jest.config.js (for custom transformers and CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(css|less)$': 'identity-obj-proxy',  },  transform: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/fileTransformer.js',  },};
We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.
tipRemember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors:"transform": {  "\\.[jt]sx?$": "babel-jest",  "\\.css$": "some-css-transformer",}
Configuring Jest to find our files​
Now that Jest knows how to process our files, we need to tell it how to find them. For webpack's modules, and extensions options there are direct analogs in Jest's moduleDirectories and moduleFileExtensions options.
jest.config.jsmodule.exports = {  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
note<rootDir> is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your package.json is located unless you specify a custom rootDir option in your configuration.
Similarly, Jest's counterpart for Webpack's resolve.roots (an alternative to setting NODE_PATH) is modulePaths.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
And finally, we have to handle the webpack alias. For that, we can make use of the moduleNameMapper option again.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',    '^react(.*)$': '<rootDir>/vendor/react-master$1',    '^config$': '<rootDir>/configs/app-config.js',  },};
That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.
tipFor more complex webpack configurations, you may also want to investigate projects such as: babel-plugin-webpack-loaders.
Using with webpack​
In addition to installing babel-jest as described earlier, you'll need to add @babel/preset-env like so:
npmYarnpnpmnpm install --save-dev @babel/preset-envyarn add --dev @babel/preset-envpnpm add --save-dev @babel/preset-env
Then, you'll want to configure Babel as follows:
.babelrc{  "presets": ["@babel/preset-env"]}
tipJest caches files to speed up test execution. If you updated .babelrc and Jest is not working as expected, try clearing the cache by running jest --clearCache.
tipIf you use dynamic imports (import('some-file.js').then(module => ...)), you need to enable the dynamic-import-node plugin..babelrc{  "presets": [["env", {"modules": false}]],  "plugins": ["syntax-dynamic-import"],  "env": {    "test": {      "plugins": ["dynamic-import-node"]    }  }}
For an example of how to use Jest with webpack with React, you can view one here.Edit this pageLast updated on Sep 12, 2023 by Simen BekkhusPreviousECMAScript ModulesNextUsing with puppeteerA webpack exampleHandling Static AssetsMocking CSS ModulesConfiguring Jest to find our filesUsing with webpack\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nGlobalsVersion: 29.7On this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work) (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example', ({a, b, expected}) => {  // all arguments are of type `number`});
Otherwise it will require a generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // without the generic argument in this case types would default to `unknown`});Edit this pageLast updated on Jan 15, 2025 by John Vandenberg\n\nGlobalsVersion: 29.7On this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work) (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example', ({a, b, expected}) => {  // all arguments are of type `number`});
Otherwise it will require a generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // without the generic argument in this case types would default to `unknown`});Edit this pageLast updated on Jan 15, 2025 by John VandenbergNextExpectMethodsReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each\n\n\n\nMock FunctionsVersion: 29.7On this pageMock FunctionsMock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with jest.fn(). If no implementation is given, the mock function will return undefined when invoked.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferencemockFn.getMockName()mockFn.mock.callsmockFn.mock.resultsmockFn.mock.instancesmockFn.mock.contextsmockFn.mock.lastCallmockFn.mockClear()mockFn.mockReset()mockFn.mockRestore()mockFn.mockImplementation(fn)mockFn.mockImplementationOnce(fn)mockFn.mockName(name)mockFn.mockReturnThis()mockFn.mockReturnValue(value)mockFn.mockReturnValueOnce(value)mockFn.mockResolvedValue(value)mockFn.mockResolvedValueOnce(value)mockFn.mockRejectedValue(value)mockFn.mockRejectedValueOnce(value)mockFn.withImplementation(fn, callback)Replaced PropertiesreplacedProperty.replaceValue(value)replacedProperty.restore()TypeScript Usagejest.fn(implementation?)jest.Mock<T>jest.Mocked<Source>jest.Replaced<Source>jest.mocked(source, options?)jest.Spied<Source>

Reference​
mockFn.getMockName()​
Returns the mock name string set by calling .mockName().
mockFn.mock.calls​
An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.calls array that looks like this:
[  ['arg1', 'arg2'],  ['arg3', 'arg4'],];
mockFn.mock.results​
An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a type property, and a value property. type will be one of the following:

'return' - Indicates that the call completed by returning normally.
'throw' - Indicates that the call completed by throwing a value.
'incomplete' - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.

The value property contains the value that was thrown or returned. value is undefined when type === 'incomplete'.
For example: A mock function f that has been called three times, returning 'result1', throwing an error, and then returning 'result2', would have a mock.results array that looks like this:
[  {    type: 'return',    value: 'result1',  },  {    type: 'throw',    value: {      /* Error instance */    },  },  {    type: 'return',    value: 'result2',  },];
mockFn.mock.instances​
An array that contains all the object instances that have been instantiated from this mock function using new.
For example: A mock function that has been instantiated twice would have the following mock.instances array:
const mockFn = jest.fn();const a = new mockFn();const b = new mockFn();mockFn.mock.instances[0] === a; // truemockFn.mock.instances[1] === b; // true
mockFn.mock.contexts​
An array that contains the contexts for all calls of the mock function.
A context is the this value that a function receives when called. The context can be set using Function.prototype.bind, Function.prototype.call or Function.prototype.apply.
For example:
const mockFn = jest.fn();const boundMockFn = mockFn.bind(thisContext0);boundMockFn('a', 'b');mockFn.call(thisContext1, 'a', 'b');mockFn.apply(thisContext2, ['a', 'b']);mockFn.mock.contexts[0] === thisContext0; // truemockFn.mock.contexts[1] === thisContext1; // truemockFn.mock.contexts[2] === thisContext2; // true
mockFn.mock.lastCall​
An array containing the call arguments of the last call that was made to this mock function. If the function was not called, it will return undefined.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.lastCall array that looks like this:
['arg3', 'arg4'];
mockFn.mockClear()​
Clears all information stored in the mockFn.mock.calls, mockFn.mock.instances, mockFn.mock.contexts and mockFn.mock.results arrays. Often this is useful when you want to clean up a mocks usage data between two assertions.
The clearMocks configuration option is available to clear mocks automatically before each tests.
cautionBeware that mockFn.mockClear() will replace mockFn.mock, not just reset the values of its properties! You should, therefore, avoid assigning mockFn.mock to other variables, temporary or not, to make sure you don't access stale data.
mockFn.mockReset()​
Does everything that mockFn.mockClear() does, and also replaces the mock implementation with an empty function, returning undefined.
The resetMocks configuration option is available to reset mocks automatically before each test.
mockFn.mockRestore()​
Does everything that mockFn.mockReset() does, and also restores the original (non-mocked) implementation.
This is useful when you want to mock functions in certain test cases and restore the original implementation in others.
The restoreMocks configuration option is available to restore mocks automatically before each test.
infomockFn.mockRestore() only works when the mock was created with jest.spyOn(). Thus you have to take care of restoration yourself when manually assigning jest.fn().
mockFn.mockImplementation(fn)​
Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself – the only difference is that the implementation will also be executed when the mock is called.
tipjest.fn(implementation) is a shorthand for jest.fn().mockImplementation(implementation).
JavaScriptTypeScriptconst mockFn = jest.fn(scalar => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39import {jest} from '@jest/globals';const mockFn = jest.fn((scalar: number) => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39
.mockImplementation() can also be used to mock class constructors:
JavaScriptTypeScriptSomeClass.jsmodule.exports = class SomeClass {  method(a, b) {}};SomeClass.test.jsconst SomeClass = require('./SomeClass');jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn();SomeClass.mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);SomeClass.tsexport class SomeClass {  method(a: string, b: string): void {}}SomeClass.test.tsimport {jest} from '@jest/globals';import {SomeClass} from './SomeClass';jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn<(a: string, b: string) => void>();jest.mocked(SomeClass).mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);
mockFn.mockImplementationOnce(fn)​
Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // falseimport {jest} from '@jest/globals';const mockFn = jest  .fn<(cb: (a: null, b: boolean) => void) => void>()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // false
When the mocked function runs out of implementations defined with .mockImplementationOnce(), it will execute the default implementation set with jest.fn(() => defaultValue) or .mockImplementation(() => defaultValue) if they were called:
const mockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockName(name)​
Accepts a string to use in test result output in place of 'jest.fn()' to indicate which mock function is being referenced.
For example:
const mockFn = jest.fn().mockName('mockedFunction');// mockFn();expect(mockFn).toHaveBeenCalled();
Will result in this error:
expect(mockedFunction).toHaveBeenCalled()Expected number of calls: >= 1Received number of calls:    0
mockFn.mockReturnThis()​
Shorthand for:
jest.fn(function () {  return this;});
mockFn.mockReturnValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => value);
Accepts a value that will be returned whenever the mock function is called.
JavaScriptTypeScriptconst mock = jest.fn();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43import {jest} from '@jest/globals';const mock = jest.fn<() => number>();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43
mockFn.mockReturnValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => value);
Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more mockReturnValueOnce values to use, calls will return a value specified by mockReturnValue.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'import {jest} from '@jest/globals';const mockFn = jest  .fn<() => string>()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockResolvedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.resolve(value));
Useful to mock async functions in async tests:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest.fn().mockResolvedValue(43);  await asyncMock(); // 43});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest.fn<() => Promise<number>>().mockResolvedValue(43);  await asyncMock(); // 43});
mockFn.mockResolvedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.resolve(value));
Useful to resolve different values over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});
mockFn.mockRejectedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.reject(value));
Useful to create async mock functions that will always reject:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<never>>()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});
mockFn.mockRejectedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.reject(value));
Useful together with .mockResolvedValueOnce() or to reject with different exceptions over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});
mockFn.withImplementation(fn, callback)​
Accepts a function which should be temporarily used as the implementation of the mock while the callback is being executed.
test('test', () => {  const mock = jest.fn(() => 'outside callback');  mock.withImplementation(    () => 'inside callback',    () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
mockFn.withImplementation can be used regardless of whether or not the callback is asynchronous (returns a thenable). If the callback is asynchronous a promise will be returned. Awaiting the promise will await the callback and reset the implementation.
test('async test', async () => {  const mock = jest.fn(() => 'outside callback');  // We await this call since the callback is async  await mock.withImplementation(    () => 'inside callback',    async () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
Replaced Properties​
replacedProperty.replaceValue(value)​
Changes the value of already replaced property. This is useful when you want to replace property and then adjust the value in specific tests. As an alternative, you can call jest.replaceProperty() multiple times on same property.
replacedProperty.restore()​
Restores object's property to the original value.
Beware that replacedProperty.restore() only works when the property value was replaced with jest.replaceProperty().
The restoreMocks configuration option is available to restore replaced properties automatically before each test.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.fn(implementation?)​
Correct mock typings will be inferred if implementation is passed to jest.fn(). There are many use cases where the implementation is omitted. To ensure type safety you may pass a generic type argument (also see the examples above for more reference):
import {expect, jest, test} from '@jest/globals';import type add from './add';import calculate from './calc';test('calculate calls add', () => {  // Create a new mock that can be used in place of `add`.  const mockAdd = jest.fn<typeof add>();  // `.mockImplementation()` now can infer that `a` and `b` are `number`  // and that the returned value is a `number`.  mockAdd.mockImplementation((a, b) => {    // Yes, this mock is still adding two numbers but imagine this    // was a complex function we are mocking.    return a + b;  });  // `mockAdd` is properly typed and therefore accepted by anything  // requiring `add`.  calculate(mockAdd, 1, 2);  expect(mockAdd).toHaveBeenCalledTimes(1);  expect(mockAdd).toHaveBeenCalledWith(1, 2);});
jest.Mock<T>​
Constructs the type of a mock function, e.g. the return type of jest.fn(). It can be useful if you have to defined a recursive mock function:
import {jest} from '@jest/globals';const sumRecursively: jest.Mock<(value: number) => number> = jest.fn(value => {  if (value === 0) {    return 0;  } else {    return value + fn(value - 1);  }});
jest.Mocked<Source>​
The jest.Mocked<Source> utility type returns the Source type wrapped with type definitions of Jest mock function.
import {expect, jest, test} from '@jest/globals';import type {fetch} from 'node-fetch';jest.mock('node-fetch');let mockedFetch: jest.Mocked<typeof fetch>;afterEach(() => {  mockedFetch.mockClear();});test('makes correct call', () => {  mockedFetch = getMockedFetch();  // ...});test('returns correct data', () => {  mockedFetch = getMockedFetch();  // ...});
Types of classes, functions or objects can be passed as type argument to jest.Mocked<Source>. If you prefer to constrain the input type, use: jest.MockedClass<Source>, jest.MockedFunction<Source> or jest.MockedObject<Source>.
jest.Replaced<Source>​
The jest.Replaced<Source> utility type returns the Source type wrapped with type definitions of Jest replaced property.
src/utils.tsexport function isLocalhost(): boolean {  return process.env['HOSTNAME'] === 'localhost';}
src/__tests__/utils.test.tsimport {afterEach, expect, it, jest} from '@jest/globals';import {isLocalhost} from '../utils';let replacedEnv: jest.Replaced<typeof process.env> | undefined = undefined;afterEach(() => {  replacedEnv?.restore();});it('isLocalhost should detect localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'localhost'});  expect(isLocalhost()).toBe(true);});it('isLocalhost should detect non-localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'example.com'});  expect(isLocalhost()).toBe(false);});
jest.mocked(source, options?)​
The mocked() helper method wraps types of the source object and its deep nested members with type definitions of Jest mock function. You can pass {shallow: true} as the options argument to disable the deeply mocked behavior.
Returns the source object.
song.tsexport const song = {  one: {    more: {      time: (t: number) => {        return t;      },    },  },};
song.test.tsimport {expect, jest, test} from '@jest/globals';import {song} from './song';jest.mock('./song');jest.spyOn(console, 'log');const mockedSong = jest.mocked(song);// or through `jest.Mocked<Source>`// const mockedSong = song as jest.Mocked<typeof song>;test('deep method is typed correctly', () => {  mockedSong.one.more.time.mockReturnValue(12);  expect(mockedSong.one.more.time(10)).toBe(12);  expect(mockedSong.one.more.time.mock.calls).toHaveLength(1);});test('direct usage', () => {  jest.mocked(console.log).mockImplementation(() => {    return;  });  console.log('one more time');  expect(jest.mocked(console.log).mock.calls).toHaveLength(1);});
jest.Spied<Source>​
Constructs the type of a spied class or function (i.e. the return type of jest.spyOn()).
__utils__/setDateNow.tsimport {jest} from '@jest/globals';export function setDateNow(now: number): jest.Spied<typeof Date.now> {  return jest.spyOn(Date, 'now').mockReturnValue(now);}
import {afterEach, expect, type jest, test} from '@jest/globals';import {setDateNow} from './__utils__/setDateNow';let spiedDateNow: jest.Spied<typeof Date.now> | undefined = undefined;afterEach(() => {  spiedDateNow?.mockReset();});test('renders correctly with a given date', () => {  spiedDateNow = setDateNow(1_482_363_367_071);  // ...  expect(spiedDateNow).toHaveBeenCalledTimes(1);});
Types of a class or function can be passed as type argument to jest.Spied<Source>. If you prefer to constrain the input type, use: jest.SpiedClass<Source> or jest.SpiedFunction<Source>.
Use jest.SpiedGetter<Source> or jest.SpiedSetter<Source> to create the type of a spied getter or setter respectively.Edit this pageLast updated on Dec 30, 2023 by Simen Bekkhus\n\nMock FunctionsVersion: 29.7On this pageMock FunctionsMock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with jest.fn(). If no implementation is given, the mock function will return undefined when invoked.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferencemockFn.getMockName()mockFn.mock.callsmockFn.mock.resultsmockFn.mock.instancesmockFn.mock.contextsmockFn.mock.lastCallmockFn.mockClear()mockFn.mockReset()mockFn.mockRestore()mockFn.mockImplementation(fn)mockFn.mockImplementationOnce(fn)mockFn.mockName(name)mockFn.mockReturnThis()mockFn.mockReturnValue(value)mockFn.mockReturnValueOnce(value)mockFn.mockResolvedValue(value)mockFn.mockResolvedValueOnce(value)mockFn.mockRejectedValue(value)mockFn.mockRejectedValueOnce(value)mockFn.withImplementation(fn, callback)Replaced PropertiesreplacedProperty.replaceValue(value)replacedProperty.restore()TypeScript Usagejest.fn(implementation?)jest.Mock<T>jest.Mocked<Source>jest.Replaced<Source>jest.mocked(source, options?)jest.Spied<Source>

Reference​
mockFn.getMockName()​
Returns the mock name string set by calling .mockName().
mockFn.mock.calls​
An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.calls array that looks like this:
[  ['arg1', 'arg2'],  ['arg3', 'arg4'],];
mockFn.mock.results​
An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a type property, and a value property. type will be one of the following:

'return' - Indicates that the call completed by returning normally.
'throw' - Indicates that the call completed by throwing a value.
'incomplete' - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.

The value property contains the value that was thrown or returned. value is undefined when type === 'incomplete'.
For example: A mock function f that has been called three times, returning 'result1', throwing an error, and then returning 'result2', would have a mock.results array that looks like this:
[  {    type: 'return',    value: 'result1',  },  {    type: 'throw',    value: {      /* Error instance */    },  },  {    type: 'return',    value: 'result2',  },];
mockFn.mock.instances​
An array that contains all the object instances that have been instantiated from this mock function using new.
For example: A mock function that has been instantiated twice would have the following mock.instances array:
const mockFn = jest.fn();const a = new mockFn();const b = new mockFn();mockFn.mock.instances[0] === a; // truemockFn.mock.instances[1] === b; // true
mockFn.mock.contexts​
An array that contains the contexts for all calls of the mock function.
A context is the this value that a function receives when called. The context can be set using Function.prototype.bind, Function.prototype.call or Function.prototype.apply.
For example:
const mockFn = jest.fn();const boundMockFn = mockFn.bind(thisContext0);boundMockFn('a', 'b');mockFn.call(thisContext1, 'a', 'b');mockFn.apply(thisContext2, ['a', 'b']);mockFn.mock.contexts[0] === thisContext0; // truemockFn.mock.contexts[1] === thisContext1; // truemockFn.mock.contexts[2] === thisContext2; // true
mockFn.mock.lastCall​
An array containing the call arguments of the last call that was made to this mock function. If the function was not called, it will return undefined.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.lastCall array that looks like this:
['arg3', 'arg4'];
mockFn.mockClear()​
Clears all information stored in the mockFn.mock.calls, mockFn.mock.instances, mockFn.mock.contexts and mockFn.mock.results arrays. Often this is useful when you want to clean up a mocks usage data between two assertions.
The clearMocks configuration option is available to clear mocks automatically before each tests.
cautionBeware that mockFn.mockClear() will replace mockFn.mock, not just reset the values of its properties! You should, therefore, avoid assigning mockFn.mock to other variables, temporary or not, to make sure you don't access stale data.
mockFn.mockReset()​
Does everything that mockFn.mockClear() does, and also replaces the mock implementation with an empty function, returning undefined.
The resetMocks configuration option is available to reset mocks automatically before each test.
mockFn.mockRestore()​
Does everything that mockFn.mockReset() does, and also restores the original (non-mocked) implementation.
This is useful when you want to mock functions in certain test cases and restore the original implementation in others.
The restoreMocks configuration option is available to restore mocks automatically before each test.
infomockFn.mockRestore() only works when the mock was created with jest.spyOn(). Thus you have to take care of restoration yourself when manually assigning jest.fn().
mockFn.mockImplementation(fn)​
Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself – the only difference is that the implementation will also be executed when the mock is called.
tipjest.fn(implementation) is a shorthand for jest.fn().mockImplementation(implementation).
JavaScriptTypeScriptconst mockFn = jest.fn(scalar => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39import {jest} from '@jest/globals';const mockFn = jest.fn((scalar: number) => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39
.mockImplementation() can also be used to mock class constructors:
JavaScriptTypeScriptSomeClass.jsmodule.exports = class SomeClass {  method(a, b) {}};SomeClass.test.jsconst SomeClass = require('./SomeClass');jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn();SomeClass.mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);SomeClass.tsexport class SomeClass {  method(a: string, b: string): void {}}SomeClass.test.tsimport {jest} from '@jest/globals';import {SomeClass} from './SomeClass';jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn<(a: string, b: string) => void>();jest.mocked(SomeClass).mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);
mockFn.mockImplementationOnce(fn)​
Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // falseimport {jest} from '@jest/globals';const mockFn = jest  .fn<(cb: (a: null, b: boolean) => void) => void>()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // false
When the mocked function runs out of implementations defined with .mockImplementationOnce(), it will execute the default implementation set with jest.fn(() => defaultValue) or .mockImplementation(() => defaultValue) if they were called:
const mockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockName(name)​
Accepts a string to use in test result output in place of 'jest.fn()' to indicate which mock function is being referenced.
For example:
const mockFn = jest.fn().mockName('mockedFunction');// mockFn();expect(mockFn).toHaveBeenCalled();
Will result in this error:
expect(mockedFunction).toHaveBeenCalled()Expected number of calls: >= 1Received number of calls:    0
mockFn.mockReturnThis()​
Shorthand for:
jest.fn(function () {  return this;});
mockFn.mockReturnValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => value);
Accepts a value that will be returned whenever the mock function is called.
JavaScriptTypeScriptconst mock = jest.fn();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43import {jest} from '@jest/globals';const mock = jest.fn<() => number>();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43
mockFn.mockReturnValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => value);
Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more mockReturnValueOnce values to use, calls will return a value specified by mockReturnValue.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'import {jest} from '@jest/globals';const mockFn = jest  .fn<() => string>()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockResolvedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.resolve(value));
Useful to mock async functions in async tests:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest.fn().mockResolvedValue(43);  await asyncMock(); // 43});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest.fn<() => Promise<number>>().mockResolvedValue(43);  await asyncMock(); // 43});
mockFn.mockResolvedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.resolve(value));
Useful to resolve different values over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});
mockFn.mockRejectedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.reject(value));
Useful to create async mock functions that will always reject:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<never>>()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});
mockFn.mockRejectedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.reject(value));
Useful together with .mockResolvedValueOnce() or to reject with different exceptions over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});
mockFn.withImplementation(fn, callback)​
Accepts a function which should be temporarily used as the implementation of the mock while the callback is being executed.
test('test', () => {  const mock = jest.fn(() => 'outside callback');  mock.withImplementation(    () => 'inside callback',    () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
mockFn.withImplementation can be used regardless of whether or not the callback is asynchronous (returns a thenable). If the callback is asynchronous a promise will be returned. Awaiting the promise will await the callback and reset the implementation.
test('async test', async () => {  const mock = jest.fn(() => 'outside callback');  // We await this call since the callback is async  await mock.withImplementation(    () => 'inside callback',    async () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
Replaced Properties​
replacedProperty.replaceValue(value)​
Changes the value of already replaced property. This is useful when you want to replace property and then adjust the value in specific tests. As an alternative, you can call jest.replaceProperty() multiple times on same property.
replacedProperty.restore()​
Restores object's property to the original value.
Beware that replacedProperty.restore() only works when the property value was replaced with jest.replaceProperty().
The restoreMocks configuration option is available to restore replaced properties automatically before each test.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.fn(implementation?)​
Correct mock typings will be inferred if implementation is passed to jest.fn(). There are many use cases where the implementation is omitted. To ensure type safety you may pass a generic type argument (also see the examples above for more reference):
import {expect, jest, test} from '@jest/globals';import type add from './add';import calculate from './calc';test('calculate calls add', () => {  // Create a new mock that can be used in place of `add`.  const mockAdd = jest.fn<typeof add>();  // `.mockImplementation()` now can infer that `a` and `b` are `number`  // and that the returned value is a `number`.  mockAdd.mockImplementation((a, b) => {    // Yes, this mock is still adding two numbers but imagine this    // was a complex function we are mocking.    return a + b;  });  // `mockAdd` is properly typed and therefore accepted by anything  // requiring `add`.  calculate(mockAdd, 1, 2);  expect(mockAdd).toHaveBeenCalledTimes(1);  expect(mockAdd).toHaveBeenCalledWith(1, 2);});
jest.Mock<T>​
Constructs the type of a mock function, e.g. the return type of jest.fn(). It can be useful if you have to defined a recursive mock function:
import {jest} from '@jest/globals';const sumRecursively: jest.Mock<(value: number) => number> = jest.fn(value => {  if (value === 0) {    return 0;  } else {    return value + fn(value - 1);  }});
jest.Mocked<Source>​
The jest.Mocked<Source> utility type returns the Source type wrapped with type definitions of Jest mock function.
import {expect, jest, test} from '@jest/globals';import type {fetch} from 'node-fetch';jest.mock('node-fetch');let mockedFetch: jest.Mocked<typeof fetch>;afterEach(() => {  mockedFetch.mockClear();});test('makes correct call', () => {  mockedFetch = getMockedFetch();  // ...});test('returns correct data', () => {  mockedFetch = getMockedFetch();  // ...});
Types of classes, functions or objects can be passed as type argument to jest.Mocked<Source>. If you prefer to constrain the input type, use: jest.MockedClass<Source>, jest.MockedFunction<Source> or jest.MockedObject<Source>.
jest.Replaced<Source>​
The jest.Replaced<Source> utility type returns the Source type wrapped with type definitions of Jest replaced property.
src/utils.tsexport function isLocalhost(): boolean {  return process.env['HOSTNAME'] === 'localhost';}
src/__tests__/utils.test.tsimport {afterEach, expect, it, jest} from '@jest/globals';import {isLocalhost} from '../utils';let replacedEnv: jest.Replaced<typeof process.env> | undefined = undefined;afterEach(() => {  replacedEnv?.restore();});it('isLocalhost should detect localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'localhost'});  expect(isLocalhost()).toBe(true);});it('isLocalhost should detect non-localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'example.com'});  expect(isLocalhost()).toBe(false);});
jest.mocked(source, options?)​
The mocked() helper method wraps types of the source object and its deep nested members with type definitions of Jest mock function. You can pass {shallow: true} as the options argument to disable the deeply mocked behavior.
Returns the source object.
song.tsexport const song = {  one: {    more: {      time: (t: number) => {        return t;      },    },  },};
song.test.tsimport {expect, jest, test} from '@jest/globals';import {song} from './song';jest.mock('./song');jest.spyOn(console, 'log');const mockedSong = jest.mocked(song);// or through `jest.Mocked<Source>`// const mockedSong = song as jest.Mocked<typeof song>;test('deep method is typed correctly', () => {  mockedSong.one.more.time.mockReturnValue(12);  expect(mockedSong.one.more.time(10)).toBe(12);  expect(mockedSong.one.more.time.mock.calls).toHaveLength(1);});test('direct usage', () => {  jest.mocked(console.log).mockImplementation(() => {    return;  });  console.log('one more time');  expect(jest.mocked(console.log).mock.calls).toHaveLength(1);});
jest.Spied<Source>​
Constructs the type of a spied class or function (i.e. the return type of jest.spyOn()).
__utils__/setDateNow.tsimport {jest} from '@jest/globals';export function setDateNow(now: number): jest.Spied<typeof Date.now> {  return jest.spyOn(Date, 'now').mockReturnValue(now);}
import {afterEach, expect, type jest, test} from '@jest/globals';import {setDateNow} from './__utils__/setDateNow';let spiedDateNow: jest.Spied<typeof Date.now> | undefined = undefined;afterEach(() => {  spiedDateNow?.mockReset();});test('renders correctly with a given date', () => {  spiedDateNow = setDateNow(1_482_363_367_071);  // ...  expect(spiedDateNow).toHaveBeenCalledTimes(1);});
Types of a class or function can be passed as type argument to jest.Spied<Source>. If you prefer to constrain the input type, use: jest.SpiedClass<Source> or jest.SpiedFunction<Source>.
Use jest.SpiedGetter<Source> or jest.SpiedSetter<Source> to create the type of a spied getter or setter respectively.Edit this pageLast updated on Dec 30, 2023 by Simen BekkhusPreviousExpectNextThe Jest ObjectMethodsReferencemockFn.getMockName()mockFn.mock.callsmockFn.mock.resultsmockFn.mock.instancesmockFn.mock.contextsmockFn.mock.lastCallmockFn.mockClear()mockFn.mockReset()mockFn.mockRestore()mockFn.mockImplementation(fn)mockFn.mockImplementationOnce(fn)mockFn.mockName(name)mockFn.mockReturnThis()mockFn.mockReturnValue(value)mockFn.mockReturnValueOnce(value)mockFn.mockResolvedValue(value)mockFn.mockResolvedValueOnce(value)mockFn.mockRejectedValue(value)mockFn.mockRejectedValueOnce(value)mockFn.withImplementation(fn, callback)Replaced PropertiesreplacedProperty.replaceValue(value)replacedProperty.restore()TypeScript Usagejest.fn(implementation?)jest.Mock<T>jest.Mocked<Source>jest.Replaced<Source>jest.mocked(source, options?)jest.Spied<Source>\n\n\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nIntroductionGetting StartedVersion: 29.7On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguring JestVersion: 29.7On this pageConfiguring JestThe Jest philosophy is to work great by default, but sometimes you just need more configuration power.
It is recommended to define the configuration in a dedicated JavaScript, TypeScript or JSON file. The file will be discovered automatically, if it is named jest.config.js|ts|mjs|cjs|json. You can use --config flag to pass an explicit path to the file.
noteKeep in mind that the resulting configuration object must always be JSON-serializable.
The configuration file should simply export an object:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  verbose: true,};module.exports = config;import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
Or a function returning an object:
JavaScriptTypeScript/** @returns {Promise<import('jest').Config>} */module.exports = async () => {  return {    verbose: true,  };};import type {Config} from 'jest';export default async (): Promise<Config> => {  return {    verbose: true,  };};
tipTo read TypeScript configuration files Jest requires ts-node. Make sure it is installed in your project.
The configuration also can be stored in a JSON file as a plain object:
jest.config.json{  "bail": 1,  "verbose": true}
Alternatively Jest's configuration can be defined through the "jest" key in the package.json of your project:
package.json{  "name": "my-project",  "jest": {    "verbose": true  }}
Options​
infoYou can retrieve Jest's defaults from jest-config to extend them if needed:JavaScriptTypeScriptconst {defaults} = require('jest-config');/** @type {import('jest').Config} */const config = {  moduleFileExtensions: [...defaults.moduleFileExtensions, 'mts', 'cts'],};module.exports = config;import type {Config} from 'jest';import {defaults} from 'jest-config';const config: Config = {  moduleFileExtensions: [...defaults.moduleFileExtensions, 'mts'],};export default config;

automock [boolean]bail [number | boolean]cacheDirectory [string]clearMocks [boolean]collectCoverage [boolean]collectCoverageFrom [array]coverageDirectory [string]coveragePathIgnorePatterns [array<string>]coverageProvider [string]coverageReporters [array<string | [string, options]>]coverageThreshold [object]dependencyExtractor [string]displayName [string, object]errorOnDeprecated [boolean]extensionsToTreatAsEsm [array<string>]fakeTimers [object]forceCoverageMatch [array<string>]globals [object]globalSetup [string]globalTeardown [string]haste [object]injectGlobals [boolean]maxConcurrency [number]maxWorkers [number | string]moduleDirectories [array<string>]moduleFileExtensions [array<string>]moduleNameMapper [object<string, string | array<string>>]modulePathIgnorePatterns [array<string>]modulePaths [array<string>]notify [boolean]notifyMode [string]openHandlesTimeout [number]preset [string]prettierPath [string]projects [array<string | ProjectConfig>]randomize [boolean]reporters [array<moduleName | [moduleName, options]>]resetMocks [boolean]resetModules [boolean]resolver [string]restoreMocks [boolean]rootDir [string]roots [array<string>]runner [string]sandboxInjectedGlobals [array<string>]setupFiles [array]setupFilesAfterEnv [array]showSeed [boolean]slowTestThreshold [number]snapshotFormat [object]snapshotResolver [string]snapshotSerializers [array<string>]testEnvironment [string]testEnvironmentOptions [Object]testFailureExitCode [number]testMatch [array<string>]testPathIgnorePatterns [array<string>]testRegex [string | array<string>]testResultsProcessor [string]testRunner [string]testSequencer [string]testTimeout [number]transform [object<string, pathToTransformer | [pathToTransformer, object]>]transformIgnorePatterns [array<string>]unmockedModulePathPatterns [array<string>]verbose [boolean]watchPathIgnorePatterns [array<string>]watchPlugins [array<string | [string, Object]>]watchman [boolean]workerIdleMemoryLimit [number|string]// [string]workerThreads

Reference​
automock [boolean]​
Default: false
This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.
Example:
utils.jsexport default {  authorize: () => 'token',  isAuthorized: secret => secret === 'wizard',};
__tests__/automock.test.jsimport utils from '../utils';test('if utils mocked automatically', () => {  // Public methods of `utils` are now mock functions  expect(utils.authorize.mock).toBeTruthy();  expect(utils.isAuthorized.mock).toBeTruthy();  // You can provide them with your own implementation  // or pass the expected return value  utils.authorize.mockReturnValue('mocked_token');  utils.isAuthorized.mockReturnValue(true);  expect(utils.authorize()).toBe('mocked_token');  expect(utils.isAuthorized('not_wizard')).toBeTruthy();});
noteNode modules are automatically mocked when you have a manual mock in place (e.g.: __mocks__/lodash.js). More info here.Node.js core modules, like fs, are not mocked by default. They can be mocked explicitly, like jest.mock('fs').
bail [number | boolean]​
Default: 0
By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after n failures. Setting bail to true is the same as setting bail to 1.
cacheDirectory [string]​
Default: "/tmp/<path>"
The directory where Jest should store its cached dependency information.
Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem churn that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.
clearMocks [boolean]​
Default: false
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
collectCoverage [boolean]​
Default: false
Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.
Jest ships with two coverage providers: babel (default) and v8. See the coverageProvider option for more details.
infoThe babel and v8 coverage providers use /* istanbul ignore next */ and /* c8 ignore next */ comments to exclude lines from coverage reports, respectively. For more information, you can view the istanbuljs documentation and the c8 documentation.
collectCoverageFrom [array]​
Default: undefined
An array of glob patterns indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};export default config;
This will collect coverage information for all the files inside the project's rootDir, except the ones that match **/node_modules/** or **/vendor/**.
tipEach glob pattern is applied in the order they are specified in the config. For example ["!**/__tests__/**", "**/*.js"] will not exclude __tests__ because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after **/*.js.
noteThis option requires collectCoverage to be set to true or Jest to be invoked with --coverage.
Help:If you are seeing coverage output such as...=============================== Coverage summary ===============================Statements   : Unknown% ( 0/0 )Branches     : Unknown% ( 0/0 )Functions    : Unknown% ( 0/0 )Lines        : Unknown% ( 0/0 )================================================================================Jest: Coverage data for global was not found.Most likely your glob patterns are not matching any files. Refer to the micromatch documentation to ensure your globs are compatible.
coverageDirectory [string]​
Default: undefined
The directory where Jest should output its coverage files.
coveragePathIgnorePatterns [array<string>]​
Default: ["/node_modules/"]
An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: ["<rootDir>/build/", "<rootDir>/node_modules/"].
coverageProvider [string]​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
coverageReporters [array<string | [string, options]>]​
Default: ["clover", "json", "lcov", "text"]
A list of reporter names that Jest uses when writing coverage reports. Any istanbul reporter can be used.
tipSetting this option overwrites the default values. Add "text" or "text-summary" to see a coverage summary in the console output.
Additional options can be passed using the tuple form. For example, you may hide coverage report lines for all fully-covered files:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};module.exports = config;import type {Config} from 'jest';const config: Config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};export default config;
For more information about the options object shape refer to CoverageReporterWithOptions type in the type definitions.
coverageThreshold [object]​
Default: undefined
This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as global, as a glob, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.
For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};export default config;
If globs or paths are specified alongside global, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, an error is returned.
For example, with the following configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};export default config;
Jest will fail if:

The ./src/components directory has less than 40% branch or statement coverage.
One of the files matching the ./src/reducers/**/*.js glob has less than 90% statement coverage.
The ./src/api/very-important-module.js file has less than 100% coverage.
Every remaining file combined has less than 50% coverage (global).

dependencyExtractor [string]​
Default: undefined
This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an extract function. E.g.:
const crypto = require('crypto');const fs = require('fs');module.exports = {  extract(code, filePath, defaultExtract) {    const deps = defaultExtract(code, filePath);    // Scan the file and add dependencies in `deps` (which is a `Set`)    return deps;  },  getCacheKey() {    return crypto      .createHash('md5')      .update(fs.readFileSync(__filename))      .digest('hex');  },};
The extract function should return an iterable (Array, Set, etc.) with the dependencies found in the code.
That module can also contain a getCacheKey function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.
displayName [string, object]​
default: undefined
Allows for a label to be printed alongside a test while it is running. This becomes more useful in multi-project repositories where there can be many jest configuration files. This visually tells which project a test belongs to.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  displayName: 'CLIENT',};module.exports = config;import type {Config} from 'jest';const config: Config = {  displayName: 'CLIENT',};export default config;
Alternatively, an object with the properties name and color can be passed. This allows for a custom configuration of the background color of the displayName. displayName defaults to white when its value is a string. Jest uses chalk to provide the color. As such, all of the valid options for colors supported by chalk are also supported by Jest.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};export default config;
errorOnDeprecated [boolean]​
Default: false
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
extensionsToTreatAsEsm [array<string>]​
Default: []
Jest will run .mjs and .js files with nearest package.json's type field set to module as ECMAScript Modules. If you have any other files that should run with native ESM, you need to specify their file extension here.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  extensionsToTreatAsEsm: ['.ts'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  extensionsToTreatAsEsm: ['.ts'],};export default config;
cautionJest's ESM support is still experimental, see its docs for more details.
fakeTimers [object]​
Default: {}
The fake timers may be useful when a piece of code sets a long timeout that we don't want to wait for in a test. For additional details see Fake Timers guide and API documentation.
This option provides the default configuration of fake timers for all tests. Calling jest.useFakeTimers() in a test file will use these options or will override them if a configuration object is passed. For example, you can tell Jest to keep the original implementation of process.nextTick() and adjust the limit of recursive timers that will be run:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};export default config;
fakeTime.test.js// install fake timers for this file using the options from Jest configurationjest.useFakeTimers();test('increase the limit of recursive timers for this and following tests', () => {  jest.useFakeTimers({timerLimit: 5000});  // ...});
tipInstead of including jest.useFakeTimers() in each test file, you can enable fake timers globally for all tests in your Jest configuration:JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,  },};export default config;
Configuration options:
type FakeableAPI =  | 'Date'  | 'hrtime'  | 'nextTick'  | 'performance'  | 'queueMicrotask'  | 'requestAnimationFrame'  | 'cancelAnimationFrame'  | 'requestIdleCallback'  | 'cancelIdleCallback'  | 'setImmediate'  | 'clearImmediate'  | 'setInterval'  | 'clearInterval'  | 'setTimeout'  | 'clearTimeout';type ModernFakeTimersConfig = {  /**   * If set to `true` all timers will be advanced automatically by 20 milliseconds   * every 20 milliseconds. A custom time delta may be provided by passing a number.   * The default is `false`.   */  advanceTimers?: boolean | number;  /**   * List of names of APIs that should not be faked. The default is `[]`, meaning   * all APIs are faked.   */  doNotFake?: Array<FakeableAPI>;  /** Whether fake timers should be enabled for all test files. The default is `false`. */  enableGlobally?: boolean;  /**   * Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.   * The default is `false`.   */  legacyFakeTimers?: boolean;  /** Sets current system time to be used by fake timers, in milliseconds. The default is `Date.now()`. */  now?: number;  /** Maximum number of recursive timers that will be run. The default is `100_000` timers. */  timerLimit?: number;};
Legacy Fake TimersFor some reason you might have to use legacy implementation of fake timers. Here is how to enable it globally (additional options are not supported):JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};export default config;
forceCoverageMatch [array<string>]​
Default: ['']
Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.
For example, if you have tests in source files named with .t.js extension as following:
sum.t.jsexport function sum(a, b) {  return a + b;}if (process.env.NODE_ENV === 'test') {  test('sum', () => {    expect(sum(1, 2)).toBe(3);  });}
You can collect coverage from those files with setting forceCoverageMatch.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  forceCoverageMatch: ['**/*.t.js'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  forceCoverageMatch: ['**/*.t.js'],};export default config;
globals [object]​
Default: {}
A set of global variables that need to be available in all test environments.
For example, the following would create a global __DEV__ variable set to true in all test environments:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  globals: {    __DEV__: true,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  globals: {    __DEV__: true,  },};export default config;
noteIf you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will not be persisted across test runs for other test files. In addition, the globals object must be json-serializable, so it can't be used to specify global functions. For that, you should use setupFiles.
globalSetup [string]​
Default: undefined
This option allows the use of a custom global setup module, which must export a function (it can be sync or async). The function will be triggered once before all test suites and it will receive two arguments: Jest's globalConfig and projectConfig.
infoA global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.Any global variables that are defined through globalSetup can only be read in globalTeardown. You cannot retrieve globals defined here in your test suites.While code transformation is applied to the linked setup-file, Jest will not transform any code in node_modules. This is due to the need to load the actual transformers (e.g. babel or typescript) to perform transformation.
setup.jsmodule.exports = async function (globalConfig, projectConfig) {  console.log(globalConfig.testPathPattern);  console.log(projectConfig.cache);  // Set reference to mongod in order to close the server during teardown.  globalThis.__MONGOD__ = mongod;};
teardown.jsmodule.exports = async function (globalConfig, projectConfig) {  console.log(globalConfig.testPathPattern);  console.log(projectConfig.cache);  await globalThis.__MONGOD__.stop();};
globalTeardown [string]​
Default: undefined
This option allows the use of a custom global teardown module which must export a function (it can be sync or async). The function will be triggered once after all test suites and it will receive two arguments: Jest's globalConfig and projectConfig.
infoA global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.The same caveat concerning transformation of node_modules as for globalSetup applies to globalTeardown.
haste [object]​
Default: undefined
This will be used to configure the behavior of jest-haste-map, Jest's internal file crawler/cache system. The following options are supported:
type HasteConfig = {  /** Whether to hash files using SHA-1. */  computeSha1?: boolean;  /** The platform to use as the default, e.g. 'ios'. */  defaultPlatform?: string | null;  /** Force use of Node's `fs` APIs rather than shelling out to `find` */  forceNodeFilesystemAPI?: boolean;  /**   * Whether to follow symlinks when crawling for files.   *   This options cannot be used in projects which use watchman.   *   Projects with `watchman` set to true will error if this option is set to true.   */  enableSymlinks?: boolean;  /** Path to a custom implementation of Haste. */  hasteImplModulePath?: string;  /** All platforms to target, e.g ['ios', 'android']. */  platforms?: Array<string>;  /** Whether to throw an error on module collision. */  throwOnModuleCollision?: boolean;  /** Custom HasteMap module */  hasteMapModulePath?: string;  /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */  retainAllFiles?: boolean;};
injectGlobals [boolean]​
Default: true
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
maxConcurrency [number]​
Default: 5
A number limiting the number of tests that are allowed to run at the same time when using test.concurrent. Any test above this limit will be queued and executed once a slot is released.
maxWorkers [number | string]​
Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  maxWorkers: '50%',};module.exports = config;import type {Config} from 'jest';const config: Config = {  maxWorkers: '50%',};export default config;
moduleDirectories [array<string>]​
Default: ["node_modules"]
An array of directory names to be searched recursively up from the requiring module's location. Setting this option will override the default, if you wish to still search node_modules for packages include it along with any other options:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  moduleDirectories: ['node_modules', 'bower_components'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  moduleDirectories: ['node_modules', 'bower_components'],};export default config;
cautionIt is discouraged to use '.' as one of the moduleDirectories, because this prevents scoped packages such as @emotion/react from accessing packages with the same subdirectory name (react). See this issue for more details. In most cases, it is preferable to use the moduleNameMapper configuration instead.
moduleFileExtensions [array<string>]​
Default: ["js", "mjs", "cjs", "jsx", "ts", "tsx", "json", "node"]
An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.
We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving "ts" and/or "tsx" to the beginning of the array.
moduleNameMapper [object<string, string | array<string>>]​
Default: null
A map from regular expressions to module names or to arrays of module names that allow to stub out resources, like images or styles with a single module.
Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.
Use <rootDir> string token to refer to rootDir value if you want to use file paths.
Additionally, you can substitute captured regex groups using numbered backreferences.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};export default config;
The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.
infoIf you provide module names without boundaries ^$ it may cause hard to spot errors. E.g. relay will replace all modules which contain relay as a substring in its name: relay, react-relay and graphql-relay will all be pointed to your stub.
modulePathIgnorePatterns [array<string>]​
Default: []
An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be require()-able in the test environment.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};export default config;
modulePaths [array<string>]​
Default: []
An alternative API to setting the NODE_PATH env variable, modulePaths is an array of absolute paths to additional locations to search when resolving modules. Use the <rootDir> string token to include the path to your project's root directory.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  modulePaths: ['<rootDir>/app/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  modulePaths: ['<rootDir>/app/'],};export default config;
notify [boolean]​
Default: false
Activates native OS notifications for test results. To display the notifications Jest needs node-notifier package, which must be installed additionally:
npmYarnpnpmnpm install --save-dev node-notifieryarn add --dev node-notifierpnpm add --save-dev node-notifier
tipOn macOS, remember to allow notifications from terminal-notifier under System Preferences > Notifications & Focus.On Windows, node-notifier creates a new start menu entry on the first use and not display the notification. Notifications will be properly displayed on subsequent runs.
notifyMode [string]​
Default: failure-change
Specifies notification mode. Requires notify: true.
Modes​

always: always send a notification.
failure: send a notification when tests fail.
success: send a notification when tests pass.
change: send a notification when the status changed.
success-change: send a notification when tests pass or once when it fails.
failure-change: send a notification when tests fail or once when it passes.

openHandlesTimeout [number]​
Default: 1000
Print a warning indicating that there are probable open handles if Jest does not exit cleanly this number of milliseconds after it completes. Use 0 to disable the warning.
preset [string]​
Default: undefined
A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a jest-preset.json, jest-preset.js, jest-preset.cjs or jest-preset.mjs file at the root.
For example, this preset foo-bar/jest-preset.js will be configured as follows:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  preset: 'foo-bar',};module.exports = config;import type {Config} from 'jest';const config: Config = {  preset: 'foo-bar',};export default config;
Presets may also be relative to filesystem paths:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  preset: './node_modules/foo-bar/jest-preset.js',};module.exports = config;import type {Config} from 'jest';const config: Config = {  preset: './node_modules/foo-bar/jest-preset.js',};export default config;
infoIf you also have specified rootDir, the resolution of this file will be relative to that root directory.
prettierPath [string]​
Default: 'prettier'
Sets the path to the prettier node module used to update inline snapshots.
Prettier version 3 is not supported!You can either pass prettierPath: null in your config to disable using prettier if you don't need it, or use v2 of Prettier solely for Jest.package.json{  "devDependencies": {    "prettier-2": "npm:prettier@^2"  }}JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  prettierPath: require.resolve('prettier-2'),};module.exports = config;import type {Config} from 'jest';const config: Config = {  prettierPath: require.resolve('prettier-2'),};export default config;We hope to support Prettier v3 seamlessly out of the box in a future version of Jest. See this tracking issue.
projects [array<string | ProjectConfig>]​
Default: undefined
When the projects configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};export default config;
This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.
The projects feature can also be used to run multiple configurations or multiple runners. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via jest-runner-eslint) in the same invocation of Jest:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};export default config;
tipWhen using multi-project runner, it's recommended to add a displayName for each project. This will show the displayName of a project next to its tests.
noteWith the projects option enabled, Jest will copy the root-level configuration options to each individual child configuration during the test run, resolving its values in the child's context. This means that string tokens like <rootDir> will point to the child's root directory even if they are defined in the root-level configuration.
randomize [boolean]​
Default: false
The equivalent of the --randomize flag to randomize the order of the tests in a file.
reporters [array<moduleName | [moduleName, options]>]​
Default: undefined
Use this configuration option to add reporters to Jest. It must be a list of reporter names, additional options can be passed to a reporter using the tuple form:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};export default config;
Default Reporter​
If custom reporters are specified, the default Jest reporter will be overridden. If you wish to keep it, 'default' must be passed as a reporters name:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};export default config;
GitHub Actions Reporter​
If included in the list, the built-in GitHub Actions Reporter will annotate changed files with test failure messages and (if used with 'silent: false') print logs with github group features for easy navigation. Note that 'default' should not be used in this case as 'github-actions' will handle that already, so remember to also include 'summary'. If you wish to use it only for annotations simply leave only the reporter without options as the default value of 'silent' is 'true':
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [['github-actions', {silent: false}], 'summary'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [['github-actions', {silent: false}], 'summary'],};export default config;
Summary Reporter​
Summary reporter prints out summary of all tests. It is a part of default reporter, hence it will be enabled if 'default' is included in the list. For instance, you might want to use it as stand-alone reporter instead of the default one, or together with Silent Reporter:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: ['jest-silent-reporter', 'summary'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: ['jest-silent-reporter', 'summary'],};export default config;
The summary reporter accepts options. Since it is included in the default reporter you may also pass the options there.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [['default', {summaryThreshold: 10}]],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [['default', {summaryThreshold: 10}]],};export default config;
The summaryThreshold option behaves in the following way, if the total number of test suites surpasses this threshold, a detailed summary of all failed tests will be printed after executing all the tests. It defaults to 20.
Custom Reporters​
tipHungry for reporters? Take a look at long list of awesome reporters from Awesome Jest.
Custom reporter module must export a class that takes globalConfig, reporterOptions and reporterContext as constructor arguments:
custom-reporter.jsclass CustomReporter {  constructor(globalConfig, reporterOptions, reporterContext) {    this._globalConfig = globalConfig;    this._options = reporterOptions;    this._context = reporterContext;  }  onRunComplete(testContexts, results) {    console.log('Custom reporter output:');    console.log('global config:', this._globalConfig);    console.log('options for this reporter from Jest config:', this._options);    console.log('reporter context passed from test scheduler:', this._context);  }  // Optionally, reporters can force Jest to exit with non zero code by returning  // an `Error` from `getLastError()` method.  getLastError() {    if (this._shouldFail) {      return new Error('Custom error reported!');    }  }}module.exports = CustomReporter;
noteFor the full list of hooks and argument types see the Reporter interface in packages/jest-reporters/src/types.ts.
resetMocks [boolean]​
Default: false
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
resetModules [boolean]​
Default: false
By default, each test file gets its own independent module registry. Enabling resetModules goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that the local module state doesn't conflict between tests. This can be done programmatically using jest.resetModules().
resolver [string]​
Default: undefined
This option allows the use of a custom resolver. This resolver must be a module that exports either:

a function expecting a string as the first argument for the path to resolve and an options object as the second argument. The function should either return a path to the module that should be resolved or throw an error if the module can't be found. or
an object containing async and/or sync properties. The sync property should be a function with the shape explained above, and the async property should also be a function that accepts the same arguments, but returns a promise which resolves with the path to the module or rejects with an error.

The options object provided to resolvers has the shape:
type ResolverOptions = {  /** Directory to begin resolving from. */  basedir: string;  /** List of export conditions. */  conditions?: Array<string>;  /** Instance of default resolver. */  defaultResolver: (path: string, options: ResolverOptions) => string;  /** List of file extensions to search in order. */  extensions?: Array<string>;  /** List of directory names to be looked up for modules recursively. */  moduleDirectory?: Array<string>;  /** List of `require.paths` to use if nothing is found in `node_modules`. */  paths?: Array<string>;  /** Allows transforming parsed `package.json` contents. */  packageFilter?: (pkg: PackageJSON, file: string, dir: string) => PackageJSON;  /** Allows transforms a path within a package. */  pathFilter?: (pkg: PackageJSON, path: string, relativePath: string) => string;  /** Current root directory. */  rootDir?: string;};
tipThe defaultResolver passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom synchronous one, e.g. (path, options) and returns a string or throws.
For example, if you want to respect Browserify's "browser" field, you can use the following resolver:
resolver.jsconst browserResolve = require('browser-resolve');module.exports = browserResolve.sync;
And add it to Jest configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  resolver: '<rootDir>/resolver.js',};module.exports = config;import type {Config} from 'jest';const config: Config = {  resolver: '<rootDir>/resolver.js',};export default config;
By combining defaultResolver and packageFilter we can implement a package.json "pre-processor" that allows us to change how the default resolver will resolve modules. For example, imagine we want to use the field "module" if it is present, otherwise fallback to "main":
module.exports = (path, options) => {  // Call the defaultResolver, so we leverage its cache, error handling, etc.  return options.defaultResolver(path, {    ...options,    // Use packageFilter to process parsed `package.json` before the resolution (see https://www.npmjs.com/package/resolve#resolveid-opts-cb)    packageFilter: pkg => {      return {        ...pkg,        // Alter the value of `main` before resolving the package        main: pkg.module || pkg.main,      };    },  });};
restoreMocks [boolean]​
Default: false
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
rootDir [string]​
Default: The root of the directory containing your Jest config file or the package.json or the pwd if no package.json is found
The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your package.json and want the root directory to be the root of your repo, the value for this config param will default to the directory of the package.json.
Oftentimes, you'll want to set this to 'src' or 'lib', corresponding to where in your repository the code is stored.
tipUsing '<rootDir>' as a string token in any other path-based configuration settings will refer back to this value. For example, if you want a setupFiles entry to point at the some-setup.js file at the root of the project, set its value to: '<rootDir>/some-setup.js'.
roots [array<string>]​
Default: ["<rootDir>"]
A list of paths to directories that Jest should use to search for files in.
There are times where you only want Jest to search in a single sub-directory (such as cases where you have a src/ directory in your repo), but prevent it from accessing the rest of the repo.
infoWhile rootDir is mostly used as a token to be re-used in other configuration options, roots is used by the internals of Jest to locate test files and source files. This applies also when searching for manual mocks for modules from node_modules (__mocks__ will need to live in one of the roots).By default, roots has a single entry <rootDir> but there are cases where you may want to have multiple roots within one project, for example roots: ["<rootDir>/src/", "<rootDir>/tests/"].
runner [string]​
Default: "jest-runner"
This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:

jest-runner-eslint
jest-runner-mocha
jest-runner-tsc
jest-runner-prettier

infoThe runner property value can omit the jest-runner- prefix of the package name.
To write a test-runner, export a class with which accepts globalConfig in the constructor, and has a runTests method with the signature:
async function runTests(  tests: Array<Test>,  watcher: TestWatcher,  onStart: OnTestStart,  onResult: OnTestSuccess,  onFailure: OnTestFailure,  options: TestRunnerOptions,): Promise<void>;
If you need to restrict your test-runner to only run in serial rather than being executed in parallel your class should have the property isSerial to be set as true.
sandboxInjectedGlobals [array<string>]​
tipRenamed from extraGlobals in Jest 28.
Default: undefined
Test files run inside a vm, which slows calls to global context properties (e.g. Math). With this option you can specify extra properties to be defined inside the vm for faster lookups.
For example, if your tests call Math often, you can pass it by setting sandboxInjectedGlobals.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  sandboxInjectedGlobals: ['Math'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  sandboxInjectedGlobals: ['Math'],};export default config;
noteThis option has no effect if you use native ESM.
setupFiles [array]​
Default: []
A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment before executing setupFilesAfterEnv and before the test code itself.
tipIf your setup script is a CJS module, it may export an async function. Jest will call the function and await its result. This might be useful to fetch some data asynchronously. If the file is an ESM module, simply use top-level await to achieve the same result.
setupFilesAfterEnv [array]​
Default: []
A list of paths to modules that run some code to configure or set up the testing framework before each test file in the suite is executed. Since setupFiles executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment but before the test code itself.
In other words, setupFilesAfterEnv modules are meant for code which is repeating in each test file. Having the test framework installed makes Jest globals, jest object and expect accessible in the modules. For example, you can add extra matchers from jest-extended library or call setup and teardown hooks:
setup-jest.jsconst matchers = require('jest-extended');expect.extend(matchers);afterEach(() => {  jest.useRealTimers();});
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};export default config;
showSeed [boolean]​
Default: false
The equivalent of the --showSeed flag to print the seed in the test report summary.
slowTestThreshold [number]​
Default: 5
The number of seconds after which a test is considered as slow and reported as such in the results.
snapshotFormat [object]​
Default: {escapeString: false, printBasicPrototype: false}
Allows overriding specific snapshot formatting options documented in the pretty-format readme, with the exceptions of compareKeys and plugins. For example, this config would have the snapshot formatter not print a prefix for "Object" and "Array":
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  snapshotFormat: {    printBasicPrototype: false,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  snapshotFormat: {    printBasicPrototype: false,  },};export default config;
some.test.jstest('does not show prototypes for object and array inline', () => {  const object = {    array: [{hello: 'Danger'}],  };  expect(object).toMatchInlineSnapshot(`    {      "array": [        {          "hello": "Danger",        },      ],    }  `);});
snapshotResolver [string]​
Default: undefined
The path to a module that can resolve test<->snapshot path. This config option lets you customize where Jest stores snapshot files on disk.
custom-resolver.jsmodule.exports = {  // resolves from test to snapshot path  resolveSnapshotPath: (testPath, snapshotExtension) =>    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,  // resolves from snapshot to test path  resolveTestPath: (snapshotFilePath, snapshotExtension) =>    snapshotFilePath      .replace('__snapshots__', '__tests__')      .slice(0, -snapshotExtension.length),  // Example test path, used for preflight consistency check of the implementation above  testPathForConsistencyCheck: 'some/__tests__/example.test.js',};
snapshotSerializers [array<string>]​
Default: []
A list of paths to snapshot serializer modules Jest should use for snapshot testing.
Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See snapshot test tutorial for more information.
custom-serializer.jsmodule.exports = {  serialize(val, config, indentation, depth, refs, printer) {    return `Pretty foo: ${printer(val.foo)}`;  },  test(val) {    return val && Object.prototype.hasOwnProperty.call(val, 'foo');  },};
printer is a function that serializes a value using existing plugins.
Add custom-serializer to your Jest configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};export default config;
Finally tests would look as follows:
test(() => {  const bar = {    foo: {      x: 1,      y: 2,    },  };  expect(bar).toMatchSnapshot();});
Rendered snapshot:
Pretty foo: Object {  "x": 1,  "y": 2,}
tipTo make a dependency explicit instead of implicit, you can call expect.addSnapshotSerializer to add a module for an individual test file instead of adding its path to snapshotSerializers in Jest configuration.More about serializers API can be found here.
testEnvironment [string]​
Default: "node"
The test environment that will be used for testing. The default environment in Jest is a Node.js environment. If you are building a web app, you can use a browser-like environment through jsdom instead.
By adding a @jest-environment docblock at the top of the file, you can specify another environment to be used for all tests in that file:
/** * @jest-environment jsdom */test('use jsdom in this test file', () => {  const element = document.createElement('div');  expect(element).not.toBeNull();});
You can create your own module that will be used for setting up the test environment. The module must export a class with setup, teardown and getVmContext methods. You can also pass variables from this module to your test suites by assigning them to this.global object – this will make them available in your test suites as global variables. The constructor is passed globalConfig and projectConfig as its first argument, and testEnvironmentContext as its second.
The class may optionally expose an asynchronous handleTestEvent method to bind to events fired by jest-circus. Normally, jest-circus test runner would pause until a promise returned from handleTestEvent gets fulfilled, except for the next events: start_describe_definition, finish_describe_definition, add_hook, add_test or error (for the up-to-date list you can look at SyncEvent type in the types definitions). That is caused by backward compatibility reasons and process.on('unhandledRejection', callback) signature, but that usually should not be a problem for most of the use cases.
Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with its value set to an empty string. If the pragma is not present, it will not be present in the object.
To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in my-custom-environment.js in some subfolder of your project, then the annotation might look like this:
/** * @jest-environment ./src/test/my-custom-environment */
infoTestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.
Example:
// my-custom-environmentconst NodeEnvironment = require('jest-environment-node').TestEnvironment;class CustomEnvironment extends NodeEnvironment {  constructor(config, context) {    super(config, context);    console.log(config.globalConfig);    console.log(config.projectConfig);    this.testPath = context.testPath;    this.docblockPragmas = context.docblockPragmas;  }  async setup() {    await super.setup();    await someSetupTasks(this.testPath);    this.global.someGlobalObject = createGlobalObject();    // Will trigger if docblock contains @my-custom-pragma my-pragma-value    if (this.docblockPragmas['my-custom-pragma'] === 'my-pragma-value') {      // ...    }  }  async teardown() {    this.global.someGlobalObject = destroyGlobalObject();    await someTeardownTasks();    await super.teardown();  }  getVmContext() {    return super.getVmContext();  }  async handleTestEvent(event, state) {    if (event.name === 'test_start') {      // ...    }  }}module.exports = CustomEnvironment;
// my-test-suite/** * @jest-environment ./my-custom-environment */let someGlobalObject;beforeAll(() => {  someGlobalObject = globalThis.someGlobalObject;});
testEnvironmentOptions [Object]​
Default: {}
Test environment options that will be passed to the testEnvironment. The relevant options depend on the environment.
For example, you can override options passed to jsdom:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};export default config;
Both jest-environment-jsdom and jest-environment-node allow specifying customExportConditions, which allow you to control which versions of a library are loaded from exports in package.json. jest-environment-jsdom defaults to ['browser']. jest-environment-node defaults to ['node', 'node-addons'].
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    customExportConditions: ['react-native'],  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    customExportConditions: ['react-native'],  },};export default config;
These options can also be passed in a docblock, similar to testEnvironment. The string with options must be parseable by JSON.parse:
/** * @jest-environment jsdom * @jest-environment-options {"url": "https://jestjs.io/"} */test('use jsdom and set the URL in this test file', () => {  expect(window.location.href).toBe('https://jestjs.io/');});
testFailureExitCode [number]​
Default: 1
The exit code Jest returns on test failure.
infoThis does not change the exit code in the case of Jest errors (e.g. invalid configuration).
testMatch [array<string>]​
(default: [ "**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)" ])
The glob patterns Jest uses to detect test files. By default it looks for .js, .jsx, .ts and .tsx files inside of __tests__ folders, as well as any files with a suffix of .test or .spec (e.g. Component.test.js or Component.spec.js). It will also find files called test.js or spec.js.
See the micromatch package for details of the patterns you can specify.
See also testRegex [string | array<string>], but note that you cannot specify both options.
tipEach glob pattern is applied in the order they are specified in the config. For example ["!**/__fixtures__/**", "**/__tests__/**/*.js"] will not exclude __fixtures__ because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after **/__tests__/**/*.js.
testPathIgnorePatterns [array<string>]​
Default: ["/node_modules/"]
An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: ["<rootDir>/build/", "<rootDir>/node_modules/"].
testRegex [string | array<string>]​
Default: (/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$
The pattern or patterns Jest uses to detect test files. By default it looks for .js, .jsx, .ts and .tsx files inside of __tests__ folders, as well as any files with a suffix of .test or .spec (e.g. Component.test.js or Component.spec.js). It will also find files called test.js or spec.js. See also testMatch [array<string>], but note that you cannot specify both options.
The following is a visualization of the default regex:
├── __tests__│   └── component.spec.js # test│   └── anything # test├── package.json # not test├── foo.test.js # test├── bar.spec.jsx # test└── component.js # not test
infotestRegex will try to detect test files using the absolute file path, therefore, having a folder with a name that matches it will run all the files as tests.
testResultsProcessor [string]​
Default: undefined
This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:
{  "success": boolean,  "startTime": epoch,  "numTotalTestSuites": number,  "numPassedTestSuites": number,  "numFailedTestSuites": number,  "numRuntimeErrorTestSuites": number,  "numTotalTests": number,  "numPassedTests": number,  "numFailedTests": number,  "numPendingTests": number,  "numTodoTests": number,  "openHandles": Array<Error>,  "testResults": [{    "numFailingTests": number,    "numPassingTests": number,    "numPendingTests": number,    "testResults": [{      "title": string (message in it block),      "status": "failed" | "pending" | "passed",      "ancestorTitles": [string (message in describe blocks)],      "failureMessages": [string],      "numPassingAsserts": number,      "location": {        "column": number,        "line": number      },      "duration": number | null    },    ...    ],    "perfStats": {      "start": epoch,      "end": epoch    },    "testFilePath": absolute path to test file,    "coverage": {}  },  "testExecError:" (exists if there was a top-level failure) {    "message": string    "stack": string  }  ...  ]}
testResultsProcessor and reporters are very similar to each other. One difference is that a test result processor only gets called after all tests finished. Whereas a reporter has the ability to receive test results after individual tests and/or test suites are finished.
testRunner [string]​
Default: jest-circus/runner
This option allows the use of a custom test runner. The default is jest-circus. A custom test runner can be provided by specifying a path to a test runner implementation.
The test runner module must export a function with the following signature:
function testRunner(  globalConfig: GlobalConfig,  config: ProjectConfig,  environment: Environment,  runtime: Runtime,  testPath: string,): Promise<TestResult>;
An example of such function can be found in our default jasmine2 test runner package.
testSequencer [string]​
Default: @jest/test-sequencer
This option allows you to use a custom sequencer instead of Jest's default.
tipBoth sort and shard may optionally return a Promise.
For example, you may sort test paths alphabetically:
custom-sequencer.jsconst Sequencer = require('@jest/test-sequencer').default;class CustomSequencer extends Sequencer {  /**   * Select tests for shard requested via --shard=shardIndex/shardCount   * Sharding is applied before sorting   */  shard(tests, {shardIndex, shardCount}) {    const shardSize = Math.ceil(tests.length / shardCount);    const shardStart = shardSize * (shardIndex - 1);    const shardEnd = shardSize * shardIndex;    return [...tests]      .sort((a, b) => (a.path > b.path ? 1 : -1))      .slice(shardStart, shardEnd);  }  /**   * Sort test to determine order of execution   * Sorting is applied after sharding   */  sort(tests) {    // Test structure information    // https://github.com/jestjs/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21    const copyTests = [...tests];    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));  }}module.exports = CustomSequencer;
Add custom-sequencer to your Jest configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  testSequencer: 'path/to/custom-sequencer.js',};module.exports = config;import type {Config} from 'jest';const config: Config = {  testSequencer: 'path/to/custom-sequencer.js',};export default config;
testTimeout [number]​
Default: 5000
Default timeout of a test in milliseconds.
transform [object<string, pathToTransformer | [pathToTransformer, object]>]​
Default: {"\\.[jt]sx?$": "babel-jest"}
A map from regular expressions to paths to transformers. Optionally, a tuple with configuration options can be passed as second argument: {filePattern: ['path-to-transformer', {options}]}. For example, here is how you can configure babel-jest for non-default behavior: {'\\.js$': ['babel-jest', {rootMode: 'upward'}]}.
Jest runs the code of your project as JavaScript, hence a transformer is needed if you use some syntax not supported by Node out of the box (such as JSX, TypeScript, Vue templates). By default, Jest will use babel-jest transformer, which will load your project's Babel configuration and transform any file matching the /\.[jt]sx?$/ RegExp (in other words, any .js, .jsx, .ts or .tsx file). In addition, babel-jest will inject the Babel plugin necessary for mock hoisting talked about in ES Module mocking.
See the Code Transformation section for more details and instructions on building your own transformer.
tipKeep in mind that a transformer only runs once per file unless the file has changed.Remember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors:JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};export default config;
transformIgnorePatterns [array<string>]​
Default: ["/node_modules/", "\\.pnp\\.[^\\\/]+$"]
An array of regexp pattern strings that are matched against all source file paths before transformation. If the file path matches any of the patterns, it will not be transformed.
Providing regexp patterns that overlap with each other may result in files not being transformed that you expected to be transformed. For example:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],};export default config;
The first pattern will match (and therefore not transform) files inside /node_modules except for those in /node_modules/foo/ and /node_modules/bar/. The second pattern will match (and therefore not transform) files inside any path with /bar/ in it. With the two together, files in /node_modules/bar/ will not be transformed because it does match the second pattern, even though it was excluded by the first.
Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled code. Since all files inside node_modules are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use transformIgnorePatterns to allow transpiling such modules. You'll find a good example of this use case in React Native Guide.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};export default config;
tipIf you use pnpm and need to convert some packages under node_modules, you need to note that the packages in this folder (e.g. node_modules/package-a/) have been symlinked to the path under .pnpm (e.g. node_modules/.pnpm/[email protected]/node_modules/package-a/), so using <rootDir>/node_modules/(?!(package-a|@scope/pkg-b)/) directly will not be recognized, while is to use:JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative pattern to match the second 'node_modules/' in 'node_modules/.pnpm/@[email protected]/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative path to match the second 'node_modules/' in 'node_modules/.pnpm/@[email protected]/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};export default config;It should be noted that the folder name of pnpm under .pnpm is the package name plus @ and version number, so writing / will not be recognized, but using @ can.
unmockedModulePathPatterns [array<string>]​
Default: []
An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.
This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore, lodash, etc). It's generally a best practice to keep this list as small as possible and always use explicit jest.mock()/jest.unmock() calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.
It is possible to override this setting in individual tests by explicitly calling jest.mock() at the top of the test file.
verbose [boolean]​
Default: false or true if there is only one test file to run
Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution.
watchPathIgnorePatterns [array<string>]​
Default: []
An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.
These patterns match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: ["<rootDir>/node_modules/"].
Even if nothing is specified here, the watcher will ignore changes to the version control folders (.git, .hg, .sl). Other hidden files and directories, i.e. those that begin with a dot (.), are watched by default. Remember to escape the dot when you add them to watchPathIgnorePatterns as it is a special RegExp character.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};export default config;
watchPlugins [array<string | [string, Object]>]​
Default: []
This option allows you to use custom watch plugins. Read more about watch plugins here.
Examples of watch plugins include:

jest-watch-master
jest-watch-select-projects
jest-watch-suspend
jest-watch-typeahead
jest-watch-yarn-workspaces

infoThe values in the watchPlugins property value can omit the jest-watch- prefix of the package name.
watchman [boolean]​
Default: true
Whether to use watchman for file crawling.
workerIdleMemoryLimit [number|string]​
Default: undefined
Specifies the memory limit for workers before they are recycled and is primarily a work-around for this issue;
After the worker has executed a test the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. The limit can be specified in a number of different ways and whatever the result is Math.floor is used to turn it into an integer value:

<= 1 - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory
\> 1 - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use 1.1.
With units

50% - As above, a percentage of total system memory
100KB, 65MB, etc - With units to denote a fixed memory limit.

K / KB - Kilobytes (x1000)
KiB - Kibibytes (x1024)
M / MB - Megabytes
MiB - Mebibytes
G / GB - Gigabytes
GiB - Gibibytes





cautionPercentage based memory limit does not work on Linux CircleCI workers due to incorrect system memory being reported.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  workerIdleMemoryLimit: 0.2,};module.exports = config;import type {Config} from 'jest';const config: Config = {  workerIdleMemoryLimit: 0.2,};export default config;
// [string]​
This option allows comments in package.json. Include the comment text as the value of this key:
package.json{  "name": "my-project",  "jest": {    "//": "Comment goes here",    "verbose": true  }}
workerThreads​
Default: false
Whether to use worker threads for parallelization. Child processes are used by default.
Using worker threads may help to improve performance.
cautionThis is experimental feature. Keep in mind that the worker threads use structured clone instead of JSON.stringify() to serialize messages. This means that built-in JavaScript objects as BigInt, Map or Set will get serialized properly. However extra properties set on Error, Map or Set will not be passed on through the serialization step. For more details see the article on structured clone.Edit this pageLast updated on Jan 16, 2025 by Edwin Kofler\n\nConfiguring JestVersion: 29.7On this pageConfiguring JestThe Jest philosophy is to work great by default, but sometimes you just need more configuration power.
It is recommended to define the configuration in a dedicated JavaScript, TypeScript or JSON file. The file will be discovered automatically, if it is named jest.config.js|ts|mjs|cjs|json. You can use --config flag to pass an explicit path to the file.
noteKeep in mind that the resulting configuration object must always be JSON-serializable.
The configuration file should simply export an object:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  verbose: true,};module.exports = config;import type {Config} from 'jest';const config: Config = {  verbose: true,};export default config;
Or a function returning an object:
JavaScriptTypeScript/** @returns {Promise<import('jest').Config>} */module.exports = async () => {  return {    verbose: true,  };};import type {Config} from 'jest';export default async (): Promise<Config> => {  return {    verbose: true,  };};
tipTo read TypeScript configuration files Jest requires ts-node. Make sure it is installed in your project.
The configuration also can be stored in a JSON file as a plain object:
jest.config.json{  "bail": 1,  "verbose": true}
Alternatively Jest's configuration can be defined through the "jest" key in the package.json of your project:
package.json{  "name": "my-project",  "jest": {    "verbose": true  }}
Options​
infoYou can retrieve Jest's defaults from jest-config to extend them if needed:JavaScriptTypeScriptconst {defaults} = require('jest-config');/** @type {import('jest').Config} */const config = {  moduleFileExtensions: [...defaults.moduleFileExtensions, 'mts', 'cts'],};module.exports = config;import type {Config} from 'jest';import {defaults} from 'jest-config';const config: Config = {  moduleFileExtensions: [...defaults.moduleFileExtensions, 'mts'],};export default config;

automock [boolean]bail [number | boolean]cacheDirectory [string]clearMocks [boolean]collectCoverage [boolean]collectCoverageFrom [array]coverageDirectory [string]coveragePathIgnorePatterns [array<string>]coverageProvider [string]coverageReporters [array<string | [string, options]>]coverageThreshold [object]dependencyExtractor [string]displayName [string, object]errorOnDeprecated [boolean]extensionsToTreatAsEsm [array<string>]fakeTimers [object]forceCoverageMatch [array<string>]globals [object]globalSetup [string]globalTeardown [string]haste [object]injectGlobals [boolean]maxConcurrency [number]maxWorkers [number | string]moduleDirectories [array<string>]moduleFileExtensions [array<string>]moduleNameMapper [object<string, string | array<string>>]modulePathIgnorePatterns [array<string>]modulePaths [array<string>]notify [boolean]notifyMode [string]openHandlesTimeout [number]preset [string]prettierPath [string]projects [array<string | ProjectConfig>]randomize [boolean]reporters [array<moduleName | [moduleName, options]>]resetMocks [boolean]resetModules [boolean]resolver [string]restoreMocks [boolean]rootDir [string]roots [array<string>]runner [string]sandboxInjectedGlobals [array<string>]setupFiles [array]setupFilesAfterEnv [array]showSeed [boolean]slowTestThreshold [number]snapshotFormat [object]snapshotResolver [string]snapshotSerializers [array<string>]testEnvironment [string]testEnvironmentOptions [Object]testFailureExitCode [number]testMatch [array<string>]testPathIgnorePatterns [array<string>]testRegex [string | array<string>]testResultsProcessor [string]testRunner [string]testSequencer [string]testTimeout [number]transform [object<string, pathToTransformer | [pathToTransformer, object]>]transformIgnorePatterns [array<string>]unmockedModulePathPatterns [array<string>]verbose [boolean]watchPathIgnorePatterns [array<string>]watchPlugins [array<string | [string, Object]>]watchman [boolean]workerIdleMemoryLimit [number|string]// [string]workerThreads

Reference​
automock [boolean]​
Default: false
This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.
Example:
utils.jsexport default {  authorize: () => 'token',  isAuthorized: secret => secret === 'wizard',};
__tests__/automock.test.jsimport utils from '../utils';test('if utils mocked automatically', () => {  // Public methods of `utils` are now mock functions  expect(utils.authorize.mock).toBeTruthy();  expect(utils.isAuthorized.mock).toBeTruthy();  // You can provide them with your own implementation  // or pass the expected return value  utils.authorize.mockReturnValue('mocked_token');  utils.isAuthorized.mockReturnValue(true);  expect(utils.authorize()).toBe('mocked_token');  expect(utils.isAuthorized('not_wizard')).toBeTruthy();});
noteNode modules are automatically mocked when you have a manual mock in place (e.g.: __mocks__/lodash.js). More info here.Node.js core modules, like fs, are not mocked by default. They can be mocked explicitly, like jest.mock('fs').
bail [number | boolean]​
Default: 0
By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after n failures. Setting bail to true is the same as setting bail to 1.
cacheDirectory [string]​
Default: "/tmp/<path>"
The directory where Jest should store its cached dependency information.
Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem churn that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.
clearMocks [boolean]​
Default: false
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
collectCoverage [boolean]​
Default: false
Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.
Jest ships with two coverage providers: babel (default) and v8. See the coverageProvider option for more details.
infoThe babel and v8 coverage providers use /* istanbul ignore next */ and /* c8 ignore next */ comments to exclude lines from coverage reports, respectively. For more information, you can view the istanbuljs documentation and the c8 documentation.
collectCoverageFrom [array]​
Default: undefined
An array of glob patterns indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  collectCoverageFrom: [    '**/*.{js,jsx}',    '!**/node_modules/**',    '!**/vendor/**',  ],};export default config;
This will collect coverage information for all the files inside the project's rootDir, except the ones that match **/node_modules/** or **/vendor/**.
tipEach glob pattern is applied in the order they are specified in the config. For example ["!**/__tests__/**", "**/*.js"] will not exclude __tests__ because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after **/*.js.
noteThis option requires collectCoverage to be set to true or Jest to be invoked with --coverage.
Help:If you are seeing coverage output such as...=============================== Coverage summary ===============================Statements   : Unknown% ( 0/0 )Branches     : Unknown% ( 0/0 )Functions    : Unknown% ( 0/0 )Lines        : Unknown% ( 0/0 )================================================================================Jest: Coverage data for global was not found.Most likely your glob patterns are not matching any files. Refer to the micromatch documentation to ensure your globs are compatible.
coverageDirectory [string]​
Default: undefined
The directory where Jest should output its coverage files.
coveragePathIgnorePatterns [array<string>]​
Default: ["/node_modules/"]
An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: ["<rootDir>/build/", "<rootDir>/node_modules/"].
coverageProvider [string]​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
coverageReporters [array<string | [string, options]>]​
Default: ["clover", "json", "lcov", "text"]
A list of reporter names that Jest uses when writing coverage reports. Any istanbul reporter can be used.
tipSetting this option overwrites the default values. Add "text" or "text-summary" to see a coverage summary in the console output.
Additional options can be passed using the tuple form. For example, you may hide coverage report lines for all fully-covered files:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};module.exports = config;import type {Config} from 'jest';const config: Config = {  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],};export default config;
For more information about the options object shape refer to CoverageReporterWithOptions type in the type definitions.
coverageThreshold [object]​
Default: undefined
This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as global, as a glob, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.
For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 80,      functions: 80,      lines: 80,      statements: -10,    },  },};export default config;
If globs or paths are specified alongside global, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, an error is returned.
For example, with the following configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  coverageThreshold: {    global: {      branches: 50,      functions: 50,      lines: 50,      statements: 50,    },    './src/components/': {      branches: 40,      statements: 40,    },    './src/reducers/**/*.js': {      statements: 90,    },    './src/api/very-important-module.js': {      branches: 100,      functions: 100,      lines: 100,      statements: 100,    },  },};export default config;
Jest will fail if:

The ./src/components directory has less than 40% branch or statement coverage.
One of the files matching the ./src/reducers/**/*.js glob has less than 90% statement coverage.
The ./src/api/very-important-module.js file has less than 100% coverage.
Every remaining file combined has less than 50% coverage (global).

dependencyExtractor [string]​
Default: undefined
This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an extract function. E.g.:
const crypto = require('crypto');const fs = require('fs');module.exports = {  extract(code, filePath, defaultExtract) {    const deps = defaultExtract(code, filePath);    // Scan the file and add dependencies in `deps` (which is a `Set`)    return deps;  },  getCacheKey() {    return crypto      .createHash('md5')      .update(fs.readFileSync(__filename))      .digest('hex');  },};
The extract function should return an iterable (Array, Set, etc.) with the dependencies found in the code.
That module can also contain a getCacheKey function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.
displayName [string, object]​
default: undefined
Allows for a label to be printed alongside a test while it is running. This becomes more useful in multi-project repositories where there can be many jest configuration files. This visually tells which project a test belongs to.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  displayName: 'CLIENT',};module.exports = config;import type {Config} from 'jest';const config: Config = {  displayName: 'CLIENT',};export default config;
Alternatively, an object with the properties name and color can be passed. This allows for a custom configuration of the background color of the displayName. displayName defaults to white when its value is a string. Jest uses chalk to provide the color. As such, all of the valid options for colors supported by chalk are also supported by Jest.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  displayName: {    name: 'CLIENT',    color: 'blue',  },};export default config;
errorOnDeprecated [boolean]​
Default: false
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
extensionsToTreatAsEsm [array<string>]​
Default: []
Jest will run .mjs and .js files with nearest package.json's type field set to module as ECMAScript Modules. If you have any other files that should run with native ESM, you need to specify their file extension here.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  extensionsToTreatAsEsm: ['.ts'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  extensionsToTreatAsEsm: ['.ts'],};export default config;
cautionJest's ESM support is still experimental, see its docs for more details.
fakeTimers [object]​
Default: {}
The fake timers may be useful when a piece of code sets a long timeout that we don't want to wait for in a test. For additional details see Fake Timers guide and API documentation.
This option provides the default configuration of fake timers for all tests. Calling jest.useFakeTimers() in a test file will use these options or will override them if a configuration object is passed. For example, you can tell Jest to keep the original implementation of process.nextTick() and adjust the limit of recursive timers that will be run:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  fakeTimers: {    doNotFake: ['nextTick'],    timerLimit: 1000,  },};export default config;
fakeTime.test.js// install fake timers for this file using the options from Jest configurationjest.useFakeTimers();test('increase the limit of recursive timers for this and following tests', () => {  jest.useFakeTimers({timerLimit: 5000});  // ...});
tipInstead of including jest.useFakeTimers() in each test file, you can enable fake timers globally for all tests in your Jest configuration:JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,  },};export default config;
Configuration options:
type FakeableAPI =  | 'Date'  | 'hrtime'  | 'nextTick'  | 'performance'  | 'queueMicrotask'  | 'requestAnimationFrame'  | 'cancelAnimationFrame'  | 'requestIdleCallback'  | 'cancelIdleCallback'  | 'setImmediate'  | 'clearImmediate'  | 'setInterval'  | 'clearInterval'  | 'setTimeout'  | 'clearTimeout';type ModernFakeTimersConfig = {  /**   * If set to `true` all timers will be advanced automatically by 20 milliseconds   * every 20 milliseconds. A custom time delta may be provided by passing a number.   * The default is `false`.   */  advanceTimers?: boolean | number;  /**   * List of names of APIs that should not be faked. The default is `[]`, meaning   * all APIs are faked.   */  doNotFake?: Array<FakeableAPI>;  /** Whether fake timers should be enabled for all test files. The default is `false`. */  enableGlobally?: boolean;  /**   * Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.   * The default is `false`.   */  legacyFakeTimers?: boolean;  /** Sets current system time to be used by fake timers, in milliseconds. The default is `Date.now()`. */  now?: number;  /** Maximum number of recursive timers that will be run. The default is `100_000` timers. */  timerLimit?: number;};
Legacy Fake TimersFor some reason you might have to use legacy implementation of fake timers. Here is how to enable it globally (additional options are not supported):JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  fakeTimers: {    enableGlobally: true,    legacyFakeTimers: true,  },};export default config;
forceCoverageMatch [array<string>]​
Default: ['']
Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.
For example, if you have tests in source files named with .t.js extension as following:
sum.t.jsexport function sum(a, b) {  return a + b;}if (process.env.NODE_ENV === 'test') {  test('sum', () => {    expect(sum(1, 2)).toBe(3);  });}
You can collect coverage from those files with setting forceCoverageMatch.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  forceCoverageMatch: ['**/*.t.js'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  forceCoverageMatch: ['**/*.t.js'],};export default config;
globals [object]​
Default: {}
A set of global variables that need to be available in all test environments.
For example, the following would create a global __DEV__ variable set to true in all test environments:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  globals: {    __DEV__: true,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  globals: {    __DEV__: true,  },};export default config;
noteIf you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will not be persisted across test runs for other test files. In addition, the globals object must be json-serializable, so it can't be used to specify global functions. For that, you should use setupFiles.
globalSetup [string]​
Default: undefined
This option allows the use of a custom global setup module, which must export a function (it can be sync or async). The function will be triggered once before all test suites and it will receive two arguments: Jest's globalConfig and projectConfig.
infoA global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.Any global variables that are defined through globalSetup can only be read in globalTeardown. You cannot retrieve globals defined here in your test suites.While code transformation is applied to the linked setup-file, Jest will not transform any code in node_modules. This is due to the need to load the actual transformers (e.g. babel or typescript) to perform transformation.
setup.jsmodule.exports = async function (globalConfig, projectConfig) {  console.log(globalConfig.testPathPattern);  console.log(projectConfig.cache);  // Set reference to mongod in order to close the server during teardown.  globalThis.__MONGOD__ = mongod;};
teardown.jsmodule.exports = async function (globalConfig, projectConfig) {  console.log(globalConfig.testPathPattern);  console.log(projectConfig.cache);  await globalThis.__MONGOD__.stop();};
globalTeardown [string]​
Default: undefined
This option allows the use of a custom global teardown module which must export a function (it can be sync or async). The function will be triggered once after all test suites and it will receive two arguments: Jest's globalConfig and projectConfig.
infoA global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.The same caveat concerning transformation of node_modules as for globalSetup applies to globalTeardown.
haste [object]​
Default: undefined
This will be used to configure the behavior of jest-haste-map, Jest's internal file crawler/cache system. The following options are supported:
type HasteConfig = {  /** Whether to hash files using SHA-1. */  computeSha1?: boolean;  /** The platform to use as the default, e.g. 'ios'. */  defaultPlatform?: string | null;  /** Force use of Node's `fs` APIs rather than shelling out to `find` */  forceNodeFilesystemAPI?: boolean;  /**   * Whether to follow symlinks when crawling for files.   *   This options cannot be used in projects which use watchman.   *   Projects with `watchman` set to true will error if this option is set to true.   */  enableSymlinks?: boolean;  /** Path to a custom implementation of Haste. */  hasteImplModulePath?: string;  /** All platforms to target, e.g ['ios', 'android']. */  platforms?: Array<string>;  /** Whether to throw an error on module collision. */  throwOnModuleCollision?: boolean;  /** Custom HasteMap module */  hasteMapModulePath?: string;  /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */  retainAllFiles?: boolean;};
injectGlobals [boolean]​
Default: true
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
maxConcurrency [number]​
Default: 5
A number limiting the number of tests that are allowed to run at the same time when using test.concurrent. Any test above this limit will be queued and executed once a slot is released.
maxWorkers [number | string]​
Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  maxWorkers: '50%',};module.exports = config;import type {Config} from 'jest';const config: Config = {  maxWorkers: '50%',};export default config;
moduleDirectories [array<string>]​
Default: ["node_modules"]
An array of directory names to be searched recursively up from the requiring module's location. Setting this option will override the default, if you wish to still search node_modules for packages include it along with any other options:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  moduleDirectories: ['node_modules', 'bower_components'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  moduleDirectories: ['node_modules', 'bower_components'],};export default config;
cautionIt is discouraged to use '.' as one of the moduleDirectories, because this prevents scoped packages such as @emotion/react from accessing packages with the same subdirectory name (react). See this issue for more details. In most cases, it is preferable to use the moduleNameMapper configuration instead.
moduleFileExtensions [array<string>]​
Default: ["js", "mjs", "cjs", "jsx", "ts", "tsx", "json", "node"]
An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.
We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving "ts" and/or "tsx" to the beginning of the array.
moduleNameMapper [object<string, string | array<string>>]​
Default: null
A map from regular expressions to module names or to arrays of module names that allow to stub out resources, like images or styles with a single module.
Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.
Use <rootDir> string token to refer to rootDir value if you want to use file paths.
Additionally, you can substitute captured regex groups using numbered backreferences.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  moduleNameMapper: {    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',    '^[./a-zA-Z0-9$_-]+\\.png$': '<rootDir>/RelativeImageStub.js',    'module_name_(.*)': '<rootDir>/substituted_module_$1.js',    'assets/(.*)': [      '<rootDir>/images/$1',      '<rootDir>/photos/$1',      '<rootDir>/recipes/$1',    ],  },};export default config;
The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.
infoIf you provide module names without boundaries ^$ it may cause hard to spot errors. E.g. relay will replace all modules which contain relay as a substring in its name: relay, react-relay and graphql-relay will all be pointed to your stub.
modulePathIgnorePatterns [array<string>]​
Default: []
An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be require()-able in the test environment.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  modulePathIgnorePatterns: ['<rootDir>/build/'],};export default config;
modulePaths [array<string>]​
Default: []
An alternative API to setting the NODE_PATH env variable, modulePaths is an array of absolute paths to additional locations to search when resolving modules. Use the <rootDir> string token to include the path to your project's root directory.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  modulePaths: ['<rootDir>/app/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  modulePaths: ['<rootDir>/app/'],};export default config;
notify [boolean]​
Default: false
Activates native OS notifications for test results. To display the notifications Jest needs node-notifier package, which must be installed additionally:
npmYarnpnpmnpm install --save-dev node-notifieryarn add --dev node-notifierpnpm add --save-dev node-notifier
tipOn macOS, remember to allow notifications from terminal-notifier under System Preferences > Notifications & Focus.On Windows, node-notifier creates a new start menu entry on the first use and not display the notification. Notifications will be properly displayed on subsequent runs.
notifyMode [string]​
Default: failure-change
Specifies notification mode. Requires notify: true.
Modes​

always: always send a notification.
failure: send a notification when tests fail.
success: send a notification when tests pass.
change: send a notification when the status changed.
success-change: send a notification when tests pass or once when it fails.
failure-change: send a notification when tests fail or once when it passes.

openHandlesTimeout [number]​
Default: 1000
Print a warning indicating that there are probable open handles if Jest does not exit cleanly this number of milliseconds after it completes. Use 0 to disable the warning.
preset [string]​
Default: undefined
A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a jest-preset.json, jest-preset.js, jest-preset.cjs or jest-preset.mjs file at the root.
For example, this preset foo-bar/jest-preset.js will be configured as follows:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  preset: 'foo-bar',};module.exports = config;import type {Config} from 'jest';const config: Config = {  preset: 'foo-bar',};export default config;
Presets may also be relative to filesystem paths:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  preset: './node_modules/foo-bar/jest-preset.js',};module.exports = config;import type {Config} from 'jest';const config: Config = {  preset: './node_modules/foo-bar/jest-preset.js',};export default config;
infoIf you also have specified rootDir, the resolution of this file will be relative to that root directory.
prettierPath [string]​
Default: 'prettier'
Sets the path to the prettier node module used to update inline snapshots.
Prettier version 3 is not supported!You can either pass prettierPath: null in your config to disable using prettier if you don't need it, or use v2 of Prettier solely for Jest.package.json{  "devDependencies": {    "prettier-2": "npm:prettier@^2"  }}JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  prettierPath: require.resolve('prettier-2'),};module.exports = config;import type {Config} from 'jest';const config: Config = {  prettierPath: require.resolve('prettier-2'),};export default config;We hope to support Prettier v3 seamlessly out of the box in a future version of Jest. See this tracking issue.
projects [array<string | ProjectConfig>]​
Default: undefined
When the projects configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  projects: ['<rootDir>', '<rootDir>/examples/*'],};export default config;
This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.
The projects feature can also be used to run multiple configurations or multiple runners. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via jest-runner-eslint) in the same invocation of Jest:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  projects: [    {      displayName: 'test',    },    {      displayName: 'lint',      runner: 'jest-runner-eslint',      testMatch: ['<rootDir>/**/*.js'],    },  ],};export default config;
tipWhen using multi-project runner, it's recommended to add a displayName for each project. This will show the displayName of a project next to its tests.
noteWith the projects option enabled, Jest will copy the root-level configuration options to each individual child configuration during the test run, resolving its values in the child's context. This means that string tokens like <rootDir> will point to the child's root directory even if they are defined in the root-level configuration.
randomize [boolean]​
Default: false
The equivalent of the --randomize flag to randomize the order of the tests in a file.
reporters [array<moduleName | [moduleName, options]>]​
Default: undefined
Use this configuration option to add reporters to Jest. It must be a list of reporter names, additional options can be passed to a reporter using the tuple form:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],  ],};export default config;
Default Reporter​
If custom reporters are specified, the default Jest reporter will be overridden. If you wish to keep it, 'default' must be passed as a reporters name:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [    'default',    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],  ],};export default config;
GitHub Actions Reporter​
If included in the list, the built-in GitHub Actions Reporter will annotate changed files with test failure messages and (if used with 'silent: false') print logs with github group features for easy navigation. Note that 'default' should not be used in this case as 'github-actions' will handle that already, so remember to also include 'summary'. If you wish to use it only for annotations simply leave only the reporter without options as the default value of 'silent' is 'true':
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [['github-actions', {silent: false}], 'summary'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [['github-actions', {silent: false}], 'summary'],};export default config;
Summary Reporter​
Summary reporter prints out summary of all tests. It is a part of default reporter, hence it will be enabled if 'default' is included in the list. For instance, you might want to use it as stand-alone reporter instead of the default one, or together with Silent Reporter:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: ['jest-silent-reporter', 'summary'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: ['jest-silent-reporter', 'summary'],};export default config;
The summary reporter accepts options. Since it is included in the default reporter you may also pass the options there.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  reporters: [['default', {summaryThreshold: 10}]],};module.exports = config;import type {Config} from 'jest';const config: Config = {  reporters: [['default', {summaryThreshold: 10}]],};export default config;
The summaryThreshold option behaves in the following way, if the total number of test suites surpasses this threshold, a detailed summary of all failed tests will be printed after executing all the tests. It defaults to 20.
Custom Reporters​
tipHungry for reporters? Take a look at long list of awesome reporters from Awesome Jest.
Custom reporter module must export a class that takes globalConfig, reporterOptions and reporterContext as constructor arguments:
custom-reporter.jsclass CustomReporter {  constructor(globalConfig, reporterOptions, reporterContext) {    this._globalConfig = globalConfig;    this._options = reporterOptions;    this._context = reporterContext;  }  onRunComplete(testContexts, results) {    console.log('Custom reporter output:');    console.log('global config:', this._globalConfig);    console.log('options for this reporter from Jest config:', this._options);    console.log('reporter context passed from test scheduler:', this._context);  }  // Optionally, reporters can force Jest to exit with non zero code by returning  // an `Error` from `getLastError()` method.  getLastError() {    if (this._shouldFail) {      return new Error('Custom error reported!');    }  }}module.exports = CustomReporter;
noteFor the full list of hooks and argument types see the Reporter interface in packages/jest-reporters/src/types.ts.
resetMocks [boolean]​
Default: false
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
resetModules [boolean]​
Default: false
By default, each test file gets its own independent module registry. Enabling resetModules goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that the local module state doesn't conflict between tests. This can be done programmatically using jest.resetModules().
resolver [string]​
Default: undefined
This option allows the use of a custom resolver. This resolver must be a module that exports either:

a function expecting a string as the first argument for the path to resolve and an options object as the second argument. The function should either return a path to the module that should be resolved or throw an error if the module can't be found. or
an object containing async and/or sync properties. The sync property should be a function with the shape explained above, and the async property should also be a function that accepts the same arguments, but returns a promise which resolves with the path to the module or rejects with an error.

The options object provided to resolvers has the shape:
type ResolverOptions = {  /** Directory to begin resolving from. */  basedir: string;  /** List of export conditions. */  conditions?: Array<string>;  /** Instance of default resolver. */  defaultResolver: (path: string, options: ResolverOptions) => string;  /** List of file extensions to search in order. */  extensions?: Array<string>;  /** List of directory names to be looked up for modules recursively. */  moduleDirectory?: Array<string>;  /** List of `require.paths` to use if nothing is found in `node_modules`. */  paths?: Array<string>;  /** Allows transforming parsed `package.json` contents. */  packageFilter?: (pkg: PackageJSON, file: string, dir: string) => PackageJSON;  /** Allows transforms a path within a package. */  pathFilter?: (pkg: PackageJSON, path: string, relativePath: string) => string;  /** Current root directory. */  rootDir?: string;};
tipThe defaultResolver passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom synchronous one, e.g. (path, options) and returns a string or throws.
For example, if you want to respect Browserify's "browser" field, you can use the following resolver:
resolver.jsconst browserResolve = require('browser-resolve');module.exports = browserResolve.sync;
And add it to Jest configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  resolver: '<rootDir>/resolver.js',};module.exports = config;import type {Config} from 'jest';const config: Config = {  resolver: '<rootDir>/resolver.js',};export default config;
By combining defaultResolver and packageFilter we can implement a package.json "pre-processor" that allows us to change how the default resolver will resolve modules. For example, imagine we want to use the field "module" if it is present, otherwise fallback to "main":
module.exports = (path, options) => {  // Call the defaultResolver, so we leverage its cache, error handling, etc.  return options.defaultResolver(path, {    ...options,    // Use packageFilter to process parsed `package.json` before the resolution (see https://www.npmjs.com/package/resolve#resolveid-opts-cb)    packageFilter: pkg => {      return {        ...pkg,        // Alter the value of `main` before resolving the package        main: pkg.module || pkg.main,      };    },  });};
restoreMocks [boolean]​
Default: false
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
rootDir [string]​
Default: The root of the directory containing your Jest config file or the package.json or the pwd if no package.json is found
The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your package.json and want the root directory to be the root of your repo, the value for this config param will default to the directory of the package.json.
Oftentimes, you'll want to set this to 'src' or 'lib', corresponding to where in your repository the code is stored.
tipUsing '<rootDir>' as a string token in any other path-based configuration settings will refer back to this value. For example, if you want a setupFiles entry to point at the some-setup.js file at the root of the project, set its value to: '<rootDir>/some-setup.js'.
roots [array<string>]​
Default: ["<rootDir>"]
A list of paths to directories that Jest should use to search for files in.
There are times where you only want Jest to search in a single sub-directory (such as cases where you have a src/ directory in your repo), but prevent it from accessing the rest of the repo.
infoWhile rootDir is mostly used as a token to be re-used in other configuration options, roots is used by the internals of Jest to locate test files and source files. This applies also when searching for manual mocks for modules from node_modules (__mocks__ will need to live in one of the roots).By default, roots has a single entry <rootDir> but there are cases where you may want to have multiple roots within one project, for example roots: ["<rootDir>/src/", "<rootDir>/tests/"].
runner [string]​
Default: "jest-runner"
This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:

jest-runner-eslint
jest-runner-mocha
jest-runner-tsc
jest-runner-prettier

infoThe runner property value can omit the jest-runner- prefix of the package name.
To write a test-runner, export a class with which accepts globalConfig in the constructor, and has a runTests method with the signature:
async function runTests(  tests: Array<Test>,  watcher: TestWatcher,  onStart: OnTestStart,  onResult: OnTestSuccess,  onFailure: OnTestFailure,  options: TestRunnerOptions,): Promise<void>;
If you need to restrict your test-runner to only run in serial rather than being executed in parallel your class should have the property isSerial to be set as true.
sandboxInjectedGlobals [array<string>]​
tipRenamed from extraGlobals in Jest 28.
Default: undefined
Test files run inside a vm, which slows calls to global context properties (e.g. Math). With this option you can specify extra properties to be defined inside the vm for faster lookups.
For example, if your tests call Math often, you can pass it by setting sandboxInjectedGlobals.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  sandboxInjectedGlobals: ['Math'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  sandboxInjectedGlobals: ['Math'],};export default config;
noteThis option has no effect if you use native ESM.
setupFiles [array]​
Default: []
A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment before executing setupFilesAfterEnv and before the test code itself.
tipIf your setup script is a CJS module, it may export an async function. Jest will call the function and await its result. This might be useful to fetch some data asynchronously. If the file is an ESM module, simply use top-level await to achieve the same result.
setupFilesAfterEnv [array]​
Default: []
A list of paths to modules that run some code to configure or set up the testing framework before each test file in the suite is executed. Since setupFiles executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment but before the test code itself.
In other words, setupFilesAfterEnv modules are meant for code which is repeating in each test file. Having the test framework installed makes Jest globals, jest object and expect accessible in the modules. For example, you can add extra matchers from jest-extended library or call setup and teardown hooks:
setup-jest.jsconst matchers = require('jest-extended');expect.extend(matchers);afterEach(() => {  jest.useRealTimers();});
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  setupFilesAfterEnv: ['<rootDir>/setup-jest.js'],};export default config;
showSeed [boolean]​
Default: false
The equivalent of the --showSeed flag to print the seed in the test report summary.
slowTestThreshold [number]​
Default: 5
The number of seconds after which a test is considered as slow and reported as such in the results.
snapshotFormat [object]​
Default: {escapeString: false, printBasicPrototype: false}
Allows overriding specific snapshot formatting options documented in the pretty-format readme, with the exceptions of compareKeys and plugins. For example, this config would have the snapshot formatter not print a prefix for "Object" and "Array":
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  snapshotFormat: {    printBasicPrototype: false,  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  snapshotFormat: {    printBasicPrototype: false,  },};export default config;
some.test.jstest('does not show prototypes for object and array inline', () => {  const object = {    array: [{hello: 'Danger'}],  };  expect(object).toMatchInlineSnapshot(`    {      "array": [        {          "hello": "Danger",        },      ],    }  `);});
snapshotResolver [string]​
Default: undefined
The path to a module that can resolve test<->snapshot path. This config option lets you customize where Jest stores snapshot files on disk.
custom-resolver.jsmodule.exports = {  // resolves from test to snapshot path  resolveSnapshotPath: (testPath, snapshotExtension) =>    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,  // resolves from snapshot to test path  resolveTestPath: (snapshotFilePath, snapshotExtension) =>    snapshotFilePath      .replace('__snapshots__', '__tests__')      .slice(0, -snapshotExtension.length),  // Example test path, used for preflight consistency check of the implementation above  testPathForConsistencyCheck: 'some/__tests__/example.test.js',};
snapshotSerializers [array<string>]​
Default: []
A list of paths to snapshot serializer modules Jest should use for snapshot testing.
Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See snapshot test tutorial for more information.
custom-serializer.jsmodule.exports = {  serialize(val, config, indentation, depth, refs, printer) {    return `Pretty foo: ${printer(val.foo)}`;  },  test(val) {    return val && Object.prototype.hasOwnProperty.call(val, 'foo');  },};
printer is a function that serializes a value using existing plugins.
Add custom-serializer to your Jest configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  snapshotSerializers: ['path/to/custom-serializer.js'],};export default config;
Finally tests would look as follows:
test(() => {  const bar = {    foo: {      x: 1,      y: 2,    },  };  expect(bar).toMatchSnapshot();});
Rendered snapshot:
Pretty foo: Object {  "x": 1,  "y": 2,}
tipTo make a dependency explicit instead of implicit, you can call expect.addSnapshotSerializer to add a module for an individual test file instead of adding its path to snapshotSerializers in Jest configuration.More about serializers API can be found here.
testEnvironment [string]​
Default: "node"
The test environment that will be used for testing. The default environment in Jest is a Node.js environment. If you are building a web app, you can use a browser-like environment through jsdom instead.
By adding a @jest-environment docblock at the top of the file, you can specify another environment to be used for all tests in that file:
/** * @jest-environment jsdom */test('use jsdom in this test file', () => {  const element = document.createElement('div');  expect(element).not.toBeNull();});
You can create your own module that will be used for setting up the test environment. The module must export a class with setup, teardown and getVmContext methods. You can also pass variables from this module to your test suites by assigning them to this.global object – this will make them available in your test suites as global variables. The constructor is passed globalConfig and projectConfig as its first argument, and testEnvironmentContext as its second.
The class may optionally expose an asynchronous handleTestEvent method to bind to events fired by jest-circus. Normally, jest-circus test runner would pause until a promise returned from handleTestEvent gets fulfilled, except for the next events: start_describe_definition, finish_describe_definition, add_hook, add_test or error (for the up-to-date list you can look at SyncEvent type in the types definitions). That is caused by backward compatibility reasons and process.on('unhandledRejection', callback) signature, but that usually should not be a problem for most of the use cases.
Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with its value set to an empty string. If the pragma is not present, it will not be present in the object.
To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in my-custom-environment.js in some subfolder of your project, then the annotation might look like this:
/** * @jest-environment ./src/test/my-custom-environment */
infoTestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.
Example:
// my-custom-environmentconst NodeEnvironment = require('jest-environment-node').TestEnvironment;class CustomEnvironment extends NodeEnvironment {  constructor(config, context) {    super(config, context);    console.log(config.globalConfig);    console.log(config.projectConfig);    this.testPath = context.testPath;    this.docblockPragmas = context.docblockPragmas;  }  async setup() {    await super.setup();    await someSetupTasks(this.testPath);    this.global.someGlobalObject = createGlobalObject();    // Will trigger if docblock contains @my-custom-pragma my-pragma-value    if (this.docblockPragmas['my-custom-pragma'] === 'my-pragma-value') {      // ...    }  }  async teardown() {    this.global.someGlobalObject = destroyGlobalObject();    await someTeardownTasks();    await super.teardown();  }  getVmContext() {    return super.getVmContext();  }  async handleTestEvent(event, state) {    if (event.name === 'test_start') {      // ...    }  }}module.exports = CustomEnvironment;
// my-test-suite/** * @jest-environment ./my-custom-environment */let someGlobalObject;beforeAll(() => {  someGlobalObject = globalThis.someGlobalObject;});
testEnvironmentOptions [Object]​
Default: {}
Test environment options that will be passed to the testEnvironment. The relevant options depend on the environment.
For example, you can override options passed to jsdom:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    html: '<html lang="zh-cmn-Hant"></html>',    url: 'https://jestjs.io/',    userAgent: 'Agent/007',  },};export default config;
Both jest-environment-jsdom and jest-environment-node allow specifying customExportConditions, which allow you to control which versions of a library are loaded from exports in package.json. jest-environment-jsdom defaults to ['browser']. jest-environment-node defaults to ['node', 'node-addons'].
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    customExportConditions: ['react-native'],  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  testEnvironment: 'jsdom',  testEnvironmentOptions: {    customExportConditions: ['react-native'],  },};export default config;
These options can also be passed in a docblock, similar to testEnvironment. The string with options must be parseable by JSON.parse:
/** * @jest-environment jsdom * @jest-environment-options {"url": "https://jestjs.io/"} */test('use jsdom and set the URL in this test file', () => {  expect(window.location.href).toBe('https://jestjs.io/');});
testFailureExitCode [number]​
Default: 1
The exit code Jest returns on test failure.
infoThis does not change the exit code in the case of Jest errors (e.g. invalid configuration).
testMatch [array<string>]​
(default: [ "**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)" ])
The glob patterns Jest uses to detect test files. By default it looks for .js, .jsx, .ts and .tsx files inside of __tests__ folders, as well as any files with a suffix of .test or .spec (e.g. Component.test.js or Component.spec.js). It will also find files called test.js or spec.js.
See the micromatch package for details of the patterns you can specify.
See also testRegex [string | array<string>], but note that you cannot specify both options.
tipEach glob pattern is applied in the order they are specified in the config. For example ["!**/__fixtures__/**", "**/__tests__/**/*.js"] will not exclude __fixtures__ because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after **/__tests__/**/*.js.
testPathIgnorePatterns [array<string>]​
Default: ["/node_modules/"]
An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: ["<rootDir>/build/", "<rootDir>/node_modules/"].
testRegex [string | array<string>]​
Default: (/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$
The pattern or patterns Jest uses to detect test files. By default it looks for .js, .jsx, .ts and .tsx files inside of __tests__ folders, as well as any files with a suffix of .test or .spec (e.g. Component.test.js or Component.spec.js). It will also find files called test.js or spec.js. See also testMatch [array<string>], but note that you cannot specify both options.
The following is a visualization of the default regex:
├── __tests__│   └── component.spec.js # test│   └── anything # test├── package.json # not test├── foo.test.js # test├── bar.spec.jsx # test└── component.js # not test
infotestRegex will try to detect test files using the absolute file path, therefore, having a folder with a name that matches it will run all the files as tests.
testResultsProcessor [string]​
Default: undefined
This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:
{  "success": boolean,  "startTime": epoch,  "numTotalTestSuites": number,  "numPassedTestSuites": number,  "numFailedTestSuites": number,  "numRuntimeErrorTestSuites": number,  "numTotalTests": number,  "numPassedTests": number,  "numFailedTests": number,  "numPendingTests": number,  "numTodoTests": number,  "openHandles": Array<Error>,  "testResults": [{    "numFailingTests": number,    "numPassingTests": number,    "numPendingTests": number,    "testResults": [{      "title": string (message in it block),      "status": "failed" | "pending" | "passed",      "ancestorTitles": [string (message in describe blocks)],      "failureMessages": [string],      "numPassingAsserts": number,      "location": {        "column": number,        "line": number      },      "duration": number | null    },    ...    ],    "perfStats": {      "start": epoch,      "end": epoch    },    "testFilePath": absolute path to test file,    "coverage": {}  },  "testExecError:" (exists if there was a top-level failure) {    "message": string    "stack": string  }  ...  ]}
testResultsProcessor and reporters are very similar to each other. One difference is that a test result processor only gets called after all tests finished. Whereas a reporter has the ability to receive test results after individual tests and/or test suites are finished.
testRunner [string]​
Default: jest-circus/runner
This option allows the use of a custom test runner. The default is jest-circus. A custom test runner can be provided by specifying a path to a test runner implementation.
The test runner module must export a function with the following signature:
function testRunner(  globalConfig: GlobalConfig,  config: ProjectConfig,  environment: Environment,  runtime: Runtime,  testPath: string,): Promise<TestResult>;
An example of such function can be found in our default jasmine2 test runner package.
testSequencer [string]​
Default: @jest/test-sequencer
This option allows you to use a custom sequencer instead of Jest's default.
tipBoth sort and shard may optionally return a Promise.
For example, you may sort test paths alphabetically:
custom-sequencer.jsconst Sequencer = require('@jest/test-sequencer').default;class CustomSequencer extends Sequencer {  /**   * Select tests for shard requested via --shard=shardIndex/shardCount   * Sharding is applied before sorting   */  shard(tests, {shardIndex, shardCount}) {    const shardSize = Math.ceil(tests.length / shardCount);    const shardStart = shardSize * (shardIndex - 1);    const shardEnd = shardSize * shardIndex;    return [...tests]      .sort((a, b) => (a.path > b.path ? 1 : -1))      .slice(shardStart, shardEnd);  }  /**   * Sort test to determine order of execution   * Sorting is applied after sharding   */  sort(tests) {    // Test structure information    // https://github.com/jestjs/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21    const copyTests = [...tests];    return copyTests.sort((testA, testB) => (testA.path > testB.path ? 1 : -1));  }}module.exports = CustomSequencer;
Add custom-sequencer to your Jest configuration:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  testSequencer: 'path/to/custom-sequencer.js',};module.exports = config;import type {Config} from 'jest';const config: Config = {  testSequencer: 'path/to/custom-sequencer.js',};export default config;
testTimeout [number]​
Default: 5000
Default timeout of a test in milliseconds.
transform [object<string, pathToTransformer | [pathToTransformer, object]>]​
Default: {"\\.[jt]sx?$": "babel-jest"}
A map from regular expressions to paths to transformers. Optionally, a tuple with configuration options can be passed as second argument: {filePattern: ['path-to-transformer', {options}]}. For example, here is how you can configure babel-jest for non-default behavior: {'\\.js$': ['babel-jest', {rootMode: 'upward'}]}.
Jest runs the code of your project as JavaScript, hence a transformer is needed if you use some syntax not supported by Node out of the box (such as JSX, TypeScript, Vue templates). By default, Jest will use babel-jest transformer, which will load your project's Babel configuration and transform any file matching the /\.[jt]sx?$/ RegExp (in other words, any .js, .jsx, .ts or .tsx file). In addition, babel-jest will inject the Babel plugin necessary for mock hoisting talked about in ES Module mocking.
See the Code Transformation section for more details and instructions on building your own transformer.
tipKeep in mind that a transformer only runs once per file unless the file has changed.Remember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors:JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};module.exports = config;import type {Config} from 'jest';const config: Config = {  transform: {    '\\.[jt]sx?$': 'babel-jest',    '\\.css$': 'some-css-transformer',  },};export default config;
transformIgnorePatterns [array<string>]​
Default: ["/node_modules/", "\\.pnp\\.[^\\\/]+$"]
An array of regexp pattern strings that are matched against all source file paths before transformation. If the file path matches any of the patterns, it will not be transformed.
Providing regexp patterns that overlap with each other may result in files not being transformed that you expected to be transformed. For example:
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],};export default config;
The first pattern will match (and therefore not transform) files inside /node_modules except for those in /node_modules/foo/ and /node_modules/bar/. The second pattern will match (and therefore not transform) files inside any path with /bar/ in it. With the two together, files in /node_modules/bar/ will not be transformed because it does match the second pattern, even though it was excluded by the first.
Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled code. Since all files inside node_modules are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use transformIgnorePatterns to allow transpiling such modules. You'll find a good example of this use case in React Native Guide.
These pattern strings match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/bower_components/',    '<rootDir>/node_modules/',  ],};export default config;
tipIf you use pnpm and need to convert some packages under node_modules, you need to note that the packages in this folder (e.g. node_modules/package-a/) have been symlinked to the path under .pnpm (e.g. node_modules/.pnpm/[email protected]/node_modules/package-a/), so using <rootDir>/node_modules/(?!(package-a|@scope/pkg-b)/) directly will not be recognized, while is to use:JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative pattern to match the second 'node_modules/' in 'node_modules/.pnpm/@[email protected]/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};module.exports = config;import type {Config} from 'jest';const config: Config = {  transformIgnorePatterns: [    '<rootDir>/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)',    /* if config file is under '~/packages/lib-a/' */    `${path.join(      __dirname,      '../..',    )}/node_modules/.pnpm/(?!(package-a|@scope\\+pkg-b)@)`,    /* or using relative path to match the second 'node_modules/' in 'node_modules/.pnpm/@[email protected]/node_modules/@scope/pkg-b/' */    'node_modules/(?!.pnpm|package-a|@scope/pkg-b)',  ],};export default config;It should be noted that the folder name of pnpm under .pnpm is the package name plus @ and version number, so writing / will not be recognized, but using @ can.
unmockedModulePathPatterns [array<string>]​
Default: []
An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.
This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore, lodash, etc). It's generally a best practice to keep this list as small as possible and always use explicit jest.mock()/jest.unmock() calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.
It is possible to override this setting in individual tests by explicitly calling jest.mock() at the top of the test file.
verbose [boolean]​
Default: false or true if there is only one test file to run
Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution.
watchPathIgnorePatterns [array<string>]​
Default: []
An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.
These patterns match against the full path. Use the <rootDir> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: ["<rootDir>/node_modules/"].
Even if nothing is specified here, the watcher will ignore changes to the version control folders (.git, .hg, .sl). Other hidden files and directories, i.e. those that begin with a dot (.), are watched by default. Remember to escape the dot when you add them to watchPathIgnorePatterns as it is a special RegExp character.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};module.exports = config;import type {Config} from 'jest';const config: Config = {  watchPathIgnorePatterns: ['<rootDir>/\\.tmp/', '<rootDir>/bar/'],};export default config;
watchPlugins [array<string | [string, Object]>]​
Default: []
This option allows you to use custom watch plugins. Read more about watch plugins here.
Examples of watch plugins include:

jest-watch-master
jest-watch-select-projects
jest-watch-suspend
jest-watch-typeahead
jest-watch-yarn-workspaces

infoThe values in the watchPlugins property value can omit the jest-watch- prefix of the package name.
watchman [boolean]​
Default: true
Whether to use watchman for file crawling.
workerIdleMemoryLimit [number|string]​
Default: undefined
Specifies the memory limit for workers before they are recycled and is primarily a work-around for this issue;
After the worker has executed a test the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. The limit can be specified in a number of different ways and whatever the result is Math.floor is used to turn it into an integer value:

<= 1 - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory
\> 1 - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use 1.1.
With units

50% - As above, a percentage of total system memory
100KB, 65MB, etc - With units to denote a fixed memory limit.

K / KB - Kilobytes (x1000)
KiB - Kibibytes (x1024)
M / MB - Megabytes
MiB - Mebibytes
G / GB - Gigabytes
GiB - Gibibytes





cautionPercentage based memory limit does not work on Linux CircleCI workers due to incorrect system memory being reported.
JavaScriptTypeScript/** @type {import('jest').Config} */const config = {  workerIdleMemoryLimit: 0.2,};module.exports = config;import type {Config} from 'jest';const config: Config = {  workerIdleMemoryLimit: 0.2,};export default config;
// [string]​
This option allows comments in package.json. Include the comment text as the value of this key:
package.json{  "name": "my-project",  "jest": {    "//": "Comment goes here",    "verbose": true  }}
workerThreads​
Default: false
Whether to use worker threads for parallelization. Child processes are used by default.
Using worker threads may help to improve performance.
cautionThis is experimental feature. Keep in mind that the worker threads use structured clone instead of JSON.stringify() to serialize messages. This means that built-in JavaScript objects as BigInt, Map or Set will get serialized properly. However extra properties set on Error, Map or Set will not be passed on through the serialization step. For more details see the article on structured clone.Edit this pageLast updated on Jan 16, 2025 by Edwin KoflerPreviousThe Jest ObjectNextJest CLI OptionsOptionsReferenceautomock [boolean]bail [number | boolean]cacheDirectory [string]clearMocks [boolean]collectCoverage [boolean]collectCoverageFrom [array]coverageDirectory [string]coveragePathIgnorePatterns [array<string>]coverageProvider [string]coverageReporters [array<string | [string, options]>]coverageThreshold [object]dependencyExtractor [string]displayName [string, object]errorOnDeprecated [boolean]extensionsToTreatAsEsm [array<string>]fakeTimers [object]forceCoverageMatch [array<string>]globals [object]globalSetup [string]globalTeardown [string]haste [object]injectGlobals [boolean]maxConcurrency [number]maxWorkers [number | string]moduleDirectories [array<string>]moduleFileExtensions [array<string>]moduleNameMapper [object<string, string | array<string>>]modulePathIgnorePatterns [array<string>]modulePaths [array<string>]notify [boolean]notifyMode [string]openHandlesTimeout [number]preset [string]prettierPath [string]projects [array<string | ProjectConfig>]randomize [boolean]reporters [array<moduleName | [moduleName, options]>]resetMocks [boolean]resetModules [boolean]resolver [string]restoreMocks [boolean]rootDir [string]roots [array<string>]runner [string]sandboxInjectedGlobals [array<string>]setupFiles [array]setupFilesAfterEnv [array]showSeed [boolean]slowTestThreshold [number]snapshotFormat [object]snapshotResolver [string]snapshotSerializers [array<string>]testEnvironment [string]testEnvironmentOptions [Object]testFailureExitCode [number]testMatch [array<string>]testPathIgnorePatterns [array<string>]testRegex [string | array<string>]testResultsProcessor [string]testRunner [string]testSequencer [string]testTimeout [number]transform [object<string, pathToTransformer | [pathToTransformer, object]>]transformIgnorePatterns [array<string>]unmockedModulePathPatterns [array<string>]verbose [boolean]watchPathIgnorePatterns [array<string>]watchPlugins [array<string | [string, Object]>]watchman [boolean]workerIdleMemoryLimit [number|string]// [string]workerThreads\n\n\n\nJest CLI OptionsVersion: 29.7On this pageJest CLI OptionsThe jest command line runner has a number of useful options. You can run jest --help to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's Configuration options can also be specified through the CLI.
Here is a brief overview:
Running from the command line​
Run all tests (default):
jest
Run only the tests that were specified with a pattern or filename:
jest my-test #orjest path/to/my-test.js
Run tests related to changed files based on hg/git (uncommitted files):
jest -o
Run tests related to path/to/fileA.js and path/to/fileB.js:
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
Run tests that match this spec name (match against the name in describe or test, basically).
jest -t name-of-spec
Run watch mode:
jest --watch #runs jest -o by defaultjest --watchAll #runs all tests
Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.
Using with package manager​
If you run Jest via your package manager, you can still pass the command line arguments directly as Jest arguments.
Instead of:
jest -u -t="ColorPicker"
you can use:
npmYarnpnpmnpm test -- -u -t="ColorPicker"yarn test -u -t="ColorPicker"pnpm test -u -t="ColorPicker"
Camelcase & dashed args support​
Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:
jest --collect-coveragejest --collectCoverage
Arguments can also be mixed:
jest --update-snapshot --detectOpenHandles
Options​
noteCLI options take precedence over values from the Configuration.

Camelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--init--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPattern=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--watch--watchAll--watchman--workerThreads

Reference​
jest <regexForTestFiles>​
When you run jest with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: jest "my.*(complex)?pattern". On Windows, you will need to use / as a path separator or escape \ as \\.
--bail[=<n>]​
Alias: -b. Exit the test suite immediately upon n number of failing test suite. Defaults to 1.
--cache​
Whether to use the cache. Defaults to true. Disable the cache using --no-cache.
cautionThe cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.
If you want to inspect the cache, use --showConfig and look at the cacheDirectory value. If you need to clear the cache, use --clearCache.
--changedFilesWithAncestor​
Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to --onlyChanged.
--changedSince​
Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to --onlyChanged.
--ci​
When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with --updateSnapshot.
--clearCache​
Deletes the Jest cache directory and then exits without running tests. Will delete cacheDirectory if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling jest --showConfig.
cautionClearing the cache will reduce performance.
--clearMocks​
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
--collectCoverageFrom=<glob>​
A glob pattern relative to rootDir matching the files that coverage info needs to be collected from.
--colors​
Forces test results output highlighting even if stdout is not a TTY.
noteAlternatively you can set the environment variable FORCE_COLOR=true to forcefully enable or FORCE_COLOR=false to disable colorized output. The use of FORCE_COLOR overrides all other color support checks.
--config=<path>​
Alias: -c. The path to a Jest config file specifying how to find and execute tests. If no rootDir is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.
--coverage[=<boolean>]​
Alias: --collectCoverage. Indicates that test coverage information should be collected and reported in the output. Optionally pass <boolean> to override option set in configuration.
--coverageDirectory=<path>​
The directory where Jest should output its coverage files.
--coverageProvider=<provider>​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
--debug​
Print debugging info about your Jest config.
--detectOpenHandles​
Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use --forceExit in order for Jest to exit to potentially track down the reason. This implies --runInBand, making tests run serially. Implemented using async_hooks. This option has a significant performance penalty and should only be used for debugging.
--env=<environment>​
The test environment used for all tests. This can point to any file or node module. Examples: jsdom, node or path/to/my-environment.js.
--errorOnDeprecated​
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--expand​
Alias: -e. Use this flag to show full diffs and errors instead of a patch.
--filter=<file>​
Path to a module exporting a filtering function. This asynchronous function receives a list of test paths which can be manipulated to exclude tests from running by returning an object with shape { filtered: Array<{ test: string }> }. Especially useful when used in conjunction with a testing infrastructure to filter known broken tests, e.g.
my-filter.jsmodule.exports = testPaths => {  const allowedPaths = testPaths    .filter(filteringFunction)    .map(test => ({test})); // [{ test: "path1.spec.js" }, { test: "path2.spec.js" }, etc]  return {    filtered: allowedPaths,  };};
--findRelatedTests <spaceSeparatedListOfSourceFiles>​
Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with --coverage to include a test coverage for the source files, no duplicate --collectCoverageFrom arguments needed.
--forceExit​
Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up.
cautionThis feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use --detectOpenHandles to help track it down.
--help​
Show the help information, similar to this page.
--ignoreProjects <project1> ... <projectN>​
Ignore the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--init​
Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a jest.config.js file with a short description for each option.
--injectGlobals​
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
--json​
Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
--lastCommit​
Run all tests affected by file changes in the last commit made. Behaves similarly to --onlyChanged.
--listTests​
Lists all test files that Jest will run given the arguments, and exits.
--logHeapUsage​
Logs the heap usage after every test. Useful to debug memory leaks. Use together with --runInBand and --expose-gc in node.
--maxConcurrency=<num>​
Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use test.concurrent.
--maxWorkers=<num>|<string>​
Alias: -w. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration: --maxWorkers=50%
--noStackTrace​
Disables stack trace in test results output.
--notify​
Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.
--onlyChanged​
Alias: -o. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).
--onlyFailures​
Alias: -f. Run tests that failed in the previous execution.
--openHandlesTimeout=<milliseconds>​
When --detectOpenHandles and --forceExit are disabled, Jest will print a warning if the process has not exited cleanly after this number of milliseconds. A value of 0 disables the warning. Defaults to 1000.
--outputFile=<filename>​
Write test results to a file when the --json option is also specified. The returned JSON structure is documented in testResultsProcessor.
--passWithNoTests​
Allows the test suite to pass when no files are found.
--projects <path1> ... <pathN>​
Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the projects configuration option.
noteIf configuration files are found in the specified paths, all projects specified within those configuration files will be run.
--randomize​
Shuffle the order of the tests within a file. The shuffling is based on the seed. See --seed=<num> for more info.
Seed value is displayed when this option is set. Equivalent to setting the CLI option --showSeed.
jest --randomize --seed 1234
noteThis option is only supported using the default jest-circus test runner.
--reporters​
Run tests with specified reporters. Reporter options are not available via CLI. Example with multiple reporters:
jest --reporters="default" --reporters="jest-junit"
--resetMocks​
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--restoreMocks​
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--roots​
A list of paths to directories that Jest should use to search for files in.
--runInBand​
Alias: -i. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.
--runTestsByPath​
Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file.
For example, given the following file structure:
__tests__└── t1.test.js # test└── t2.test.js # test
When ran with a pattern, no test is found:
jest --runTestsByPath __tests__/t
Output:
No tests found
However, passing an exact path will execute only the given test:
jest --runTestsByPath __tests__/t1.test.js
Output:
PASS __tests__/t1.test.js
tipThe default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files.
--seed=<num>​
Sets a seed value that can be retrieved in a test file via jest.getSeed(). The seed value must be between -0x80000000 and 0x7fffffff inclusive (-2147483648 (-(2 ** 31)) and 2147483647 (2 ** 31 - 1) in decimal).
jest --seed=1324
tipIf this option is not specified Jest will randomly generate the value. You can use the --showSeed flag to print the seed in the test report summary.Jest uses the seed internally for shuffling the order in which test suites are run. If the --randomize option is used, the seed is also used for shuffling the order of tests within each describe block. When dealing with flaky tests, rerunning with the same seed might help reproduce the failure.
--selectProjects <project1> ... <projectN>​
Run the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--setupFilesAfterEnv <path1> ... <pathN>​
A list of paths to modules that run some code to configure or to set up the testing framework before each test. Beware that files imported by the setup scripts will not be mocked during testing.
--shard​
The test suite shard to execute in a format of (?<shardIndex>\d+)/(?<shardCount>\d+).
shardIndex describes which shard to select while shardCount controls the number of shards the suite should be split into.
shardIndex and shardCount have to be 1-based, positive numbers, and shardIndex has to be lower than or equal to shardCount.
When shard is specified the configured testSequencer has to implement a shard method.
For example, to split the suite into three shards, each running one third of the tests:
jest --shard=1/3jest --shard=2/3jest --shard=3/3
--showConfig​
Print your Jest config and then exits.
--showSeed​
Prints the seed value in the test report summary. See --seed=<num> for the details.
Can also be set in configuration. See showSeed.
--silent​
Prevent tests from printing messages through the console.
--testEnvironmentOptions=<json string>​
A JSON string with options that will be passed to the testEnvironment. The relevant options depend on the environment.
--testLocationInResults​
Adds a location field to test results. Useful if you want to report the location of a test in a reporter.
noteIn the resulting object column is 0-indexed while line is not.{  "column": 4,  "line": 5}
--testMatch glob1 ... globN​
The glob patterns Jest uses to detect test files. Please refer to the testMatch configuration for details.
--testNamePattern=<regex>​
Alias: -t. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like 'GET /api/posts with auth', then you can use jest -t=auth.
tipThe regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.
--testPathIgnorePatterns=<regex>|[array]​
A single or array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to --testPathPattern, it will only run those tests with a path that does not match with the provided regexp expressions.
To pass as an array use escaped parentheses and space delimited regexps such as \(/node_modules/ /tests/e2e/\). Alternatively, you can omit parentheses by combining regexps into a single regexp like /node_modules/|/tests/e2e/. These two examples are equivalent.
--testPathPattern=<regex>​
A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use / as a path separator or escape \ as \\.
--testRunner=<path>​
Lets you specify a custom test runner.
--testSequencer=<path>​
Lets you specify a custom test sequencer. Please refer to the testSequencer configuration for details.
--testTimeout=<number>​
Default timeout of a test in milliseconds. Default value: 5000.
--updateSnapshot​
Alias: -u. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with --testNamePattern to re-record snapshots.
--useStderr​
Divert all output to stderr.
--verbose​
Display individual test results with the test suite hierarchy.
--version​
Alias: -v. Print the version and exit.
--watch​
Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the --watchAll option instead.
tipUse --no-watch (or --watch=false) to explicitly disable the watch mode if it was enabled using --watch. In most CI environments, this is automatically handled for you.
--watchAll​
Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the --watch option.
tipUse --no-watchAll (or --watchAll=false) to explicitly disable the watch mode if it was enabled using --watchAll. In most CI environments, this is automatically handled for you.
--watchman​
Whether to use watchman for file crawling. Defaults to true. Disable using --no-watchman.
--workerThreads​
Whether to use worker threads for parallelization. Child processes are used by default.
cautionThis is experimental feature. See the workerThreads configuration option for more details.Edit this pageLast updated on Sep 26, 2024 by Jörn Zaefferer\n\nJest CLI OptionsVersion: 29.7On this pageJest CLI OptionsThe jest command line runner has a number of useful options. You can run jest --help to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's Configuration options can also be specified through the CLI.
Here is a brief overview:
Running from the command line​
Run all tests (default):
jest
Run only the tests that were specified with a pattern or filename:
jest my-test #orjest path/to/my-test.js
Run tests related to changed files based on hg/git (uncommitted files):
jest -o
Run tests related to path/to/fileA.js and path/to/fileB.js:
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
Run tests that match this spec name (match against the name in describe or test, basically).
jest -t name-of-spec
Run watch mode:
jest --watch #runs jest -o by defaultjest --watchAll #runs all tests
Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.
Using with package manager​
If you run Jest via your package manager, you can still pass the command line arguments directly as Jest arguments.
Instead of:
jest -u -t="ColorPicker"
you can use:
npmYarnpnpmnpm test -- -u -t="ColorPicker"yarn test -u -t="ColorPicker"pnpm test -u -t="ColorPicker"
Camelcase & dashed args support​
Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:
jest --collect-coveragejest --collectCoverage
Arguments can also be mixed:
jest --update-snapshot --detectOpenHandles
Options​
noteCLI options take precedence over values from the Configuration.

Camelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--init--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPattern=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--watch--watchAll--watchman--workerThreads

Reference​
jest <regexForTestFiles>​
When you run jest with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: jest "my.*(complex)?pattern". On Windows, you will need to use / as a path separator or escape \ as \\.
--bail[=<n>]​
Alias: -b. Exit the test suite immediately upon n number of failing test suite. Defaults to 1.
--cache​
Whether to use the cache. Defaults to true. Disable the cache using --no-cache.
cautionThe cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.
If you want to inspect the cache, use --showConfig and look at the cacheDirectory value. If you need to clear the cache, use --clearCache.
--changedFilesWithAncestor​
Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to --onlyChanged.
--changedSince​
Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to --onlyChanged.
--ci​
When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with --updateSnapshot.
--clearCache​
Deletes the Jest cache directory and then exits without running tests. Will delete cacheDirectory if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling jest --showConfig.
cautionClearing the cache will reduce performance.
--clearMocks​
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
--collectCoverageFrom=<glob>​
A glob pattern relative to rootDir matching the files that coverage info needs to be collected from.
--colors​
Forces test results output highlighting even if stdout is not a TTY.
noteAlternatively you can set the environment variable FORCE_COLOR=true to forcefully enable or FORCE_COLOR=false to disable colorized output. The use of FORCE_COLOR overrides all other color support checks.
--config=<path>​
Alias: -c. The path to a Jest config file specifying how to find and execute tests. If no rootDir is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.
--coverage[=<boolean>]​
Alias: --collectCoverage. Indicates that test coverage information should be collected and reported in the output. Optionally pass <boolean> to override option set in configuration.
--coverageDirectory=<path>​
The directory where Jest should output its coverage files.
--coverageProvider=<provider>​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
--debug​
Print debugging info about your Jest config.
--detectOpenHandles​
Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use --forceExit in order for Jest to exit to potentially track down the reason. This implies --runInBand, making tests run serially. Implemented using async_hooks. This option has a significant performance penalty and should only be used for debugging.
--env=<environment>​
The test environment used for all tests. This can point to any file or node module. Examples: jsdom, node or path/to/my-environment.js.
--errorOnDeprecated​
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--expand​
Alias: -e. Use this flag to show full diffs and errors instead of a patch.
--filter=<file>​
Path to a module exporting a filtering function. This asynchronous function receives a list of test paths which can be manipulated to exclude tests from running by returning an object with shape { filtered: Array<{ test: string }> }. Especially useful when used in conjunction with a testing infrastructure to filter known broken tests, e.g.
my-filter.jsmodule.exports = testPaths => {  const allowedPaths = testPaths    .filter(filteringFunction)    .map(test => ({test})); // [{ test: "path1.spec.js" }, { test: "path2.spec.js" }, etc]  return {    filtered: allowedPaths,  };};
--findRelatedTests <spaceSeparatedListOfSourceFiles>​
Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with --coverage to include a test coverage for the source files, no duplicate --collectCoverageFrom arguments needed.
--forceExit​
Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up.
cautionThis feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use --detectOpenHandles to help track it down.
--help​
Show the help information, similar to this page.
--ignoreProjects <project1> ... <projectN>​
Ignore the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--init​
Generate a basic configuration file. Based on your project, Jest will ask you a few questions that will help to generate a jest.config.js file with a short description for each option.
--injectGlobals​
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
--json​
Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
--lastCommit​
Run all tests affected by file changes in the last commit made. Behaves similarly to --onlyChanged.
--listTests​
Lists all test files that Jest will run given the arguments, and exits.
--logHeapUsage​
Logs the heap usage after every test. Useful to debug memory leaks. Use together with --runInBand and --expose-gc in node.
--maxConcurrency=<num>​
Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use test.concurrent.
--maxWorkers=<num>|<string>​
Alias: -w. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration: --maxWorkers=50%
--noStackTrace​
Disables stack trace in test results output.
--notify​
Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.
--onlyChanged​
Alias: -o. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).
--onlyFailures​
Alias: -f. Run tests that failed in the previous execution.
--openHandlesTimeout=<milliseconds>​
When --detectOpenHandles and --forceExit are disabled, Jest will print a warning if the process has not exited cleanly after this number of milliseconds. A value of 0 disables the warning. Defaults to 1000.
--outputFile=<filename>​
Write test results to a file when the --json option is also specified. The returned JSON structure is documented in testResultsProcessor.
--passWithNoTests​
Allows the test suite to pass when no files are found.
--projects <path1> ... <pathN>​
Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the projects configuration option.
noteIf configuration files are found in the specified paths, all projects specified within those configuration files will be run.
--randomize​
Shuffle the order of the tests within a file. The shuffling is based on the seed. See --seed=<num> for more info.
Seed value is displayed when this option is set. Equivalent to setting the CLI option --showSeed.
jest --randomize --seed 1234
noteThis option is only supported using the default jest-circus test runner.
--reporters​
Run tests with specified reporters. Reporter options are not available via CLI. Example with multiple reporters:
jest --reporters="default" --reporters="jest-junit"
--resetMocks​
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--restoreMocks​
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--roots​
A list of paths to directories that Jest should use to search for files in.
--runInBand​
Alias: -i. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.
--runTestsByPath​
Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file.
For example, given the following file structure:
__tests__└── t1.test.js # test└── t2.test.js # test
When ran with a pattern, no test is found:
jest --runTestsByPath __tests__/t
Output:
No tests found
However, passing an exact path will execute only the given test:
jest --runTestsByPath __tests__/t1.test.js
Output:
PASS __tests__/t1.test.js
tipThe default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files.
--seed=<num>​
Sets a seed value that can be retrieved in a test file via jest.getSeed(). The seed value must be between -0x80000000 and 0x7fffffff inclusive (-2147483648 (-(2 ** 31)) and 2147483647 (2 ** 31 - 1) in decimal).
jest --seed=1324
tipIf this option is not specified Jest will randomly generate the value. You can use the --showSeed flag to print the seed in the test report summary.Jest uses the seed internally for shuffling the order in which test suites are run. If the --randomize option is used, the seed is also used for shuffling the order of tests within each describe block. When dealing with flaky tests, rerunning with the same seed might help reproduce the failure.
--selectProjects <project1> ... <projectN>​
Run the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--setupFilesAfterEnv <path1> ... <pathN>​
A list of paths to modules that run some code to configure or to set up the testing framework before each test. Beware that files imported by the setup scripts will not be mocked during testing.
--shard​
The test suite shard to execute in a format of (?<shardIndex>\d+)/(?<shardCount>\d+).
shardIndex describes which shard to select while shardCount controls the number of shards the suite should be split into.
shardIndex and shardCount have to be 1-based, positive numbers, and shardIndex has to be lower than or equal to shardCount.
When shard is specified the configured testSequencer has to implement a shard method.
For example, to split the suite into three shards, each running one third of the tests:
jest --shard=1/3jest --shard=2/3jest --shard=3/3
--showConfig​
Print your Jest config and then exits.
--showSeed​
Prints the seed value in the test report summary. See --seed=<num> for the details.
Can also be set in configuration. See showSeed.
--silent​
Prevent tests from printing messages through the console.
--testEnvironmentOptions=<json string>​
A JSON string with options that will be passed to the testEnvironment. The relevant options depend on the environment.
--testLocationInResults​
Adds a location field to test results. Useful if you want to report the location of a test in a reporter.
noteIn the resulting object column is 0-indexed while line is not.{  "column": 4,  "line": 5}
--testMatch glob1 ... globN​
The glob patterns Jest uses to detect test files. Please refer to the testMatch configuration for details.
--testNamePattern=<regex>​
Alias: -t. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like 'GET /api/posts with auth', then you can use jest -t=auth.
tipThe regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.
--testPathIgnorePatterns=<regex>|[array]​
A single or array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to --testPathPattern, it will only run those tests with a path that does not match with the provided regexp expressions.
To pass as an array use escaped parentheses and space delimited regexps such as \(/node_modules/ /tests/e2e/\). Alternatively, you can omit parentheses by combining regexps into a single regexp like /node_modules/|/tests/e2e/. These two examples are equivalent.
--testPathPattern=<regex>​
A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use / as a path separator or escape \ as \\.
--testRunner=<path>​
Lets you specify a custom test runner.
--testSequencer=<path>​
Lets you specify a custom test sequencer. Please refer to the testSequencer configuration for details.
--testTimeout=<number>​
Default timeout of a test in milliseconds. Default value: 5000.
--updateSnapshot​
Alias: -u. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with --testNamePattern to re-record snapshots.
--useStderr​
Divert all output to stderr.
--verbose​
Display individual test results with the test suite hierarchy.
--version​
Alias: -v. Print the version and exit.
--watch​
Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the --watchAll option instead.
tipUse --no-watch (or --watch=false) to explicitly disable the watch mode if it was enabled using --watch. In most CI environments, this is automatically handled for you.
--watchAll​
Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the --watch option.
tipUse --no-watchAll (or --watchAll=false) to explicitly disable the watch mode if it was enabled using --watchAll. In most CI environments, this is automatically handled for you.
--watchman​
Whether to use watchman for file crawling. Defaults to true. Disable using --no-watchman.
--workerThreads​
Whether to use worker threads for parallelization. Child processes are used by default.
cautionThis is experimental feature. See the workerThreads configuration option for more details.Edit this pageLast updated on Sep 26, 2024 by Jörn ZaeffererPreviousConfiguring JestNextEnvironment VariablesRunning from the command lineUsing with package managerCamelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--init--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPattern=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--watch--watchAll--watchman--workerThreads\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nGlobalsVersion: NextOn this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all input values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example same type', ({a, b, expected}) => {  // all arguments are of type `number` because all inputs (a, b, expected) are of type `number`});
If the inputs have different types, the arguments will be typed as a union of all the input types (i.e. type of the variables inside the template literal):
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${'three'}  ${3} | ${4} | ${'seven'}  ${5} | ${6} | ${'eleven'}`('template literal example different types', ({a, b, expected}) => {  // all arguments are of type `number | string` because some inputs (a, b) are of type `number` and some others (expected) are of type `string`});
Otherwise, if you want each argument to have the right type, you have to explicitly provide the generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // all arguments are typed as expected, e.g. `a: number`, `expected: string`, `extra: boolean | undefined`});
cautionKeep in mind the variables inside the template literal are not type checked, so you have to ensure that their types are correct.import {test} from '@jest/globals';test.each<{a: number; expected: string}>`  a                            | expected  ${1}                         | ${'one'}  ${'will not raise TS error'} | ${'two'}  ${3}                         | ${'three'}`('template literal with wrongly typed input', ({a, expected}) => {  // all arguments are typed as stated in the generic: `a: number`, `expected: string`  // WARNING: `a` is of type `number` but will be a string in the 2nd test case.});Edit this pageLast updated on Jan 15, 2025 by John Vandenberg\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).GlobalsVersion: NextOn this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all input values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example same type', ({a, b, expected}) => {  // all arguments are of type `number` because all inputs (a, b, expected) are of type `number`});
If the inputs have different types, the arguments will be typed as a union of all the input types (i.e. type of the variables inside the template literal):
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${'three'}  ${3} | ${4} | ${'seven'}  ${5} | ${6} | ${'eleven'}`('template literal example different types', ({a, b, expected}) => {  // all arguments are of type `number | string` because some inputs (a, b) are of type `number` and some others (expected) are of type `string`});
Otherwise, if you want each argument to have the right type, you have to explicitly provide the generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // all arguments are typed as expected, e.g. `a: number`, `expected: string`, `extra: boolean | undefined`});
cautionKeep in mind the variables inside the template literal are not type checked, so you have to ensure that their types are correct.import {test} from '@jest/globals';test.each<{a: number; expected: string}>`  a                            | expected  ${1}                         | ${'one'}  ${'will not raise TS error'} | ${'two'}  ${3}                         | ${'three'}`('template literal with wrongly typed input', ({a, expected}) => {  // all arguments are typed as stated in the generic: `a: number`, `expected: string`  // WARNING: `a` is of type `number` but will be a string in the 2nd test case.});Edit this pageLast updated on Jan 15, 2025 by John VandenbergNextExpectMethodsReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nはじめにはじめましょうVersion: NextOn this pageはじめましょうお気に入りのパッケージマネージャーを使用して Jest をインストールします。
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
2つの数値を加算する関数のテストを書くことから始めてみましょう。 まずsum.js ファイルを作成します。
function sum(a, b) {  return a + b;}module.exports = sum;
その後、sum.test.js というファイルを作成します。 このファイルに実際のテストが含まれます。
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
package.json に以下を追加します。
{  "scripts": {    "test": "jest"  }}
最後に、yarn test または npm test を実行すると、Jest は以下のメッセージを表示します。
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
あなたは Jest を使用して、最初のテストを書き、うまくいきました!
このテストは expect と、 toBe を使用し、2 つの値が同じかテストしました。 他の Jest でテスト可能なものについては、Using Matcher を参照してください。
コマンドラインからの実行​
Jest は、CLI から様々な便利なオプションを付けて、直接実行できます。 （実行するためには、例えば yarn global add jestまたはnpm install jest --global でインストールし、PATH でグローバルに利用可能になっている必要があります。 ）
ここでは my-test を Jest で実行し、実行後に OS の通知を表示する方法を示します。 そのとき構成ファイルとして config.json を使用します。
jest my-test --notify --config=config.json
コマンドラインから Jest を実行する方法の詳細については、Jest CLI Options を参考にしてください。
追加設定​
基本の設定ファイルを生成する​
次のコマンドを実行すると、Jest はあなたのプロジェクトの構成に基づいたいくつかの質問をし、その回答から短いコメント付きの基本の設定ファイルを生成します。
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Babel を使用する​
Babel を使用するために、yarn で必要な依存関係をインストールしてください。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Node.jsの現在のバージョンをターゲットにするためにBabelを定義するには、babel.config.jsというファイルをプロジェクトのルートに作ってください。
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Babelの設定にJestを認識させるJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. これを避けるには、 transform設定を明示的にリセットして下さい。jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Webpack を使用する​
Jestは webpackでアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 webpack は他のツールよりもユニークで挑戦的な機能を提供しています。 具体的な使い方は webpack guide を参照してください。
Vite を使用する​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jestは parcel-bundleで webpack と同様にアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 Parcelは設定が不要です。 使用を開始するには公式ドキュメントを参照してください。
TypeScript を使用する​
babel 経由で​
Jest は Babel 経由で TypeScript をサポートしています。 まず、 Babelを使用するを確認してください。 次に、@babel/preset-typescript をインストールします。
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
最後に、@babel/preset-typescript を babel.config.js 内のプリセットのリストに追加してください。
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
BabelでTypeScriptを使う場合、いくつかの注意事項があります。 BabelはTypescriptを純粋なトランスパイルによりサポートしているため、Jestはテストの実行時にテストコードの型検査を行いません。 型検査を行いたい場合、代わりに ts-jest を使用するか、TypeScriptコンパイラ のtsc をテストとは別に(またはビルドプロセスの一部として)使用してください。
ts-jest 経由で​
ts-jestはJest用のソースマップをサポートするTypeScriptプリプロセッサです。こちらを使うことで、TypeScriptで書かれたプロジェクトをJestでテストできるようになります。
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}このページを編集\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the 最新バージョン (29.7).はじめにはじめましょうVersion: NextOn this pageはじめましょうお気に入りのパッケージマネージャーを使用して Jest をインストールします。
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
2つの数値を加算する関数のテストを書くことから始めてみましょう。 まずsum.js ファイルを作成します。
function sum(a, b) {  return a + b;}module.exports = sum;
その後、sum.test.js というファイルを作成します。 このファイルに実際のテストが含まれます。
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
package.json に以下を追加します。
{  "scripts": {    "test": "jest"  }}
最後に、yarn test または npm test を実行すると、Jest は以下のメッセージを表示します。
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
あなたは Jest を使用して、最初のテストを書き、うまくいきました!
このテストは expect と、 toBe を使用し、2 つの値が同じかテストしました。 他の Jest でテスト可能なものについては、Using Matcher を参照してください。
コマンドラインからの実行​
Jest は、CLI から様々な便利なオプションを付けて、直接実行できます。 （実行するためには、例えば yarn global add jestまたはnpm install jest --global でインストールし、PATH でグローバルに利用可能になっている必要があります。 ）
ここでは my-test を Jest で実行し、実行後に OS の通知を表示する方法を示します。 そのとき構成ファイルとして config.json を使用します。
jest my-test --notify --config=config.json
コマンドラインから Jest を実行する方法の詳細については、Jest CLI Options を参考にしてください。
追加設定​
基本の設定ファイルを生成する​
次のコマンドを実行すると、Jest はあなたのプロジェクトの構成に基づいたいくつかの質問をし、その回答から短いコメント付きの基本の設定ファイルを生成します。
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Babel を使用する​
Babel を使用するために、yarn で必要な依存関係をインストールしてください。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Node.jsの現在のバージョンをターゲットにするためにBabelを定義するには、babel.config.jsというファイルをプロジェクトのルートに作ってください。
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Babelの設定にJestを認識させるJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. これを避けるには、 transform設定を明示的にリセットして下さい。jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Webpack を使用する​
Jestは webpackでアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 webpack は他のツールよりもユニークで挑戦的な機能を提供しています。 具体的な使い方は webpack guide を参照してください。
Vite を使用する​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jestは parcel-bundleで webpack と同様にアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 Parcelは設定が不要です。 使用を開始するには公式ドキュメントを参照してください。
TypeScript を使用する​
babel 経由で​
Jest は Babel 経由で TypeScript をサポートしています。 まず、 Babelを使用するを確認してください。 次に、@babel/preset-typescript をインストールします。
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
最後に、@babel/preset-typescript を babel.config.js 内のプリセットのリストに追加してください。
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
BabelでTypeScriptを使う場合、いくつかの注意事項があります。 BabelはTypescriptを純粋なトランスパイルによりサポートしているため、Jestはテストの実行時にテストコードの型検査を行いません。 型検査を行いたい場合、代わりに ts-jest を使用するか、TypeScriptコンパイラ のtsc をテストとは別に(またはビルドプロセスの一部として)使用してください。
ts-jest 経由で​
ts-jestはJest用のソースマップをサポートするTypeScriptプリプロセッサです。こちらを使うことで、TypeScriptで書かれたプロジェクトをJestでテストできるようになります。
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}このページを編集NextMatcherを使用するコマンドラインからの実行追加設定基本の設定ファイルを生成するBabel を使用するUsing with bundlersWebpack を使用するVite を使用するUsing ParcelTypeScript を使用するUsing ESLint\n\n\n\nIntroducciónEmpezandoVersion: NextOn this pageEmpezandoInstale Jest usando su administrador de paquetes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Empecemos escribiendo una prueba para una función hipotética que suma dos números. Primero, crea un archivo suma.js:
function suma(a, b) {  return a + b;}module.exports = suma;
Luego, crea un archivo llamado suma.test.js. Este contendrá nuestra prueba actual:
const suma = require('./suma');test('sumar 1 + 2 es igual a 3', () => {  expect(suma(1, 2)).toBe(3);});
Agrega la siguiente sección a tu package.json:
{  "scripts": {    "test": "jest"  }}
Finalmente, ejecuta yarn test o npm test y Jest imprimirá en la pantalla este mensaje:
PASS  ./suma.test.js✓ sumar 1 + 2 es igual a 3 (5ms)
¡Acabas de escribir tu primera prueba usando Jest!
Esta prueba usa expect y toBe para probar que dos valores son exactamente idénticos. Para aprender sobre otras cosas que Jest puede probar, mira Usando Matchers.
Ejecutando desde la línea de comandos​
Puedes ejecutar Jest directamente desde la CLI (si está disponible globalmente en tu PATH, p.e. con yarn global add jest o npm install jest --global) con varias opciones útiles.
Así es como puedes correr Jest en archivos que coinciden my-test, usando config.json como archivo de configuración y mostrar una notificación nativa del SO después de ejecutarlo:
jest my-test --notify --config=config.json
Si quieres aprender más sobre correr jest a través de la línea de comandos, hecha una mirada a la página de Opciones de Jest CLI.
Configuración Adicional​
Genera un fichero de configuración básico​
Basado en tu proyecto, Jest te hará algunas preguntas y creará un archivo de configuración básica con una corta descripción por cada opción:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale las dependencias requeridas:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configura Babel para tu versión actual de Node creando un fichero babel.config.js en la raíz de tu proyecto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuración ideal para Babel dependerá de tu proyecto. Consulte la documentación de Babel para obtener más detalles.
Haz que tu configuración de Babel sepa que usas JestJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest se instala automáticamente al instalar Jest y transformará automáticamente los archivos si existe una configuración de Babel en su proyecto. Para evitar este comportamiento, puede restablecer explícitamente la opción de configuración de transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Usando webpack​
Jest puede ser usado en proyectos que usan webpack para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos sobre otras herramientas. Consulta la documentación oficial para comenzar.
Usando Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest puede ser usado en proyectos que usan parcel para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos por sobre otras herramientas. Refer to the official docs to get started.
Usando TypeScript​
Via babel​
Jest soporta TypeScript, a través de Babel. Primero, asegúrate de haber seguido las intrucciones en Usando Babel de arriba. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Luego agrega @babel/preset-typescript a la lista de presets en tu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Existen algunas cosas que debes tener en cuenta cuando uses TypeScript con Babel. Dado que el soporte de TypeScript en Babel se limita a la transpilación, Jest no comprobará los tipos de tus tests cuando éstos se ejecuten. Si lo deseas, puedes utilizar ts-jest o simplemente ejecutar el compilador de TypeScript por separado (como parte del proceso de compilación).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this page\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroducciónEmpezandoVersion: NextOn this pageEmpezandoInstale Jest usando su administrador de paquetes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Empecemos escribiendo una prueba para una función hipotética que suma dos números. Primero, crea un archivo suma.js:
function suma(a, b) {  return a + b;}module.exports = suma;
Luego, crea un archivo llamado suma.test.js. Este contendrá nuestra prueba actual:
const suma = require('./suma');test('sumar 1 + 2 es igual a 3', () => {  expect(suma(1, 2)).toBe(3);});
Agrega la siguiente sección a tu package.json:
{  "scripts": {    "test": "jest"  }}
Finalmente, ejecuta yarn test o npm test y Jest imprimirá en la pantalla este mensaje:
PASS  ./suma.test.js✓ sumar 1 + 2 es igual a 3 (5ms)
¡Acabas de escribir tu primera prueba usando Jest!
Esta prueba usa expect y toBe para probar que dos valores son exactamente idénticos. Para aprender sobre otras cosas que Jest puede probar, mira Usando Matchers.
Ejecutando desde la línea de comandos​
Puedes ejecutar Jest directamente desde la CLI (si está disponible globalmente en tu PATH, p.e. con yarn global add jest o npm install jest --global) con varias opciones útiles.
Así es como puedes correr Jest en archivos que coinciden my-test, usando config.json como archivo de configuración y mostrar una notificación nativa del SO después de ejecutarlo:
jest my-test --notify --config=config.json
Si quieres aprender más sobre correr jest a través de la línea de comandos, hecha una mirada a la página de Opciones de Jest CLI.
Configuración Adicional​
Genera un fichero de configuración básico​
Basado en tu proyecto, Jest te hará algunas preguntas y creará un archivo de configuración básica con una corta descripción por cada opción:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale las dependencias requeridas:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configura Babel para tu versión actual de Node creando un fichero babel.config.js en la raíz de tu proyecto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuración ideal para Babel dependerá de tu proyecto. Consulte la documentación de Babel para obtener más detalles.
Haz que tu configuración de Babel sepa que usas JestJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest se instala automáticamente al instalar Jest y transformará automáticamente los archivos si existe una configuración de Babel en su proyecto. Para evitar este comportamiento, puede restablecer explícitamente la opción de configuración de transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Usando webpack​
Jest puede ser usado en proyectos que usan webpack para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos sobre otras herramientas. Consulta la documentación oficial para comenzar.
Usando Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest puede ser usado en proyectos que usan parcel para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos por sobre otras herramientas. Refer to the official docs to get started.
Usando TypeScript​
Via babel​
Jest soporta TypeScript, a través de Babel. Primero, asegúrate de haber seguido las intrucciones en Usando Babel de arriba. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Luego agrega @babel/preset-typescript a la lista de presets en tu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Existen algunas cosas que debes tener en cuenta cuando uses TypeScript con Babel. Dado que el soporte de TypeScript en Babel se limita a la transpilación, Jest no comprobará los tipos de tus tests cuando éstos se ejecuten. Si lo deseas, puedes utilizar ts-jest o simplemente ejecutar el compilador de TypeScript por separado (como parte del proceso de compilación).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageNextUtilizando ComparadoresEjecutando desde la línea de comandosConfiguración AdicionalGenera un fichero de configuración básicoUsando BabelUsing with bundlersUsando webpackUsando ViteUsing ParcelUsando TypeScriptUsing ESLint\n\n\n\nIntroductionPremiers pasVersion : SuivantSur cette pagePremiers pasInstallez Jest en utilisant votre gestionnaire de paquets favori :
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Commençons par écrire un test pour une hypothétique fonction qui additionne deux nombres. Tout d’abord, créez un fichier sum.js :
function sum(a, b) {  return a + b;}module.exports = sum;
Ensuite, créez un fichier nommé sum.test.js. Il s'agit de notre test actuel :
test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Ajoutez la section suivante à votre package.json :
{  "scripts": {    "test": "jest"  }}
Enfin, lancez yarn test ou npm test et Jest affichera ce message :
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Vous venez d'écrire votre premier test avec Jest avec succès !
Ce test utilise expect et toBe pour tester que deux valeurs sont exactement identiques. Pour connaître les autres éléments que Jest peut tester, consultez Utilisation des comparateurs.
Exécution en mode ligne de commande​
Vous pouvez exécuter Jest directement depuis le CLI (si celui-ci est globalement disponible dans votre PATH, par exemple yarn global add jest ou npm install jest --global) avec une variété d'options utiles.
Voici comment exécuter Jest sur des fichiers correspondant à my-test, en utilisant config.json comme fichier de configuration et afficher une notification de l'OS natif après l'exécution :
jest my-test --notify --config=config.json
Si vous souhaitez en apprendre davantage sur l'exécution de jest en mode ligne de commande, consultez la page Options CLI de Jest.
Configuration additionnelle​
Générez un fichier de configuration de base​
Basé sur votre projet, Jest vous posera quelques questions et créera un fichier de configuration de base avec une courte description pour chaque option :
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Utilisez Babel​
Pour utiliser Babel, installez les dépendances requises :
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configurez Babel pour cibler votre version actuelle de Node en créant un fichier babel.config.js à la racine de votre projet :
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuration idéale pour Babel dépendra de votre projet. Consultez la documentation de Babel pour plus de détails.
Faites en sorte que votre configuration Babel soit adaptée à JestJest définira process.env.NODE_ENV avec 'test' s'il n'est pas défini avec quelque chose d'autre. Vous pouvez l'utiliser dans votre configuration pour paramétrer de manière conditionnelle uniquement la compilation nécessaire pour Jest, par exemple.babel.config.jsmodule.exports = api => {  const isTest = api. nv('test');  // Vous pouvez utiliser isTest pour déterminer les presets et les plugins à utiliser.  return {    // ...  };};remarquebabel-jest est automatiquement installé lorsque vous installez Jest et transformera automatiquement les fichiers si une configuration de babel existe dans votre projet. Pour éviter ce résultat, vous pouvez réinitialiser explicitement l'option de configuration transform :jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Utilisez Webpack​
Jest peut être utilisé dans les projets qui utilisent webpack pour gérer les ressources, les styles et la compilation. webpack offre quelques défis singuliers par rapport à d'autres outils. Consultez le guide webpack pour commencer.
Utilisation de Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Utilisation de Parcel​
Jest peut être utilisé dans les projets qui utilisent parcel-bundler pour gérer les ressources, les styles et la compilation de manière similaire à webpack. Parcel nécessite aucune configuration. Reportez-vous à la documentation officielle pour commencer.
Utilisez TypeScript​
Via babel​
Jest prend en charge TypeScript, via Babel. Tout d'abord, assurez-vous d'avoir suivi les instructions sur l'utilisation de Babel ci-dessus. Ensuite, installez @babel/preset-typescript :
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Ensuite, ajoutez @babel/preset-typescript à la liste des presets dans votre babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Toutefois, l'utilisation de TypeScript avec Babel présente quelques inconvénients. La prise en charge de TypeScript dans Babel étant purement une transpilation, Jest ne vérifiera pas le typage de vos tests lors de leur exécution. Si vous souhaitez cela, vous pouvez à la place utiliser ts-jest, ou simplement exécuter le compilateur TypeScript tsc séparément (ou dans le prolongement de votre processus de construction).
Via ts-jest​
ts-jest est un préprocesseur TypeScript avec la prise en charge de source map pour Jest qui vous permet d'utiliser Jest pour tester les projets écrits en TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Afin que Jest puisse transpiler TypeScript avec ts-jest, vous aurez besoin de créer un fichier de configuration .
Définitions de type​
Il existe deux façons d'avoir les API globales Jest typées pour les fichiers de test écrits en TypeScript.
Vous pouvez utiliser les définitions de types qui sont livrées avec Jest et seront mises à jour chaque fois que vous mettez à jour Jest. Installez le paquet @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Et importez les API depuis le paquet :
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
astuceConsultez la documentation d'utilisation supplémentaire de describe.each/test.each et des fonctions simulées.
Ou vous pouvez choisir d'installer le paquet @types/jest. Il fournit des types pour les globales Jest sans devoir les importer.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Essayez de faire correspondre les versions de Jest et @types/jest aussi proche que possible. Par exemple, si vous utilisez Jest 27.4.0 alors l'installation 27.4.x de @types/jest est idéal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Modifier cette page\n\nCeci est une documentation non publiée pour la version Suivant de Jest.Pour une documentation à jour, consultez la dernière version (29.7).IntroductionPremiers pasVersion : SuivantSur cette pagePremiers pasInstallez Jest en utilisant votre gestionnaire de paquets favori :
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Commençons par écrire un test pour une hypothétique fonction qui additionne deux nombres. Tout d’abord, créez un fichier sum.js :
function sum(a, b) {  return a + b;}module.exports = sum;
Ensuite, créez un fichier nommé sum.test.js. Il s'agit de notre test actuel :
test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Ajoutez la section suivante à votre package.json :
{  "scripts": {    "test": "jest"  }}
Enfin, lancez yarn test ou npm test et Jest affichera ce message :
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Vous venez d'écrire votre premier test avec Jest avec succès !
Ce test utilise expect et toBe pour tester que deux valeurs sont exactement identiques. Pour connaître les autres éléments que Jest peut tester, consultez Utilisation des comparateurs.
Exécution en mode ligne de commande​
Vous pouvez exécuter Jest directement depuis le CLI (si celui-ci est globalement disponible dans votre PATH, par exemple yarn global add jest ou npm install jest --global) avec une variété d'options utiles.
Voici comment exécuter Jest sur des fichiers correspondant à my-test, en utilisant config.json comme fichier de configuration et afficher une notification de l'OS natif après l'exécution :
jest my-test --notify --config=config.json
Si vous souhaitez en apprendre davantage sur l'exécution de jest en mode ligne de commande, consultez la page Options CLI de Jest.
Configuration additionnelle​
Générez un fichier de configuration de base​
Basé sur votre projet, Jest vous posera quelques questions et créera un fichier de configuration de base avec une courte description pour chaque option :
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Utilisez Babel​
Pour utiliser Babel, installez les dépendances requises :
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configurez Babel pour cibler votre version actuelle de Node en créant un fichier babel.config.js à la racine de votre projet :
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuration idéale pour Babel dépendra de votre projet. Consultez la documentation de Babel pour plus de détails.
Faites en sorte que votre configuration Babel soit adaptée à JestJest définira process.env.NODE_ENV avec 'test' s'il n'est pas défini avec quelque chose d'autre. Vous pouvez l'utiliser dans votre configuration pour paramétrer de manière conditionnelle uniquement la compilation nécessaire pour Jest, par exemple.babel.config.jsmodule.exports = api => {  const isTest = api. nv('test');  // Vous pouvez utiliser isTest pour déterminer les presets et les plugins à utiliser.  return {    // ...  };};remarquebabel-jest est automatiquement installé lorsque vous installez Jest et transformera automatiquement les fichiers si une configuration de babel existe dans votre projet. Pour éviter ce résultat, vous pouvez réinitialiser explicitement l'option de configuration transform :jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Utilisez Webpack​
Jest peut être utilisé dans les projets qui utilisent webpack pour gérer les ressources, les styles et la compilation. webpack offre quelques défis singuliers par rapport à d'autres outils. Consultez le guide webpack pour commencer.
Utilisation de Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Utilisation de Parcel​
Jest peut être utilisé dans les projets qui utilisent parcel-bundler pour gérer les ressources, les styles et la compilation de manière similaire à webpack. Parcel nécessite aucune configuration. Reportez-vous à la documentation officielle pour commencer.
Utilisez TypeScript​
Via babel​
Jest prend en charge TypeScript, via Babel. Tout d'abord, assurez-vous d'avoir suivi les instructions sur l'utilisation de Babel ci-dessus. Ensuite, installez @babel/preset-typescript :
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Ensuite, ajoutez @babel/preset-typescript à la liste des presets dans votre babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Toutefois, l'utilisation de TypeScript avec Babel présente quelques inconvénients. La prise en charge de TypeScript dans Babel étant purement une transpilation, Jest ne vérifiera pas le typage de vos tests lors de leur exécution. Si vous souhaitez cela, vous pouvez à la place utiliser ts-jest, ou simplement exécuter le compilateur TypeScript tsc séparément (ou dans le prolongement de votre processus de construction).
Via ts-jest​
ts-jest est un préprocesseur TypeScript avec la prise en charge de source map pour Jest qui vous permet d'utiliser Jest pour tester les projets écrits en TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Afin que Jest puisse transpiler TypeScript avec ts-jest, vous aurez besoin de créer un fichier de configuration .
Définitions de type​
Il existe deux façons d'avoir les API globales Jest typées pour les fichiers de test écrits en TypeScript.
Vous pouvez utiliser les définitions de types qui sont livrées avec Jest et seront mises à jour chaque fois que vous mettez à jour Jest. Installez le paquet @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Et importez les API depuis le paquet :
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
astuceConsultez la documentation d'utilisation supplémentaire de describe.each/test.each et des fonctions simulées.
Ou vous pouvez choisir d'installer le paquet @types/jest. Il fournit des types pour les globales Jest sans devoir les importer.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Essayez de faire correspondre les versions de Jest et @types/jest aussi proche que possible. Par exemple, si vous utilisez Jest 27.4.0 alors l'installation 27.4.x de @types/jest est idéal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Modifier cette pageSuivantUtilisation des comparateursExécution en mode ligne de commandeConfiguration additionnelleGénérez un fichier de configuration de baseUtilisez BabelUsing with bundlersUtilisez WebpackUtilisation de ViteUtilisation de ParcelUtilisez TypeScriptUsing ESLint\n\n\n\nIntroduçãoIniciandoVersão: PróximoOn this pageIniciandoInstale Jest usando seu gerenciador de pacotes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Vamos começar por escrever um teste para uma função hipotética que soma dois números. Primeiro, crie um arquivo sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Em seguida, crie um arquivo chamado sum.test.js. Este irá conter o nosso teste real:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adicione a seguinte seção ao seu package.json:
{  "scripts": {    "test": "jest"  }}
Por fim, execute yarn test ou npm run test e o Jest irá imprimir a seguinte mensagem:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Você escreveu com sucesso seu primeiro teste usando Jest!
Este teste usou expect e toBe para testar que dois valores eram exatamente idênticos. Para saber mais sobre as outras coisas que Jest pode testar, consulte Usando Matchers.
Executando a partir da linha de comando​
Você pode executar Jest diretamente da CLI (se ele estiver disponível globalmente em seu PATH, por exemplo: yarn global add jest ou npm install -g jest) com uma variedade de comandos úteis.
Aqui vemos como executar Jest em arquivos que correspondam ao my-test, usando config.json como um arquivo de configuração e exibir uma notificação nativa no Sistema Operacional após a execução:
jest my-test --notify --config=config.json
Se você gostaria de aprender mais sobre como executar jest através da linha de comando, dê uma olhada na página  Opções de CLI Jest.
Configuração adicional​
Gerando um arquivo de configuração básico​
Com base no seu projeto, o Jest fará algumas perguntas e irá criar um arquivo básico de configuração com uma breve descrição para cada opção:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale as dependências necessárias:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure o Babel para marcar a sua versão atual do Node criando um arquivo babel.config.js na raiz do seu projeto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
A configuração ideal para o Babel dependerá do seu projeto. Veja a documentação do Babel para mais detalhes.
Making your Babel config jest-awareJest definirá process.env.NODE_ENV para 'test' se não estiver definido para outra coisa. Você pode usar isso em sua configuração para configurar condicionalmente apenas a compilação necessária para Jest, por exemplo.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest é instalado automaticamente quando instalar Jest e irá automaticamente transformar arquivos caso uma configuração de babel existir em seu projeto. Para evitar esse comportamento, você pode redefinir explicitamente a opção de configuração de transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Usando webpack​
Jest pode ser usado em projetos que usam webpack para gerenciar assets, estilos e compilação. webpack oferece alguns desafios únicos em relação à outras ferramentas. Consulte o guia do webpack para começar.
Usando Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Usando Parcel​
Jest pode ser usado em projetos que usam parcel-bundler para gerenciar ativos, estilos, e compilação semelhante ao webpack. Parcel requer configuração zero. Veja a documentação oficial para começar.
Usando TypeScript​
Via babel​
O Jest suporta TypeScript, via Babel. Primeiro certifique-se que você seguir as instruções em usando o Babel acima. Em seguida, instale o @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Então adicione o @babel/preset-typescript à lista de presets em seu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
No entanto, há algumas ressalvas para usar TypeScript com Babel. Como o suporte para TypeScript em Babel é puramente transpilação, Jest não irá checar seus testes enquanto eles são executados. Se você quiser isso, você pode usar ts-jest em vez disso. ou apenas execute o compilador TypeScript tsc separadamente (ou como parte de seu processo de compilação).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Para que Jest interprete TypeScript com ts-jest, talvez você precise criar um arquivo de configuração.
Definições de tipo​
Existem duas maneiras de ter Jest global APIs tipado para arquivos de teste escritos em TypeScript.
Você pode usar as definições de tipo que já vem com o Jest e serão atualizadas a cada vez que você atualizar o Jest. Instale o pacote @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
E importe as APIs de:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipVeja a documentação de uso adicional de describe.each/test.each e funções de simulação (mock, em inglês).
Ou você pode escolher instalar o pacote @types/jest. Ele fornece tipos para os globais do Jest sem necessidade de importá-los.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
informação@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Tente coincidir com versões do Jest e @types/jest o mais próximo possível. Por exemplo, se você estiver usando a versão 27.4.0 do jest, então instalar 27.4.x de @types/jest é ideal.
Usando ESLint​
Jest pode ser usado com o ESLint sem qualquer configuração adicional, desde que você importe os ajudantes globais do Jest (describe, it, etc.) do @jest/globals antes de usá-los em seus arquivos de teste. Isso é necessário para evitar erros no-undef do ESLint, que não conhece sobre os globais do Jest.
Se quiser evitar essas importações, você pode configurar seu ambiente ESLint para suportar esses globais adicionando o ambiente jest:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Ou usar o eslint-plugin-jest que tem um efeito similar:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Editar esta página\n\nEssa documentação não foi lançada para a versão Jest Próximo.For up-to-date documentation, see the última versão (29.7).IntroduçãoIniciandoVersão: PróximoOn this pageIniciandoInstale Jest usando seu gerenciador de pacotes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Vamos começar por escrever um teste para uma função hipotética que soma dois números. Primeiro, crie um arquivo sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Em seguida, crie um arquivo chamado sum.test.js. Este irá conter o nosso teste real:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adicione a seguinte seção ao seu package.json:
{  "scripts": {    "test": "jest"  }}
Por fim, execute yarn test ou npm run test e o Jest irá imprimir a seguinte mensagem:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Você escreveu com sucesso seu primeiro teste usando Jest!
Este teste usou expect e toBe para testar que dois valores eram exatamente idênticos. Para saber mais sobre as outras coisas que Jest pode testar, consulte Usando Matchers.
Executando a partir da linha de comando​
Você pode executar Jest diretamente da CLI (se ele estiver disponível globalmente em seu PATH, por exemplo: yarn global add jest ou npm install -g jest) com uma variedade de comandos úteis.
Aqui vemos como executar Jest em arquivos que correspondam ao my-test, usando config.json como um arquivo de configuração e exibir uma notificação nativa no Sistema Operacional após a execução:
jest my-test --notify --config=config.json
Se você gostaria de aprender mais sobre como executar jest através da linha de comando, dê uma olhada na página  Opções de CLI Jest.
Configuração adicional​
Gerando um arquivo de configuração básico​
Com base no seu projeto, o Jest fará algumas perguntas e irá criar um arquivo básico de configuração com uma breve descrição para cada opção:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Usando Babel​
Para usar Babel, instale as dependências necessárias:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure o Babel para marcar a sua versão atual do Node criando um arquivo babel.config.js na raiz do seu projeto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
A configuração ideal para o Babel dependerá do seu projeto. Veja a documentação do Babel para mais detalhes.
Making your Babel config jest-awareJest definirá process.env.NODE_ENV para 'test' se não estiver definido para outra coisa. Você pode usar isso em sua configuração para configurar condicionalmente apenas a compilação necessária para Jest, por exemplo.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest é instalado automaticamente quando instalar Jest e irá automaticamente transformar arquivos caso uma configuração de babel existir em seu projeto. Para evitar esse comportamento, você pode redefinir explicitamente a opção de configuração de transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Usando webpack​
Jest pode ser usado em projetos que usam webpack para gerenciar assets, estilos e compilação. webpack oferece alguns desafios únicos em relação à outras ferramentas. Consulte o guia do webpack para começar.
Usando Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Usando Parcel​
Jest pode ser usado em projetos que usam parcel-bundler para gerenciar ativos, estilos, e compilação semelhante ao webpack. Parcel requer configuração zero. Veja a documentação oficial para começar.
Usando TypeScript​
Via babel​
O Jest suporta TypeScript, via Babel. Primeiro certifique-se que você seguir as instruções em usando o Babel acima. Em seguida, instale o @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Então adicione o @babel/preset-typescript à lista de presets em seu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
No entanto, há algumas ressalvas para usar TypeScript com Babel. Como o suporte para TypeScript em Babel é puramente transpilação, Jest não irá checar seus testes enquanto eles são executados. Se você quiser isso, você pode usar ts-jest em vez disso. ou apenas execute o compilador TypeScript tsc separadamente (ou como parte de seu processo de compilação).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Para que Jest interprete TypeScript com ts-jest, talvez você precise criar um arquivo de configuração.
Definições de tipo​
Existem duas maneiras de ter Jest global APIs tipado para arquivos de teste escritos em TypeScript.
Você pode usar as definições de tipo que já vem com o Jest e serão atualizadas a cada vez que você atualizar o Jest. Instale o pacote @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
E importe as APIs de:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipVeja a documentação de uso adicional de describe.each/test.each e funções de simulação (mock, em inglês).
Ou você pode escolher instalar o pacote @types/jest. Ele fornece tipos para os globais do Jest sem necessidade de importá-los.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
informação@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Tente coincidir com versões do Jest e @types/jest o mais próximo possível. Por exemplo, se você estiver usando a versão 27.4.0 do jest, então instalar 27.4.x de @types/jest é ideal.
Usando ESLint​
Jest pode ser usado com o ESLint sem qualquer configuração adicional, desde que você importe os ajudantes globais do Jest (describe, it, etc.) do @jest/globals antes de usá-los em seus arquivos de teste. Isso é necessário para evitar erros no-undef do ESLint, que não conhece sobre os globais do Jest.
Se quiser evitar essas importações, você pode configurar seu ambiente ESLint para suportar esses globais adicionando o ambiente jest:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Ou usar o eslint-plugin-jest que tem um efeito similar:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Editar esta páginaPróximoUsando MatchersExecutando a partir da linha de comandoConfiguração adicionalGerando um arquivo de configuração básicoUsando BabelUsing with bundlersUsando webpackUsando ViteUsando ParcelUsando TypeScriptUsando ESLint\n\n\n\nIntroducerePrimii pașiVersion: ÎnainteOn this pagePrimii pașiInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adăugați secțiunea următoare în fișierul vostru package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Tocmai ați scris cu succes primul test folosind Jest!
Testul acesta a folosit expect și toBe pentru a testa dacă două valori sunt identice. Pentru a afla mai multe lucruri pe care Jest le poate testa, vezi Utilizarea regulilor de potrivire.
Rularea din linia de comandă​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Iată cum să executaţi Jest pe fişierele my-test, folosind config.json ca fişier de configurare şi afişarea unei notificări native de sistem după rulare:
jest my-test --notify --config=config.json
Dacă doriţi să aflaţi mai multe despre rularea jest prin linia de comandă, vezi pagina de Opțiuni Jest pentru linia de comandă.
Informații suplimentare​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Folosind Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Pentru a evita acest comportament, aveţi posibilitatea să reiniţializaţi explicit opţiunea de configurare transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Folosind Webpack​
Jest poate fi utilizat în proiecte care folosesc webpack pentru gestionarea fișierelor statice, stiluri şi compilare. webpack oferă unele provocări unice față de alte instrumente. Urmați ghidul webpack pentru a începe.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Folosind TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this page\n\nThis is unreleased documentation for Jest Înainte version.For up-to-date documentation, see the latest version (29.7).IntroducerePrimii pașiVersion: ÎnainteOn this pagePrimii pașiInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adăugați secțiunea următoare în fișierul vostru package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Tocmai ați scris cu succes primul test folosind Jest!
Testul acesta a folosit expect și toBe pentru a testa dacă două valori sunt identice. Pentru a afla mai multe lucruri pe care Jest le poate testa, vezi Utilizarea regulilor de potrivire.
Rularea din linia de comandă​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Iată cum să executaţi Jest pe fişierele my-test, folosind config.json ca fişier de configurare şi afişarea unei notificări native de sistem după rulare:
jest my-test --notify --config=config.json
Dacă doriţi să aflaţi mai multe despre rularea jest prin linia de comandă, vezi pagina de Opțiuni Jest pentru linia de comandă.
Informații suplimentare​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Folosind Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Pentru a evita acest comportament, aveţi posibilitatea să reiniţializaţi explicit opţiunea de configurare transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Folosind Webpack​
Jest poate fi utilizat în proiecte care folosesc webpack pentru gestionarea fișierelor statice, stiluri şi compilare. webpack oferă unele provocări unice față de alte instrumente. Urmați ghidul webpack pentru a începe.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Folosind TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageÎnainteUtilizarea regulilor de potrivireRularea din linia de comandăInformații suplimentareGenerate a basic configuration fileFolosind BabelUsing with bundlersFolosind WebpackUsing ViteUsing ParcelFolosind TypeScriptUsing ESLint\n\n\n\nВведениеНачало работыVersion: ДалееOn this pageНачало работыУстановите Jest используя ваш любимый менеджер пакетов:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Для начала напишем тест для функции, которая складывает два числа. Во-первых создайте файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Затем создайте файл с именем sum.test.js. Он будет содержать сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Добавьте следующий раздел в package.json:
{  "scripts": {    "test": "jest"  }}
Наконец, запустите yarn test или npm run test и Jest выведет это сообщение:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Вы только что успешно написали первый тест с использованием Jest!
Данный тест использует expect и toBe для проверки идентичности двух данных значений. Чтобы узнать об остальных вещах, которые можно протестировать с использованием Jest, смотрите использование сопоставлений.
Запуск из командной строки​
Вы можете запустить Jest прямо из командной строки (если он глобально доступен в PATH, например yarn global add jest или npm install jest --global) с множеством полезных опций.
Вот так можно запустить Jest для проверки файлов совпадающих с my-test, используя config.json в качестве файла конфигурации и для отображения нативного уведомления ОС после завершения:
jest my-test --notify --config=config.json
Если вы хотите узнать больше о работе с jest в командной строке, обратите внимание на страницу параметров командной строки Jest.
Дополнительная конфигурация​
Создание базового файла конфигурации​
Исходя из ваших нужд, Jest задаст вам несколько вопросов и создаст базовый файл конфигурации с кратким описанием для каждой опции:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
С использованием Babel​
Для использования с Babel, установите необходимые зависимости через yarn:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Настройте Babel на вашу текущую версию Node Js, создав файл babel.config.js в корне вашего проекта:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Идеальная конфигурация Babel будет зависеть от вашего проекта. Дополнительную информацию см. в документации Babe.l.
Добавление отдельной конфигурации для Babel только на время запуска JestJest автоматически установит для process.env.NODE_ENV значение 'test' если не указано другое. Вы можете использовать эту опцию, чтобы добавить настройки, которые будут использоваться только во время запуска Jest, например:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Для обхода данного поведения, вы можете явно сбросить опцию transform в конфигурации:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
С использованием Webpack​
Jest может использоваться в проектах, использующих webpack для управления ресурсами, стилями и компиляцией. Webpack действительно привносит некоторые особенности, способные создать проблемы программистам, в сравнении с другими инструментами. Обратитесь к разделу руководство по работе с Webpack для начала работы с ним.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest может использоваться в проектах, использующих parcel-bundler для управления изображениями, стилями и компиляцией аналогично webpack Parcel не требует настройки Обратитесь к официальной документации для начала работы.
С использованием TypeScript​
Через babel​
Jest поддерживает TypeScript, через Babel. Сначала убедитесь, что вы следовали инструкциям по настройке Babel выше. Далее установите @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Затем добавьте @babel/preset-typescript в список пресетов в ваш babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Однако, есть несколько подводных камней в использовании TypeScript вместе с Babel. Поскольку TypeScript поддерживается в Babel через транспиляцию, Jest не будет проверять типы ваших тестах когда они запущены. Если вы хотите, то вы можете использовать ts-jest взамен, или просто запустите компилятор TypeScript tsc отдельно (или как часть вашего процесса сборки).
Через ts-jest​
ts-jest это препроцессор TypeScript с поддержкой исходных карт Jest, который позволяет использовать Jest для тестирования проектов, написанных на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Определения типов​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
И импортируйте API из него:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Использование ESLint​
Jest может использоваться с ESLint без дальнейшей конфигурации при импорте Jest global helpers (Описание, это, и т. д.) из @jest/globals перед использованием их в вашем тестовом файле. Это необходимо для того, чтобы избежать ошибок no-undef от ESLint, которые не знают о глобальных системах Jest.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редактировать страницу\n\nЭто неизданная документация для версии Jest Далее.Для получения актуальной документации обратитесь к последняя версия (29.7).ВведениеНачало работыVersion: ДалееOn this pageНачало работыУстановите Jest используя ваш любимый менеджер пакетов:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Для начала напишем тест для функции, которая складывает два числа. Во-первых создайте файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Затем создайте файл с именем sum.test.js. Он будет содержать сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Добавьте следующий раздел в package.json:
{  "scripts": {    "test": "jest"  }}
Наконец, запустите yarn test или npm run test и Jest выведет это сообщение:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Вы только что успешно написали первый тест с использованием Jest!
Данный тест использует expect и toBe для проверки идентичности двух данных значений. Чтобы узнать об остальных вещах, которые можно протестировать с использованием Jest, смотрите использование сопоставлений.
Запуск из командной строки​
Вы можете запустить Jest прямо из командной строки (если он глобально доступен в PATH, например yarn global add jest или npm install jest --global) с множеством полезных опций.
Вот так можно запустить Jest для проверки файлов совпадающих с my-test, используя config.json в качестве файла конфигурации и для отображения нативного уведомления ОС после завершения:
jest my-test --notify --config=config.json
Если вы хотите узнать больше о работе с jest в командной строке, обратите внимание на страницу параметров командной строки Jest.
Дополнительная конфигурация​
Создание базового файла конфигурации​
Исходя из ваших нужд, Jest задаст вам несколько вопросов и создаст базовый файл конфигурации с кратким описанием для каждой опции:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
С использованием Babel​
Для использования с Babel, установите необходимые зависимости через yarn:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Настройте Babel на вашу текущую версию Node Js, создав файл babel.config.js в корне вашего проекта:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Идеальная конфигурация Babel будет зависеть от вашего проекта. Дополнительную информацию см. в документации Babe.l.
Добавление отдельной конфигурации для Babel только на время запуска JestJest автоматически установит для process.env.NODE_ENV значение 'test' если не указано другое. Вы можете использовать эту опцию, чтобы добавить настройки, которые будут использоваться только во время запуска Jest, например:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. Для обхода данного поведения, вы можете явно сбросить опцию transform в конфигурации:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
С использованием Webpack​
Jest может использоваться в проектах, использующих webpack для управления ресурсами, стилями и компиляцией. Webpack действительно привносит некоторые особенности, способные создать проблемы программистам, в сравнении с другими инструментами. Обратитесь к разделу руководство по работе с Webpack для начала работы с ним.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest может использоваться в проектах, использующих parcel-bundler для управления изображениями, стилями и компиляцией аналогично webpack Parcel не требует настройки Обратитесь к официальной документации для начала работы.
С использованием TypeScript​
Через babel​
Jest поддерживает TypeScript, через Babel. Сначала убедитесь, что вы следовали инструкциям по настройке Babel выше. Далее установите @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Затем добавьте @babel/preset-typescript в список пресетов в ваш babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Однако, есть несколько подводных камней в использовании TypeScript вместе с Babel. Поскольку TypeScript поддерживается в Babel через транспиляцию, Jest не будет проверять типы ваших тестах когда они запущены. Если вы хотите, то вы можете использовать ts-jest взамен, или просто запустите компилятор TypeScript tsc отдельно (или как часть вашего процесса сборки).
Через ts-jest​
ts-jest это препроцессор TypeScript с поддержкой исходных карт Jest, который позволяет использовать Jest для тестирования проектов, написанных на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Определения типов​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
И импортируйте API из него:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Использование ESLint​
Jest может использоваться с ESLint без дальнейшей конфигурации при импорте Jest global helpers (Описание, это, и т. д.) из @jest/globals перед использованием их в вашем тестовом файле. Это необходимо для того, чтобы избежать ошибок no-undef от ESLint, которые не знают о глобальных системах Jest.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редактировать страницуДалееИспользование сопоставленийЗапуск из командной строкиДополнительная конфигурацияСоздание базового файла конфигурацииС использованием BabelUsing with bundlersС использованием WebpackUsing ViteUsing ParcelС использованием TypeScriptИспользование ESLint\n\n\n\nВступПочаток роботиВерсія: NextНа цій сторінціПочаток роботиВстановіть Jest за допомогою вашого улюбленого менеджера пакетів:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Давайте почнемо з написання тесту для гіпотетичної функції, яка додає два числа. Спочатку створіть файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Далі, створіть файл з назвою sum.test.js. Що буде містити сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Додайте наступну секцію до вашого package.json:
{  "scripts": {    "test": "jest"  }}
Тепер виконайте yarn test або npm test і Jest виведе це повідомлення:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Ви тільки що успішно написали свій перший тест, використовуючи Jest!
Цей тест використовує expect and toBe для перевірки, що два значення абсолютно ідентичні. Щоб дізнатися про інші речі, які Jest може тестувати, перегляньте  Використання Matchers.
Запуск з командного рядка​
Ви можете запустити Jest безпосередньо з командного рядка (якщо він доступний глобально у вашому PATH, наприклад yarn global add jest або npm install jest --global) з широким набором корисних параметрів.
Ось як можна запустити Jest для файлів, назва яких відповідає шаблону my-test, використовуючи config.json як файл конфігурації та з відображенням нативних сповіщень ОС після запуску:
jest my-test --notify --config=config.json
Щоб дізнатися більше про запуск jest з командного рядка, відвідайте сторінку параметри командного рядка Jest.
Додаткові налаштування​
Згенеруйте основний файл конфігурації​
В залежності від вашого проекту, Jest поставить вам кілька питань і створить початковий файл конфігурації з коротким описом кожного налаштування:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Використання Babel​
Щоб використовувати Babel, встановіть необхідні залежності:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Налаштуйте Babel відповідно до вашої версії Node, створивши файл babel.config.js в кореневому каталозі проекту:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Ідеальна конфігурація для Babel буде залежати від вашого проекту. Перегляньте документацію Babel для отримання додаткової інформації.
Налаштування вашої конфігурації Babel для роботи з JestJest встановлює значення 'test' в process.env.NODE_ENV, якщо не вказано інше. Ви можете використовувати це у вашій конфігурації для налаштування тільки тих параметрів компіляції, які потрібні для Jest, наприклад:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest автоматично встановлюється під час встановлення Jest і буде автоматично транслювати файли, якщо конфігурація Babel існує у вашому проєкті. Щоб відключити цю поведінку, ви можете явно очистити конфігураційни параметр transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Використання webpack​
Jest може застосовуватися в проектах, які використовують  webpack для керування ресурсами, стилями та компіляції коду. webpack кидає певні унікальні виклики для використання інших інструментів. Перегляньте посібник по роботі з webpack щоб почати його використовувати.
Використання Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Використання Parcel​
Jest може використовуватись в проектах, що використовують parсel-bundler для керування ресурсами, стилями та компіляції, подібної до webpack. Parcel вимагає нульову конфігурацію. Зверніться до офіційної документації, щоб розпочати роботу.
Використання TypeScript​
За допомогою Babel​
Jest підтримує TypeScript, за допомогою Babel. По-перше, переконайтеся, що ви дотримувались інструкцій використовуючи Babel вище. Після цього встановіть @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Тоді додайте @babel/preset-typescript до списку пресетів у вашому babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Проте, є деякі застереження щодо використання TypeScript з Babel. Оскільки TypeScript в Babel є суто транспіляцією, Jest не буде перевіряти ваші тести, коли вони будуть запущені. Якщо вам це потрібно, ви можете використовувати ts-jest , або просто запустіть компілятор TypeScript tsc окремо (або до вашої частини процесу збірки).
За допомогою ts-jest​
ts-jest це препроцесор TypeScript з пітримкою source map для Jest, який дозволяє використовувати Jest для тестування проектів, написаних на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Для того, щоб Jest переклав TypeScript за допомогою ts-jest, вам також може знадобитись файл конфігурації.
Визначення типів​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Встановіть @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Та імпортуйте з нього API:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
порадаSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редагувати цю сторінку\n\nЦе неопублікована документація для версії Jest Next.Для актуальної документації перегляньте остання версія (29.7).ВступПочаток роботиВерсія: NextНа цій сторінціПочаток роботиВстановіть Jest за допомогою вашого улюбленого менеджера пакетів:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Давайте почнемо з написання тесту для гіпотетичної функції, яка додає два числа. Спочатку створіть файл sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Далі, створіть файл з назвою sum.test.js. Що буде містити сам тест:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Додайте наступну секцію до вашого package.json:
{  "scripts": {    "test": "jest"  }}
Тепер виконайте yarn test або npm test і Jest виведе це повідомлення:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Ви тільки що успішно написали свій перший тест, використовуючи Jest!
Цей тест використовує expect and toBe для перевірки, що два значення абсолютно ідентичні. Щоб дізнатися про інші речі, які Jest може тестувати, перегляньте  Використання Matchers.
Запуск з командного рядка​
Ви можете запустити Jest безпосередньо з командного рядка (якщо він доступний глобально у вашому PATH, наприклад yarn global add jest або npm install jest --global) з широким набором корисних параметрів.
Ось як можна запустити Jest для файлів, назва яких відповідає шаблону my-test, використовуючи config.json як файл конфігурації та з відображенням нативних сповіщень ОС після запуску:
jest my-test --notify --config=config.json
Щоб дізнатися більше про запуск jest з командного рядка, відвідайте сторінку параметри командного рядка Jest.
Додаткові налаштування​
Згенеруйте основний файл конфігурації​
В залежності від вашого проекту, Jest поставить вам кілька питань і створить початковий файл конфігурації з коротким описом кожного налаштування:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Використання Babel​
Щоб використовувати Babel, встановіть необхідні залежності:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Налаштуйте Babel відповідно до вашої версії Node, створивши файл babel.config.js в кореневому каталозі проекту:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
Ідеальна конфігурація для Babel буде залежати від вашого проекту. Перегляньте документацію Babel для отримання додаткової інформації.
Налаштування вашої конфігурації Babel для роботи з JestJest встановлює значення 'test' в process.env.NODE_ENV, якщо не вказано інше. Ви можете використовувати це у вашій конфігурації для налаштування тільки тих параметрів компіляції, які потрібні для Jest, наприклад:babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest автоматично встановлюється під час встановлення Jest і буде автоматично транслювати файли, якщо конфігурація Babel існує у вашому проєкті. Щоб відключити цю поведінку, ви можете явно очистити конфігураційни параметр transform:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Використання webpack​
Jest може застосовуватися в проектах, які використовують  webpack для керування ресурсами, стилями та компіляції коду. webpack кидає певні унікальні виклики для використання інших інструментів. Перегляньте посібник по роботі з webpack щоб почати його використовувати.
Використання Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Використання Parcel​
Jest може використовуватись в проектах, що використовують parсel-bundler для керування ресурсами, стилями та компіляції, подібної до webpack. Parcel вимагає нульову конфігурацію. Зверніться до офіційної документації, щоб розпочати роботу.
Використання TypeScript​
За допомогою Babel​
Jest підтримує TypeScript, за допомогою Babel. По-перше, переконайтеся, що ви дотримувались інструкцій використовуючи Babel вище. Після цього встановіть @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Тоді додайте @babel/preset-typescript до списку пресетів у вашому babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Проте, є деякі застереження щодо використання TypeScript з Babel. Оскільки TypeScript в Babel є суто транспіляцією, Jest не буде перевіряти ваші тести, коли вони будуть запущені. Якщо вам це потрібно, ви можете використовувати ts-jest , або просто запустіть компілятор TypeScript tsc окремо (або до вашої частини процесу збірки).
За допомогою ts-jest​
ts-jest це препроцесор TypeScript з пітримкою source map для Jest, який дозволяє використовувати Jest для тестування проектів, написаних на TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Для того, щоб Jest переклав TypeScript за допомогою ts-jest, вам також може знадобитись файл конфігурації.
Визначення типів​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Встановіть @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Та імпортуйте з нього API:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
порадаSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Редагувати цю сторінкуNextВикористання матчерівЗапуск з командного рядкаДодаткові налаштуванняЗгенеруйте основний файл конфігураціїВикористання BabelUsing with bundlersВикористання webpackВикористання ViteВикористання ParcelВикористання TypeScriptUsing ESLint\n\n\n\n介绍快速开始版本：下一个在本页快速开始使用你最喜欢的包管理器安装Jest：
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
举个例子，我们先写一个两数相加的函数。 首先，创建 sum.js 文件︰
function sum(a, b) {  return a + b;}module.exports = sum;
然后，创建名为 sum.test.js 的文件。 此文件中将包含我们的实际测试︰
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
随后，将下列配置内容添加到您的 package.json：
{  "scripts": {    "test": "jest"  }}
最后，运行 yarn test 或 npm run test ，Jest将打印下面这个消息：
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
您刚刚完成了您的首个 Jest 测试！
此测试使用 expect 和 toBe 来测试两值是否一致。 要了解 Jest 能进行的更多测试，请参阅使用匹配器章节。
在命令行中运行​
你可以通过命令行直接运行Jest(前提是jest已经处于你的环境变量 PATH中，例如通过 yarn global add jest 或 npm install jest --global安装的Jest) ，并为其指定各种有用的配置项。
这里演示了如何对能匹配到 my-test 的文件运行 Jest、使用config.json 作为一个配置文件、并在运行完成后显示一个原生的操作系统通知。
jest my-test --notify --config=config.json
如果你愿意了解更多关于通过命令行运行 jest 的内容，请继续阅读 Jest CLI 选项 页面。
更多配置​
生成基础配置文件​
基于您的项目，Jest将向您提出几个问题，并将创建一个基本的配置文件，每个选项都有一个简短的说明：
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
使用 Babel​
如果需要使用 Babel，安装所需的依赖。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
可以在工程的根目录下创建一个babel.config.js文件用于配置与你当前Node版本兼容的Babel：
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Jest与Babel的协同若 process.env.NODE_ENV 未设置，Jest将把它设置为 'test' 。你可以用 if语句设置Jest执行的编译配置。例如：babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};备注babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 如果要避免这个行为，你可以显式的重置 transform 配置项：jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
使用 webpack​
Jest 可以用于使用 webpack 来管理资源、 样式和编译的项目中。 webpack 与其他工具相比多了一些独特的挑战。 参考 webpack 指南 来开始起步。
使用 Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
使用 Parcel​
Parcel是一个类似于Webpack的零配置管理资源及样式的构建工具。Jest可以在Parcel构建的项目中使用。可以去Parcel官网 尝试一下。   请查看Parcel的 官方文档 进行操作。
使用 TypeScript​
通过 babel实现​
Jest可以通过Babel支持TypeScript。 首先，在项目中正确的使用Babel。 接着，安装 @babel/preset-typescript
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
你需要添加@babel/preset-typescript的预设到babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
不过，在配合使用TypeScript与Babel时，仍然有一些 注意事项 。   因为Babel对Typescrip的支持是纯编译形式（无类型校验），因此Jest在运行测试时不会对它们进行类型检查。  如果需要类型校验，可以改用ts-jest，也可以单独运行TypeScript编译器  tsc （或作为构建过程的一部分）。
通过 ts-jest实现​
ts-jest 是一个支持 sourcemap 的 TypeScript 预处理器，让你使用 TypeScript 编写 Jest 测试项目
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
类型定义​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. 安装 @jest/globals 包：
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
然后从中导入API：
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
提示See the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
信息@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
使用 ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}编辑此页\n\n这是尚未发布的 Jest 下一个 版本文档。要查看最新文档，请参阅最新版本（29.7）。介绍快速开始版本：下一个在本页快速开始使用你最喜欢的包管理器安装Jest：
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
举个例子，我们先写一个两数相加的函数。 首先，创建 sum.js 文件︰
function sum(a, b) {  return a + b;}module.exports = sum;
然后，创建名为 sum.test.js 的文件。 此文件中将包含我们的实际测试︰
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
随后，将下列配置内容添加到您的 package.json：
{  "scripts": {    "test": "jest"  }}
最后，运行 yarn test 或 npm run test ，Jest将打印下面这个消息：
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
您刚刚完成了您的首个 Jest 测试！
此测试使用 expect 和 toBe 来测试两值是否一致。 要了解 Jest 能进行的更多测试，请参阅使用匹配器章节。
在命令行中运行​
你可以通过命令行直接运行Jest(前提是jest已经处于你的环境变量 PATH中，例如通过 yarn global add jest 或 npm install jest --global安装的Jest) ，并为其指定各种有用的配置项。
这里演示了如何对能匹配到 my-test 的文件运行 Jest、使用config.json 作为一个配置文件、并在运行完成后显示一个原生的操作系统通知。
jest my-test --notify --config=config.json
如果你愿意了解更多关于通过命令行运行 jest 的内容，请继续阅读 Jest CLI 选项 页面。
更多配置​
生成基础配置文件​
基于您的项目，Jest将向您提出几个问题，并将创建一个基本的配置文件，每个选项都有一个简短的说明：
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
使用 Babel​
如果需要使用 Babel，安装所需的依赖。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
可以在工程的根目录下创建一个babel.config.js文件用于配置与你当前Node版本兼容的Babel：
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Jest与Babel的协同若 process.env.NODE_ENV 未设置，Jest将把它设置为 'test' 。你可以用 if语句设置Jest执行的编译配置。例如：babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};备注babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 如果要避免这个行为，你可以显式的重置 transform 配置项：jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
使用 webpack​
Jest 可以用于使用 webpack 来管理资源、 样式和编译的项目中。 webpack 与其他工具相比多了一些独特的挑战。 参考 webpack 指南 来开始起步。
使用 Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
使用 Parcel​
Parcel是一个类似于Webpack的零配置管理资源及样式的构建工具。Jest可以在Parcel构建的项目中使用。可以去Parcel官网 尝试一下。   请查看Parcel的 官方文档 进行操作。
使用 TypeScript​
通过 babel实现​
Jest可以通过Babel支持TypeScript。 首先，在项目中正确的使用Babel。 接着，安装 @babel/preset-typescript
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
你需要添加@babel/preset-typescript的预设到babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
不过，在配合使用TypeScript与Babel时，仍然有一些 注意事项 。   因为Babel对Typescrip的支持是纯编译形式（无类型校验），因此Jest在运行测试时不会对它们进行类型检查。  如果需要类型校验，可以改用ts-jest，也可以单独运行TypeScript编译器  tsc （或作为构建过程的一部分）。
通过 ts-jest实现​
ts-jest 是一个支持 sourcemap 的 TypeScript 预处理器，让你使用 TypeScript 编写 Jest 测试项目
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
类型定义​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. 安装 @jest/globals 包：
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
然后从中导入API：
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
提示See the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
信息@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
使用 ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}编辑此页下一个匹配器的使用在命令行中运行更多配置生成基础配置文件使用 BabelUsing with bundlers使用 webpack使用 Vite使用 Parcel使用 TypeScript使用 ESLint\n\n\n\nIntroductionUsing MatchersVersion: NextOn this pageUsing MatchersJest uses "matchers" to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the expect API doc.
Common Matchers​
The simplest way to test a value is with exact equality.
test('two plus two is four', () => {  expect(2 + 2).toBe(4);});
In this code, expect(2 + 2) returns an "expectation" object. You typically won't do much with these expectation objects except call matchers on them. In this code, .toBe(4) is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.
toBe uses Object.is to test exact equality. If you want to check the value of an object, use toEqual:
test('object assignment', () => {  const data = {one: 1};  data['two'] = 2;  expect(data).toEqual({one: 1, two: 2});});
toEqual recursively checks every field of an object or array.
tiptoEqual ignores object keys with undefined properties, undefined array items, array sparseness, or object type mismatch. To take these into account use toStrictEqual instead.
You can also test for the opposite of a matcher using not:
test('adding positive numbers is not zero', () => {  for (let a = 1; a < 10; a++) {    for (let b = 1; b < 10; b++) {      expect(a + b).not.toBe(0);    }  }});
Truthiness​
In tests, you sometimes need to distinguish between undefined, null, and false, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.

toBeNull matches only null
toBeUndefined matches only undefined
toBeDefined is the opposite of toBeUndefined
toBeTruthy matches anything that an if statement treats as true
toBeFalsy matches anything that an if statement treats as false

For example:
test('null', () => {  const n = null;  expect(n).toBeNull();  expect(n).toBeDefined();  expect(n).not.toBeUndefined();  expect(n).not.toBeTruthy();  expect(n).toBeFalsy();});test('zero', () => {  const z = 0;  expect(z).not.toBeNull();  expect(z).toBeDefined();  expect(z).not.toBeUndefined();  expect(z).not.toBeTruthy();  expect(z).toBeFalsy();});
You should use the matcher that most precisely corresponds to what you want your code to be doing.
Numbers​
Most ways of comparing numbers have matcher equivalents.
test('two plus two', () => {  const value = 2 + 2;  expect(value).toBeGreaterThan(3);  expect(value).toBeGreaterThanOrEqual(3.5);  expect(value).toBeLessThan(5);  expect(value).toBeLessThanOrEqual(4.5);  // toBe and toEqual are equivalent for numbers  expect(value).toBe(4);  expect(value).toEqual(4);});
For floating point equality, use toBeCloseTo instead of toEqual, because you don't want a test to depend on a tiny rounding error.
test('adding floating point numbers', () => {  const value = 0.1 + 0.2;  //expect(value).toBe(0.3);           This won't work because of rounding error  expect(value).toBeCloseTo(0.3); // This works.});
Strings​
You can check strings against regular expressions with toMatch:
test('there is no I in team', () => {  expect('team').not.toMatch(/I/);});test('but there is a "stop" in Christoph', () => {  expect('Christoph').toMatch(/stop/);});
Arrays and iterables​
You can check if an array or iterable contains a particular item using toContain:
const shoppingList = [  'diapers',  'kleenex',  'trash bags',  'paper towels',  'milk',];test('the shopping list has milk on it', () => {  expect(shoppingList).toContain('milk');  expect(new Set(shoppingList)).toContain('milk');});
Exceptions​
If you want to test whether a particular function throws an error when it's called, use toThrow.
function compileAndroidCode() {  throw new Error('you are using the wrong JDK!');}test('compiling android goes as expected', () => {  expect(() => compileAndroidCode()).toThrow();  expect(() => compileAndroidCode()).toThrow(Error);  // You can also use a string that must be contained in the error message or a regexp  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');  expect(() => compileAndroidCode()).toThrow(/JDK/);  // Or you can match an exact error message using a regexp like below  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass});
tipThe function that throws an exception needs to be invoked within a wrapping function otherwise the toThrow assertion will fail.
And More​
This is just a taste. For a complete list of matchers, check out the reference docs.
Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you test asynchronous code.Edit this pageLast updated on Feb 10, 2023 by Tom Mrazauskas\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionUsing MatchersVersion: NextOn this pageUsing MatchersJest uses "matchers" to let you test values in different ways. This document will introduce some commonly used matchers. For the full list, see the expect API doc.
Common Matchers​
The simplest way to test a value is with exact equality.
test('two plus two is four', () => {  expect(2 + 2).toBe(4);});
In this code, expect(2 + 2) returns an "expectation" object. You typically won't do much with these expectation objects except call matchers on them. In this code, .toBe(4) is the matcher. When Jest runs, it tracks all the failing matchers so that it can print out nice error messages for you.
toBe uses Object.is to test exact equality. If you want to check the value of an object, use toEqual:
test('object assignment', () => {  const data = {one: 1};  data['two'] = 2;  expect(data).toEqual({one: 1, two: 2});});
toEqual recursively checks every field of an object or array.
tiptoEqual ignores object keys with undefined properties, undefined array items, array sparseness, or object type mismatch. To take these into account use toStrictEqual instead.
You can also test for the opposite of a matcher using not:
test('adding positive numbers is not zero', () => {  for (let a = 1; a < 10; a++) {    for (let b = 1; b < 10; b++) {      expect(a + b).not.toBe(0);    }  }});
Truthiness​
In tests, you sometimes need to distinguish between undefined, null, and false, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.

toBeNull matches only null
toBeUndefined matches only undefined
toBeDefined is the opposite of toBeUndefined
toBeTruthy matches anything that an if statement treats as true
toBeFalsy matches anything that an if statement treats as false

For example:
test('null', () => {  const n = null;  expect(n).toBeNull();  expect(n).toBeDefined();  expect(n).not.toBeUndefined();  expect(n).not.toBeTruthy();  expect(n).toBeFalsy();});test('zero', () => {  const z = 0;  expect(z).not.toBeNull();  expect(z).toBeDefined();  expect(z).not.toBeUndefined();  expect(z).not.toBeTruthy();  expect(z).toBeFalsy();});
You should use the matcher that most precisely corresponds to what you want your code to be doing.
Numbers​
Most ways of comparing numbers have matcher equivalents.
test('two plus two', () => {  const value = 2 + 2;  expect(value).toBeGreaterThan(3);  expect(value).toBeGreaterThanOrEqual(3.5);  expect(value).toBeLessThan(5);  expect(value).toBeLessThanOrEqual(4.5);  // toBe and toEqual are equivalent for numbers  expect(value).toBe(4);  expect(value).toEqual(4);});
For floating point equality, use toBeCloseTo instead of toEqual, because you don't want a test to depend on a tiny rounding error.
test('adding floating point numbers', () => {  const value = 0.1 + 0.2;  //expect(value).toBe(0.3);           This won't work because of rounding error  expect(value).toBeCloseTo(0.3); // This works.});
Strings​
You can check strings against regular expressions with toMatch:
test('there is no I in team', () => {  expect('team').not.toMatch(/I/);});test('but there is a "stop" in Christoph', () => {  expect('Christoph').toMatch(/stop/);});
Arrays and iterables​
You can check if an array or iterable contains a particular item using toContain:
const shoppingList = [  'diapers',  'kleenex',  'trash bags',  'paper towels',  'milk',];test('the shopping list has milk on it', () => {  expect(shoppingList).toContain('milk');  expect(new Set(shoppingList)).toContain('milk');});
Exceptions​
If you want to test whether a particular function throws an error when it's called, use toThrow.
function compileAndroidCode() {  throw new Error('you are using the wrong JDK!');}test('compiling android goes as expected', () => {  expect(() => compileAndroidCode()).toThrow();  expect(() => compileAndroidCode()).toThrow(Error);  // You can also use a string that must be contained in the error message or a regexp  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');  expect(() => compileAndroidCode()).toThrow(/JDK/);  // Or you can match an exact error message using a regexp like below  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK$/); // Test fails  expect(() => compileAndroidCode()).toThrow(/^you are using the wrong JDK!$/); // Test pass});
tipThe function that throws an exception needs to be invoked within a wrapping function otherwise the toThrow assertion will fail.
And More​
This is just a taste. For a complete list of matchers, check out the reference docs.
Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you test asynchronous code.Edit this pageLast updated on Feb 10, 2023 by Tom MrazauskasPreviousGetting StartedNextTesting Asynchronous CodeCommon MatchersTruthinessNumbersStringsArrays and iterablesExceptionsAnd More\n\n\n\nIntroductionTesting Asynchronous CodeVersion: NextOn this pageTesting Asynchronous CodeIt's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.
Promises​
Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail.
For example, let's say that fetchData returns a promise that is supposed to resolve to the string 'peanut butter'. We could test it with:
test('the data is peanut butter', () => {  return fetchData().then(data => {    expect(data).toBe('peanut butter');  });});
Async/Await​
Alternatively, you can use async and await in your tests. To write an async test, use the async keyword in front of the function passed to test. For example, the same fetchData scenario can be tested with:
test('the data is peanut butter', async () => {  const data = await fetchData();  expect(data).toBe('peanut butter');});test('the fetch fails with an error', async () => {  expect.assertions(1);  try {    await fetchData();  } catch (error) {    expect(error).toMatch('error');  }});
You can combine async and await with .resolves or .rejects.
test('the data is peanut butter', async () => {  await expect(fetchData()).resolves.toBe('peanut butter');});test('the fetch fails with an error', async () => {  await expect(fetchData()).rejects.toMatch('error');});
In these cases, async and await are effectively syntactic sugar for the same logic as the promises example uses.
cautionBe sure to return (or await) the promise - if you omit the return/await statement, your test will complete before the promise returned from fetchData resolves or rejects.
If you expect a promise to be rejected, use the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test.
test('the fetch fails with an error', () => {  expect.assertions(1);  return fetchData().catch(error => expect(error).toMatch('error'));});
Callbacks​
If you don't use promises, you can use callbacks. For example, let's say that fetchData, instead of returning a promise, expects a callback, i.e. fetches some data and calls callback(null, data) when it is complete. You want to test that this returned data is the string 'peanut butter'.
By default, Jest tests complete once they reach the end of their execution. That means this test will not work as intended:
// Don't do this!test('the data is peanut butter', () => {  function callback(error, data) {    if (error) {      throw error;    }    expect(data).toBe('peanut butter');  }  fetchData(callback);});
The problem is that the test will complete as soon as fetchData completes, before ever calling the callback.
There is an alternate form of test that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called done. Jest will wait until the done callback is called before finishing the test.
test('the data is peanut butter', done => {  function callback(error, data) {    if (error) {      done(error);      return;    }    try {      expect(data).toBe('peanut butter');      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});
If done() is never called, the test will fail (with timeout error), which is what you want to happen.
If the expect statement fails, it throws an error and done() is not called. If we want to see in the test log why it failed, we have to wrap expect in a try block and pass the error in the catch block to done. Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).
cautionJest will throw an error, if the same test function is passed a done() callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests.
.resolves / .rejects​
You can also use the .resolves matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.
test('the data is peanut butter', () => {  return expect(fetchData()).resolves.toBe('peanut butter');});
Be sure to return the assertion—if you omit this return statement, your test will complete before the promise returned from fetchData is resolved and then() has a chance to execute the callback.
If you expect a promise to be rejected, use the .rejects matcher. It works analogically to the .resolves matcher. If the promise is fulfilled, the test will automatically fail.
test('the fetch fails with an error', () => {  return expect(fetchData()).rejects.toMatch('error');});
None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.Edit this pageLast updated on Dec 30, 2023 by Simen Bekkhus\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionTesting Asynchronous CodeVersion: NextOn this pageTesting Asynchronous CodeIt's common in JavaScript for code to run asynchronously. When you have code that runs asynchronously, Jest needs to know when the code it is testing has completed, before it can move on to another test. Jest has several ways to handle this.
Promises​
Return a promise from your test, and Jest will wait for that promise to resolve. If the promise is rejected, the test will fail.
For example, let's say that fetchData returns a promise that is supposed to resolve to the string 'peanut butter'. We could test it with:
test('the data is peanut butter', () => {  return fetchData().then(data => {    expect(data).toBe('peanut butter');  });});
Async/Await​
Alternatively, you can use async and await in your tests. To write an async test, use the async keyword in front of the function passed to test. For example, the same fetchData scenario can be tested with:
test('the data is peanut butter', async () => {  const data = await fetchData();  expect(data).toBe('peanut butter');});test('the fetch fails with an error', async () => {  expect.assertions(1);  try {    await fetchData();  } catch (error) {    expect(error).toMatch('error');  }});
You can combine async and await with .resolves or .rejects.
test('the data is peanut butter', async () => {  await expect(fetchData()).resolves.toBe('peanut butter');});test('the fetch fails with an error', async () => {  await expect(fetchData()).rejects.toMatch('error');});
In these cases, async and await are effectively syntactic sugar for the same logic as the promises example uses.
cautionBe sure to return (or await) the promise - if you omit the return/await statement, your test will complete before the promise returned from fetchData resolves or rejects.
If you expect a promise to be rejected, use the .catch method. Make sure to add expect.assertions to verify that a certain number of assertions are called. Otherwise, a fulfilled promise would not fail the test.
test('the fetch fails with an error', () => {  expect.assertions(1);  return fetchData().catch(error => expect(error).toMatch('error'));});
Callbacks​
If you don't use promises, you can use callbacks. For example, let's say that fetchData, instead of returning a promise, expects a callback, i.e. fetches some data and calls callback(null, data) when it is complete. You want to test that this returned data is the string 'peanut butter'.
By default, Jest tests complete once they reach the end of their execution. That means this test will not work as intended:
// Don't do this!test('the data is peanut butter', () => {  function callback(error, data) {    if (error) {      throw error;    }    expect(data).toBe('peanut butter');  }  fetchData(callback);});
The problem is that the test will complete as soon as fetchData completes, before ever calling the callback.
There is an alternate form of test that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called done. Jest will wait until the done callback is called before finishing the test.
test('the data is peanut butter', done => {  function callback(error, data) {    if (error) {      done(error);      return;    }    try {      expect(data).toBe('peanut butter');      done();    } catch (error) {      done(error);    }  }  fetchData(callback);});
If done() is never called, the test will fail (with timeout error), which is what you want to happen.
If the expect statement fails, it throws an error and done() is not called. If we want to see in the test log why it failed, we have to wrap expect in a try block and pass the error in the catch block to done. Otherwise, we end up with an opaque timeout error that doesn't show what value was received by expect(data).
cautionJest will throw an error, if the same test function is passed a done() callback and returns a promise. This is done as a precaution to avoid memory leaks in your tests.
.resolves / .rejects​
You can also use the .resolves matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.
test('the data is peanut butter', () => {  return expect(fetchData()).resolves.toBe('peanut butter');});
Be sure to return the assertion—if you omit this return statement, your test will complete before the promise returned from fetchData is resolved and then() has a chance to execute the callback.
If you expect a promise to be rejected, use the .rejects matcher. It works analogically to the .resolves matcher. If the promise is fulfilled, the test will automatically fail.
test('the fetch fails with an error', () => {  return expect(fetchData()).rejects.toMatch('error');});
None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.Edit this pageLast updated on Dec 30, 2023 by Simen BekkhusPreviousUsing MatchersNextSetup and TeardownPromisesAsync/AwaitCallbacks.resolves / .rejects\n\n\n\nIntroductionSetup and TeardownVersion: NextOn this pageSetup and TeardownOften while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.
Repeating Setup​
If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach hooks.
For example, let's say that several tests interact with a database of cities. You have a method initializeCityDatabase() that must be called before each of these tests, and a method clearCityDatabase() that must be called after each of these tests. You can do this with:
beforeEach(() => {  initializeCityDatabase();});afterEach(() => {  clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
beforeEach and afterEach can handle asynchronous code in the same ways that tests can handle asynchronous code - they can either take a done parameter or return a promise. For example, if initializeCityDatabase() returned a promise that resolved when the database was initialized, we would want to return that promise:
beforeEach(() => {  return initializeCityDatabase();});
One-Time Setup​
In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides beforeAll and afterAll hooks to handle this situation.
For example, if both initializeCityDatabase() and clearCityDatabase() returned promises, and the city database could be reused between tests, we could change our test code to:
beforeAll(() => {  return initializeCityDatabase();});afterAll(() => {  return clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
Scoping​
The top level before* and after* hooks apply to every test in a file. The hooks declared inside a describe block apply only to the tests within that describe block.
For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:
// Applies to all tests in this filebeforeEach(() => {  return initializeCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});describe('matching cities to foods', () => {  // Applies only to tests in this describe block  beforeEach(() => {    return initializeFoodDatabase();  });  test('Vienna <3 veal', () => {    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);  });  test('San Juan <3 plantains', () => {    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);  });});
Note that the top-level beforeEach is executed before the beforeEach inside the describe block. It may help to illustrate the order of execution of all hooks.
beforeAll(() => console.log('1 - beforeAll'));afterAll(() => console.log('1 - afterAll'));beforeEach(() => console.log('1 - beforeEach'));afterEach(() => console.log('1 - afterEach'));test('', () => console.log('1 - test'));describe('Scoped / Nested block', () => {  beforeAll(() => console.log('2 - beforeAll'));  afterAll(() => console.log('2 - afterAll'));  beforeEach(() => console.log('2 - beforeEach'));  afterEach(() => console.log('2 - afterEach'));  test('', () => console.log('2 - test'));});// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll
Order of Execution​
Jest executes all describe handlers in a test file before it executes any of the actual tests. This is another reason to do setup and teardown inside before* and after* handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.
Consider the following illustrative test file and output:
describe('describe outer', () => {  console.log('describe outer-a');  describe('describe inner 1', () => {    console.log('describe inner 1');    test('test 1', () => console.log('test 1'));  });  console.log('describe outer-b');  test('test 2', () => console.log('test 2'));  describe('describe inner 2', () => {    console.log('describe inner 2');    test('test 3', () => console.log('test 3'));  });  console.log('describe outer-c');});// describe outer-a// describe inner 1// describe outer-b// describe inner 2// describe outer-c// test 1// test 2// test 3
Just like the describe and test blocks Jest calls the before* and after* hooks in the order of declaration. Note that the after* hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:
beforeEach(() => console.log('connection setup'));beforeEach(() => console.log('database setup'));afterEach(() => console.log('database teardown'));afterEach(() => console.log('connection teardown'));test('test 1', () => console.log('test 1'));describe('extra', () => {  beforeEach(() => console.log('extra database setup'));  afterEach(() => console.log('extra database teardown'));  test('test 2', () => console.log('test 2'));});// connection setup// database setup// test 1// database teardown// connection teardown// connection setup// database setup// extra database setup// test 2// extra database teardown// database teardown// connection teardown
noteIf you are using jasmine2 test runner, take into account that it calls the after* hooks in the reverse order of declaration. To have identical output, the above example should be altered like this:  beforeEach(() => console.log('connection setup'));+ afterEach(() => console.log('connection teardown'));  beforeEach(() => console.log('database setup'));+ afterEach(() => console.log('database teardown'));- afterEach(() => console.log('database teardown'));- afterEach(() => console.log('connection teardown'));  // ...
General Advice​
If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that test command to a test.only:
test.only('this will be the only test that runs', () => {  expect(true).toBe(false);});test('this test will not run', () => {  expect('A').toBe('A');});
If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you're not sure whether some shared state is being modified, you can also try a beforeEach that logs data.Edit this pageLast updated on Jan 1, 2023 by faustAbc\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionSetup and TeardownVersion: NextOn this pageSetup and TeardownOften while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.
Repeating Setup​
If you have some work you need to do repeatedly for many tests, you can use beforeEach and afterEach hooks.
For example, let's say that several tests interact with a database of cities. You have a method initializeCityDatabase() that must be called before each of these tests, and a method clearCityDatabase() that must be called after each of these tests. You can do this with:
beforeEach(() => {  initializeCityDatabase();});afterEach(() => {  clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
beforeEach and afterEach can handle asynchronous code in the same ways that tests can handle asynchronous code - they can either take a done parameter or return a promise. For example, if initializeCityDatabase() returned a promise that resolved when the database was initialized, we would want to return that promise:
beforeEach(() => {  return initializeCityDatabase();});
One-Time Setup​
In some cases, you only need to do setup once, at the beginning of a file. This can be especially bothersome when the setup is asynchronous, so you can't do it inline. Jest provides beforeAll and afterAll hooks to handle this situation.
For example, if both initializeCityDatabase() and clearCityDatabase() returned promises, and the city database could be reused between tests, we could change our test code to:
beforeAll(() => {  return initializeCityDatabase();});afterAll(() => {  return clearCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});
Scoping​
The top level before* and after* hooks apply to every test in a file. The hooks declared inside a describe block apply only to the tests within that describe block.
For example, let's say we had not just a city database, but also a food database. We could do different setup for different tests:
// Applies to all tests in this filebeforeEach(() => {  return initializeCityDatabase();});test('city database has Vienna', () => {  expect(isCity('Vienna')).toBeTruthy();});test('city database has San Juan', () => {  expect(isCity('San Juan')).toBeTruthy();});describe('matching cities to foods', () => {  // Applies only to tests in this describe block  beforeEach(() => {    return initializeFoodDatabase();  });  test('Vienna <3 veal', () => {    expect(isValidCityFoodPair('Vienna', 'Wiener Schnitzel')).toBe(true);  });  test('San Juan <3 plantains', () => {    expect(isValidCityFoodPair('San Juan', 'Mofongo')).toBe(true);  });});
Note that the top-level beforeEach is executed before the beforeEach inside the describe block. It may help to illustrate the order of execution of all hooks.
beforeAll(() => console.log('1 - beforeAll'));afterAll(() => console.log('1 - afterAll'));beforeEach(() => console.log('1 - beforeEach'));afterEach(() => console.log('1 - afterEach'));test('', () => console.log('1 - test'));describe('Scoped / Nested block', () => {  beforeAll(() => console.log('2 - beforeAll'));  afterAll(() => console.log('2 - afterAll'));  beforeEach(() => console.log('2 - beforeEach'));  afterEach(() => console.log('2 - afterEach'));  test('', () => console.log('2 - test'));});// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll
Order of Execution​
Jest executes all describe handlers in a test file before it executes any of the actual tests. This is another reason to do setup and teardown inside before* and after* handlers rather than inside the describe blocks. Once the describe blocks are complete, by default Jest runs all the tests serially in the order they were encountered in the collection phase, waiting for each to finish and be tidied up before moving on.
Consider the following illustrative test file and output:
describe('describe outer', () => {  console.log('describe outer-a');  describe('describe inner 1', () => {    console.log('describe inner 1');    test('test 1', () => console.log('test 1'));  });  console.log('describe outer-b');  test('test 2', () => console.log('test 2'));  describe('describe inner 2', () => {    console.log('describe inner 2');    test('test 3', () => console.log('test 3'));  });  console.log('describe outer-c');});// describe outer-a// describe inner 1// describe outer-b// describe inner 2// describe outer-c// test 1// test 2// test 3
Just like the describe and test blocks Jest calls the before* and after* hooks in the order of declaration. Note that the after* hooks of the enclosing scope are called first. For example, here is how you can set up and tear down resources which depend on each other:
beforeEach(() => console.log('connection setup'));beforeEach(() => console.log('database setup'));afterEach(() => console.log('database teardown'));afterEach(() => console.log('connection teardown'));test('test 1', () => console.log('test 1'));describe('extra', () => {  beforeEach(() => console.log('extra database setup'));  afterEach(() => console.log('extra database teardown'));  test('test 2', () => console.log('test 2'));});// connection setup// database setup// test 1// database teardown// connection teardown// connection setup// database setup// extra database setup// test 2// extra database teardown// database teardown// connection teardown
noteIf you are using jasmine2 test runner, take into account that it calls the after* hooks in the reverse order of declaration. To have identical output, the above example should be altered like this:  beforeEach(() => console.log('connection setup'));+ afterEach(() => console.log('connection teardown'));  beforeEach(() => console.log('database setup'));+ afterEach(() => console.log('database teardown'));- afterEach(() => console.log('database teardown'));- afterEach(() => console.log('connection teardown'));  // ...
General Advice​
If a test is failing, one of the first things to check should be whether the test is failing when it's the only test that runs. To run only one test with Jest, temporarily change that test command to a test.only:
test.only('this will be the only test that runs', () => {  expect(true).toBe(false);});test('this test will not run', () => {  expect('A').toBe('A');});
If you have a test that often fails when it's run as part of a larger suite, but doesn't fail when you run it alone, it's a good bet that something from a different test is interfering with this one. You can often fix this by clearing some shared state with beforeEach. If you're not sure whether some shared state is being modified, you can also try a beforeEach that logs data.Edit this pageLast updated on Jan 1, 2023 by faustAbcPreviousTesting Asynchronous CodeNextMock FunctionsRepeating SetupOne-Time SetupScopingOrder of ExecutionGeneral Advice\n\n\n\nIntroductionMock FunctionsVersion: NextOn this pageMock FunctionsMock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with new, and allowing test-time configuration of return values.
There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a manual mock to override a module dependency.
Using a mock function​
Let's imagine we're testing an implementation of a function forEach, which invokes a callback for each item in a supplied array.
forEach.jsexport function forEach(items, callback) {  for (const item of items) {    callback(item);  }}
To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.
forEach.test.jsconst forEach = require('./forEach');const mockCallback = jest.fn(x => 42 + x);test('forEach mock function', () => {  forEach([0, 1], mockCallback);  // The mock function was called twice  expect(mockCallback.mock.calls).toHaveLength(2);  // The first argument of the first call to the function was 0  expect(mockCallback.mock.calls[0][0]).toBe(0);  // The first argument of the second call to the function was 1  expect(mockCallback.mock.calls[1][0]).toBe(1);  // The return value of the first call to the function was 42  expect(mockCallback.mock.results[0].value).toBe(42);});
.mock property​
All mock functions have this special .mock property, which is where data about how the function has been called and what the function returned is kept. The .mock property also tracks the value of this for each call, so it is possible to inspect this as well:
const myMock1 = jest.fn();const a = new myMock1();console.log(myMock1.mock.instances);// > [ <a> ]const myMock2 = jest.fn();const b = {};const bound = myMock2.bind(b);bound();console.log(myMock2.mock.contexts);// > [ <b> ]
These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:
// The function was called exactly onceexpect(someMockFunction.mock.calls).toHaveLength(1);// The first arg of the first call to the function was 'first arg'expect(someMockFunction.mock.calls[0][0]).toBe('first arg');// The second arg of the first call to the function was 'second arg'expect(someMockFunction.mock.calls[0][1]).toBe('second arg');// The return value of the first call to the function was 'return value'expect(someMockFunction.mock.results[0].value).toBe('return value');// The function was called with a certain `this` context: the `element` object.expect(someMockFunction.mock.contexts[0]).toBe(element);// This function was instantiated exactly twiceexpect(someMockFunction.mock.instances.length).toBe(2);// The object returned by the first instantiation of this function// had a `name` property whose value was set to 'test'expect(someMockFunction.mock.instances[0].name).toBe('test');// The first argument of the last call to the function was 'test'expect(someMockFunction.mock.lastCall[0]).toBe('test');
Mock Return Values​
Mock functions can also be used to inject test values into your code during a test:
const myMock = jest.fn();console.log(myMock());// > undefinedmyMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());// > 10, 'x', true, true
Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.
const filterTestFn = jest.fn();// Make the mock return `true` for the first call,// and `false` for the second callfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [11, 12].filter(num => filterTestFn(num));console.log(result);// > [11]console.log(filterTestFn.mock.calls[0][0]); // 11console.log(filterTestFn.mock.calls[1][0]); // 12
Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.
Mocking Modules​
Suppose we have a class that fetches users from our API. The class uses axios to call the API then returns the data attribute which contains all the users:
users.jsimport axios from 'axios';class Users {  static all() {    return axios.get('/users.json').then(resp => resp.data);  }}export default Users;
Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the jest.mock(...) function to automatically mock the axios module.
Once we mock the module we can provide a mockResolvedValue for .get that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.
users.test.jsimport axios from 'axios';import Users from './users';jest.mock('axios');test('should fetch users', () => {  const users = [{name: 'Bob'}];  const resp = {data: users};  axios.get.mockResolvedValue(resp);  // or you could use the following depending on your use case:  // axios.get.mockImplementation(() => Promise.resolve(resp))  return Users.all().then(data => expect(data).toEqual(users));});
Mocking Partials​
Subsets of a module can be mocked and the rest of the module can keep their actual implementation:
foo-bar-baz.jsexport const foo = 'foo';export const bar = () => 'bar';export default () => 'baz';
//test.jsimport defaultExport, {bar, foo} from '../foo-bar-baz';jest.mock('../foo-bar-baz', () => {  const originalModule = jest.requireActual('../foo-bar-baz');  //Mock the default export and named export 'foo'  return {    __esModule: true,    ...originalModule,    default: jest.fn(() => 'mocked baz'),    foo: 'mocked foo',  };});test('should do a partial mock', () => {  const defaultExportResult = defaultExport();  expect(defaultExportResult).toBe('mocked baz');  expect(defaultExport).toHaveBeenCalled();  expect(foo).toBe('mocked foo');  expect(bar()).toBe('bar');});
Mock Implementations​
Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with jest.fn or the mockImplementationOnce method on mock functions.
const myMockFn = jest.fn(cb => cb(null, true));myMockFn((err, val) => console.log(val));// > true
The mockImplementation method is useful when you need to define the default implementation of a mock function that is created from another module:
foo.jsmodule.exports = function () {  // some implementation;};
test.jsjest.mock('../foo'); // this happens automatically with automockingconst foo = require('../foo');// foo is a mock functionfoo.mockImplementation(() => 42);foo();// > 42
When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the mockImplementationOnce method:
const myMockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));myMockFn((err, val) => console.log(val));// > truemyMockFn((err, val) => console.log(val));// > false
When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with jest.fn (if it is defined):
const myMockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());// > 'first call', 'second call', 'default', 'default'
For cases where we have methods that are typically chained (and thus always need to return this), we have a sugary API to simplify this in the form of a .mockReturnThis() function that also sits on all mocks:
const myObj = {  myMethod: jest.fn().mockReturnThis(),};// is the same asconst otherObj = {  myMethod: jest.fn(function () {    return this;  }),};
Mock Names​
You can optionally provide a name for your mock functions, which will be displayed instead of 'jest.fn()' in the test error output. Use .mockName() if you want to be able to quickly identify the mock function reporting an error in your test output.
const myMockFn = jest  .fn()  .mockReturnValue('default')  .mockImplementation(scalar => 42 + scalar)  .mockName('add42');
Custom Matchers​
Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:
// The mock function was called at least onceexpect(mockFunc).toHaveBeenCalled();// The mock function was called at least once with the specified argsexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2);// The last call to the mock function was called with the specified argsexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);// All calls and the name of the mock is written as a snapshotexpect(mockFunc).toMatchSnapshot();
These matchers are sugar for common forms of inspecting the .mock property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:
// The mock function was called at least onceexpect(mockFunc.mock.calls.length).toBeGreaterThan(0);// The mock function was called at least once with the specified argsexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);// The last call to the mock function was called with the specified argsexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([  arg1,  arg2,]);// The first arg of the last call to the mock function was `42`// (note that there is no sugar helper for this specific of an assertion)expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// A snapshot will check that a mock was invoked the same number of times,// in the same order, with the same arguments. It will also assert on the name.expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);expect(mockFunc.getMockName()).toBe('a mock name');
For a complete list of matchers, check out the reference docs.Edit this pageLast updated on Dec 29, 2023 by Simen Bekkhus\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionMock FunctionsVersion: NextOn this pageMock FunctionsMock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with new, and allowing test-time configuration of return values.
There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a manual mock to override a module dependency.
Using a mock function​
Let's imagine we're testing an implementation of a function forEach, which invokes a callback for each item in a supplied array.
forEach.jsexport function forEach(items, callback) {  for (const item of items) {    callback(item);  }}
To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.
forEach.test.jsconst forEach = require('./forEach');const mockCallback = jest.fn(x => 42 + x);test('forEach mock function', () => {  forEach([0, 1], mockCallback);  // The mock function was called twice  expect(mockCallback.mock.calls).toHaveLength(2);  // The first argument of the first call to the function was 0  expect(mockCallback.mock.calls[0][0]).toBe(0);  // The first argument of the second call to the function was 1  expect(mockCallback.mock.calls[1][0]).toBe(1);  // The return value of the first call to the function was 42  expect(mockCallback.mock.results[0].value).toBe(42);});
.mock property​
All mock functions have this special .mock property, which is where data about how the function has been called and what the function returned is kept. The .mock property also tracks the value of this for each call, so it is possible to inspect this as well:
const myMock1 = jest.fn();const a = new myMock1();console.log(myMock1.mock.instances);// > [ <a> ]const myMock2 = jest.fn();const b = {};const bound = myMock2.bind(b);bound();console.log(myMock2.mock.contexts);// > [ <b> ]
These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:
// The function was called exactly onceexpect(someMockFunction.mock.calls).toHaveLength(1);// The first arg of the first call to the function was 'first arg'expect(someMockFunction.mock.calls[0][0]).toBe('first arg');// The second arg of the first call to the function was 'second arg'expect(someMockFunction.mock.calls[0][1]).toBe('second arg');// The return value of the first call to the function was 'return value'expect(someMockFunction.mock.results[0].value).toBe('return value');// The function was called with a certain `this` context: the `element` object.expect(someMockFunction.mock.contexts[0]).toBe(element);// This function was instantiated exactly twiceexpect(someMockFunction.mock.instances.length).toBe(2);// The object returned by the first instantiation of this function// had a `name` property whose value was set to 'test'expect(someMockFunction.mock.instances[0].name).toBe('test');// The first argument of the last call to the function was 'test'expect(someMockFunction.mock.lastCall[0]).toBe('test');
Mock Return Values​
Mock functions can also be used to inject test values into your code during a test:
const myMock = jest.fn();console.log(myMock());// > undefinedmyMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());// > 10, 'x', true, true
Mock functions are also very effective in code that uses a functional continuation-passing style. Code written in this style helps avoid the need for complicated stubs that recreate the behavior of the real component they're standing in for, in favor of injecting values directly into the test right before they're used.
const filterTestFn = jest.fn();// Make the mock return `true` for the first call,// and `false` for the second callfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [11, 12].filter(num => filterTestFn(num));console.log(result);// > [11]console.log(filterTestFn.mock.calls[0][0]); // 11console.log(filterTestFn.mock.calls[1][0]); // 12
Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.
Mocking Modules​
Suppose we have a class that fetches users from our API. The class uses axios to call the API then returns the data attribute which contains all the users:
users.jsimport axios from 'axios';class Users {  static all() {    return axios.get('/users.json').then(resp => resp.data);  }}export default Users;
Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the jest.mock(...) function to automatically mock the axios module.
Once we mock the module we can provide a mockResolvedValue for .get that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.
users.test.jsimport axios from 'axios';import Users from './users';jest.mock('axios');test('should fetch users', () => {  const users = [{name: 'Bob'}];  const resp = {data: users};  axios.get.mockResolvedValue(resp);  // or you could use the following depending on your use case:  // axios.get.mockImplementation(() => Promise.resolve(resp))  return Users.all().then(data => expect(data).toEqual(users));});
Mocking Partials​
Subsets of a module can be mocked and the rest of the module can keep their actual implementation:
foo-bar-baz.jsexport const foo = 'foo';export const bar = () => 'bar';export default () => 'baz';
//test.jsimport defaultExport, {bar, foo} from '../foo-bar-baz';jest.mock('../foo-bar-baz', () => {  const originalModule = jest.requireActual('../foo-bar-baz');  //Mock the default export and named export 'foo'  return {    __esModule: true,    ...originalModule,    default: jest.fn(() => 'mocked baz'),    foo: 'mocked foo',  };});test('should do a partial mock', () => {  const defaultExportResult = defaultExport();  expect(defaultExportResult).toBe('mocked baz');  expect(defaultExport).toHaveBeenCalled();  expect(foo).toBe('mocked foo');  expect(bar()).toBe('bar');});
Mock Implementations​
Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with jest.fn or the mockImplementationOnce method on mock functions.
const myMockFn = jest.fn(cb => cb(null, true));myMockFn((err, val) => console.log(val));// > true
The mockImplementation method is useful when you need to define the default implementation of a mock function that is created from another module:
foo.jsmodule.exports = function () {  // some implementation;};
test.jsjest.mock('../foo'); // this happens automatically with automockingconst foo = require('../foo');// foo is a mock functionfoo.mockImplementation(() => 42);foo();// > 42
When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the mockImplementationOnce method:
const myMockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));myMockFn((err, val) => console.log(val));// > truemyMockFn((err, val) => console.log(val));// > false
When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with jest.fn (if it is defined):
const myMockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());// > 'first call', 'second call', 'default', 'default'
For cases where we have methods that are typically chained (and thus always need to return this), we have a sugary API to simplify this in the form of a .mockReturnThis() function that also sits on all mocks:
const myObj = {  myMethod: jest.fn().mockReturnThis(),};// is the same asconst otherObj = {  myMethod: jest.fn(function () {    return this;  }),};
Mock Names​
You can optionally provide a name for your mock functions, which will be displayed instead of 'jest.fn()' in the test error output. Use .mockName() if you want to be able to quickly identify the mock function reporting an error in your test output.
const myMockFn = jest  .fn()  .mockReturnValue('default')  .mockImplementation(scalar => 42 + scalar)  .mockName('add42');
Custom Matchers​
Finally, in order to make it less demanding to assert how mock functions have been called, we've added some custom matcher functions for you:
// The mock function was called at least onceexpect(mockFunc).toHaveBeenCalled();// The mock function was called at least once with the specified argsexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2);// The last call to the mock function was called with the specified argsexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);// All calls and the name of the mock is written as a snapshotexpect(mockFunc).toMatchSnapshot();
These matchers are sugar for common forms of inspecting the .mock property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:
// The mock function was called at least onceexpect(mockFunc.mock.calls.length).toBeGreaterThan(0);// The mock function was called at least once with the specified argsexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);// The last call to the mock function was called with the specified argsexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([  arg1,  arg2,]);// The first arg of the last call to the mock function was `42`// (note that there is no sugar helper for this specific of an assertion)expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// A snapshot will check that a mock was invoked the same number of times,// in the same order, with the same arguments. It will also assert on the name.expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);expect(mockFunc.getMockName()).toBe('a mock name');
For a complete list of matchers, check out the reference docs.Edit this pageLast updated on Dec 29, 2023 by Simen BekkhusPreviousSetup and TeardownNextJest PlatformUsing a mock function.mock propertyMock Return ValuesMocking ModulesMocking PartialsMock ImplementationsMock NamesCustom Matchers\n\n\n\nIntroductionJest PlatformVersion: NextOn this pageJest PlatformYou can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:
jest-changed-files​
Tool for identifying modified files in a git/hg repository. Exports two functions:

getChangedFilesForRoots returns a promise that resolves to an object with the changed files and repos.
findRepos returns a promise that resolves to a set of repositories contained in the specified path.

Example​
const {getChangedFilesForRoots} = require('jest-changed-files');// print the set of modified files since last commit in the current repogetChangedFilesForRoots(['./'], {  lastCommit: true,}).then(result => console.log(result.changedFiles));
You can read more about jest-changed-files in the readme file.
jest-diff​
Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a "pretty-printed" string illustrating the difference between the two arguments.
Example​
const {diff} = require('jest-diff');const a = {a: {b: {c: 5}}};const b = {a: {b: {c: 6}}};const result = diff(a, b);// print diffconsole.log(result);
jest-docblock​
Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.
Example​
const {parseWithComments} = require('jest-docblock');const code = `/** * This is a sample * * @flow */ console.log('Hello World!');`;const parsed = parseWithComments(code);// prints an object with two attributes: comments and pragmas.console.log(parsed);
You can read more about jest-docblock in the readme file.
jest-get-type​
Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.
Example​
const {getType} = require('jest-get-type');const array = [1, 2, 3];const nullValue = null;const undefinedValue = undefined;// prints 'array'console.log(getType(array));// prints 'null'console.log(getType(nullValue));// prints 'undefined'console.log(getType(undefinedValue));
jest-validate​
Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:

hasDeprecationWarnings, a boolean indicating whether the submitted configuration has deprecation warnings,
isValid, a boolean indicating whether the configuration is correct or not.

Example​
const {validate} = require('jest-validate');const configByUser = {  transform: '<rootDir>/node_modules/my-custom-transform',};const result = validate(configByUser, {  comment: '  Documentation: http://custom-docs.com',  exampleConfig: {transform: '<rootDir>/node_modules/babel-jest'},});console.log(result);
You can read more about jest-validate in the readme file.
jest-worker​
Module used for parallelization of tasks. Exports a class JestWorker that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.
Example​
heavy-task.jsmodule.exports = {  myHeavyTask: args => {    // long running CPU intensive task.  },};
main.jsasync function main() {  const worker = new Worker(require.resolve('./heavy-task.js'));  // run 2 tasks in parallel with different arguments  const results = await Promise.all([    worker.myHeavyTask({foo: 'bar'}),    worker.myHeavyTask({bar: 'foo'}),  ]);  console.log(results);}main();
You can read more about jest-worker in the readme file.
pretty-format​
Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.
Example​
const {format: prettyFormat} = require('pretty-format');const val = {object: {}};val.circularReference = val;val[Symbol('foo')] = 'foo';val.map = new Map([['prop', 'value']]);val.array = [-0, Infinity, NaN];console.log(prettyFormat(val));
You can read more about pretty-format in the readme file.Edit this pageLast updated on Aug 15, 2023 by Frazer Smith\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionJest PlatformVersion: NextOn this pageJest PlatformYou can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:
jest-changed-files​
Tool for identifying modified files in a git/hg repository. Exports two functions:

getChangedFilesForRoots returns a promise that resolves to an object with the changed files and repos.
findRepos returns a promise that resolves to a set of repositories contained in the specified path.

Example​
const {getChangedFilesForRoots} = require('jest-changed-files');// print the set of modified files since last commit in the current repogetChangedFilesForRoots(['./'], {  lastCommit: true,}).then(result => console.log(result.changedFiles));
You can read more about jest-changed-files in the readme file.
jest-diff​
Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a "pretty-printed" string illustrating the difference between the two arguments.
Example​
const {diff} = require('jest-diff');const a = {a: {b: {c: 5}}};const b = {a: {b: {c: 6}}};const result = diff(a, b);// print diffconsole.log(result);
jest-docblock​
Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.
Example​
const {parseWithComments} = require('jest-docblock');const code = `/** * This is a sample * * @flow */ console.log('Hello World!');`;const parsed = parseWithComments(code);// prints an object with two attributes: comments and pragmas.console.log(parsed);
You can read more about jest-docblock in the readme file.
jest-get-type​
Module that identifies the primitive type of any JavaScript value. Exports a function that returns a string with the type of the value passed as argument.
Example​
const {getType} = require('jest-get-type');const array = [1, 2, 3];const nullValue = null;const undefinedValue = undefined;// prints 'array'console.log(getType(array));// prints 'null'console.log(getType(nullValue));// prints 'undefined'console.log(getType(undefinedValue));
jest-validate​
Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:

hasDeprecationWarnings, a boolean indicating whether the submitted configuration has deprecation warnings,
isValid, a boolean indicating whether the configuration is correct or not.

Example​
const {validate} = require('jest-validate');const configByUser = {  transform: '<rootDir>/node_modules/my-custom-transform',};const result = validate(configByUser, {  comment: '  Documentation: http://custom-docs.com',  exampleConfig: {transform: '<rootDir>/node_modules/babel-jest'},});console.log(result);
You can read more about jest-validate in the readme file.
jest-worker​
Module used for parallelization of tasks. Exports a class JestWorker that takes the path of Node.js module and lets you call the module's exported methods as if they were class methods, returning a promise that resolves when the specified method finishes its execution in a forked process.
Example​
heavy-task.jsmodule.exports = {  myHeavyTask: args => {    // long running CPU intensive task.  },};
main.jsasync function main() {  const worker = new Worker(require.resolve('./heavy-task.js'));  // run 2 tasks in parallel with different arguments  const results = await Promise.all([    worker.myHeavyTask({foo: 'bar'}),    worker.myHeavyTask({bar: 'foo'}),  ]);  console.log(results);}main();
You can read more about jest-worker in the readme file.
pretty-format​
Exports a function that converts any JavaScript value into a human-readable string. Supports all built-in JavaScript types out of the box and allows extension for application-specific types via user-defined plugins.
Example​
const {format: prettyFormat} = require('pretty-format');const val = {object: {}};val.circularReference = val;val[Symbol('foo')] = 'foo';val.map = new Map([['prop', 'value']]);val.array = [-0, Infinity, NaN];console.log(prettyFormat(val));
You can read more about pretty-format in the readme file.Edit this pageLast updated on Aug 15, 2023 by Frazer SmithPreviousMock FunctionsNextJest Communityjest-changed-filesExamplejest-diffExamplejest-docblockExamplejest-get-typeExamplejest-validateExamplejest-workerExamplepretty-formatExample\n\n\n\nIntroductionJest CommunityVersion: NextOn this pageJest CommunityThe community around Jest is working hard to make the testing experience even greater.
jest-community is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:

vscode-jest
jest-extended
eslint-plugin-jest
awesome-jest

Community projects under one organization are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.
Awesome Jest​
The jest-community org maintains an awesome-jest list of great projects and resources related to Jest.
If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (send a PR here) or if you would like to transfer your project to the jest-community org reach out to one of the owners of the org.Edit this pageLast updated on Jul 13, 2022 by Pooyan Khanjankhani\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionJest CommunityVersion: NextOn this pageJest CommunityThe community around Jest is working hard to make the testing experience even greater.
jest-community is a new GitHub organization for high quality Jest additions curated by Jest maintainers and collaborators. It already features some of our favorite projects, to name a few:

vscode-jest
jest-extended
eslint-plugin-jest
awesome-jest

Community projects under one organization are a great way for Jest to experiment with new ideas/techniques and approaches. Encourage contributions from the community and publish contributions independently at a faster pace.
Awesome Jest​
The jest-community org maintains an awesome-jest list of great projects and resources related to Jest.
If you have something awesome to share, feel free to reach out to us! We'd love to share your project on the awesome-jest list (send a PR here) or if you would like to transfer your project to the jest-community org reach out to one of the owners of the org.Edit this pageLast updated on Jul 13, 2022 by Pooyan KhanjankhaniPreviousJest PlatformNextMore ResourcesAwesome Jest\n\n\n\nIntroductionMore ResourcesVersion: NextOn this pageMore ResourcesBy now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.
Browse the docs​

Learn about Snapshot Testing, Mock Functions, and more in our in-depth guides.
Migrate your existing tests to Jest by following our migration guide.
Learn how to configure Jest.
Look at the full API Reference.
Troubleshoot problems with Jest.

Learn by example​
You will find a number of example test cases in the examples folder on GitHub. You can also learn from the excellent tests used by the React, Relay, and React Native projects.
Join the community​
Ask questions and find answers from other Jest users like you. Reactiflux is a Discord chat where a lot of Jest discussion happens. Check out the #testing channel.
Follow the Jest Twitter account and blog to find out what's happening in the world of Jest.Edit this pageLast updated on Aug 15, 2023 by Frazer Smith\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionMore ResourcesVersion: NextOn this pageMore ResourcesBy now you should have a good idea of how Jest can help you test your applications. If you're interested in learning more, here's some related stuff you might want to check out.
Browse the docs​

Learn about Snapshot Testing, Mock Functions, and more in our in-depth guides.
Migrate your existing tests to Jest by following our migration guide.
Learn how to configure Jest.
Look at the full API Reference.
Troubleshoot problems with Jest.

Learn by example​
You will find a number of example test cases in the examples folder on GitHub. You can also learn from the excellent tests used by the React, Relay, and React Native projects.
Join the community​
Ask questions and find answers from other Jest users like you. Reactiflux is a Discord chat where a lot of Jest discussion happens. Check out the #testing channel.
Follow the Jest Twitter account and blog to find out what's happening in the world of Jest.Edit this pageLast updated on Aug 15, 2023 by Frazer SmithPreviousJest CommunityNextSnapshot TestingBrowse the docsLearn by exampleJoin the community\n\n\n\nGuidesSnapshot TestingVersion: NextOn this pageSnapshot TestingSnapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.
A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.
Snapshot Testing with Jest​
A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this example test for a Link component:
import renderer from 'react-test-renderer';import Link from '../Link';it('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.facebook.com">Facebook</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
The first time this test is run, Jest creates a snapshot file that looks like this:
exports[`renders correctly 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses pretty-format to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the <Link> component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.
noteThe snapshot is directly scoped to the data you render – in our example the <Link> component with page prop passed to it. This implies that even if any other file has missing props (say, App.js) in the <Link> component, it will still pass the test as the test doesn't know the usage of <Link> component and it's scoped only to the Link.js. Also, rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.
infoMore information on how snapshot testing works and why we built it can be found on the release blog post. We recommend reading this blog post to get a good sense of when you should use snapshot testing. We also recommend watching this egghead video on Snapshot Testing with Jest.
Updating Snapshots​
It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.
One such situation can arise if we intentionally change the address the Link component in our example is pointing to.
// Updated test case with a Link to a different addressit('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.instagram.com">Instagram</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
In that case, Jest will print this output:

Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.
To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:
jest --updateSnapshot
Go ahead and accept the changes by running the above command. You may also use the equivalent single-character -u flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.
If you'd like to limit which snapshot test cases get re-generated, you can pass an additional --testNamePattern flag to re-record snapshots only for those tests that match the pattern.
You can try out this functionality by cloning the snapshot example, modifying the Link component, and running Jest.
Interactive Snapshot Mode​
Failed snapshots can also be updated interactively in watch mode:

Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.
From here you can choose to update that snapshot or skip to the next:

Once you're finished, Jest will give you a summary before returning back to watch mode:

Inline Snapshots​
Inline snapshots behave identically to external snapshots (.snap files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.
Example:
First, you write a test, calling .toMatchInlineSnapshot() with no arguments:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot();});
The next time you run Jest, tree will be evaluated, and a snapshot will be written as an argument to toMatchInlineSnapshot:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot(`    <a      className="normal"      href="https://example.com"      onMouseEnter={[Function]}      onMouseLeave={[Function]}    >      Example Site    </a>  `);});
That's all there is to it! You can even update the snapshots with --updateSnapshot or using the u key in --watch mode.
By default, Jest handles the writing of snapshots into your source code. However, if you're using prettier in your project, Jest will detect this and delegate the work to prettier instead (including honoring your configuration).
Property Matchers​
Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:
it('will fail every time', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot();});// Snapshotexports[`will fail every time 1`] = `{  "createdAt": 2018-05-19T23:36:09.816Z,  "id": 3,  "name": "LeBron James",}`;
For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:
it('will check the matchers and pass', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    id: expect.any(Number),  });});// Snapshotexports[`will check the matchers and pass 1`] = `{  "createdAt": Any<Date>,  "id": Any<Number>,  "name": "LeBron James",}`;
Any given value that is not a matcher will be checked exactly and saved to the snapshot:
it('will check the values and pass', () => {  const user = {    createdAt: new Date(),    name: 'Bond... James Bond',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    name: 'Bond... James Bond',  });});// Snapshotexports[`will check the values and pass 1`] = `{  "createdAt": Any<Date>,  "name": 'Bond... James Bond',}`;
tipIf the case concerns a string not an object then you need to replace random part of that string on your own before testing the snapshot.
You can use for that e.g. replace() and regular expressions.const randomNumber = Math.round(Math.random() * 100);const stringWithRandomData = `<div id="${randomNumber}">Lorem ipsum</div>`;const stringWithConstantData = stringWithRandomData.replace(/id="\d+"/, 123);expect(stringWithConstantData).toMatchSnapshot();Other ways this can be done is using the snapshot serializer or mocking the library responsible for generating the random part of the code you're snapshotting.
Best Practices​
Snapshots are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.
1. Treat snapshots as code​
Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.
Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.
As mentioned previously, Jest uses pretty-format to make snapshots human-readable, but you may find it useful to introduce additional tools, like eslint-plugin-jest with its no-large-snapshots option, or snapshot-diff with its component snapshot comparison feature, to promote committing short, focused assertions.
The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.
2. Tests should be deterministic​
Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.
For example, if you have a Clock component that uses Date.now(), the snapshot generated from this component will be different every time the test case is run. In this case we can mock the Date.now() method to return a consistent value every time the test is run:
Date.now = jest.fn(() => 1_482_363_367_071);
Now, every time the snapshot test case runs, Date.now() will return 1482363367071 consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.
3. Use descriptive snapshot names​
Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.
For example, compare:
exports[`<UserName /> should handle some test case`] = `null`;exports[`<UserName /> should handle some other test case`] = `<div>  Alan Turing</div>`;
To:
exports[`<UserName /> should render null`] = `null`;exports[`<UserName /> should render Alan Turing`] = `<div>  Alan Turing</div>`;
Since the latter describes exactly what's expected in the output, it's more clear to see when it's wrong:
exports[`<UserName /> should render null`] = `<div>  Alan Turing</div>`;exports[`<UserName /> should render Alan Turing`] = `null`;
Frequently Asked Questions​
Are snapshots written automatically on Continuous Integration (CI) systems?​
No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing --updateSnapshot. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.
Should snapshot files be committed?​
Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.
Does snapshot testing only work with React components?​
React and React Native components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of snapshotting CLI output in the Jest repo.
What's the difference between snapshot testing and visual regression testing?​
Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the Jest blog.
Does snapshot testing replace unit testing?​
Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.
What is the performance of snapshot testing regarding speed and size of the generated files?​
Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the toMatchSnapshot matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.
How do I resolve conflicts within snapshot files?​
Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.
Is it possible to apply test-driven development principles with snapshot testing?​
Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.
Does code coverage work with snapshot testing?​
Yes, as well as with any other test.Edit this pageLast updated on Sep 25, 2023 by Simen Bekkhus\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).GuidesSnapshot TestingVersion: NextOn this pageSnapshot TestingSnapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.
A typical snapshot test case renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the UI component.
Snapshot Testing with Jest​
A similar approach can be taken when it comes to testing your React components. Instead of rendering the graphical UI, which would require building the entire app, you can use a test renderer to quickly generate a serializable value for your React tree. Consider this example test for a Link component:
import renderer from 'react-test-renderer';import Link from '../Link';it('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.facebook.com">Facebook</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
The first time this test is run, Jest creates a snapshot file that looks like this:
exports[`renders correctly 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses pretty-format to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the <Link> component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.
noteThe snapshot is directly scoped to the data you render – in our example the <Link> component with page prop passed to it. This implies that even if any other file has missing props (say, App.js) in the <Link> component, it will still pass the test as the test doesn't know the usage of <Link> component and it's scoped only to the Link.js. Also, rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.
infoMore information on how snapshot testing works and why we built it can be found on the release blog post. We recommend reading this blog post to get a good sense of when you should use snapshot testing. We also recommend watching this egghead video on Snapshot Testing with Jest.
Updating Snapshots​
It's straightforward to spot when a snapshot test fails after a bug has been introduced. When that happens, go ahead and fix the issue and make sure your snapshot tests are passing again. Now, let's talk about the case when a snapshot test is failing due to an intentional implementation change.
One such situation can arise if we intentionally change the address the Link component in our example is pointing to.
// Updated test case with a Link to a different addressit('renders correctly', () => {  const tree = renderer    .create(<Link page="http://www.instagram.com">Instagram</Link>)    .toJSON();  expect(tree).toMatchSnapshot();});
In that case, Jest will print this output:

Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.
To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:
jest --updateSnapshot
Go ahead and accept the changes by running the above command. You may also use the equivalent single-character -u flag to re-generate snapshots if you prefer. This will re-generate snapshot artifacts for all failing snapshot tests. If we had any additional failing snapshot tests due to an unintentional bug, we would need to fix the bug before re-generating snapshots to avoid recording snapshots of the buggy behavior.
If you'd like to limit which snapshot test cases get re-generated, you can pass an additional --testNamePattern flag to re-record snapshots only for those tests that match the pattern.
You can try out this functionality by cloning the snapshot example, modifying the Link component, and running Jest.
Interactive Snapshot Mode​
Failed snapshots can also be updated interactively in watch mode:

Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.
From here you can choose to update that snapshot or skip to the next:

Once you're finished, Jest will give you a summary before returning back to watch mode:

Inline Snapshots​
Inline snapshots behave identically to external snapshots (.snap files), except the snapshot values are written automatically back into the source code. This means you can get the benefits of automatically generated snapshots without having to switch to an external file to make sure the correct value was written.
Example:
First, you write a test, calling .toMatchInlineSnapshot() with no arguments:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot();});
The next time you run Jest, tree will be evaluated, and a snapshot will be written as an argument to toMatchInlineSnapshot:
it('renders correctly', () => {  const tree = renderer    .create(<Link page="https://example.com">Example Site</Link>)    .toJSON();  expect(tree).toMatchInlineSnapshot(`    <a      className="normal"      href="https://example.com"      onMouseEnter={[Function]}      onMouseLeave={[Function]}    >      Example Site    </a>  `);});
That's all there is to it! You can even update the snapshots with --updateSnapshot or using the u key in --watch mode.
By default, Jest handles the writing of snapshots into your source code. However, if you're using prettier in your project, Jest will detect this and delegate the work to prettier instead (including honoring your configuration).
Property Matchers​
Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:
it('will fail every time', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot();});// Snapshotexports[`will fail every time 1`] = `{  "createdAt": 2018-05-19T23:36:09.816Z,  "id": 3,  "name": "LeBron James",}`;
For these cases, Jest allows providing an asymmetric matcher for any property. These matchers are checked before the snapshot is written or tested, and then saved to the snapshot file instead of the received value:
it('will check the matchers and pass', () => {  const user = {    createdAt: new Date(),    id: Math.floor(Math.random() * 20),    name: 'LeBron James',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    id: expect.any(Number),  });});// Snapshotexports[`will check the matchers and pass 1`] = `{  "createdAt": Any<Date>,  "id": Any<Number>,  "name": "LeBron James",}`;
Any given value that is not a matcher will be checked exactly and saved to the snapshot:
it('will check the values and pass', () => {  const user = {    createdAt: new Date(),    name: 'Bond... James Bond',  };  expect(user).toMatchSnapshot({    createdAt: expect.any(Date),    name: 'Bond... James Bond',  });});// Snapshotexports[`will check the values and pass 1`] = `{  "createdAt": Any<Date>,  "name": 'Bond... James Bond',}`;
tipIf the case concerns a string not an object then you need to replace random part of that string on your own before testing the snapshot.
You can use for that e.g. replace() and regular expressions.const randomNumber = Math.round(Math.random() * 100);const stringWithRandomData = `<div id="${randomNumber}">Lorem ipsum</div>`;const stringWithConstantData = stringWithRandomData.replace(/id="\d+"/, 123);expect(stringWithConstantData).toMatchSnapshot();Other ways this can be done is using the snapshot serializer or mocking the library responsible for generating the random part of the code you're snapshotting.
Best Practices​
Snapshots are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.
1. Treat snapshots as code​
Commit snapshots and review them as part of your regular code review process. This means treating snapshots as you would any other type of test or code in your project.
Ensure that your snapshots are readable by keeping them focused, short, and by using tools that enforce these stylistic conventions.
As mentioned previously, Jest uses pretty-format to make snapshots human-readable, but you may find it useful to introduce additional tools, like eslint-plugin-jest with its no-large-snapshots option, or snapshot-diff with its component snapshot comparison feature, to promote committing short, focused assertions.
The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.
2. Tests should be deterministic​
Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.
For example, if you have a Clock component that uses Date.now(), the snapshot generated from this component will be different every time the test case is run. In this case we can mock the Date.now() method to return a consistent value every time the test is run:
Date.now = jest.fn(() => 1_482_363_367_071);
Now, every time the snapshot test case runs, Date.now() will return 1482363367071 consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.
3. Use descriptive snapshot names​
Always strive to use descriptive test and/or snapshot names for snapshots. The best names describe the expected snapshot content. This makes it easier for reviewers to verify the snapshots during review, and for anyone to know whether or not an outdated snapshot is the correct behavior before updating.
For example, compare:
exports[`<UserName /> should handle some test case`] = `null`;exports[`<UserName /> should handle some other test case`] = `<div>  Alan Turing</div>`;
To:
exports[`<UserName /> should render null`] = `null`;exports[`<UserName /> should render Alan Turing`] = `<div>  Alan Turing</div>`;
Since the latter describes exactly what's expected in the output, it's more clear to see when it's wrong:
exports[`<UserName /> should render null`] = `<div>  Alan Turing</div>`;exports[`<UserName /> should render Alan Turing`] = `null`;
Frequently Asked Questions​
Are snapshots written automatically on Continuous Integration (CI) systems?​
No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing --updateSnapshot. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.
Should snapshot files be committed?​
Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.
Does snapshot testing only work with React components?​
React and React Native components are a good use case for snapshot testing. However, snapshots can capture any serializable value and should be used anytime the goal is testing whether the output is correct. The Jest repository contains many examples of testing the output of Jest itself, the output of Jest's assertion library as well as log messages from various parts of the Jest codebase. See an example of snapshotting CLI output in the Jest repo.
What's the difference between snapshot testing and visual regression testing?​
Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the Jest blog.
Does snapshot testing replace unit testing?​
Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.
What is the performance of snapshot testing regarding speed and size of the generated files?​
Jest has been rewritten with performance in mind, and snapshot testing is not an exception. Since snapshots are stored within text files, this way of testing is fast and reliable. Jest generates a new file for each test file that invokes the toMatchSnapshot matcher. The size of the snapshots is pretty small: For reference, the size of all snapshot files in the Jest codebase itself is less than 300 KB.
How do I resolve conflicts within snapshot files?​
Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.
Is it possible to apply test-driven development principles with snapshot testing?​
Although it is possible to write snapshot files manually, that is usually not approachable. Snapshots help to figure out whether the output of the modules covered by tests is changed, rather than giving guidance to design the code in the first place.
Does code coverage work with snapshot testing?​
Yes, as well as with any other test.Edit this pageLast updated on Sep 25, 2023 by Simen BekkhusPreviousMore ResourcesNextAn Async ExampleSnapshot Testing with JestUpdating SnapshotsInteractive Snapshot ModeInline SnapshotsProperty MatchersBest Practices1. Treat snapshots as code2. Tests should be deterministic3. Use descriptive snapshot namesFrequently Asked QuestionsAre snapshots written automatically on Continuous Integration (CI) systems?Should snapshot files be committed?Does snapshot testing only work with React components?What's the difference between snapshot testing and visual regression testing?Does snapshot testing replace unit testing?What is the performance of snapshot testing regarding speed and size of the generated files?How do I resolve conflicts within snapshot files?Is it possible to apply test-driven development principles with snapshot testing?Does code coverage work with snapshot testing?\n\n\n\nFramework GuidesTesting React AppsVersion: NextOn this pageTesting React AppsAt Facebook, we use Jest to test React applications.
Setup​
Setup with Create React App​
If you are new to React, we recommend using Create React App. It is ready to use and ships with Jest! You will only need to add react-test-renderer for rendering snapshots.
Run
npmYarnpnpmnpm install --save-dev react-test-rendereryarn add --dev react-test-rendererpnpm add --save-dev react-test-renderer
Setup without Create React App​
If you have an existing application you'll need to install a few packages to make everything work well together. We are using the babel-jest package and the react babel preset to transform our code inside of the test environment. Also see using babel.
Run
npmYarnpnpmnpm install --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendereryarn add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendererpnpm add --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer
Your package.json should look something like this (where <current-version> is the actual latest version number for the package). Please add the scripts and jest configuration entries:
{  "dependencies": {    "react": "<current-version>",    "react-dom": "<current-version>"  },  "devDependencies": {    "@babel/preset-env": "<current-version>",    "@babel/preset-react": "<current-version>",    "babel-jest": "<current-version>",    "jest": "<current-version>",    "react-test-renderer": "<current-version>"  },  "scripts": {    "test": "jest"  }}
babel.config.jsmodule.exports = {  presets: [    '@babel/preset-env',    ['@babel/preset-react', {runtime: 'automatic'}],  ],};
And you're good to go!
Snapshot Testing​
Let's create a snapshot test for a Link component that renders hyperlinks:
Link.jsimport {useState} from 'react';const STATUS = {  HOVERED: 'hovered',  NORMAL: 'normal',};export default function Link({page, children}) {  const [status, setStatus] = useState(STATUS.NORMAL);  const onMouseEnter = () => {    setStatus(STATUS.HOVERED);  };  const onMouseLeave = () => {    setStatus(STATUS.NORMAL);  };  return (    <a      className={status}      href={page || '#'}      onMouseEnter={onMouseEnter}      onMouseLeave={onMouseLeave}    >      {children}    </a>  );}
noteExamples are using Function components, but Class components can be tested in the same way. See React: Function and Class Components. Reminders that with Class components, we expect Jest to be used to test props and not methods directly.
Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:
Link.test.jsimport renderer from 'react-test-renderer';import Link from '../Link';it('changes the class when hovered', () => {  const component = renderer.create(    <Link page="http://www.facebook.com">Facebook</Link>,  );  let tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseEnter();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseLeave();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();});
When you run yarn test or jest, this will produce an output file like this:
__tests__/__snapshots__/Link.test.js.snapexports[`changes the class when hovered 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 2`] = `<a  className="hovered"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 3`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with jest -u to overwrite the existing snapshot.
The code for this example is available at examples/snapshot.
Snapshot Testing with Mocks, Enzyme and React 16+​
There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:
jest.mock('../SomeDirectory/SomeComponent', () => 'SomeComponent');
Then you will see warnings in the console:
Warning: <SomeComponent /> is using uppercase HTML. Always use lowercase HTML tags in React.# Or:Warning: The tag <SomeComponent> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.
React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:

Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:
jest.mock('./SomeComponent', () => () => 'SomeComponent');

Render as a custom element. DOM "custom elements" aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.
jest.mock('./Widget', () => () => <mock-widget />);

Use react-test-renderer. The test renderer doesn't care about element types and will happily accept e.g. SomeComponent. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.
Disable warnings all together (should be done in your jest setup file):
jest.mock('fbjs/lib/warning', () => require('fbjs/lib/emptyFunction'));
This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.

DOM Testing​
If you'd like to assert, and manipulate your rendered components you can use @testing-library/react, Enzyme, or React's TestUtils. The following example use @testing-library/react.
@testing-library/react​
npmYarnpnpmnpm install --save-dev @testing-library/reactyarn add --dev @testing-library/reactpnpm add --save-dev @testing-library/react
Let's implement a checkbox which swaps between two labels:
CheckboxWithLabel.jsimport {useState} from 'react';export default function CheckboxWithLabel({labelOn, labelOff}) {  const [isChecked, setIsChecked] = useState(false);  const onChange = () => {    setIsChecked(!isChecked);  };  return (    <label>      <input type="checkbox" checked={isChecked} onChange={onChange} />      {isChecked ? labelOn : labelOff}    </label>  );}
__tests__/CheckboxWithLabel-test.jsimport {cleanup, fireEvent, render} from '@testing-library/react';import CheckboxWithLabel from '../CheckboxWithLabel';// Note: running cleanup afterEach is done automatically for you in @testing-library/[email protected] or higher// unmount and cleanup DOM after the test is finished.afterEach(cleanup);it('CheckboxWithLabel changes the text after click', () => {  const {queryByLabelText, getByLabelText} = render(    <CheckboxWithLabel labelOn="On" labelOff="Off" />,  );  expect(queryByLabelText(/off/i)).toBeTruthy();  fireEvent.click(getByLabelText(/off/i));  expect(queryByLabelText(/on/i)).toBeTruthy();});
The code for this example is available at examples/react-testing-library.
Custom transformers​
If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using @babel/core:
custom-transformer.js'use strict';const {transform} = require('@babel/core');const jestPreset = require('babel-preset-jest');module.exports = {  process(src, filename) {    const result = transform(src, {      filename,      presets: [jestPreset],    });    return result || src;  },};
Don't forget to install the @babel/core and babel-preset-jest packages for this example to work.
To make this work with Jest you need to update your Jest configuration with this: "transform": {"\\.js$": "path/to/custom-transformer.js"}.
If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:
const babelJest = require('babel-jest');module.exports = babelJest.createTransformer({  presets: ['my-custom-preset'],});
See dedicated docs for more details.Edit this pageLast updated on Aug 15, 2023 by Frazer Smith\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).Framework GuidesTesting React AppsVersion: NextOn this pageTesting React AppsAt Facebook, we use Jest to test React applications.
Setup​
Setup with Create React App​
If you are new to React, we recommend using Create React App. It is ready to use and ships with Jest! You will only need to add react-test-renderer for rendering snapshots.
Run
npmYarnpnpmnpm install --save-dev react-test-rendereryarn add --dev react-test-rendererpnpm add --save-dev react-test-renderer
Setup without Create React App​
If you have an existing application you'll need to install a few packages to make everything work well together. We are using the babel-jest package and the react babel preset to transform our code inside of the test environment. Also see using babel.
Run
npmYarnpnpmnpm install --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendereryarn add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-rendererpnpm add --save-dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer
Your package.json should look something like this (where <current-version> is the actual latest version number for the package). Please add the scripts and jest configuration entries:
{  "dependencies": {    "react": "<current-version>",    "react-dom": "<current-version>"  },  "devDependencies": {    "@babel/preset-env": "<current-version>",    "@babel/preset-react": "<current-version>",    "babel-jest": "<current-version>",    "jest": "<current-version>",    "react-test-renderer": "<current-version>"  },  "scripts": {    "test": "jest"  }}
babel.config.jsmodule.exports = {  presets: [    '@babel/preset-env',    ['@babel/preset-react', {runtime: 'automatic'}],  ],};
And you're good to go!
Snapshot Testing​
Let's create a snapshot test for a Link component that renders hyperlinks:
Link.jsimport {useState} from 'react';const STATUS = {  HOVERED: 'hovered',  NORMAL: 'normal',};export default function Link({page, children}) {  const [status, setStatus] = useState(STATUS.NORMAL);  const onMouseEnter = () => {    setStatus(STATUS.HOVERED);  };  const onMouseLeave = () => {    setStatus(STATUS.NORMAL);  };  return (    <a      className={status}      href={page || '#'}      onMouseEnter={onMouseEnter}      onMouseLeave={onMouseLeave}    >      {children}    </a>  );}
noteExamples are using Function components, but Class components can be tested in the same way. See React: Function and Class Components. Reminders that with Class components, we expect Jest to be used to test props and not methods directly.
Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:
Link.test.jsimport renderer from 'react-test-renderer';import Link from '../Link';it('changes the class when hovered', () => {  const component = renderer.create(    <Link page="http://www.facebook.com">Facebook</Link>,  );  let tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseEnter();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();  // manually trigger the callback  renderer.act(() => {    tree.props.onMouseLeave();  });  // re-rendering  tree = component.toJSON();  expect(tree).toMatchSnapshot();});
When you run yarn test or jest, this will produce an output file like this:
__tests__/__snapshots__/Link.test.js.snapexports[`changes the class when hovered 1`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 2`] = `<a  className="hovered"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;exports[`changes the class when hovered 3`] = `<a  className="normal"  href="http://www.facebook.com"  onMouseEnter={[Function]}  onMouseLeave={[Function]}>  Facebook</a>`;
The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with jest -u to overwrite the existing snapshot.
The code for this example is available at examples/snapshot.
Snapshot Testing with Mocks, Enzyme and React 16+​
There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:
jest.mock('../SomeDirectory/SomeComponent', () => 'SomeComponent');
Then you will see warnings in the console:
Warning: <SomeComponent /> is using uppercase HTML. Always use lowercase HTML tags in React.# Or:Warning: The tag <SomeComponent> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.
React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:

Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:
jest.mock('./SomeComponent', () => () => 'SomeComponent');

Render as a custom element. DOM "custom elements" aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.
jest.mock('./Widget', () => () => <mock-widget />);

Use react-test-renderer. The test renderer doesn't care about element types and will happily accept e.g. SomeComponent. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.
Disable warnings all together (should be done in your jest setup file):
jest.mock('fbjs/lib/warning', () => require('fbjs/lib/emptyFunction'));
This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.

DOM Testing​
If you'd like to assert, and manipulate your rendered components you can use @testing-library/react, Enzyme, or React's TestUtils. The following example use @testing-library/react.
@testing-library/react​
npmYarnpnpmnpm install --save-dev @testing-library/reactyarn add --dev @testing-library/reactpnpm add --save-dev @testing-library/react
Let's implement a checkbox which swaps between two labels:
CheckboxWithLabel.jsimport {useState} from 'react';export default function CheckboxWithLabel({labelOn, labelOff}) {  const [isChecked, setIsChecked] = useState(false);  const onChange = () => {    setIsChecked(!isChecked);  };  return (    <label>      <input type="checkbox" checked={isChecked} onChange={onChange} />      {isChecked ? labelOn : labelOff}    </label>  );}
__tests__/CheckboxWithLabel-test.jsimport {cleanup, fireEvent, render} from '@testing-library/react';import CheckboxWithLabel from '../CheckboxWithLabel';// Note: running cleanup afterEach is done automatically for you in @testing-library/[email protected] or higher// unmount and cleanup DOM after the test is finished.afterEach(cleanup);it('CheckboxWithLabel changes the text after click', () => {  const {queryByLabelText, getByLabelText} = render(    <CheckboxWithLabel labelOn="On" labelOff="Off" />,  );  expect(queryByLabelText(/off/i)).toBeTruthy();  fireEvent.click(getByLabelText(/off/i));  expect(queryByLabelText(/on/i)).toBeTruthy();});
The code for this example is available at examples/react-testing-library.
Custom transformers​
If you need more advanced functionality, you can also build your own transformer. Instead of using babel-jest, here is an example of using @babel/core:
custom-transformer.js'use strict';const {transform} = require('@babel/core');const jestPreset = require('babel-preset-jest');module.exports = {  process(src, filename) {    const result = transform(src, {      filename,      presets: [jestPreset],    });    return result || src;  },};
Don't forget to install the @babel/core and babel-preset-jest packages for this example to work.
To make this work with Jest you need to update your Jest configuration with this: "transform": {"\\.js$": "path/to/custom-transformer.js"}.
If you'd like to build a transformer with babel support, you can also use babel-jest to compose one and pass in your custom configuration options:
const babelJest = require('babel-jest');module.exports = babelJest.createTransformer({  presets: ['my-custom-preset'],});
See dedicated docs for more details.Edit this pageLast updated on Aug 15, 2023 by Frazer SmithPreviousArchitectureNextTesting React Native AppsSetupSetup with Create React AppSetup without Create React AppSnapshot TestingDOM TestingCustom transformers\n\n\n\nUpgrade GuidesFrom v28 to v29Version: NextOn this pageFrom v28 to v29Upgrading Jest from v28 to v29? This guide aims to help refactoring your configuration and tests.
infoSee changelog for the full list of changes.
noteUpgrading from an older version? You can see the upgrade guide from v27 to v28 here.
Compatibility​
The supported Node versions are 14.15, 16.10, 18.0 and above.
Snapshot format​
As announced in the Jest 28 blog post, Jest 29 has changed the default snapshot formatting to {escapeString: false, printBasicPrototype: false}.
If you want to keep the old behavior, you can set the snapshotFormat property to:
+ snapshotFormat: {+   escapeString: true,+   printBasicPrototype: true+ }
JSDOM upgrade​
jest-environment-jsdom has upgraded jsdom from v19 to v20.
infoIf you use jest-environment-jsdom, the minimum TypeScript version is set to 4.5.
Notably, jsdom@20 includes support for crypto.getRandomValues(), which means packages like uuid and nanoid, which doesn't work properly in Jest@28, can work without extra polyfills.
pretty-format​
ConvertAnsi plugin is removed from pretty-format package in favour of jest-serializer-ansi-escapes.
jest-mock​
Exports of Mocked* utility types from jest-mock package have changed. MaybeMockedDeep and MaybeMocked now are exported as Mocked and MockedShallow respectively; only deep mocked variants of MockedClass, MockedFunction and MockedObject are exposed.
TypeScript​

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.mocked()​
The jest.mocked() helper method now wraps types of deep members of passed object by default. If you have used the method with true as the second argument, remove it to avoid type errors:
- const mockedObject = jest.mocked(someObject, true);+ const mockedObject = jest.mocked(someObject);
To have the old shallow mocked behavior, pass {shallow: true} as the second argument:
- const mockedObject = jest.mocked(someObject);+ const mockedObject = jest.mocked(someObject, {shallow: true});Edit this pageLast updated on Sep 23, 2023 by Michael Knight\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).Upgrade GuidesFrom v28 to v29Version: NextOn this pageFrom v28 to v29Upgrading Jest from v28 to v29? This guide aims to help refactoring your configuration and tests.
infoSee changelog for the full list of changes.
noteUpgrading from an older version? You can see the upgrade guide from v27 to v28 here.
Compatibility​
The supported Node versions are 14.15, 16.10, 18.0 and above.
Snapshot format​
As announced in the Jest 28 blog post, Jest 29 has changed the default snapshot formatting to {escapeString: false, printBasicPrototype: false}.
If you want to keep the old behavior, you can set the snapshotFormat property to:
+ snapshotFormat: {+   escapeString: true,+   printBasicPrototype: true+ }
JSDOM upgrade​
jest-environment-jsdom has upgraded jsdom from v19 to v20.
infoIf you use jest-environment-jsdom, the minimum TypeScript version is set to 4.5.
Notably, jsdom@20 includes support for crypto.getRandomValues(), which means packages like uuid and nanoid, which doesn't work properly in Jest@28, can work without extra polyfills.
pretty-format​
ConvertAnsi plugin is removed from pretty-format package in favour of jest-serializer-ansi-escapes.
jest-mock​
Exports of Mocked* utility types from jest-mock package have changed. MaybeMockedDeep and MaybeMocked now are exported as Mocked and MockedShallow respectively; only deep mocked variants of MockedClass, MockedFunction and MockedObject are exposed.
TypeScript​

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.mocked()​
The jest.mocked() helper method now wraps types of deep members of passed object by default. If you have used the method with true as the second argument, remove it to avoid type errors:
- const mockedObject = jest.mocked(someObject, true);+ const mockedObject = jest.mocked(someObject);
To have the old shallow mocked behavior, pass {shallow: true} as the second argument:
- const mockedObject = jest.mocked(someObject);+ const mockedObject = jest.mocked(someObject, {shallow: true});Edit this pageLast updated on Sep 23, 2023 by Michael KnightPreviousTesting Web FrameworksCompatibilitySnapshot formatJSDOM upgradepretty-formatjest-mockTypeScriptjest.mocked()\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nJest CLI OptionsVersion: NextOn this pageJest CLI OptionsThe jest command line runner has a number of useful options. You can run jest --help to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's Configuration options can also be specified through the CLI.
Here is a brief overview:
Running from the command line​
Run all tests (default):
jest
Run only the tests that were specified with a pattern or filename:
jest my-test #orjest path/to/my-test.js
Run tests related to changed files based on hg/git (uncommitted files):
jest -o
Run tests related to path/to/fileA.js and path/to/fileB.js:
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
Run tests that match this spec name (match against the name in describe or test, basically).
jest -t name-of-spec
Run watch mode:
jest --watch #runs jest -o by defaultjest --watchAll #runs all tests
Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.
Using with package manager​
If you run Jest via your package manager, you can still pass the command line arguments directly as Jest arguments.
Instead of:
jest -u -t="ColorPicker"
you can use:
npmYarnpnpmnpm test -- -u -t="ColorPicker"yarn test -u -t="ColorPicker"pnpm test -u -t="ColorPicker"
Camelcase & dashed args support​
Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:
jest --collect-coveragejest --collectCoverage
Arguments can also be mixed:
jest --update-snapshot --detectOpenHandles
Options​
noteCLI options take precedence over values from the Configuration.

Camelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPatterns=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--waitNextEventLoopTurnForUnhandledRejectionEvents--watch--watchAll--watchman--workerThreads

Reference​
jest <regexForTestFiles>​
When you run jest with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: jest "my.*(complex)?pattern". On Windows, you will need to use / as a path separator or escape \ as \\.
--bail[=<n>]​
Alias: -b. Exit the test suite immediately upon n number of failing test suite. Defaults to 1.
--cache​
Whether to use the cache. Defaults to true. Disable the cache using --no-cache.
cautionThe cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.
If you want to inspect the cache, use --showConfig and look at the cacheDirectory value. If you need to clear the cache, use --clearCache.
--changedFilesWithAncestor​
Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to --onlyChanged.
--changedSince​
Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to --onlyChanged.
--ci​
When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with --updateSnapshot.
--clearCache​
Deletes the Jest cache directory and then exits without running tests. Will delete cacheDirectory if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling jest --showConfig.
cautionClearing the cache will reduce performance.
--clearMocks​
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
--collectCoverageFrom=<glob>​
A glob pattern relative to rootDir matching the files that coverage info needs to be collected from.
--colors​
Forces test results output highlighting even if stdout is not a TTY.
noteAlternatively you can set the environment variable FORCE_COLOR=true to forcefully enable or FORCE_COLOR=false to disable colorized output. The use of FORCE_COLOR overrides all other color support checks.
--config=<path>​
Alias: -c. The path to a Jest config file specifying how to find and execute tests. If no rootDir is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.
--coverage[=<boolean>]​
Alias: --collectCoverage. Indicates that test coverage information should be collected and reported in the output. Optionally pass <boolean> to override option set in configuration.
--coverageDirectory=<path>​
The directory where Jest should output its coverage files.
--coverageProvider=<provider>​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
--debug​
Print debugging info about your Jest config.
--detectOpenHandles​
Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use --forceExit in order for Jest to exit to potentially track down the reason. This implies --runInBand, making tests run serially. Implemented using async_hooks. This option has a significant performance penalty and should only be used for debugging.
--env=<environment>​
The test environment used for all tests. This can point to any file or node module. Examples: jsdom, node or path/to/my-environment.js.
--errorOnDeprecated​
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--expand​
Alias: -e. Use this flag to show full diffs and errors instead of a patch.
--filter=<file>​
Path to a module exporting a filtering function. This asynchronous function receives a list of test paths which can be manipulated to exclude tests from running and must return an object with shape { filtered: Array<string> } containing the tests that should be run by Jest. Especially useful when used in conjunction with a testing infrastructure to filter known broken tests.
my-filter.js// This filter when applied will only run tests ending in .spec.js (not the best way to do it, but it's just an example):const filteringFunction = testPath => testPath.endsWith('.spec.js');module.exports = testPaths => {  const allowedPaths = testPaths.filter(filteringFunction); // ["path1.spec.js", "path2.spec.js", etc]  return {    filtered: allowedPaths,  };};
--findRelatedTests <spaceSeparatedListOfSourceFiles>​
Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with --coverage to include a test coverage for the source files, no duplicate --collectCoverageFrom arguments needed.
--forceExit​
Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up.
cautionThis feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use --detectOpenHandles to help track it down.
--help​
Show the help information, similar to this page.
--ignoreProjects <project1> ... <projectN>​
Ignore the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--injectGlobals​
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
--json​
Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
--lastCommit​
Run all tests affected by file changes in the last commit made. Behaves similarly to --onlyChanged.
--listTests​
Lists all test files that Jest will run given the arguments, and exits.
--logHeapUsage​
Logs the heap usage after every test. Useful to debug memory leaks. Use together with --runInBand and --expose-gc in node.
--maxConcurrency=<num>​
Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use test.concurrent.
--maxWorkers=<num>|<string>​
Alias: -w. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration: --maxWorkers=50%
--noStackTrace​
Disables stack trace in test results output.
--notify​
Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.
--onlyChanged​
Alias: -o. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).
--onlyFailures​
Alias: -f. Run tests that failed in the previous execution.
--openHandlesTimeout=<milliseconds>​
When --detectOpenHandles and --forceExit are disabled, Jest will print a warning if the process has not exited cleanly after this number of milliseconds. A value of 0 disables the warning. Defaults to 1000.
--outputFile=<filename>​
Write test results to a file when the --json option is also specified. The returned JSON structure is documented in testResultsProcessor.
--passWithNoTests​
Allows the test suite to pass when no files are found.
--projects <path1> ... <pathN>​
Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the projects configuration option.
noteIf configuration files are found in the specified paths, all projects specified within those configuration files will be run.
--randomize​
Shuffle the order of the tests within a file. The shuffling is based on the seed. See --seed=<num> for more info.
Seed value is displayed when this option is set. Equivalent to setting the CLI option --showSeed.
jest --randomize --seed 1234
noteThis option is only supported using the default jest-circus test runner.
--reporters​
Run tests with specified reporters. Reporter options are not available via CLI. Example with multiple reporters:
jest --reporters="default" --reporters="jest-junit"
--resetMocks​
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--restoreMocks​
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--roots​
A list of paths to directories that Jest should use to search for files in.
--runInBand​
Alias: -i. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.
--runTestsByPath​
Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file.
For example, given the following file structure:
__tests__└── t1.test.js # test└── t2.test.js # test
When ran with a pattern, no test is found:
jest --runTestsByPath __tests__/t
Output:
No tests found
However, passing an exact path will execute only the given test:
jest --runTestsByPath __tests__/t1.test.js
Output:
PASS __tests__/t1.test.js
tipThe default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files.
--seed=<num>​
Sets a seed value that can be retrieved in a test file via jest.getSeed(). The seed value must be between -0x80000000 and 0x7fffffff inclusive (-2147483648 (-(2 ** 31)) and 2147483647 (2 ** 31 - 1) in decimal).
jest --seed=1324
tipIf this option is not specified Jest will randomly generate the value. You can use the --showSeed flag to print the seed in the test report summary.Jest uses the seed internally for shuffling the order in which test suites are run. If the --randomize option is used, the seed is also used for shuffling the order of tests within each describe block. When dealing with flaky tests, rerunning with the same seed might help reproduce the failure.
--selectProjects <project1> ... <projectN>​
Run the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--setupFilesAfterEnv <path1> ... <pathN>​
A list of paths to modules that run some code to configure or to set up the testing framework before each test. Beware that files imported by the setup scripts will not be mocked during testing.
--shard​
The test suite shard to execute in a format of (?<shardIndex>\d+)/(?<shardCount>\d+).
shardIndex describes which shard to select while shardCount controls the number of shards the suite should be split into.
shardIndex and shardCount have to be 1-based, positive numbers, and shardIndex has to be lower than or equal to shardCount.
When shard is specified the configured testSequencer has to implement a shard method.
For example, to split the suite into three shards, each running one third of the tests:
jest --shard=1/3jest --shard=2/3jest --shard=3/3
--showConfig​
Print your Jest config and then exits.
--showSeed​
Prints the seed value in the test report summary. See --seed=<num> for the details.
Can also be set in configuration. See showSeed.
--silent​
Prevent tests from printing messages through the console.
--testEnvironmentOptions=<json string>​
A JSON string with options that will be passed to the testEnvironment. The relevant options depend on the environment.
--testLocationInResults​
Adds a location field to test results. Useful if you want to report the location of a test in a reporter.
noteIn the resulting object column is 0-indexed while line is not.{  "column": 4,  "line": 5}
--testMatch glob1 ... globN​
The glob patterns Jest uses to detect test files. Please refer to the testMatch configuration for details.
--testNamePattern=<regex>​
Alias: -t. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like 'GET /api/posts with auth', then you can use jest -t=auth.
tipThe regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.
--testPathIgnorePatterns=<regex>|[array]​
A single or array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to --testPathPatterns, it will only run those tests with a path that does not match with the provided regexp expressions.
To pass as an array use escaped parentheses and space delimited regexps such as \(/node_modules/ /tests/e2e/\). Alternatively, you can omit parentheses by combining regexps into a single regexp like /node_modules/|/tests/e2e/. These two examples are equivalent.
--testPathPatterns=<regex>​
A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use / as a path separator or escape \ as \\.
--testRunner=<path>​
Lets you specify a custom test runner.
--testSequencer=<path>​
Lets you specify a custom test sequencer. Please refer to the testSequencer configuration for details.
--testTimeout=<number>​
Default timeout of a test in milliseconds. Default value: 5000.
--updateSnapshot​
Alias: -u. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with --testNamePattern to re-record snapshots.
--useStderr​
Divert all output to stderr.
--verbose​
Display individual test results with the test suite hierarchy.
--version​
Alias: -v. Print the version and exit.
--waitNextEventLoopTurnForUnhandledRejectionEvents​
Gives one event loop turn to handle rejectionHandled, uncaughtException or unhandledRejection.
Without this flag Jest may report false-positive errors (e.g. actually handled rejection reported) or not report actually unhandled rejection (or report it for different test case).
This option may add a noticeable overhead for fast test suites.
--watch​
Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the --watchAll option instead.
tipUse --no-watch (or --watch=false) to explicitly disable the watch mode if it was enabled using --watch. In most CI environments, this is automatically handled for you.
--watchAll​
Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the --watch option.
tipUse --no-watchAll (or --watchAll=false) to explicitly disable the watch mode if it was enabled using --watchAll. In most CI environments, this is automatically handled for you.
--watchman​
Whether to use watchman for file crawling. Defaults to true. Disable using --no-watchman.
--workerThreads​
Whether to use worker threads for parallelization. Child processes are used by default.
cautionThis is experimental feature. See the workerThreads configuration option for more details.Edit this pageLast updated on Sep 26, 2024 by Jörn Zaefferer\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).Jest CLI OptionsVersion: NextOn this pageJest CLI OptionsThe jest command line runner has a number of useful options. You can run jest --help to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's Configuration options can also be specified through the CLI.
Here is a brief overview:
Running from the command line​
Run all tests (default):
jest
Run only the tests that were specified with a pattern or filename:
jest my-test #orjest path/to/my-test.js
Run tests related to changed files based on hg/git (uncommitted files):
jest -o
Run tests related to path/to/fileA.js and path/to/fileB.js:
jest --findRelatedTests path/to/fileA.js path/to/fileB.js
Run tests that match this spec name (match against the name in describe or test, basically).
jest -t name-of-spec
Run watch mode:
jest --watch #runs jest -o by defaultjest --watchAll #runs all tests
Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.
Using with package manager​
If you run Jest via your package manager, you can still pass the command line arguments directly as Jest arguments.
Instead of:
jest -u -t="ColorPicker"
you can use:
npmYarnpnpmnpm test -- -u -t="ColorPicker"yarn test -u -t="ColorPicker"pnpm test -u -t="ColorPicker"
Camelcase & dashed args support​
Jest supports both camelcase and dashed arg formats. The following examples will have an equal result:
jest --collect-coveragejest --collectCoverage
Arguments can also be mixed:
jest --update-snapshot --detectOpenHandles
Options​
noteCLI options take precedence over values from the Configuration.

Camelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPatterns=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--waitNextEventLoopTurnForUnhandledRejectionEvents--watch--watchAll--watchman--workerThreads

Reference​
jest <regexForTestFiles>​
When you run jest with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: jest "my.*(complex)?pattern". On Windows, you will need to use / as a path separator or escape \ as \\.
--bail[=<n>]​
Alias: -b. Exit the test suite immediately upon n number of failing test suite. Defaults to 1.
--cache​
Whether to use the cache. Defaults to true. Disable the cache using --no-cache.
cautionThe cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.
If you want to inspect the cache, use --showConfig and look at the cacheDirectory value. If you need to clear the cache, use --clearCache.
--changedFilesWithAncestor​
Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to --onlyChanged.
--changedSince​
Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to --onlyChanged.
--ci​
When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with --updateSnapshot.
--clearCache​
Deletes the Jest cache directory and then exits without running tests. Will delete cacheDirectory if the option is passed, or Jest's default cache directory. The default cache directory can be found by calling jest --showConfig.
cautionClearing the cache will reduce performance.
--clearMocks​
Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling jest.clearAllMocks() before each test. This does not remove any mock implementation that may have been provided.
--collectCoverageFrom=<glob>​
A glob pattern relative to rootDir matching the files that coverage info needs to be collected from.
--colors​
Forces test results output highlighting even if stdout is not a TTY.
noteAlternatively you can set the environment variable FORCE_COLOR=true to forcefully enable or FORCE_COLOR=false to disable colorized output. The use of FORCE_COLOR overrides all other color support checks.
--config=<path>​
Alias: -c. The path to a Jest config file specifying how to find and execute tests. If no rootDir is set in the config, the directory containing the config file is assumed to be the rootDir for the project. This can also be a JSON-encoded value which Jest will use as configuration.
--coverage[=<boolean>]​
Alias: --collectCoverage. Indicates that test coverage information should be collected and reported in the output. Optionally pass <boolean> to override option set in configuration.
--coverageDirectory=<path>​
The directory where Jest should output its coverage files.
--coverageProvider=<provider>​
Indicates which provider should be used to instrument code for coverage. Allowed values are babel (default) or v8.
--debug​
Print debugging info about your Jest config.
--detectOpenHandles​
Attempt to collect and print open handles preventing Jest from exiting cleanly. Use this in cases where you need to use --forceExit in order for Jest to exit to potentially track down the reason. This implies --runInBand, making tests run serially. Implemented using async_hooks. This option has a significant performance penalty and should only be used for debugging.
--env=<environment>​
The test environment used for all tests. This can point to any file or node module. Examples: jsdom, node or path/to/my-environment.js.
--errorOnDeprecated​
Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.
--expand​
Alias: -e. Use this flag to show full diffs and errors instead of a patch.
--filter=<file>​
Path to a module exporting a filtering function. This asynchronous function receives a list of test paths which can be manipulated to exclude tests from running and must return an object with shape { filtered: Array<string> } containing the tests that should be run by Jest. Especially useful when used in conjunction with a testing infrastructure to filter known broken tests.
my-filter.js// This filter when applied will only run tests ending in .spec.js (not the best way to do it, but it's just an example):const filteringFunction = testPath => testPath.endsWith('.spec.js');module.exports = testPaths => {  const allowedPaths = testPaths.filter(filteringFunction); // ["path1.spec.js", "path2.spec.js", etc]  return {    filtered: allowedPaths,  };};
--findRelatedTests <spaceSeparatedListOfSourceFiles>​
Find and run the tests that cover a space separated list of source files that were passed in as arguments. Useful for pre-commit hook integration to run the minimal amount of tests necessary. Can be used together with --coverage to include a test coverage for the source files, no duplicate --collectCoverageFrom arguments needed.
--forceExit​
Force Jest to exit after all tests have completed running. This is useful when resources set up by test code cannot be adequately cleaned up.
cautionThis feature is an escape-hatch. If Jest doesn't exit at the end of a test run, it means external resources are still being held on to or timers are still pending in your code. It is advised to tear down external resources after each test to make sure Jest can shut down cleanly. You can use --detectOpenHandles to help track it down.
--help​
Show the help information, similar to this page.
--ignoreProjects <project1> ... <projectN>​
Ignore the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--injectGlobals​
Insert Jest's globals (expect, test, describe, beforeEach etc.) into the global environment. If you set this to false, you should import from @jest/globals, e.g.
import {expect, jest, test} from '@jest/globals';jest.useFakeTimers();test('some test', () => {  expect(Date.now()).toBe(0);});
noteThis option is only supported using the default jest-circus test runner.
--json​
Prints the test results in JSON. This mode will send all other test output and user messages to stderr.
--lastCommit​
Run all tests affected by file changes in the last commit made. Behaves similarly to --onlyChanged.
--listTests​
Lists all test files that Jest will run given the arguments, and exits.
--logHeapUsage​
Logs the heap usage after every test. Useful to debug memory leaks. Use together with --runInBand and --expose-gc in node.
--maxConcurrency=<num>​
Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use test.concurrent.
--maxWorkers=<num>|<string>​
Alias: -w. Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.
For environments with variable CPUs available, you can use percentage based configuration: --maxWorkers=50%
--noStackTrace​
Disables stack trace in test results output.
--notify​
Activates notifications for test results. Good for when you don't want your consciousness to be able to focus on anything except JavaScript testing.
--onlyChanged​
Alias: -o. Attempts to identify which tests to run based on which files have changed in the current repository. Only works if you're running tests in a git/hg repository at the moment and requires a static dependency graph (ie. no dynamic requires).
--onlyFailures​
Alias: -f. Run tests that failed in the previous execution.
--openHandlesTimeout=<milliseconds>​
When --detectOpenHandles and --forceExit are disabled, Jest will print a warning if the process has not exited cleanly after this number of milliseconds. A value of 0 disables the warning. Defaults to 1000.
--outputFile=<filename>​
Write test results to a file when the --json option is also specified. The returned JSON structure is documented in testResultsProcessor.
--passWithNoTests​
Allows the test suite to pass when no files are found.
--projects <path1> ... <pathN>​
Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the projects configuration option.
noteIf configuration files are found in the specified paths, all projects specified within those configuration files will be run.
--randomize​
Shuffle the order of the tests within a file. The shuffling is based on the seed. See --seed=<num> for more info.
Seed value is displayed when this option is set. Equivalent to setting the CLI option --showSeed.
jest --randomize --seed 1234
noteThis option is only supported using the default jest-circus test runner.
--reporters​
Run tests with specified reporters. Reporter options are not available via CLI. Example with multiple reporters:
jest --reporters="default" --reporters="jest-junit"
--resetMocks​
Automatically reset mock state before every test. Equivalent to calling jest.resetAllMocks() before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.
--restoreMocks​
Automatically restore mock state and implementation before every test. Equivalent to calling jest.restoreAllMocks() before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.
--roots​
A list of paths to directories that Jest should use to search for files in.
--runInBand​
Alias: -i. Run all tests serially in the current process, rather than creating a worker pool of child processes that run tests. This can be useful for debugging.
--runTestsByPath​
Run only the tests that were specified with their exact paths. This avoids converting them into a regular expression and matching it against every single file.
For example, given the following file structure:
__tests__└── t1.test.js # test└── t2.test.js # test
When ran with a pattern, no test is found:
jest --runTestsByPath __tests__/t
Output:
No tests found
However, passing an exact path will execute only the given test:
jest --runTestsByPath __tests__/t1.test.js
Output:
PASS __tests__/t1.test.js
tipThe default regex matching works fine on small runs, but becomes slow if provided with multiple patterns and/or against a lot of tests. This option replaces the regex matching logic and by that optimizes the time it takes Jest to filter specific test files.
--seed=<num>​
Sets a seed value that can be retrieved in a test file via jest.getSeed(). The seed value must be between -0x80000000 and 0x7fffffff inclusive (-2147483648 (-(2 ** 31)) and 2147483647 (2 ** 31 - 1) in decimal).
jest --seed=1324
tipIf this option is not specified Jest will randomly generate the value. You can use the --showSeed flag to print the seed in the test report summary.Jest uses the seed internally for shuffling the order in which test suites are run. If the --randomize option is used, the seed is also used for shuffling the order of tests within each describe block. When dealing with flaky tests, rerunning with the same seed might help reproduce the failure.
--selectProjects <project1> ... <projectN>​
Run the tests of the specified projects. Jest uses the attribute displayName in the configuration to identify each project. If you use this option, you should provide a displayName to all your projects.
--setupFilesAfterEnv <path1> ... <pathN>​
A list of paths to modules that run some code to configure or to set up the testing framework before each test. Beware that files imported by the setup scripts will not be mocked during testing.
--shard​
The test suite shard to execute in a format of (?<shardIndex>\d+)/(?<shardCount>\d+).
shardIndex describes which shard to select while shardCount controls the number of shards the suite should be split into.
shardIndex and shardCount have to be 1-based, positive numbers, and shardIndex has to be lower than or equal to shardCount.
When shard is specified the configured testSequencer has to implement a shard method.
For example, to split the suite into three shards, each running one third of the tests:
jest --shard=1/3jest --shard=2/3jest --shard=3/3
--showConfig​
Print your Jest config and then exits.
--showSeed​
Prints the seed value in the test report summary. See --seed=<num> for the details.
Can also be set in configuration. See showSeed.
--silent​
Prevent tests from printing messages through the console.
--testEnvironmentOptions=<json string>​
A JSON string with options that will be passed to the testEnvironment. The relevant options depend on the environment.
--testLocationInResults​
Adds a location field to test results. Useful if you want to report the location of a test in a reporter.
noteIn the resulting object column is 0-indexed while line is not.{  "column": 4,  "line": 5}
--testMatch glob1 ... globN​
The glob patterns Jest uses to detect test files. Please refer to the testMatch configuration for details.
--testNamePattern=<regex>​
Alias: -t. Run only tests with a name that matches the regex. For example, suppose you want to run only tests related to authorization which will have names like 'GET /api/posts with auth', then you can use jest -t=auth.
tipThe regex is matched against the full name, which is a combination of the test name and all its surrounding describe blocks.
--testPathIgnorePatterns=<regex>|[array]​
A single or array of regexp pattern strings that are tested against all tests paths before executing the test. Contrary to --testPathPatterns, it will only run those tests with a path that does not match with the provided regexp expressions.
To pass as an array use escaped parentheses and space delimited regexps such as \(/node_modules/ /tests/e2e/\). Alternatively, you can omit parentheses by combining regexps into a single regexp like /node_modules/|/tests/e2e/. These two examples are equivalent.
--testPathPatterns=<regex>​
A regexp pattern string that is matched against all tests paths before executing the test. On Windows, you will need to use / as a path separator or escape \ as \\.
--testRunner=<path>​
Lets you specify a custom test runner.
--testSequencer=<path>​
Lets you specify a custom test sequencer. Please refer to the testSequencer configuration for details.
--testTimeout=<number>​
Default timeout of a test in milliseconds. Default value: 5000.
--updateSnapshot​
Alias: -u. Use this flag to re-record every snapshot that fails during this test run. Can be used together with a test suite pattern or with --testNamePattern to re-record snapshots.
--useStderr​
Divert all output to stderr.
--verbose​
Display individual test results with the test suite hierarchy.
--version​
Alias: -v. Print the version and exit.
--waitNextEventLoopTurnForUnhandledRejectionEvents​
Gives one event loop turn to handle rejectionHandled, uncaughtException or unhandledRejection.
Without this flag Jest may report false-positive errors (e.g. actually handled rejection reported) or not report actually unhandled rejection (or report it for different test case).
This option may add a noticeable overhead for fast test suites.
--watch​
Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the --watchAll option instead.
tipUse --no-watch (or --watch=false) to explicitly disable the watch mode if it was enabled using --watch. In most CI environments, this is automatically handled for you.
--watchAll​
Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the --watch option.
tipUse --no-watchAll (or --watchAll=false) to explicitly disable the watch mode if it was enabled using --watchAll. In most CI environments, this is automatically handled for you.
--watchman​
Whether to use watchman for file crawling. Defaults to true. Disable using --no-watchman.
--workerThreads​
Whether to use worker threads for parallelization. Child processes are used by default.
cautionThis is experimental feature. See the workerThreads configuration option for more details.Edit this pageLast updated on Sep 26, 2024 by Jörn ZaeffererPreviousConfiguring JestNextEnvironment VariablesRunning from the command lineUsing with package managerCamelcase & dashed args supportOptionsReferencejest <regexForTestFiles>--bail[=<n>]--cache--changedFilesWithAncestor--changedSince--ci--clearCache--clearMocks--collectCoverageFrom=<glob>--colors--config=<path>--coverage[=<boolean>]--coverageDirectory=<path>--coverageProvider=<provider>--debug--detectOpenHandles--env=<environment>--errorOnDeprecated--expand--filter=<file>--findRelatedTests <spaceSeparatedListOfSourceFiles>--forceExit--help--ignoreProjects <project1> ... <projectN>--injectGlobals--json--lastCommit--listTests--logHeapUsage--maxConcurrency=<num>--maxWorkers=<num>|<string>--noStackTrace--notify--onlyChanged--onlyFailures--openHandlesTimeout=<milliseconds>--outputFile=<filename>--passWithNoTests--projects <path1> ... <pathN>--randomize--reporters--resetMocks--restoreMocks--roots--runInBand--runTestsByPath--seed=<num>--selectProjects <project1> ... <projectN>--setupFilesAfterEnv <path1> ... <pathN>--shard--showConfig--showSeed--silent--testEnvironmentOptions=<json string>--testLocationInResults--testMatch glob1 ... globN--testNamePattern=<regex>--testPathIgnorePatterns=<regex>|[array]--testPathPatterns=<regex>--testRunner=<path>--testSequencer=<path>--testTimeout=<number>--updateSnapshot--useStderr--verbose--version--waitNextEventLoopTurnForUnhandledRejectionEvents--watch--watchAll--watchman--workerThreads\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nGuidesUsing with webpackVersion: NextOn this pageUsing with webpackJest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.
A webpack example​
Let's start with a common sort of webpack config file and translate it to a Jest setup.
webpack.config.jsmodule.exports = {  module: {    rules: [      {        test: /\.jsx?$/,        exclude: ['node_modules'],        use: ['babel-loader'],      },      {        test: /\.css$/,        use: ['style-loader', 'css-loader'],      },      {        test: /\.gif$/,        type: 'asset/inline',      },      {        test: /\.(ttf|eot|svg)$/,        type: 'asset/resource',      },    ],  },  resolve: {    alias: {      config$: './configs/app-config.js',      react: './vendor/react-master',    },    extensions: ['.js', '.jsx'],    modules: [      'node_modules',      'bower_components',      'shared',      '/shared/vendor/modules',    ],  },};
If you have JavaScript files that are transformed by Babel, you can enable support for Babel by installing the babel-jest plugin. Non-Babel JavaScript transformations can be handled with Jest's transform config option.
Handling Static Assets​
Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.
jest.config.jsmodule.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',  },};
And the mock files themselves:
__mocks__/styleMock.jsmodule.exports = {};
__mocks__/fileMock.jsmodule.exports = 'test-file-stub';
Mocking CSS Modules​
You can use an ES6 Proxy to mock CSS Modules:
npmYarnpnpmnpm install --save-dev identity-obj-proxyyarn add --dev identity-obj-proxypnpm add --save-dev identity-obj-proxy
Then all your className lookups on the styles object will be returned as-is (e.g., styles.foobar === 'foobar'). This is pretty handy for React Snapshot Testing.
jest.config.js (for CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': 'identity-obj-proxy',  },};
If moduleNameMapper cannot fulfill your requirements, you can use Jest's transform config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that require('logo.jpg'); returns 'logo') can be written as:
fileTransformer.jsconst path = require('path');module.exports = {  process(sourceText, sourcePath, options) {    return {      code: `module.exports = ${JSON.stringify(path.basename(sourcePath))};`,    };  },};
jest.config.js (for custom transformers and CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(css|less)$': 'identity-obj-proxy',  },  transform: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/fileTransformer.js',  },};
We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.
tipRemember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors:"transform": {  "\\.[jt]sx?$": "babel-jest",  "\\.css$": "some-css-transformer",}
Configuring Jest to find our files​
Now that Jest knows how to process our files, we need to tell it how to find them. For webpack's modules, and extensions options there are direct analogs in Jest's moduleDirectories and moduleFileExtensions options.
jest.config.jsmodule.exports = {  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
note<rootDir> is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your package.json is located unless you specify a custom rootDir option in your configuration.
Similarly, Jest's counterpart for Webpack's resolve.roots (an alternative to setting NODE_PATH) is modulePaths.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
And finally, we have to handle the webpack alias. For that, we can make use of the moduleNameMapper option again.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',    '^react(.*)$': '<rootDir>/vendor/react-master$1',    '^config$': '<rootDir>/configs/app-config.js',  },};
That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.
tipFor more complex webpack configurations, you may also want to investigate projects such as: babel-plugin-webpack-loaders.
Using with webpack​
In addition to installing babel-jest as described earlier, you'll need to add @babel/preset-env like so:
npmYarnpnpmnpm install --save-dev @babel/preset-envyarn add --dev @babel/preset-envpnpm add --save-dev @babel/preset-env
Then, you'll want to configure Babel as follows:
.babelrc{  "presets": ["@babel/preset-env"]}
tipJest caches files to speed up test execution. If you updated .babelrc and Jest is not working as expected, try clearing the cache by running jest --clearCache.
tipIf you use dynamic imports (import('some-file.js').then(module => ...)), you need to enable the dynamic-import-node plugin..babelrc{  "presets": [["env", {"modules": false}]],  "plugins": ["syntax-dynamic-import"],  "env": {    "test": {      "plugins": ["dynamic-import-node"]    }  }}
For an example of how to use Jest with webpack with React, you can view one here.Edit this pageLast updated on Feb 5, 2023 by Tom Mrazauskas\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).GuidesUsing with webpackVersion: NextOn this pageUsing with webpackJest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools because it integrates directly with your application to allow managing stylesheets, assets like images and fonts, along with the expansive ecosystem of compile-to-JavaScript languages and tools.
A webpack example​
Let's start with a common sort of webpack config file and translate it to a Jest setup.
webpack.config.jsmodule.exports = {  module: {    rules: [      {        test: /\.jsx?$/,        exclude: ['node_modules'],        use: ['babel-loader'],      },      {        test: /\.css$/,        use: ['style-loader', 'css-loader'],      },      {        test: /\.gif$/,        type: 'asset/inline',      },      {        test: /\.(ttf|eot|svg)$/,        type: 'asset/resource',      },    ],  },  resolve: {    alias: {      config$: './configs/app-config.js',      react: './vendor/react-master',    },    extensions: ['.js', '.jsx'],    modules: [      'node_modules',      'bower_components',      'shared',      '/shared/vendor/modules',    ],  },};
If you have JavaScript files that are transformed by Babel, you can enable support for Babel by installing the babel-jest plugin. Non-Babel JavaScript transformations can be handled with Jest's transform config option.
Handling Static Assets​
Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.
jest.config.jsmodule.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',  },};
And the mock files themselves:
__mocks__/styleMock.jsmodule.exports = {};
__mocks__/fileMock.jsmodule.exports = 'test-file-stub';
Mocking CSS Modules​
You can use an ES6 Proxy to mock CSS Modules:
npmYarnpnpmnpm install --save-dev identity-obj-proxyyarn add --dev identity-obj-proxypnpm add --save-dev identity-obj-proxy
Then all your className lookups on the styles object will be returned as-is (e.g., styles.foobar === 'foobar'). This is pretty handy for React Snapshot Testing.
jest.config.js (for CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/__mocks__/fileMock.js',    '\\.(css|less)$': 'identity-obj-proxy',  },};
If moduleNameMapper cannot fulfill your requirements, you can use Jest's transform config option to specify how assets are transformed. For example, a transformer that returns the basename of a file (such that require('logo.jpg'); returns 'logo') can be written as:
fileTransformer.jsconst path = require('path');module.exports = {  process(sourceText, sourcePath, options) {    return {      code: `module.exports = ${JSON.stringify(path.basename(sourcePath))};`,    };  },};
jest.config.js (for custom transformers and CSS Modules)module.exports = {  moduleNameMapper: {    '\\.(css|less)$': 'identity-obj-proxy',  },  transform: {    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$':      '<rootDir>/fileTransformer.js',  },};
We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.
tipRemember to include the default babel-jest transformer explicitly, if you wish to use it alongside with additional code preprocessors:"transform": {  "\\.[jt]sx?$": "babel-jest",  "\\.css$": "some-css-transformer",}
Configuring Jest to find our files​
Now that Jest knows how to process our files, we need to tell it how to find them. For webpack's modules, and extensions options there are direct analogs in Jest's moduleDirectories and moduleFileExtensions options.
jest.config.jsmodule.exports = {  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
note<rootDir> is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your package.json is located unless you specify a custom rootDir option in your configuration.
Similarly, Jest's counterpart for Webpack's resolve.roots (an alternative to setting NODE_PATH) is modulePaths.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',  },};
And finally, we have to handle the webpack alias. For that, we can make use of the moduleNameMapper option again.
jest.config.jsmodule.exports = {  modulePaths: ['/shared/vendor/modules'],  moduleFileExtensions: ['js', 'jsx'],  moduleDirectories: ['node_modules', 'bower_components', 'shared'],  moduleNameMapper: {    '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',    '\\.(gif|ttf|eot|svg)$': '<rootDir>/__mocks__/fileMock.js',    '^react(.*)$': '<rootDir>/vendor/react-master$1',    '^config$': '<rootDir>/configs/app-config.js',  },};
That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.
tipFor more complex webpack configurations, you may also want to investigate projects such as: babel-plugin-webpack-loaders.
Using with webpack​
In addition to installing babel-jest as described earlier, you'll need to add @babel/preset-env like so:
npmYarnpnpmnpm install --save-dev @babel/preset-envyarn add --dev @babel/preset-envpnpm add --save-dev @babel/preset-env
Then, you'll want to configure Babel as follows:
.babelrc{  "presets": ["@babel/preset-env"]}
tipJest caches files to speed up test execution. If you updated .babelrc and Jest is not working as expected, try clearing the cache by running jest --clearCache.
tipIf you use dynamic imports (import('some-file.js').then(module => ...)), you need to enable the dynamic-import-node plugin..babelrc{  "presets": [["env", {"modules": false}]],  "plugins": ["syntax-dynamic-import"],  "env": {    "test": {      "plugins": ["dynamic-import-node"]    }  }}
For an example of how to use Jest with webpack with React, you can view one here.Edit this pageLast updated on Feb 5, 2023 by Tom MrazauskasPreviousECMAScript ModulesNextUsing with puppeteerA webpack exampleHandling Static AssetsMocking CSS ModulesConfiguring Jest to find our filesUsing with webpack\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nGlobalsVersion: NextOn this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all input values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example same type', ({a, b, expected}) => {  // all arguments are of type `number` because all inputs (a, b, expected) are of type `number`});
If the inputs have different types, the arguments will be typed as a union of all the input types (i.e. type of the variables inside the template literal):
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${'three'}  ${3} | ${4} | ${'seven'}  ${5} | ${6} | ${'eleven'}`('template literal example different types', ({a, b, expected}) => {  // all arguments are of type `number | string` because some inputs (a, b) are of type `number` and some others (expected) are of type `string`});
Otherwise, if you want each argument to have the right type, you have to explicitly provide the generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // all arguments are typed as expected, e.g. `a: number`, `expected: string`, `extra: boolean | undefined`});
cautionKeep in mind the variables inside the template literal are not type checked, so you have to ensure that their types are correct.import {test} from '@jest/globals';test.each<{a: number; expected: string}>`  a                            | expected  ${1}                         | ${'one'}  ${'will not raise TS error'} | ${'two'}  ${3}                         | ${'three'}`('template literal with wrongly typed input', ({a, expected}) => {  // all arguments are typed as stated in the generic: `a: number`, `expected: string`  // WARNING: `a` is of type `number` but will be a string in the 2nd test case.});Edit this pageLast updated on Jan 15, 2025 by John Vandenberg\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).GlobalsVersion: NextOn this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%$ - Number of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all input values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example same type', ({a, b, expected}) => {  // all arguments are of type `number` because all inputs (a, b, expected) are of type `number`});
If the inputs have different types, the arguments will be typed as a union of all the input types (i.e. type of the variables inside the template literal):
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${'three'}  ${3} | ${4} | ${'seven'}  ${5} | ${6} | ${'eleven'}`('template literal example different types', ({a, b, expected}) => {  // all arguments are of type `number | string` because some inputs (a, b) are of type `number` and some others (expected) are of type `string`});
Otherwise, if you want each argument to have the right type, you have to explicitly provide the generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // all arguments are typed as expected, e.g. `a: number`, `expected: string`, `extra: boolean | undefined`});
cautionKeep in mind the variables inside the template literal are not type checked, so you have to ensure that their types are correct.import {test} from '@jest/globals';test.each<{a: number; expected: string}>`  a                            | expected  ${1}                         | ${'one'}  ${'will not raise TS error'} | ${'two'}  ${3}                         | ${'three'}`('template literal with wrongly typed input', ({a, expected}) => {  // all arguments are typed as stated in the generic: `a: number`, `expected: string`  // WARNING: `a` is of type `number` but will be a string in the 2nd test case.});Edit this pageLast updated on Jan 15, 2025 by John VandenbergNextExpectMethodsReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each\n\n\n\nMock FunctionsVersion: NextOn this pageMock FunctionsMock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with jest.fn(). If no implementation is given, the mock function will return undefined when invoked.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferencemockFn.getMockName()mockFn.mock.callsmockFn.mock.resultsmockFn.mock.instancesmockFn.mock.contextsmockFn.mock.lastCallmockFn.mockClear()mockFn.mockReset()mockFn.mockRestore()mockFn.mockImplementation(fn)mockFn.mockImplementationOnce(fn)mockFn.mockName(name)mockFn.mockReturnThis()mockFn.mockReturnValue(value)mockFn.mockReturnValueOnce(value)mockFn.mockResolvedValue(value)mockFn.mockResolvedValueOnce(value)mockFn.mockRejectedValue(value)mockFn.mockRejectedValueOnce(value)mockFn.withImplementation(fn, callback)Replaced PropertiesreplacedProperty.replaceValue(value)replacedProperty.restore()TypeScript Usagejest.fn(implementation?)jest.Mock<T>jest.Mocked<Source>jest.Replaced<Source>jest.mocked(source, options?)jest.Spied<Source>

Reference​
mockFn.getMockName()​
Returns the mock name string set by calling .mockName().
mockFn.mock.calls​
An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.calls array that looks like this:
[  ['arg1', 'arg2'],  ['arg3', 'arg4'],];
mockFn.mock.results​
An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a type property, and a value property. type will be one of the following:

'return' - Indicates that the call completed by returning normally.
'throw' - Indicates that the call completed by throwing a value.
'incomplete' - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.

The value property contains the value that was thrown or returned. value is undefined when type === 'incomplete'.
For example: A mock function f that has been called three times, returning 'result1', throwing an error, and then returning 'result2', would have a mock.results array that looks like this:
[  {    type: 'return',    value: 'result1',  },  {    type: 'throw',    value: {      /* Error instance */    },  },  {    type: 'return',    value: 'result2',  },];
mockFn.mock.instances​
An array that contains all the object instances that have been instantiated from this mock function using new.
For example: A mock function that has been instantiated twice would have the following mock.instances array:
const mockFn = jest.fn();const a = new mockFn();const b = new mockFn();mockFn.mock.instances[0] === a; // truemockFn.mock.instances[1] === b; // true
mockFn.mock.contexts​
An array that contains the contexts for all calls of the mock function.
A context is the this value that a function receives when called. The context can be set using Function.prototype.bind, Function.prototype.call or Function.prototype.apply.
For example:
const mockFn = jest.fn();const boundMockFn = mockFn.bind(thisContext0);boundMockFn('a', 'b');mockFn.call(thisContext1, 'a', 'b');mockFn.apply(thisContext2, ['a', 'b']);mockFn.mock.contexts[0] === thisContext0; // truemockFn.mock.contexts[1] === thisContext1; // truemockFn.mock.contexts[2] === thisContext2; // true
mockFn.mock.lastCall​
An array containing the call arguments of the last call that was made to this mock function. If the function was not called, it will return undefined.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.lastCall array that looks like this:
['arg3', 'arg4'];
mockFn.mockClear()​
Clears all information stored in the mockFn.mock.calls, mockFn.mock.instances, mockFn.mock.contexts and mockFn.mock.results arrays. Often this is useful when you want to clean up a mocks usage data between two assertions.
The clearMocks configuration option is available to clear mocks automatically before each tests.
cautionBeware that mockFn.mockClear() will replace mockFn.mock, not just reset the values of its properties! You should, therefore, avoid assigning mockFn.mock to other variables, temporary or not, to make sure you don't access stale data.
mockFn.mockReset()​
Does everything that mockFn.mockClear() does, and also replaces the mock implementation with an empty function, returning undefined.
The resetMocks configuration option is available to reset mocks automatically before each test.
mockFn.mockRestore()​
Does everything that mockFn.mockReset() does, and also restores the original (non-mocked) implementation.
This is useful when you want to mock functions in certain test cases and restore the original implementation in others.
The restoreMocks configuration option is available to restore mocks automatically before each test.
infomockFn.mockRestore() only works when the mock was created with jest.spyOn(). Thus you have to take care of restoration yourself when manually assigning jest.fn().
mockFn.mockImplementation(fn)​
Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself – the only difference is that the implementation will also be executed when the mock is called.
tipjest.fn(implementation) is a shorthand for jest.fn().mockImplementation(implementation).
JavaScriptTypeScriptconst mockFn = jest.fn(scalar => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39import {jest} from '@jest/globals';const mockFn = jest.fn((scalar: number) => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39
.mockImplementation() can also be used to mock class constructors:
JavaScriptTypeScriptSomeClass.jsmodule.exports = class SomeClass {  method(a, b) {}};SomeClass.test.jsconst SomeClass = require('./SomeClass');jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn();SomeClass.mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);SomeClass.tsexport class SomeClass {  method(a: string, b: string): void {}}SomeClass.test.tsimport {jest} from '@jest/globals';import {SomeClass} from './SomeClass';jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn<(a: string, b: string) => void>();jest.mocked(SomeClass).mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);
mockFn.mockImplementationOnce(fn)​
Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // falseimport {jest} from '@jest/globals';const mockFn = jest  .fn<(cb: (a: null, b: boolean) => void) => void>()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // false
When the mocked function runs out of implementations defined with .mockImplementationOnce(), it will execute the default implementation set with jest.fn(() => defaultValue) or .mockImplementation(() => defaultValue) if they were called:
const mockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockName(name)​
Accepts a string to use in test result output in place of 'jest.fn()' to indicate which mock function is being referenced.
For example:
const mockFn = jest.fn().mockName('mockedFunction');// mockFn();expect(mockFn).toHaveBeenCalled();
Will result in this error:
expect(mockedFunction).toHaveBeenCalled()Expected number of calls: >= 1Received number of calls:    0
mockFn.mockReturnThis()​
Shorthand for:
jest.fn(function () {  return this;});
mockFn.mockReturnValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => value);
Accepts a value that will be returned whenever the mock function is called.
JavaScriptTypeScriptconst mock = jest.fn();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43import {jest} from '@jest/globals';const mock = jest.fn<() => number>();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43
mockFn.mockReturnValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => value);
Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more mockReturnValueOnce values to use, calls will return a value specified by mockReturnValue.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'import {jest} from '@jest/globals';const mockFn = jest  .fn<() => string>()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockResolvedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.resolve(value));
Useful to mock async functions in async tests:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest.fn().mockResolvedValue(43);  await asyncMock(); // 43});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest.fn<() => Promise<number>>().mockResolvedValue(43);  await asyncMock(); // 43});
mockFn.mockResolvedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.resolve(value));
Useful to resolve different values over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});
mockFn.mockRejectedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.reject(value));
Useful to create async mock functions that will always reject:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<never>>()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});
mockFn.mockRejectedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.reject(value));
Useful together with .mockResolvedValueOnce() or to reject with different exceptions over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});
mockFn.withImplementation(fn, callback)​
Accepts a function which should be temporarily used as the implementation of the mock while the callback is being executed.
test('test', () => {  const mock = jest.fn(() => 'outside callback');  mock.withImplementation(    () => 'inside callback',    () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
mockFn.withImplementation can be used regardless of whether or not the callback is asynchronous (returns a thenable). If the callback is asynchronous a promise will be returned. Awaiting the promise will await the callback and reset the implementation.
test('async test', async () => {  const mock = jest.fn(() => 'outside callback');  // We await this call since the callback is async  await mock.withImplementation(    () => 'inside callback',    async () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
Replaced Properties​
replacedProperty.replaceValue(value)​
Changes the value of already replaced property. This is useful when you want to replace property and then adjust the value in specific tests. As an alternative, you can call jest.replaceProperty() multiple times on same property.
replacedProperty.restore()​
Restores object's property to the original value.
Beware that replacedProperty.restore() only works when the property value was replaced with jest.replaceProperty().
The restoreMocks configuration option is available to restore replaced properties automatically before each test.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.fn(implementation?)​
Correct mock typings will be inferred if implementation is passed to jest.fn(). There are many use cases where the implementation is omitted. To ensure type safety you may pass a generic type argument (also see the examples above for more reference):
import {expect, jest, test} from '@jest/globals';import type add from './add';import calculate from './calc';test('calculate calls add', () => {  // Create a new mock that can be used in place of `add`.  const mockAdd = jest.fn<typeof add>();  // `.mockImplementation()` now can infer that `a` and `b` are `number`  // and that the returned value is a `number`.  mockAdd.mockImplementation((a, b) => {    // Yes, this mock is still adding two numbers but imagine this    // was a complex function we are mocking.    return a + b;  });  // `mockAdd` is properly typed and therefore accepted by anything  // requiring `add`.  calculate(mockAdd, 1, 2);  expect(mockAdd).toHaveBeenCalledTimes(1);  expect(mockAdd).toHaveBeenCalledWith(1, 2);});
jest.Mock<T>​
Constructs the type of a mock function, e.g. the return type of jest.fn(). It can be useful if you have to defined a recursive mock function:
import {jest} from '@jest/globals';const sumRecursively: jest.Mock<(value: number) => number> = jest.fn(value => {  if (value === 0) {    return 0;  } else {    return value + fn(value - 1);  }});
jest.Mocked<Source>​
The jest.Mocked<Source> utility type returns the Source type wrapped with type definitions of Jest mock function.
import {expect, jest, test} from '@jest/globals';import type {fetch} from 'node-fetch';jest.mock('node-fetch');let mockedFetch: jest.Mocked<typeof fetch>;afterEach(() => {  mockedFetch.mockClear();});test('makes correct call', () => {  mockedFetch = getMockedFetch();  // ...});test('returns correct data', () => {  mockedFetch = getMockedFetch();  // ...});
Types of classes, functions or objects can be passed as type argument to jest.Mocked<Source>. If you prefer to constrain the input type, use: jest.MockedClass<Source>, jest.MockedFunction<Source> or jest.MockedObject<Source>.
jest.Replaced<Source>​
The jest.Replaced<Source> utility type returns the Source type wrapped with type definitions of Jest replaced property.
src/utils.tsexport function isLocalhost(): boolean {  return process.env['HOSTNAME'] === 'localhost';}
src/__tests__/utils.test.tsimport {afterEach, expect, it, jest} from '@jest/globals';import {isLocalhost} from '../utils';let replacedEnv: jest.Replaced<typeof process.env> | undefined = undefined;afterEach(() => {  replacedEnv?.restore();});it('isLocalhost should detect localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'localhost'});  expect(isLocalhost()).toBe(true);});it('isLocalhost should detect non-localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'example.com'});  expect(isLocalhost()).toBe(false);});
jest.mocked(source, options?)​
The mocked() helper method wraps types of the source object and its deep nested members with type definitions of Jest mock function. You can pass {shallow: true} as the options argument to disable the deeply mocked behavior.
Returns the source object.
song.tsexport const song = {  one: {    more: {      time: (t: number) => {        return t;      },    },  },};
song.test.tsimport {expect, jest, test} from '@jest/globals';import {song} from './song';jest.mock('./song');jest.spyOn(console, 'log');const mockedSong = jest.mocked(song);// or through `jest.Mocked<Source>`// const mockedSong = song as jest.Mocked<typeof song>;test('deep method is typed correctly', () => {  mockedSong.one.more.time.mockReturnValue(12);  expect(mockedSong.one.more.time(10)).toBe(12);  expect(mockedSong.one.more.time.mock.calls).toHaveLength(1);});test('direct usage', () => {  jest.mocked(console.log).mockImplementation(() => {    return;  });  console.log('one more time');  expect(jest.mocked(console.log).mock.calls).toHaveLength(1);});
jest.Spied<Source>​
Constructs the type of a spied class or function (i.e. the return type of jest.spyOn()).
__utils__/setDateNow.tsimport {jest} from '@jest/globals';export function setDateNow(now: number): jest.Spied<typeof Date.now> {  return jest.spyOn(Date, 'now').mockReturnValue(now);}
import {afterEach, expect, type jest, test} from '@jest/globals';import {setDateNow} from './__utils__/setDateNow';let spiedDateNow: jest.Spied<typeof Date.now> | undefined = undefined;afterEach(() => {  spiedDateNow?.mockReset();});test('renders correctly with a given date', () => {  spiedDateNow = setDateNow(1_482_363_367_071);  // ...  expect(spiedDateNow).toHaveBeenCalledTimes(1);});
Types of a class or function can be passed as type argument to jest.Spied<Source>. If you prefer to constrain the input type, use: jest.SpiedClass<Source> or jest.SpiedFunction<Source>.
Use jest.SpiedGetter<Source> or jest.SpiedSetter<Source> to create the type of a spied getter or setter respectively.Edit this pageLast updated on Dec 30, 2023 by Simen Bekkhus\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).Mock FunctionsVersion: NextOn this pageMock FunctionsMock functions are also known as "spies", because they let you spy on the behavior of a function that is called indirectly by some other code, rather than only testing the output. You can create a mock function with jest.fn(). If no implementation is given, the mock function will return undefined when invoked.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferencemockFn.getMockName()mockFn.mock.callsmockFn.mock.resultsmockFn.mock.instancesmockFn.mock.contextsmockFn.mock.lastCallmockFn.mockClear()mockFn.mockReset()mockFn.mockRestore()mockFn.mockImplementation(fn)mockFn.mockImplementationOnce(fn)mockFn.mockName(name)mockFn.mockReturnThis()mockFn.mockReturnValue(value)mockFn.mockReturnValueOnce(value)mockFn.mockResolvedValue(value)mockFn.mockResolvedValueOnce(value)mockFn.mockRejectedValue(value)mockFn.mockRejectedValueOnce(value)mockFn.withImplementation(fn, callback)Replaced PropertiesreplacedProperty.replaceValue(value)replacedProperty.restore()TypeScript Usagejest.fn(implementation?)jest.Mock<T>jest.Mocked<Source>jest.Replaced<Source>jest.mocked(source, options?)jest.Spied<Source>

Reference​
mockFn.getMockName()​
Returns the mock name string set by calling .mockName().
mockFn.mock.calls​
An array containing the call arguments of all calls that have been made to this mock function. Each item in the array is an array of arguments that were passed during the call.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.calls array that looks like this:
[  ['arg1', 'arg2'],  ['arg3', 'arg4'],];
mockFn.mock.results​
An array containing the results of all calls that have been made to this mock function. Each entry in this array is an object containing a type property, and a value property. type will be one of the following:

'return' - Indicates that the call completed by returning normally.
'throw' - Indicates that the call completed by throwing a value.
'incomplete' - Indicates that the call has not yet completed. This occurs if you test the result from within the mock function itself, or from within a function that was called by the mock.

The value property contains the value that was thrown or returned. value is undefined when type === 'incomplete'.
For example: A mock function f that has been called three times, returning 'result1', throwing an error, and then returning 'result2', would have a mock.results array that looks like this:
[  {    type: 'return',    value: 'result1',  },  {    type: 'throw',    value: {      /* Error instance */    },  },  {    type: 'return',    value: 'result2',  },];
mockFn.mock.instances​
An array that contains all the object instances that have been instantiated from this mock function using new.
For example: A mock function that has been instantiated twice would have the following mock.instances array:
const mockFn = jest.fn();const a = new mockFn();const b = new mockFn();mockFn.mock.instances[0] === a; // truemockFn.mock.instances[1] === b; // true
mockFn.mock.contexts​
An array that contains the contexts for all calls of the mock function.
A context is the this value that a function receives when called. The context can be set using Function.prototype.bind, Function.prototype.call or Function.prototype.apply.
For example:
const mockFn = jest.fn();const boundMockFn = mockFn.bind(thisContext0);boundMockFn('a', 'b');mockFn.call(thisContext1, 'a', 'b');mockFn.apply(thisContext2, ['a', 'b']);mockFn.mock.contexts[0] === thisContext0; // truemockFn.mock.contexts[1] === thisContext1; // truemockFn.mock.contexts[2] === thisContext2; // true
mockFn.mock.lastCall​
An array containing the call arguments of the last call that was made to this mock function. If the function was not called, it will return undefined.
For example: A mock function f that has been called twice, with the arguments f('arg1', 'arg2'), and then with the arguments f('arg3', 'arg4'), would have a mock.lastCall array that looks like this:
['arg3', 'arg4'];
mockFn.mockClear()​
Clears all information stored in the mockFn.mock.calls, mockFn.mock.instances, mockFn.mock.contexts and mockFn.mock.results arrays. Often this is useful when you want to clean up a mocks usage data between two assertions.
The clearMocks configuration option is available to clear mocks automatically before each tests.
cautionBeware that mockFn.mockClear() will replace mockFn.mock, not just reset the values of its properties! You should, therefore, avoid assigning mockFn.mock to other variables, temporary or not, to make sure you don't access stale data.
mockFn.mockReset()​
Does everything that mockFn.mockClear() does, and also replaces the mock implementation with an empty function, returning undefined.
The resetMocks configuration option is available to reset mocks automatically before each test.
mockFn.mockRestore()​
Does everything that mockFn.mockReset() does, and also restores the original (non-mocked) implementation.
This is useful when you want to mock functions in certain test cases and restore the original implementation in others.
The restoreMocks configuration option is available to restore mocks automatically before each test.
infomockFn.mockRestore() only works when the mock was created with jest.spyOn(). Thus you have to take care of restoration yourself when manually assigning jest.fn().
mockFn.mockImplementation(fn)​
Accepts a function that should be used as the implementation of the mock. The mock itself will still record all calls that go into and instances that come from itself – the only difference is that the implementation will also be executed when the mock is called.
tipjest.fn(implementation) is a shorthand for jest.fn().mockImplementation(implementation).
JavaScriptTypeScriptconst mockFn = jest.fn(scalar => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39import {jest} from '@jest/globals';const mockFn = jest.fn((scalar: number) => 42 + scalar);mockFn(0); // 42mockFn(1); // 43mockFn.mockImplementation(scalar => 36 + scalar);mockFn(2); // 38mockFn(3); // 39
.mockImplementation() can also be used to mock class constructors:
JavaScriptTypeScriptSomeClass.jsmodule.exports = class SomeClass {  method(a, b) {}};SomeClass.test.jsconst SomeClass = require('./SomeClass');jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn();SomeClass.mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);SomeClass.tsexport class SomeClass {  method(a: string, b: string): void {}}SomeClass.test.tsimport {jest} from '@jest/globals';import {SomeClass} from './SomeClass';jest.mock('./SomeClass'); // this happens automatically with automockingconst mockMethod = jest.fn<(a: string, b: string) => void>();jest.mocked(SomeClass).mockImplementation(() => {  return {    method: mockMethod,  };});const some = new SomeClass();some.method('a', 'b');console.log('Calls to method:', mockMethod.mock.calls);
mockFn.mockImplementationOnce(fn)​
Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // falseimport {jest} from '@jest/globals';const mockFn = jest  .fn<(cb: (a: null, b: boolean) => void) => void>()  .mockImplementationOnce(cb => cb(null, true))  .mockImplementationOnce(cb => cb(null, false));mockFn((err, val) => console.log(val)); // truemockFn((err, val) => console.log(val)); // false
When the mocked function runs out of implementations defined with .mockImplementationOnce(), it will execute the default implementation set with jest.fn(() => defaultValue) or .mockImplementation(() => defaultValue) if they were called:
const mockFn = jest  .fn(() => 'default')  .mockImplementationOnce(() => 'first call')  .mockImplementationOnce(() => 'second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockName(name)​
Accepts a string to use in test result output in place of 'jest.fn()' to indicate which mock function is being referenced.
For example:
const mockFn = jest.fn().mockName('mockedFunction');// mockFn();expect(mockFn).toHaveBeenCalled();
Will result in this error:
expect(mockedFunction).toHaveBeenCalled()Expected number of calls: >= 1Received number of calls:    0
mockFn.mockReturnThis()​
Shorthand for:
jest.fn(function () {  return this;});
mockFn.mockReturnValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => value);
Accepts a value that will be returned whenever the mock function is called.
JavaScriptTypeScriptconst mock = jest.fn();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43import {jest} from '@jest/globals';const mock = jest.fn<() => number>();mock.mockReturnValue(42);mock(); // 42mock.mockReturnValue(43);mock(); // 43
mockFn.mockReturnValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => value);
Accepts a value that will be returned for one call to the mock function. Can be chained so that successive calls to the mock function return different values. When there are no more mockReturnValueOnce values to use, calls will return a value specified by mockReturnValue.
JavaScriptTypeScriptconst mockFn = jest  .fn()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'import {jest} from '@jest/globals';const mockFn = jest  .fn<() => string>()  .mockReturnValue('default')  .mockReturnValueOnce('first call')  .mockReturnValueOnce('second call');mockFn(); // 'first call'mockFn(); // 'second call'mockFn(); // 'default'mockFn(); // 'default'
mockFn.mockResolvedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.resolve(value));
Useful to mock async functions in async tests:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest.fn().mockResolvedValue(43);  await asyncMock(); // 43});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest.fn<() => Promise<number>>().mockResolvedValue(43);  await asyncMock(); // 43});
mockFn.mockResolvedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.resolve(value));
Useful to resolve different values over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValue('default')    .mockResolvedValueOnce('first call')    .mockResolvedValueOnce('second call');  await asyncMock(); // 'first call'  await asyncMock(); // 'second call'  await asyncMock(); // 'default'  await asyncMock(); // 'default'});
mockFn.mockRejectedValue(value)​
Shorthand for:
jest.fn().mockImplementation(() => Promise.reject(value));
Useful to create async mock functions that will always reject:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<never>>()    .mockRejectedValue(new Error('Async error message'));  await asyncMock(); // throws 'Async error message'});
mockFn.mockRejectedValueOnce(value)​
Shorthand for:
jest.fn().mockImplementationOnce(() => Promise.reject(value));
Useful together with .mockResolvedValueOnce() or to reject with different exceptions over multiple async calls:
JavaScriptTypeScripttest('async test', async () => {  const asyncMock = jest    .fn()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});import {jest, test} from '@jest/globals';test('async test', async () => {  const asyncMock = jest    .fn<() => Promise<string>>()    .mockResolvedValueOnce('first call')    .mockRejectedValueOnce(new Error('Async error message'));  await asyncMock(); // 'first call'  await asyncMock(); // throws 'Async error message'});
mockFn.withImplementation(fn, callback)​
Accepts a function which should be temporarily used as the implementation of the mock while the callback is being executed.
test('test', () => {  const mock = jest.fn(() => 'outside callback');  mock.withImplementation(    () => 'inside callback',    () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
mockFn.withImplementation can be used regardless of whether or not the callback is asynchronous (returns a thenable). If the callback is asynchronous a promise will be returned. Awaiting the promise will await the callback and reset the implementation.
test('async test', async () => {  const mock = jest.fn(() => 'outside callback');  // We await this call since the callback is async  await mock.withImplementation(    () => 'inside callback',    async () => {      mock(); // 'inside callback'    },  );  mock(); // 'outside callback'});
Replaced Properties​
replacedProperty.replaceValue(value)​
Changes the value of already replaced property. This is useful when you want to replace property and then adjust the value in specific tests. As an alternative, you can call jest.replaceProperty() multiple times on same property.
replacedProperty.restore()​
Restores object's property to the original value.
Beware that replacedProperty.restore() only works when the property value was replaced with jest.replaceProperty().
The restoreMocks configuration option is available to restore replaced properties automatically before each test.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
jest.fn(implementation?)​
Correct mock typings will be inferred if implementation is passed to jest.fn(). There are many use cases where the implementation is omitted. To ensure type safety you may pass a generic type argument (also see the examples above for more reference):
import {expect, jest, test} from '@jest/globals';import type add from './add';import calculate from './calc';test('calculate calls add', () => {  // Create a new mock that can be used in place of `add`.  const mockAdd = jest.fn<typeof add>();  // `.mockImplementation()` now can infer that `a` and `b` are `number`  // and that the returned value is a `number`.  mockAdd.mockImplementation((a, b) => {    // Yes, this mock is still adding two numbers but imagine this    // was a complex function we are mocking.    return a + b;  });  // `mockAdd` is properly typed and therefore accepted by anything  // requiring `add`.  calculate(mockAdd, 1, 2);  expect(mockAdd).toHaveBeenCalledTimes(1);  expect(mockAdd).toHaveBeenCalledWith(1, 2);});
jest.Mock<T>​
Constructs the type of a mock function, e.g. the return type of jest.fn(). It can be useful if you have to defined a recursive mock function:
import {jest} from '@jest/globals';const sumRecursively: jest.Mock<(value: number) => number> = jest.fn(value => {  if (value === 0) {    return 0;  } else {    return value + fn(value - 1);  }});
jest.Mocked<Source>​
The jest.Mocked<Source> utility type returns the Source type wrapped with type definitions of Jest mock function.
import {expect, jest, test} from '@jest/globals';import type {fetch} from 'node-fetch';jest.mock('node-fetch');let mockedFetch: jest.Mocked<typeof fetch>;afterEach(() => {  mockedFetch.mockClear();});test('makes correct call', () => {  mockedFetch = getMockedFetch();  // ...});test('returns correct data', () => {  mockedFetch = getMockedFetch();  // ...});
Types of classes, functions or objects can be passed as type argument to jest.Mocked<Source>. If you prefer to constrain the input type, use: jest.MockedClass<Source>, jest.MockedFunction<Source> or jest.MockedObject<Source>.
jest.Replaced<Source>​
The jest.Replaced<Source> utility type returns the Source type wrapped with type definitions of Jest replaced property.
src/utils.tsexport function isLocalhost(): boolean {  return process.env['HOSTNAME'] === 'localhost';}
src/__tests__/utils.test.tsimport {afterEach, expect, it, jest} from '@jest/globals';import {isLocalhost} from '../utils';let replacedEnv: jest.Replaced<typeof process.env> | undefined = undefined;afterEach(() => {  replacedEnv?.restore();});it('isLocalhost should detect localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'localhost'});  expect(isLocalhost()).toBe(true);});it('isLocalhost should detect non-localhost environment', () => {  replacedEnv = jest.replaceProperty(process, 'env', {HOSTNAME: 'example.com'});  expect(isLocalhost()).toBe(false);});
jest.mocked(source, options?)​
The mocked() helper method wraps types of the source object and its deep nested members with type definitions of Jest mock function. You can pass {shallow: true} as the options argument to disable the deeply mocked behavior.
Returns the source object.
song.tsexport const song = {  one: {    more: {      time: (t: number) => {        return t;      },    },  },};
song.test.tsimport {expect, jest, test} from '@jest/globals';import {song} from './song';jest.mock('./song');jest.spyOn(console, 'log');const mockedSong = jest.mocked(song);// or through `jest.Mocked<Source>`// const mockedSong = song as jest.Mocked<typeof song>;test('deep method is typed correctly', () => {  mockedSong.one.more.time.mockReturnValue(12);  expect(mockedSong.one.more.time(10)).toBe(12);  expect(mockedSong.one.more.time.mock.calls).toHaveLength(1);});test('direct usage', () => {  jest.mocked(console.log).mockImplementation(() => {    return;  });  console.log('one more time');  expect(jest.mocked(console.log).mock.calls).toHaveLength(1);});
jest.Spied<Source>​
Constructs the type of a spied class or function (i.e. the return type of jest.spyOn()).
__utils__/setDateNow.tsimport {jest} from '@jest/globals';export function setDateNow(now: number): jest.Spied<typeof Date.now> {  return jest.spyOn(Date, 'now').mockReturnValue(now);}
import {afterEach, expect, type jest, test} from '@jest/globals';import {setDateNow} from './__utils__/setDateNow';let spiedDateNow: jest.Spied<typeof Date.now> | undefined = undefined;afterEach(() => {  spiedDateNow?.mockReset();});test('renders correctly with a given date', () => {  spiedDateNow = setDateNow(1_482_363_367_071);  // ...  expect(spiedDateNow).toHaveBeenCalledTimes(1);});
Types of a class or function can be passed as type argument to jest.Spied<Source>. If you prefer to constrain the input type, use: jest.SpiedClass<Source> or jest.SpiedFunction<Source>.
Use jest.SpiedGetter<Source> or jest.SpiedSetter<Source> to create the type of a spied getter or setter respectively.Edit this pageLast updated on Dec 30, 2023 by Simen BekkhusPreviousExpectNextThe Jest ObjectMethodsReferencemockFn.getMockName()mockFn.mock.callsmockFn.mock.resultsmockFn.mock.instancesmockFn.mock.contextsmockFn.mock.lastCallmockFn.mockClear()mockFn.mockReset()mockFn.mockRestore()mockFn.mockImplementation(fn)mockFn.mockImplementationOnce(fn)mockFn.mockName(name)mockFn.mockReturnThis()mockFn.mockReturnValue(value)mockFn.mockReturnValueOnce(value)mockFn.mockResolvedValue(value)mockFn.mockResolvedValueOnce(value)mockFn.mockRejectedValue(value)mockFn.mockRejectedValueOnce(value)mockFn.withImplementation(fn, callback)Replaced PropertiesreplacedProperty.replaceValue(value)replacedProperty.restore()TypeScript Usagejest.fn(implementation?)jest.Mock<T>jest.Mocked<Source>jest.Replaced<Source>jest.mocked(source, options?)jest.Spied<Source>\n\n\n\nIntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-Bizri\n\nThis is unreleased documentation for Jest Next version.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: NextOn this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
npmYarnpnpmnpm init jest@latestyarn create jestpnpm create jest
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using with bundlers​
Most of the time you do not need to do anything special to work with different bundlers - the exception is if you have some plugin or configuration which generates files or have custom file resolution rules.
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest is not supported by Vite due to incompatibilities with the Vite plugin system.
There are examples for Jest integration with Vite in the vite-jest library. However, this library is not compatible with versions of Vite later than 2.4.2.
One alternative is Vitest which has an API compatible Jest.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jul 12, 2024 by Jonathan El-BizriNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing with bundlersUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nIntroductionGetting StartedVersion: 29.6On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nThis is documentation for Jest 29.6, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: 29.6On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nGlobalsVersion: 29.6On this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example', ({a, b, expected}) => {  // all arguments are of type `number`});
Otherwise it will require a generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // without the generic argument in this case types would default to `unknown`});Edit this pageLast updated on Jan 15, 2025 by John Vandenberg\n\nThis is documentation for Jest 29.6, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).GlobalsVersion: 29.6On this pageGlobalsIn your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them. However, if you prefer explicit imports, you can do import {describe, expect, test} from '@jest/globals'.

infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
Methods​

ReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each

Reference​
afterAll(fn, timeout)​
Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some global setup state that is shared across tests.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterAll(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterAll ensures that cleanUpDatabase is called after all tests run.
If afterAll is inside a describe block, it runs at the end of the describe block.
If you want to run some cleanup after every test instead of after all tests, use afterEach instead.
afterEach(fn, timeout)​
Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to clean up some temporary state that is created by each test.
For example:
const globalDatabase = makeGlobalDatabase();function cleanUpDatabase(db) {  db.cleanUp();}afterEach(() => {  cleanUpDatabase(globalDatabase);});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the afterEach ensures that cleanUpDatabase is called after each test runs.
If afterEach is inside a describe block, it only runs after the tests that are inside this describe block.
If you want to run some cleanup just once, after all of the tests run, use afterAll instead.
beforeAll(fn, timeout)​
Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to set up some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeAll(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});// Since we only set up the database once in this example, it's important// that our tests don't modify it.test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});
Here the beforeAll ensures that the database is set up before tests run. If setup was synchronous, you could do this without beforeAll. The key is that Jest will wait for a promise to resolve, so you can have asynchronous setup as well.
If beforeAll is inside a describe block, it runs at the beginning of the describe block.
If you want to run something before every test instead of before any test runs, use beforeEach instead.
beforeEach(fn, timeout)​
Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
This is often useful if you want to reset some global state that will be used by many tests.
For example:
const globalDatabase = makeGlobalDatabase();beforeEach(() => {  // Clears the database and adds some testing data.  // Jest will wait for this promise to resolve before running tests.  return globalDatabase.clear().then(() => {    return globalDatabase.insert({testData: 'foo'});  });});test('can find things', () => {  return globalDatabase.find('thing', {}, results => {    expect(results.length).toBeGreaterThan(0);  });});test('can insert a thing', () => {  return globalDatabase.insert('thing', makeThing(), response => {    expect(response.success).toBeTruthy();  });});
Here the beforeEach ensures that the database is reset for each test.
If beforeEach is inside a describe block, it runs for each test in the describe block.
If you only need to run some setup code once, before any tests run, use beforeAll instead.
describe(name, fn)​
describe(name, fn) creates a block that groups together several related tests. For example, if you have a myBeverage object that is supposed to be delicious but not sour, you could test it with:
const myBeverage = {  delicious: true,  sour: false,};describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});
This isn't required - you can write the test blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.
You can also nest describe blocks if you have a hierarchy of tests:
const binaryStringToNumber = binString => {  if (!/^[01]+$/.test(binString)) {    throw new CustomError('Not a binary number.');  }  return parseInt(binString, 2);};describe('binaryStringToNumber', () => {  describe('given an invalid binary string', () => {    test('composed of non-numbers throws CustomError', () => {      expect(() => binaryStringToNumber('abc')).toThrow(CustomError);    });    test('with extra whitespace throws CustomError', () => {      expect(() => binaryStringToNumber('  100')).toThrow(CustomError);    });  });  describe('given a valid binary string', () => {    test('returns the correct number', () => {      expect(binaryStringToNumber('100')).toBe(4);    });  });});
describe.each(table)(name, fn, timeout)​
Use describe.each if you keep duplicating the same test suites with different data. describe.each allows you to write the test suite once and pass data in.
describe.each is available with two APIs:
1. describe.each(table)(name, fn, timeout)​


table: Array of Arrays with the arguments that are passed into the fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]].


name: String the title of the test suite.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%





fn: Function the suite of tests to be run, this is the function that will receive the parameters in each row as function arguments.


Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.


Example:
describe.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
2. describe.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test suite, use $variable to inject test data into the suite title from the tagged template expressions, and $# for the index of the row.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the suite of tests to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
describe.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('$a + $b', ({a, b, expected}) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });  test(`returned value not be greater than ${expected}`, () => {    expect(a + b).not.toBeGreaterThan(expected);  });  test(`returned value not be less than ${expected}`, () => {    expect(a + b).not.toBeLessThan(expected);  });});
describe.only(name, fn)​
Also under the alias: fdescribe(name, fn)
You can use describe.only if you want to run only one describe block:
describe.only('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe('my other beverage', () => {  // ... will be skipped});
describe.only.each(table)(name, fn)​
Also under the aliases: fdescribe.each(table)(name, fn) and fdescribe.each`table`(name, fn)
Use describe.only.each if you want to only run specific tests suites of data driven tests.
describe.only.each is available with two APIs:
describe.only.each(table)(name, fn)​
describe.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.only.each`table`(name, fn)​
describe.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('passes', () => {    expect(a + b).toBe(expected);  });});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip(name, fn)​
Also under the alias: xdescribe(name, fn)
You can use describe.skip if you do not want to run the tests of a particular describe block:
describe('my beverage', () => {  test('is delicious', () => {    expect(myBeverage.delicious).toBeTruthy();  });  test('is not sour', () => {    expect(myBeverage.sour).toBeFalsy();  });});describe.skip('my other beverage', () => {  // ... will be skipped});
Using describe.skip is often a cleaner alternative to temporarily commenting out a chunk of tests. Beware that the describe block will still run. If you have some setup that also should be skipped, do it in a beforeAll or beforeEach block.
describe.skip.each(table)(name, fn)​
Also under the aliases: xdescribe.each(table)(name, fn) and xdescribe.each`table`(name, fn)
Use describe.skip.each if you want to stop running a suite of data driven tests.
describe.skip.each is available with two APIs:
describe.skip.each(table)(name, fn)​
describe.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  test(`returns ${expected}`, () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
describe.skip.each`table`(name, fn)​
describe.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  test('will not be run', () => {    expect(a + b).toBe(expected); // will not be run  });});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test(name, fn, timeout)​
Also under the alias: it(name, fn, timeout)
All you need in a test file is the test method which runs a test. For example, let's say there's a function inchesOfRain() that should be zero. Your whole test could be:
test('did not rain', () => {  expect(inchesOfRain()).toBe(0);});
The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
If a promise is returned from test, Jest will wait for the promise to resolve before letting the test complete. For example, let's say fetchBeverageList() returns a promise that is supposed to resolve to a list that has lemon in it. You can test this with:
test('has lemon in it', () => {  return fetchBeverageList().then(list => {    expect(list).toContain('lemon');  });});
Even though the call to test will return right away, the test doesn't complete until the promise resolves. For more details, see Testing Asynchronous Code page.
tipJest will also wait if you provide an argument to the test function, usually called done. This could be handy when you want to test callbacks.
test.concurrent(name, fn, timeout)​
Also under the alias: it.concurrent(name, fn, timeout)
cautiontest.concurrent is considered experimental - see here for details on missing features and other issues.
Use test.concurrent if you want the test to run concurrently.
The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
test.concurrent('addition of 2 numbers', async () => {  expect(5 + 3).toBe(8);});test.concurrent('subtraction 2 numbers', async () => {  expect(5 - 3).toBe(2);});
tipUse the maxConcurrency configuration option to prevent Jest from executing more than the specified amount of tests at the same time.
test.concurrent.each(table)(name, fn, timeout)​
Also under the alias: it.concurrent.each(table)(name, fn, timeout)
Use test.concurrent.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in, the tests are all run asynchronously.
test.concurrent.each is available with two APIs:
1. test.concurrent.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});
2. test.concurrent.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object, this will have to be an asynchronous function.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.concurrent.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.concurrent.only.each(table)(name, fn)​
Also under the alias: it.concurrent.only.each(table)(name, fn)
Use test.concurrent.only.each if you want to only run specific tests with different test data concurrently.
test.concurrent.only.each is available with two APIs:
test.concurrent.only.each(table)(name, fn)​
test.concurrent.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.concurrent.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each(table)(name, fn)​
Also under the alias: it.concurrent.skip.each(table)(name, fn)
Use test.concurrent.skip.each if you want to stop running a collection of asynchronous data driven tests.
test.concurrent.skip.each is available with two APIs:
test.concurrent.skip.each(table)(name, fn)​
test.concurrent.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', async (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.concurrent.skip.each`table`(name, fn)​
test.concurrent.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', async ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.each(table)(name, fn, timeout)​
Also under the alias: it.each(table)(name, fn) and it.each`table`(name, fn)
Use test.each if you keep duplicating the same test with different data. test.each allows you to write the test once and pass data in.
test.each is available with two APIs:
1. test.each(table)(name, fn, timeout)​

table: Array of Arrays with the arguments that are passed into the test fn for each row. If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. [1, 2, 3] -> [[1], [2], [3]]
name: String the title of the test block.

Generate unique test titles by positionally injecting parameters with printf formatting:

%p - pretty-format.
%s- String.
%d- Number.
%i - Integer.
%f - Floating point value.
%j - JSON.
%o - Object.
%# - Index of the test case.
%% - single percent sign ('%'). This does not consume an argument.


Or generate unique test titles by injecting properties of test case object with $variable

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)
You can use $# to inject the index of the test case
You cannot use $variable with the printf formatting except for %%




fn: Function the test to be run, this is the function that will receive the parameters in each row as function arguments.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});
test.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
2. test.each`table`(name, fn, timeout)​

table: Tagged Template Literal

First row of variable name column headings separated with |
One or more subsequent rows of data supplied as template literal expressions using ${value} syntax.


name: String the title of the test, use $variable to inject test data into the test title from the tagged template expressions.

To inject nested object values use you can supply a keyPath i.e. $variable.path.to.value (only works for "own" properties, e.g. $variable.constructor.name wouldn't work)


fn: Function the test to be run, this is the function that will receive the test data object.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait for each row before aborting. The default timeout is 5 seconds.

Example:
test.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.failing(name, fn, timeout)​
Also under the alias: it.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.failing when you are writing a test and expecting it to fail. These tests will behave the other way normal tests do. If failing test will throw any errors then it will pass. If it does not throw it will fail.
tipYou can use this type of test i.e. when writing code in a BDD way. In that case the tests will not show up as failing until they pass. Then you can just remove the failing modifier to make them pass.It can also be a nice way to contribute failing tests to a project, even if you don't know how to fix the bug.
Example:
test.failing('it is not equal', () => {  expect(5).toBe(6); // this test will pass});test.failing('it is equal', () => {  expect(10).toBe(10); // this test will fail});
test.failing.each(name, fn, timeout)​
Also under the alias: it.failing.each(table)(name, fn) and it.failing.each`table`(name, fn)
noteThis is only available with the default jest-circus runner.
You can also run multiple tests at once by adding each after failing.
Example:
test.failing.each([  {a: 1, b: 1, expected: 2},  {a: 1, b: 2, expected: 3},  {a: 2, b: 1, expected: 3},])('.add($a, $b)', ({a, b, expected}) => {  expect(a + b).toBe(expected);});
test.only.failing(name, fn, timeout)​
Also under the aliases: it.only.failing(name, fn, timeout), fit.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.only.failing if you want to only run a specific failing test.
test.skip.failing(name, fn, timeout)​
Also under the aliases: it.skip.failing(name, fn, timeout), xit.failing(name, fn, timeout), xtest.failing(name, fn, timeout)
noteThis is only available with the default jest-circus runner.
Use test.skip.failing if you want to skip running a specific failing test.
test.only(name, fn, timeout)​
Also under the aliases: it.only(name, fn, timeout), and fit(name, fn, timeout)
When you are debugging a large test file, you will often only want to run a subset of tests. You can use .only to specify which tests are the only ones you want to run in that test file.
Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before aborting. The default timeout is 5 seconds.
For example, let's say you had these tests:
test.only('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run in that test file, since it is run with test.only.
Usually you wouldn't check code using test.only into source control - you would use it for debugging, and remove it once you have fixed the broken tests.
test.only.each(table)(name, fn)​
Also under the aliases: it.only.each(table)(name, fn), fit.each(table)(name, fn), it.only.each`table`(name, fn) and fit.each`table`(name, fn)
Use test.only.each if you want to only run specific tests with different test data.
test.only.each is available with two APIs:
test.only.each(table)(name, fn)​
test.only.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.only.each`table`(name, fn)​
test.only.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected);});test('will not be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip(name, fn)​
Also under the aliases: it.skip(name, fn), xit(name, fn), and xtest(name, fn)
When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use test.skip to specify some tests to skip.
For example, let's say you had these tests:
test('it is raining', () => {  expect(inchesOfRain()).toBeGreaterThan(0);});test.skip('it is not snowing', () => {  expect(inchesOfSnow()).toBe(0);});
Only the "it is raining" test will run, since the other test is run with test.skip.
You could comment the test out, but it's often a bit nicer to use test.skip because it will maintain indentation and syntax highlighting.
test.skip.each(table)(name, fn)​
Also under the aliases: it.skip.each(table)(name, fn), xit.each(table)(name, fn), xtest.each(table)(name, fn), it.skip.each`table`(name, fn), xit.each`table`(name, fn) and xtest.each`table`(name, fn)
Use test.skip.each if you want to stop running a collection of data driven tests.
test.skip.each is available with two APIs:
test.skip.each(table)(name, fn)​
test.skip.each([  [1, 1, 2],  [1, 2, 3],  [2, 1, 3],])('.add(%i, %i)', (a, b, expected) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.skip.each`table`(name, fn)​
test.skip.each`  a    | b    | expected  ${1} | ${1} | ${2}  ${1} | ${2} | ${3}  ${2} | ${1} | ${3}`('returns $expected when $a is added to $b', ({a, b, expected}) => {  expect(a + b).toBe(expected); // will not be run});test('will be run', () => {  expect(1 / 0).toBe(Infinity);});
test.todo(name)​
Also under the alias: it.todo(name)
Use test.todo when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.
const add = (a, b) => a + b;test.todo('add should be associative');
tiptest.todo will throw an error if you pass it a test callback function. Use test.skip instead, if you already implemented the test, but do not want it to run.
TypeScript Usage​
infoThe TypeScript examples from this page will only work as documented if you explicitly import Jest APIs:import {expect, jest, test} from '@jest/globals';Consult the Getting Started guide for details on how to setup Jest with TypeScript.
.each​
The .each modifier offers few different ways to define a table of the test cases. Some of the APIs have caveats related with the type inference of the arguments which are passed to describe or test callback functions. Let's take a look at each of them.
noteFor simplicity test.each is picked for the examples, but the type inference is identical in all cases where .each modifier can be used: describe.each, test.concurrent.only.each, test.skip.each, etc.
Array of objects​
The array of objects API is most verbose, but it makes the type inference a painless task. A table can be inlined:
import {test} from '@jest/globals';test.each([  {name: 'a', path: 'path/to/a', count: 1, write: true},  {name: 'b', path: 'path/to/b', count: 3},])('inline table', ({name, path, count, write}) => {  // arguments are typed as expected, e.g. `write: boolean | undefined`});
Or declared separately as a variable:
import {test} from '@jest/globals';const table = [  {a: 1, b: 2, expected: 'three', extra: true},  {a: 3, b: 4, expected: 'seven', extra: false},  {a: 5, b: 6, expected: 'eleven'},];test.each(table)('table as a variable', ({a, b, expected, extra}) => {  // again everything is typed as expected, e.g. `extra: boolean | undefined`});
Array of arrays​
The array of arrays style will work smoothly with inlined tables:
import {test} from '@jest/globals';test.each([  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],])('inline table example', (a, b, expected, extra) => {  // arguments are typed as expected, e.g. `extra: boolean | undefined`});
However, if a table is declared as a separate variable, it must be typed as an array of tuples for correct type inference (this is not needed only if all elements of a row are of the same type):
import {test} from '@jest/globals';const table: Array<[number, number, string, boolean?]> = [  [1, 2, 'three', true],  [3, 4, 'seven', false],  [5, 6, 'eleven'],];test.each(table)('table as a variable example', (a, b, expected, extra) => {  // without the annotation types are incorrect, e.g. `a: number | string | boolean`});
Template literal​
If all values are of the same type, the template literal API will type the arguments correctly:
import {test} from '@jest/globals';test.each`  a    | b    | expected  ${1} | ${2} | ${3}  ${3} | ${4} | ${7}  ${5} | ${6} | ${11}`('template literal example', ({a, b, expected}) => {  // all arguments are of type `number`});
Otherwise it will require a generic type argument:
import {test} from '@jest/globals';test.each<{a: number; b: number; expected: string; extra?: boolean}>`  a    | b    | expected    | extra  ${1} | ${2} | ${'three'}  | ${true}  ${3} | ${4} | ${'seven'}  | ${false}  ${5} | ${6} | ${'eleven'}`('template literal example', ({a, b, expected, extra}) => {  // without the generic argument in this case types would default to `unknown`});Edit this pageLast updated on Jan 15, 2025 by John VandenbergNextExpectMethodsReferenceafterAll(fn, timeout)afterEach(fn, timeout)beforeAll(fn, timeout)beforeEach(fn, timeout)describe(name, fn)describe.each(table)(name, fn, timeout)describe.only(name, fn)describe.only.each(table)(name, fn)describe.skip(name, fn)describe.skip.each(table)(name, fn)test(name, fn, timeout)test.concurrent(name, fn, timeout)test.concurrent.each(table)(name, fn, timeout)test.concurrent.only.each(table)(name, fn)test.concurrent.skip.each(table)(name, fn)test.each(table)(name, fn, timeout)test.failing(name, fn, timeout)test.failing.each(name, fn, timeout)test.only.failing(name, fn, timeout)test.skip.failing(name, fn, timeout)test.only(name, fn, timeout)test.only.each(table)(name, fn)test.skip(name, fn)test.skip.each(table)(name, fn)test.todo(name)TypeScript Usage.each\n\n\n\nIntroductionGetting StartedVersion: 29.6On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunked\n\nThis is documentation for Jest 29.6, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).IntroductionGetting StartedVersion: 29.6On this pageGetting StartedInstall Jest using your favorite package manager:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Let's get started by writing a test for a hypothetical function that adds two numbers. First, create a sum.js file:
function sum(a, b) {  return a + b;}module.exports = sum;
Then, create a file named sum.test.js. This will contain our actual test:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Add the following section to your package.json:
{  "scripts": {    "test": "jest"  }}
Finally, run yarn test or npm test and Jest will print this message:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
You just successfully wrote your first test using Jest!
This test used expect and toBe to test that two values were exactly identical. To learn about the other things that Jest can test, see Using Matchers.
Running from command line​
You can run Jest directly from the CLI (if it's globally available in your PATH, e.g. by yarn global add jest or npm install jest --global) with a variety of useful options.
Here's how to run Jest on files matching my-test, using config.json as a configuration file and display a native OS notification after the run:
jest my-test --notify --config=config.json
If you'd like to learn more about running jest through the command line, take a look at the Jest CLI Options page.
Additional Configuration​
Generate a basic configuration file​
Based on your project, Jest will ask you a few questions and will create a basic configuration file with a short description for each option:
jest --init
Using Babel​
To use Babel, install required dependencies:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure Babel to target your current version of Node by creating a babel.config.js file in the root of your project:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Making your Babel config jest-awareJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the transform configuration option:jest.config.jsmodule.exports = {  transform: {},};
Using webpack​
Jest can be used in projects that use webpack to manage assets, styles, and compilation. webpack does offer some unique challenges over other tools. Refer to the webpack guide to get started.
Using Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest can be used in projects that use parcel-bundler to manage assets, styles, and compilation similar to webpack. Parcel requires zero configuration. Refer to the official docs to get started.
Using TypeScript​
Via babel​
Jest supports TypeScript, via Babel. First, make sure you followed the instructions on using Babel above. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Then add @babel/preset-typescript to the list of presets in your babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
However, there are some caveats to using TypeScript with Babel. Because TypeScript support in Babel is purely transpilation, Jest will not type-check your tests as they are run. If you want that, you can use ts-jest instead, or just run the TypeScript compiler tsc separately (or as part of your build process).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageLast updated on Jan 16, 2024 by yepitschunkedNextUsing MatchersRunning from command lineAdditional ConfigurationGenerate a basic configuration fileUsing BabelUsing webpackUsing ViteUsing ParcelUsing TypeScriptUsing ESLint\n\n\n\nはじめにはじめましょうVersion: 29.6On this pageはじめましょうお気に入りのパッケージマネージャーを使用して Jest をインストールします。
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
2つの数値を加算する関数のテストを書くことから始めてみましょう。 まずsum.js ファイルを作成します。
function sum(a, b) {  return a + b;}module.exports = sum;
その後、sum.test.js というファイルを作成します。 このファイルに実際のテストが含まれます。
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
package.json に以下を追加します。
{  "scripts": {    "test": "jest"  }}
最後に、yarn test または npm test を実行すると、Jest は以下のメッセージを表示します。
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
あなたは Jest を使用して、最初のテストを書き、うまくいきました!
このテストは expect と、 toBe を使用し、2 つの値が同じかテストしました。 他の Jest でテスト可能なものについては、Using Matcher を参照してください。
コマンドラインからの実行​
Jest は、CLI から様々な便利なオプションを付けて、直接実行できます。 （実行するためには、例えば yarn global add jestまたはnpm install jest --global でインストールし、PATH でグローバルに利用可能になっている必要があります。 ）
ここでは my-test を Jest で実行し、実行後に OS の通知を表示する方法を示します。 そのとき構成ファイルとして config.json を使用します。
jest my-test --notify --config=config.json
コマンドラインから Jest を実行する方法の詳細については、Jest CLI Options を参考にしてください。
追加設定​
基本の設定ファイルを生成する​
次のコマンドを実行すると、Jest はあなたのプロジェクトの構成に基づいたいくつかの質問をし、その回答から短いコメント付きの基本の設定ファイルを生成します。
jest --init
Babel を使用する​
Babel を使用するために、yarn で必要な依存関係をインストールしてください。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Node.jsの現在のバージョンをターゲットにするためにBabelを定義するには、babel.config.jsというファイルをプロジェクトのルートに作ってください。
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Babelの設定にJestを認識させるJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. これを避けるには、 transform設定を明示的にリセットして下さい。jest.config.jsmodule.exports = {  transform: {},};
Webpack を使用する​
Jestは webpackでアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 webpack は他のツールよりもユニークで挑戦的な機能を提供しています。 具体的な使い方は webpack guide を参照してください。
Vite を使用する​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Vite が提供するプラグインシステムの仕組みのため、Jest は vite を完全にはサポートしていませんが、vite-jest を使用した動作する第1級の Jest のインテグレーションがいくつか存在します。完全なサポートではないため、 vite-jest の制限も参照してください。 Refer to the vite guide to get started.
Using Parcel​
Jestは parcel-bundleで webpack と同様にアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 Parcelは設定が不要です。 使用を開始するには公式ドキュメントを参照してください。
TypeScript を使用する​
babel 経由で​
Jest は Babel 経由で TypeScript をサポートしています。 まず、 Babelを使用するを確認してください。 次に、@babel/preset-typescript をインストールします。
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
最後に、@babel/preset-typescript を babel.config.js 内のプリセットのリストに追加してください。
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
BabelでTypeScriptを使う場合、いくつかの注意事項があります。 BabelはTypescriptを純粋なトランスパイルによりサポートしているため、Jestはテストの実行時にテストコードの型検査を行いません。 型検査を行いたい場合、代わりに ts-jest を使用するか、TypeScriptコンパイラ のtsc をテストとは別に(またはビルドプロセスの一部として)使用してください。
ts-jest 経由で​
ts-jestはJest用のソースマップをサポートするTypeScriptプリプロセッサです。こちらを使うことで、TypeScriptで書かれたプロジェクトをJestでテストできるようになります。
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}このページを編集\n\nThis is documentation for Jest 29.6, which is no longer actively maintained.For up-to-date documentation, see the 最新バージョン (29.7).はじめにはじめましょうVersion: 29.6On this pageはじめましょうお気に入りのパッケージマネージャーを使用して Jest をインストールします。
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
2つの数値を加算する関数のテストを書くことから始めてみましょう。 まずsum.js ファイルを作成します。
function sum(a, b) {  return a + b;}module.exports = sum;
その後、sum.test.js というファイルを作成します。 このファイルに実際のテストが含まれます。
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
package.json に以下を追加します。
{  "scripts": {    "test": "jest"  }}
最後に、yarn test または npm test を実行すると、Jest は以下のメッセージを表示します。
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
あなたは Jest を使用して、最初のテストを書き、うまくいきました!
このテストは expect と、 toBe を使用し、2 つの値が同じかテストしました。 他の Jest でテスト可能なものについては、Using Matcher を参照してください。
コマンドラインからの実行​
Jest は、CLI から様々な便利なオプションを付けて、直接実行できます。 （実行するためには、例えば yarn global add jestまたはnpm install jest --global でインストールし、PATH でグローバルに利用可能になっている必要があります。 ）
ここでは my-test を Jest で実行し、実行後に OS の通知を表示する方法を示します。 そのとき構成ファイルとして config.json を使用します。
jest my-test --notify --config=config.json
コマンドラインから Jest を実行する方法の詳細については、Jest CLI Options を参考にしてください。
追加設定​
基本の設定ファイルを生成する​
次のコマンドを実行すると、Jest はあなたのプロジェクトの構成に基づいたいくつかの質問をし、その回答から短いコメント付きの基本の設定ファイルを生成します。
jest --init
Babel を使用する​
Babel を使用するために、yarn で必要な依存関係をインストールしてください。
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Node.jsの現在のバージョンをターゲットにするためにBabelを定義するには、babel.config.jsというファイルをプロジェクトのルートに作ってください。
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
The ideal configuration for Babel will depend on your project. See Babel's docs for more details.
Babelの設定にJestを認識させるJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. これを避けるには、 transform設定を明示的にリセットして下さい。jest.config.jsmodule.exports = {  transform: {},};
Webpack を使用する​
Jestは webpackでアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 webpack は他のツールよりもユニークで挑戦的な機能を提供しています。 具体的な使い方は webpack guide を参照してください。
Vite を使用する​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Vite が提供するプラグインシステムの仕組みのため、Jest は vite を完全にはサポートしていませんが、vite-jest を使用した動作する第1級の Jest のインテグレーションがいくつか存在します。完全なサポートではないため、 vite-jest の制限も参照してください。 Refer to the vite guide to get started.
Using Parcel​
Jestは parcel-bundleで webpack と同様にアセットやスタイル、コンパイル作業を管理するプロジェクトで使用できます。 Parcelは設定が不要です。 使用を開始するには公式ドキュメントを参照してください。
TypeScript を使用する​
babel 経由で​
Jest は Babel 経由で TypeScript をサポートしています。 まず、 Babelを使用するを確認してください。 次に、@babel/preset-typescript をインストールします。
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
最後に、@babel/preset-typescript を babel.config.js 内のプリセットのリストに追加してください。
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
BabelでTypeScriptを使う場合、いくつかの注意事項があります。 BabelはTypescriptを純粋なトランスパイルによりサポートしているため、Jestはテストの実行時にテストコードの型検査を行いません。 型検査を行いたい場合、代わりに ts-jest を使用するか、TypeScriptコンパイラ のtsc をテストとは別に(またはビルドプロセスの一部として)使用してください。
ts-jest 経由で​
ts-jestはJest用のソースマップをサポートするTypeScriptプリプロセッサです。こちらを使うことで、TypeScriptで書かれたプロジェクトをJestでテストできるようになります。
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}このページを編集NextMatcherを使用するコマンドラインからの実行追加設定基本の設定ファイルを生成するBabel を使用するWebpack を使用するVite を使用するUsing ParcelTypeScript を使用するUsing ESLint\n\n\n\nIntroducciónEmpezandoVersion: 29.6On this pageEmpezandoInstale Jest usando su administrador de paquetes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Empecemos escribiendo una prueba para una función hipotética que suma dos números. Primero, crea un archivo suma.js:
function suma(a, b) {  return a + b;}module.exports = suma;
Luego, crea un archivo llamado suma.test.js. Este contendrá nuestra prueba actual:
const suma = require('./suma');test('sumar 1 + 2 es igual a 3', () => {  expect(suma(1, 2)).toBe(3);});
Agrega la siguiente sección a tu package.json:
{  "scripts": {    "test": "jest"  }}
Finalmente, ejecuta yarn test o npm test y Jest imprimirá en la pantalla este mensaje:
PASS  ./suma.test.js✓ sumar 1 + 2 es igual a 3 (5ms)
¡Acabas de escribir tu primera prueba usando Jest!
Esta prueba usa expect y toBe para probar que dos valores son exactamente idénticos. Para aprender sobre otras cosas que Jest puede probar, mira Usando Matchers.
Ejecutando desde la línea de comandos​
Puedes ejecutar Jest directamente desde la CLI (si está disponible globalmente en tu PATH, p.e. con yarn global add jest o npm install jest --global) con varias opciones útiles.
Así es como puedes correr Jest en archivos que coinciden my-test, usando config.json como archivo de configuración y mostrar una notificación nativa del SO después de ejecutarlo:
jest my-test --notify --config=config.json
Si quieres aprender más sobre correr jest a través de la línea de comandos, hecha una mirada a la página de Opciones de Jest CLI.
Configuración Adicional​
Genera un fichero de configuración básico​
Basado en tu proyecto, Jest te hará algunas preguntas y creará un archivo de configuración básica con una corta descripción por cada opción:
jest --init
Usando Babel​
Para usar Babel, instale las dependencias requeridas:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configura Babel para tu versión actual de Node creando un fichero babel.config.js en la raíz de tu proyecto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuración ideal para Babel dependerá de tu proyecto. Consulte la documentación de Babel para obtener más detalles.
Haz que tu configuración de Babel sepa que usas JestJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest se instala automáticamente al instalar Jest y transformará automáticamente los archivos si existe una configuración de Babel en su proyecto. Para evitar este comportamiento, puede restablecer explícitamente la opción de configuración de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest puede ser usado en proyectos que usan webpack para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos sobre otras herramientas. Consulta la documentación oficial para comenzar.
Usando Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest puede ser usado en proyectos que usan parcel para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos por sobre otras herramientas. Refer to the official docs to get started.
Usando TypeScript​
Via babel​
Jest soporta TypeScript, a través de Babel. Primero, asegúrate de haber seguido las intrucciones en Usando Babel de arriba. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Luego agrega @babel/preset-typescript a la lista de presets en tu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Existen algunas cosas que debes tener en cuenta cuando uses TypeScript con Babel. Dado que el soporte de TypeScript en Babel se limita a la transpilación, Jest no comprobará los tipos de tus tests cuando éstos se ejecuten. Si lo deseas, puedes utilizar ts-jest o simplemente ejecutar el compilador de TypeScript por separado (como parte del proceso de compilación).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this page\n\nThis is documentation for Jest 29.6, which is no longer actively maintained.For up-to-date documentation, see the latest version (29.7).IntroducciónEmpezandoVersion: 29.6On this pageEmpezandoInstale Jest usando su administrador de paquetes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Empecemos escribiendo una prueba para una función hipotética que suma dos números. Primero, crea un archivo suma.js:
function suma(a, b) {  return a + b;}module.exports = suma;
Luego, crea un archivo llamado suma.test.js. Este contendrá nuestra prueba actual:
const suma = require('./suma');test('sumar 1 + 2 es igual a 3', () => {  expect(suma(1, 2)).toBe(3);});
Agrega la siguiente sección a tu package.json:
{  "scripts": {    "test": "jest"  }}
Finalmente, ejecuta yarn test o npm test y Jest imprimirá en la pantalla este mensaje:
PASS  ./suma.test.js✓ sumar 1 + 2 es igual a 3 (5ms)
¡Acabas de escribir tu primera prueba usando Jest!
Esta prueba usa expect y toBe para probar que dos valores son exactamente idénticos. Para aprender sobre otras cosas que Jest puede probar, mira Usando Matchers.
Ejecutando desde la línea de comandos​
Puedes ejecutar Jest directamente desde la CLI (si está disponible globalmente en tu PATH, p.e. con yarn global add jest o npm install jest --global) con varias opciones útiles.
Así es como puedes correr Jest en archivos que coinciden my-test, usando config.json como archivo de configuración y mostrar una notificación nativa del SO después de ejecutarlo:
jest my-test --notify --config=config.json
Si quieres aprender más sobre correr jest a través de la línea de comandos, hecha una mirada a la página de Opciones de Jest CLI.
Configuración Adicional​
Genera un fichero de configuración básico​
Basado en tu proyecto, Jest te hará algunas preguntas y creará un archivo de configuración básica con una corta descripción por cada opción:
jest --init
Usando Babel​
Para usar Babel, instale las dependencias requeridas:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configura Babel para tu versión actual de Node creando un fichero babel.config.js en la raíz de tu proyecto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuración ideal para Babel dependerá de tu proyecto. Consulte la documentación de Babel para obtener más detalles.
Haz que tu configuración de Babel sepa que usas JestJest will set process.env.NODE_ENV to 'test' if it's not set to something else. You can use that in your configuration to conditionally setup only the compilation needed for Jest, e.g.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest se instala automáticamente al instalar Jest y transformará automáticamente los archivos si existe una configuración de Babel en su proyecto. Para evitar este comportamiento, puede restablecer explícitamente la opción de configuración de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest puede ser usado en proyectos que usan webpack para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos sobre otras herramientas. Consulta la documentación oficial para comenzar.
Usando Vite​
Jest can be used in projects that use vite to serve source code over native ESM to provide some frontend tooling, vite is an opinionated tool and does offer some out-of-the box workflows. Jest is not fully supported by vite due to how the plugin system from vite works, but there are some working examples for first-class jest integration using vite-jest, since this is not fully supported, you might as well read the limitation of the vite-jest. Refer to the vite guide to get started.
Using Parcel​
Jest puede ser usado en proyectos que usan parcel para gestionar recursos, estilos y compilación. webpack ofrece desafíos únicos por sobre otras herramientas. Refer to the official docs to get started.
Usando TypeScript​
Via babel​
Jest soporta TypeScript, a través de Babel. Primero, asegúrate de haber seguido las intrucciones en Usando Babel de arriba. Next, install the @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Luego agrega @babel/preset-typescript a la lista de presets en tu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Existen algunas cosas que debes tener en cuenta cuando uses TypeScript con Babel. Dado que el soporte de TypeScript en Babel se limita a la transpilación, Jest no comprobará los tipos de tus tests cuando éstos se ejecuten. Si lo deseas, puedes utilizar ts-jest o simplemente ejecutar el compilador de TypeScript por separado (como parte del proceso de compilación).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
In order for Jest to transpile TypeScript with ts-jest, you may also need to create a configuration file.
Type definitions​
There are two ways to have Jest global APIs typed for test files written in TypeScript.
You can use type definitions which ships with Jest and will update each time you update Jest. Install the @jest/globals package:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
And import the APIs from it:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipSee the additional usage documentation of describe.each/test.each and mock functions.
Or you may choose to install the @types/jest package. It provides types for Jest globals without a need to import them.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Try to match versions of Jest and @types/jest as closely as possible. For example, if you are using Jest 27.4.0 then installing 27.4.x of @types/jest is ideal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Edit this pageNextUtilizando ComparadoresEjecutando desde la línea de comandosConfiguración AdicionalGenera un fichero de configuración básicoUsando BabelUsando webpackUsando ViteUsing ParcelUsando TypeScriptUsing ESLint\n\n\n\nIntroductionPremiers pasVersion : 29.6Sur cette pagePremiers pasInstallez Jest en utilisant votre gestionnaire de paquets favori :
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Commençons par écrire un test pour une hypothétique fonction qui additionne deux nombres. Tout d’abord, créez un fichier sum.js :
function sum(a, b) {  return a + b;}module.exports = sum;
Ensuite, créez un fichier nommé sum.test.js. Il s'agit de notre test actuel :
test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Ajoutez la section suivante à votre package.json :
{  "scripts": {    "test": "jest"  }}
Enfin, lancez yarn test ou npm test et Jest affichera ce message :
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Vous venez d'écrire votre premier test avec Jest avec succès !
Ce test utilise expect et toBe pour tester que deux valeurs sont exactement identiques. Pour connaître les autres éléments que Jest peut tester, consultez Utilisation des comparateurs.
Exécution en mode ligne de commande​
Vous pouvez exécuter Jest directement depuis le CLI (si celui-ci est globalement disponible dans votre PATH, par exemple yarn global add jest ou npm install jest --global) avec une variété d'options utiles.
Voici comment exécuter Jest sur des fichiers correspondant à my-test, en utilisant config.json comme fichier de configuration et afficher une notification de l'OS natif après l'exécution :
jest my-test --notify --config=config.json
Si vous souhaitez en apprendre davantage sur l'exécution de jest en mode ligne de commande, consultez la page Options CLI de Jest.
Configuration additionnelle​
Générez un fichier de configuration de base​
Basé sur votre projet, Jest vous posera quelques questions et créera un fichier de configuration de base avec une courte description pour chaque option :
jest --init
Utilisez Babel​
Pour utiliser Babel, installez les dépendances requises :
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configurez Babel pour cibler votre version actuelle de Node en créant un fichier babel.config.js à la racine de votre projet :
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuration idéale pour Babel dépendra de votre projet. Consultez la documentation de Babel pour plus de détails.
Faites en sorte que votre configuration Babel soit adaptée à JestJest définira process.env.NODE_ENV avec 'test' s'il n'est pas défini avec quelque chose d'autre. Vous pouvez l'utiliser dans votre configuration pour paramétrer de manière conditionnelle uniquement la compilation nécessaire pour Jest, par exemple.babel.config.jsmodule.exports = api => {  const isTest = api. nv('test');  // Vous pouvez utiliser isTest pour déterminer les presets et les plugins à utiliser.  return {    // ...  };};remarquebabel-jest est automatiquement installé lorsque vous installez Jest et transformera automatiquement les fichiers si une configuration de babel existe dans votre projet. Pour éviter ce résultat, vous pouvez réinitialiser explicitement l'option de configuration transform :jest.config.jsmodule.exports = {  transform: {},};
Utilisez Webpack​
Jest peut être utilisé dans les projets qui utilisent webpack pour gérer les ressources, les styles et la compilation. webpack offre quelques défis singuliers par rapport à d'autres outils. Consultez le guide webpack pour commencer.
Utilisation de Vite​
Jest peut être utilisé dans des projets qui utilisent vite pour servir le code source sur l'ESM natif afin de fournir certains outils frontaux. Vite est un outil subjectif et offre quelques flux de travail prêts à l'emploi. Jest n'est pas entièrement supporté par vite à cause de la façon dont le système de plugins de vite fonctionne, mais il y a quelques exemples fonctionnels pour une intégration de première classe en utilisant vite-jest, comme ce n'est pas entièrement supporté, vous pourriez aussi lire la limitation de vite-jest. Reportez-vous au guide vite pour commencer.
Utilisation de Parcel​
Jest peut être utilisé dans les projets qui utilisent parcel-bundler pour gérer les ressources, les styles et la compilation de manière similaire à webpack. Parcel nécessite aucune configuration. Reportez-vous à la documentation officielle pour commencer.
Utilisez TypeScript​
Via babel​
Jest prend en charge TypeScript, via Babel. Tout d'abord, assurez-vous d'avoir suivi les instructions sur l'utilisation de Babel ci-dessus. Ensuite, installez @babel/preset-typescript :
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Ensuite, ajoutez @babel/preset-typescript à la liste des presets dans votre babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Toutefois, l'utilisation de TypeScript avec Babel présente quelques inconvénients. La prise en charge de TypeScript dans Babel étant purement une transpilation, Jest ne vérifiera pas le typage de vos tests lors de leur exécution. Si vous souhaitez cela, vous pouvez à la place utiliser ts-jest, ou simplement exécuter le compilateur TypeScript tsc séparément (ou dans le prolongement de votre processus de construction).
Via ts-jest​
ts-jest est un préprocesseur TypeScript avec la prise en charge de source map pour Jest qui vous permet d'utiliser Jest pour tester les projets écrits en TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Afin que Jest puisse transpiler TypeScript avec ts-jest, vous aurez besoin de créer un fichier de configuration .
Définitions de type​
Il existe deux façons d'avoir les API globales Jest typées pour les fichiers de test écrits en TypeScript.
Vous pouvez utiliser les définitions de types qui sont livrées avec Jest et seront mises à jour chaque fois que vous mettez à jour Jest. Installez le paquet @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Et importez les API depuis le paquet :
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
astuceConsultez la documentation d'utilisation supplémentaire de describe.each/test.each et des fonctions simulées.
Ou vous pouvez choisir d'installer le paquet @types/jest. Il fournit des types pour les globales Jest sans devoir les importer.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Essayez de faire correspondre les versions de Jest et @types/jest aussi proche que possible. Par exemple, si vous utilisez Jest 27.4.0 alors l'installation 27.4.x de @types/jest est idéal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Modifier cette page\n\nIl s'agit de la documentation pour Jest 29.6, qui n'est plus activement maintenue.Pour une documentation à jour, consultez la dernière version (29.7).IntroductionPremiers pasVersion : 29.6Sur cette pagePremiers pasInstallez Jest en utilisant votre gestionnaire de paquets favori :
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Commençons par écrire un test pour une hypothétique fonction qui additionne deux nombres. Tout d’abord, créez un fichier sum.js :
function sum(a, b) {  return a + b;}module.exports = sum;
Ensuite, créez un fichier nommé sum.test.js. Il s'agit de notre test actuel :
test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Ajoutez la section suivante à votre package.json :
{  "scripts": {    "test": "jest"  }}
Enfin, lancez yarn test ou npm test et Jest affichera ce message :
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Vous venez d'écrire votre premier test avec Jest avec succès !
Ce test utilise expect et toBe pour tester que deux valeurs sont exactement identiques. Pour connaître les autres éléments que Jest peut tester, consultez Utilisation des comparateurs.
Exécution en mode ligne de commande​
Vous pouvez exécuter Jest directement depuis le CLI (si celui-ci est globalement disponible dans votre PATH, par exemple yarn global add jest ou npm install jest --global) avec une variété d'options utiles.
Voici comment exécuter Jest sur des fichiers correspondant à my-test, en utilisant config.json comme fichier de configuration et afficher une notification de l'OS natif après l'exécution :
jest my-test --notify --config=config.json
Si vous souhaitez en apprendre davantage sur l'exécution de jest en mode ligne de commande, consultez la page Options CLI de Jest.
Configuration additionnelle​
Générez un fichier de configuration de base​
Basé sur votre projet, Jest vous posera quelques questions et créera un fichier de configuration de base avec une courte description pour chaque option :
jest --init
Utilisez Babel​
Pour utiliser Babel, installez les dépendances requises :
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configurez Babel pour cibler votre version actuelle de Node en créant un fichier babel.config.js à la racine de votre projet :
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
La configuration idéale pour Babel dépendra de votre projet. Consultez la documentation de Babel pour plus de détails.
Faites en sorte que votre configuration Babel soit adaptée à JestJest définira process.env.NODE_ENV avec 'test' s'il n'est pas défini avec quelque chose d'autre. Vous pouvez l'utiliser dans votre configuration pour paramétrer de manière conditionnelle uniquement la compilation nécessaire pour Jest, par exemple.babel.config.jsmodule.exports = api => {  const isTest = api. nv('test');  // Vous pouvez utiliser isTest pour déterminer les presets et les plugins à utiliser.  return {    // ...  };};remarquebabel-jest est automatiquement installé lorsque vous installez Jest et transformera automatiquement les fichiers si une configuration de babel existe dans votre projet. Pour éviter ce résultat, vous pouvez réinitialiser explicitement l'option de configuration transform :jest.config.jsmodule.exports = {  transform: {},};
Utilisez Webpack​
Jest peut être utilisé dans les projets qui utilisent webpack pour gérer les ressources, les styles et la compilation. webpack offre quelques défis singuliers par rapport à d'autres outils. Consultez le guide webpack pour commencer.
Utilisation de Vite​
Jest peut être utilisé dans des projets qui utilisent vite pour servir le code source sur l'ESM natif afin de fournir certains outils frontaux. Vite est un outil subjectif et offre quelques flux de travail prêts à l'emploi. Jest n'est pas entièrement supporté par vite à cause de la façon dont le système de plugins de vite fonctionne, mais il y a quelques exemples fonctionnels pour une intégration de première classe en utilisant vite-jest, comme ce n'est pas entièrement supporté, vous pourriez aussi lire la limitation de vite-jest. Reportez-vous au guide vite pour commencer.
Utilisation de Parcel​
Jest peut être utilisé dans les projets qui utilisent parcel-bundler pour gérer les ressources, les styles et la compilation de manière similaire à webpack. Parcel nécessite aucune configuration. Reportez-vous à la documentation officielle pour commencer.
Utilisez TypeScript​
Via babel​
Jest prend en charge TypeScript, via Babel. Tout d'abord, assurez-vous d'avoir suivi les instructions sur l'utilisation de Babel ci-dessus. Ensuite, installez @babel/preset-typescript :
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Ensuite, ajoutez @babel/preset-typescript à la liste des presets dans votre babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
Toutefois, l'utilisation de TypeScript avec Babel présente quelques inconvénients. La prise en charge de TypeScript dans Babel étant purement une transpilation, Jest ne vérifiera pas le typage de vos tests lors de leur exécution. Si vous souhaitez cela, vous pouvez à la place utiliser ts-jest, ou simplement exécuter le compilateur TypeScript tsc séparément (ou dans le prolongement de votre processus de construction).
Via ts-jest​
ts-jest est un préprocesseur TypeScript avec la prise en charge de source map pour Jest qui vous permet d'utiliser Jest pour tester les projets écrits en TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Afin que Jest puisse transpiler TypeScript avec ts-jest, vous aurez besoin de créer un fichier de configuration .
Définitions de type​
Il existe deux façons d'avoir les API globales Jest typées pour les fichiers de test écrits en TypeScript.
Vous pouvez utiliser les définitions de types qui sont livrées avec Jest et seront mises à jour chaque fois que vous mettez à jour Jest. Installez le paquet @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
Et importez les API depuis le paquet :
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
astuceConsultez la documentation d'utilisation supplémentaire de describe.each/test.each et des fonctions simulées.
Ou vous pouvez choisir d'installer le paquet @types/jest. Il fournit des types pour les globales Jest sans devoir les importer.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
info@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Essayez de faire correspondre les versions de Jest et @types/jest aussi proche que possible. Par exemple, si vous utilisez Jest 27.4.0 alors l'installation 27.4.x de @types/jest est idéal.
Using ESLint​
Jest can be used with ESLint without any further configuration as long as you import the Jest global helpers (describe, it, etc.) from @jest/globals before using them in your test file. This is necessary to avoid no-undef errors from ESLint, which doesn't know about the Jest globals.
If you'd like to avoid these imports, you can configure your ESLint environment to support these globals by adding the jest environment:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Or use eslint-plugin-jest, which has a similar effect:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Modifier cette pageSuivantUtilisation des comparateursExécution en mode ligne de commandeConfiguration additionnelleGénérez un fichier de configuration de baseUtilisez BabelUtilisez WebpackUtilisation de ViteUtilisation de ParcelUtilisez TypeScriptUsing ESLint\n\n\n\nIntroduçãoIniciandoVersão: 29.6On this pageIniciandoInstale Jest usando seu gerenciador de pacotes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Vamos começar por escrever um teste para uma função hipotética que soma dois números. Primeiro, crie um arquivo sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Em seguida, crie um arquivo chamado sum.test.js. Este irá conter o nosso teste real:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adicione a seguinte seção ao seu package.json:
{  "scripts": {    "test": "jest"  }}
Por fim, execute yarn test ou npm run test e o Jest irá imprimir a seguinte mensagem:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Você escreveu com sucesso seu primeiro teste usando Jest!
Este teste usou expect e toBe para testar que dois valores eram exatamente idênticos. Para saber mais sobre as outras coisas que Jest pode testar, consulte Usando Matchers.
Executando a partir da linha de comando​
Você pode executar Jest diretamente da CLI (se ele estiver disponível globalmente em seu PATH, por exemplo: yarn global add jest ou npm install -g jest) com uma variedade de comandos úteis.
Aqui vemos como executar Jest em arquivos que correspondam ao my-test, usando config.json como um arquivo de configuração e exibir uma notificação nativa no Sistema Operacional após a execução:
jest my-test --notify --config=config.json
Se você gostaria de aprender mais sobre como executar jest através da linha de comando, dê uma olhada na página  Opções de CLI Jest.
Configuração adicional​
Gerando um arquivo de configuração básico​
Com base no seu projeto, o Jest fará algumas perguntas e irá criar um arquivo básico de configuração com uma breve descrição para cada opção:
jest --init
Usando Babel​
Para usar Babel, instale as dependências necessárias:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure o Babel para marcar a sua versão atual do Node criando um arquivo babel.config.js na raiz do seu projeto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
A configuração ideal para o Babel dependerá do seu projeto. Veja a documentação do Babel para mais detalhes.
Making your Babel config jest-awareJest definirá process.env.NODE_ENV para 'test' se não estiver definido para outra coisa. Você pode usar isso em sua configuração para configurar condicionalmente apenas a compilação necessária para Jest, por exemplo.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest é instalado automaticamente quando instalar Jest e irá automaticamente transformar arquivos caso uma configuração de babel existir em seu projeto. Para evitar esse comportamento, você pode redefinir explicitamente a opção de configuração de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest pode ser usado em projetos que usam webpack para gerenciar assets, estilos e compilação. webpack oferece alguns desafios únicos em relação à outras ferramentas. Consulte o guia do webpack para começar.
Usando Vite​
Jest pode ser utilizado em projetos que usam vite para servir código-fonte a partir de ESM nativo, fornecendo algumas ferramentas do frontend, vite é uma ferramenta opinativa e oferece alguns workflows diferenciados. Jest não é totalmente suportado pelo vite devido a como o sistema de plugins do vite funciona, mas há alguns exemplos para a integração de primeira classe usando vite-jest. Já que isto não é totalmente suportado, você deve ler também a limitação do vite-jest. Consulte o guia de vite para começar.
Usando Parcel​
Jest pode ser usado em projetos que usam parcel-bundler para gerenciar ativos, estilos, e compilação semelhante ao webpack. Parcel requer configuração zero. Veja a documentação oficial para começar.
Usando TypeScript​
Via babel​
O Jest suporta TypeScript, via Babel. Primeiro certifique-se que você seguir as instruções em usando o Babel acima. Em seguida, instale o @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Então adicione o @babel/preset-typescript à lista de presets em seu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
No entanto, há algumas ressalvas para usar TypeScript com Babel. Como o suporte para TypeScript em Babel é puramente transpilação, Jest não irá checar seus testes enquanto eles são executados. Se você quiser isso, você pode usar ts-jest em vez disso. ou apenas execute o compilador TypeScript tsc separadamente (ou como parte de seu processo de compilação).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Para que Jest interprete TypeScript com ts-jest, talvez você precise criar um arquivo de configuração.
Definições de tipo​
Existem duas maneiras de ter Jest global APIs tipado para arquivos de teste escritos em TypeScript.
Você pode usar as definições de tipo que já vem com o Jest e serão atualizadas a cada vez que você atualizar o Jest. Instale o pacote @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
E importe as APIs de:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipVeja a documentação de uso adicional de describe.each/test.each e funções de simulação (mock, em inglês).
Ou você pode escolher instalar o pacote @types/jest. Ele fornece tipos para os globais do Jest sem necessidade de importá-los.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
informação@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Tente coincidir com versões do Jest e @types/jest o mais próximo possível. Por exemplo, se você estiver usando a versão 27.4.0 do jest, então instalar 27.4.x de @types/jest é ideal.
Usando ESLint​
Jest pode ser usado com o ESLint sem qualquer configuração adicional, desde que você importe os ajudantes globais do Jest (describe, it, etc.) do @jest/globals antes de usá-los em seus arquivos de teste. Isso é necessário para evitar erros no-undef do ESLint, que não conhece sobre os globais do Jest.
Se quiser evitar essas importações, você pode configurar seu ambiente ESLint para suportar esses globais adicionando o ambiente jest:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Ou usar o eslint-plugin-jest que tem um efeito similar:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Editar esta página\n\nEsta é a documentação do Jest 29.6, que não é mais ativamente mantida.For up-to-date documentation, see the última versão (29.7).IntroduçãoIniciandoVersão: 29.6On this pageIniciandoInstale Jest usando seu gerenciador de pacotes favorito:
npmYarnpnpmnpm install --save-dev jestyarn add --dev jestpnpm add --save-dev jest
Vamos começar por escrever um teste para uma função hipotética que soma dois números. Primeiro, crie um arquivo sum.js:
function sum(a, b) {  return a + b;}module.exports = sum;
Em seguida, crie um arquivo chamado sum.test.js. Este irá conter o nosso teste real:
const sum = require('./sum');test('adds 1 + 2 to equal 3', () => {  expect(sum(1, 2)).toBe(3);});
Adicione a seguinte seção ao seu package.json:
{  "scripts": {    "test": "jest"  }}
Por fim, execute yarn test ou npm run test e o Jest irá imprimir a seguinte mensagem:
PASS  ./sum.test.js✓ adds 1 + 2 to equal 3 (5ms)
Você escreveu com sucesso seu primeiro teste usando Jest!
Este teste usou expect e toBe para testar que dois valores eram exatamente idênticos. Para saber mais sobre as outras coisas que Jest pode testar, consulte Usando Matchers.
Executando a partir da linha de comando​
Você pode executar Jest diretamente da CLI (se ele estiver disponível globalmente em seu PATH, por exemplo: yarn global add jest ou npm install -g jest) com uma variedade de comandos úteis.
Aqui vemos como executar Jest em arquivos que correspondam ao my-test, usando config.json como um arquivo de configuração e exibir uma notificação nativa no Sistema Operacional após a execução:
jest my-test --notify --config=config.json
Se você gostaria de aprender mais sobre como executar jest através da linha de comando, dê uma olhada na página  Opções de CLI Jest.
Configuração adicional​
Gerando um arquivo de configuração básico​
Com base no seu projeto, o Jest fará algumas perguntas e irá criar um arquivo básico de configuração com uma breve descrição para cada opção:
jest --init
Usando Babel​
Para usar Babel, instale as dependências necessárias:
npmYarnpnpmnpm install --save-dev babel-jest @babel/core @babel/preset-envyarn add --dev babel-jest @babel/core @babel/preset-envpnpm add --save-dev babel-jest @babel/core @babel/preset-env
Configure o Babel para marcar a sua versão atual do Node criando um arquivo babel.config.js na raiz do seu projeto:
babel.config.jsmodule.exports = {  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],};
A configuração ideal para o Babel dependerá do seu projeto. Veja a documentação do Babel para mais detalhes.
Making your Babel config jest-awareJest definirá process.env.NODE_ENV para 'test' se não estiver definido para outra coisa. Você pode usar isso em sua configuração para configurar condicionalmente apenas a compilação necessária para Jest, por exemplo.babel.config.jsmodule.exports = api => {  const isTest = api.env('test');  // You can use isTest to determine what presets and plugins to use.  return {    // ...  };};notebabel-jest é instalado automaticamente quando instalar Jest e irá automaticamente transformar arquivos caso uma configuração de babel existir em seu projeto. Para evitar esse comportamento, você pode redefinir explicitamente a opção de configuração de transform:jest.config.jsmodule.exports = {  transform: {},};
Usando webpack​
Jest pode ser usado em projetos que usam webpack para gerenciar assets, estilos e compilação. webpack oferece alguns desafios únicos em relação à outras ferramentas. Consulte o guia do webpack para começar.
Usando Vite​
Jest pode ser utilizado em projetos que usam vite para servir código-fonte a partir de ESM nativo, fornecendo algumas ferramentas do frontend, vite é uma ferramenta opinativa e oferece alguns workflows diferenciados. Jest não é totalmente suportado pelo vite devido a como o sistema de plugins do vite funciona, mas há alguns exemplos para a integração de primeira classe usando vite-jest. Já que isto não é totalmente suportado, você deve ler também a limitação do vite-jest. Consulte o guia de vite para começar.
Usando Parcel​
Jest pode ser usado em projetos que usam parcel-bundler para gerenciar ativos, estilos, e compilação semelhante ao webpack. Parcel requer configuração zero. Veja a documentação oficial para começar.
Usando TypeScript​
Via babel​
O Jest suporta TypeScript, via Babel. Primeiro certifique-se que você seguir as instruções em usando o Babel acima. Em seguida, instale o @babel/preset-typescript:
npmYarnpnpmnpm install --save-dev @babel/preset-typescriptyarn add --dev @babel/preset-typescriptpnpm add --save-dev @babel/preset-typescript
Então adicione o @babel/preset-typescript à lista de presets em seu babel.config.js.
babel.config.jsmodule.exports = {  presets: [    ['@babel/preset-env', {targets: {node: 'current'}}],    '@babel/preset-typescript',  ],};
No entanto, há algumas ressalvas para usar TypeScript com Babel. Como o suporte para TypeScript em Babel é puramente transpilação, Jest não irá checar seus testes enquanto eles são executados. Se você quiser isso, você pode usar ts-jest em vez disso. ou apenas execute o compilador TypeScript tsc separadamente (ou como parte de seu processo de compilação).
Via ts-jest​
ts-jest is a TypeScript preprocessor with source map support for Jest that lets you use Jest to test projects written in TypeScript.
npmYarnpnpmnpm install --save-dev ts-jestyarn add --dev ts-jestpnpm add --save-dev ts-jest
Para que Jest interprete TypeScript com ts-jest, talvez você precise criar um arquivo de configuração.
Definições de tipo​
Existem duas maneiras de ter Jest global APIs tipado para arquivos de teste escritos em TypeScript.
Você pode usar as definições de tipo que já vem com o Jest e serão atualizadas a cada vez que você atualizar o Jest. Instale o pacote @jest/globals:
npmYarnpnpmnpm install --save-dev @jest/globalsyarn add --dev @jest/globalspnpm add --save-dev @jest/globals
E importe as APIs de:
sum.test.tsimport {describe, expect, test} from '@jest/globals';import {sum} from './sum';describe('sum module', () => {  test('adds 1 + 2 to equal 3', () => {    expect(sum(1, 2)).toBe(3);  });});
tipVeja a documentação de uso adicional de describe.each/test.each e funções de simulação (mock, em inglês).
Ou você pode escolher instalar o pacote @types/jest. Ele fornece tipos para os globais do Jest sem necessidade de importá-los.
npmYarnpnpmnpm install --save-dev @types/jestyarn add --dev @types/jestpnpm add --save-dev @types/jest
informação@types/jest is a third party library maintained at DefinitelyTyped, hence the latest Jest features or versions may not be covered yet. Tente coincidir com versões do Jest e @types/jest o mais próximo possível. Por exemplo, se você estiver usando a versão 27.4.0 do jest, então instalar 27.4.x de @types/jest é ideal.
Usando ESLint​
Jest pode ser usado com o ESLint sem qualquer configuração adicional, desde que você importe os ajudantes globais do Jest (describe, it, etc.) do @jest/globals antes de usá-los em seus arquivos de teste. Isso é necessário para evitar erros no-undef do ESLint, que não conhece sobre os globais do Jest.
Se quiser evitar essas importações, você pode configurar seu ambiente ESLint para suportar esses globais adicionando o ambiente jest:
{  "overrides": [    {      "files": ["tests/**/*"],      "env": {        "jest": true      }    }  ]}
Ou usar o eslint-plugin-jest que tem um efeito similar:
{  "overrides": [    {      "files": ["tests/**/*"],      "plugins": ["jest"],      "env": {        "jest/globals": true      }    }  ]}Editar esta páginaPróximoUsando MatchersExecutando a partir da linha de comandoConfiguração adicionalGerando um arquivo de configuração básicoUsando BabelUsando webpackUsando ViteUsando ParcelUsando TypeScriptUsando ESLint\n\n\n\n