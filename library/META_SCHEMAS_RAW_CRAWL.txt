SpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSpecification The current version is 2020-12!
The previous version was 2019-09.Specification documentsSee also the release notes / change log (Work in progress).The specification is split into two parts, Core and Validation. We also publish
the Relative JSON Pointers spec although it's not currently used by Core or
Validation in any significant way.           JSON Schema Core    defines the basic foundation of JSON Schema    JSON Schema Validation    defines the validation keywords of JSON Schema     Relative JSON Pointers    extends the JSON Pointer syntax for relative pointers   Meta-schemasThe meta-schemas are schemas against which other schemas can be validated. It is self-descriptive: the JSON Schema meta-schema validates itself.The latest meta-schema is 2020-12.  For an explanation of the change to date-based identifiers, see the Specification Links page.If you are accessing these JSON document links from a web browser, you will need to save the file then open it as a JSON document.  This is due to limitations with GitHub Pages.General-purpose meta-schemaPlease note, additional vocabulary specific schema files are needed to fully construct and use the Core/Validation Dialect meta-schema.                                                                                                                                                                         Core/Validation Dialect meta-schema     Used for schemas written for pure validation.                                   Hyper-Schema Dialect meta-schema  Used for schemas written for validation (2020-12) and hyper-linking (2019-09).  Recommended Output meta-schema   Recommended output structure of the application process.                       Single-vocabulary meta-schemasThese are relevant primarily to people who want to write their own meta-schemas that build on specific parts of the existing specification.Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaUnevaluated Vocabulary meta-schemaFormat Annotation Vocabulary meta-schemaFormat Assertion Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaOutput schemas and examplesJSON Schema recommended output schemaJSON Schema verbose output exampleMigrating from older draftsThe release notes discuss the changes impacting users and implementers:JSON Schema Core and Validation
  Draft 2019-09 to Draft 2020-12Draft-07 to Draft 2019-09Draft-06 to Draft-07Draft-04 to Draft-06JSON Hyper-Schema
  There was no JSON Hyper-Schema draft for 2020-12 releases.Draft-07 to 2019-09Draft-04 to Draft-07Draft-04 to Draft-06Older draftsPlease see Specification Links for older drafts and the latest unreleased version of the specification.Go BackJSON Schema referenceUp NextSpecification LinksNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubBuild more. Break less. Empower others.JSON Schema enables the confident and reliable use of the JSON data format.Getting startedJoin SlackSearchSearchUsed byPlease visit the JSON Schema Landscape and discover more companies using JSON Schema.Why JSON Schema?While JSON is probably the most popular format for exchanging data, JSON Schema is the vocabulary that enables JSON data consistency, validity, and interoperability at scale.Streamline testing and validationSimplify your validation logic to reduce your code’s complexity and save time on development. Define constraints for your data structures to catch and prevent errors, inconsistencies, and invalid data.Exchange data seamlesslyEstablish a common language for data exchange, no matter the scale or complexity of your project. Define precise validation rules for your data structures to create shared understanding and increase interoperability across different systems and platforms.Document your dataCreate a clear, standardized representation of your data to improve understanding and collaboration among developers, stakeholders, and collaborators.Vibrant tooling ecosystemAdopt JSON Schema with an expansive range of community-driven tools, libraries, and frameworks across many programming languages.Start learning JSON SchemaRead the docsExplore the JSON Schema EcosystemDiscover JSON Schema tooling to help your organization leverage the benefits of JSON Schema. Because JSON Schema is much more than a Specification, it is a vibrant ecosystem of Validators, Generators, Linters, and other JSON Schema Utilities made by this amazing Community.ExploreWelcome to the JSON Schema CommunityWith over 60 million weekly downloads, JSON Schema has a large and active developer community across the world. Join the Community to learn, share ideas, ask questions, develop JSON Schema tooling and build new connections.Join the JSON Schema Slack Workspace!Join our Slack to ask questions, get feedback on your projects, and connect with +5000 practitioners and experts.Join SlackThe JSON Schema Blog How Oracle is Bridging the Gap Between JSON Schema and Relational DatabasesAs modern multi-model databases increasingly support JSON, it's time to explore what role JSON schema will play.Loïc Lefèvre2025-02-07 · 22 min readRead more JSON Schema Community Meetings & EventsWe hold monthly Office Hours and Open Community Working Meetings. Office Hours are every first Tuesday of the month and by appointment. Open Community Working Meetings are every third Monday of the month at 12:00 PT.Open Community Working MeetingsOffice HoursUpcoming events17JSON Schema Open Community Working MeetingMarch 17th 2025, 20:00 (UTC)26GSoC Office HoursMarch 26th 2025, 19:00 (UTC)1JSON Schema Office Hours (Europe/Americas)April 1st 2025, 14:00 (UTC)21JSON Schema Open Community Working MeetingApril 21st 2025, 19:00 (UTC)6JSON Schema Office Hours (APAC/Americas)May 6th 2025, 22:00 (UTC)19JSON Schema Open Community Working MeetingMay 19th 2025, 19:00 (UTC)3JSON Schema Office Hours (Europe/Americas)June 3rd 2025, 14:00 (UTC)View CalendarStart contributing to JSON SchemaContributeSponsorsIf you ❤️ JSON Schema consider becoming a sponsoror a backer .Support us!Gold SponsorsYour logo hereSilver SponsorsYour logo hereBronze SponsorsYour logo hereSupported byThe following companies support us by letting us use their products.Email us for more info! Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSpecification The current version is 2020-12!
The previous version was 2019-09.Specification documentsSee also the release notes / change log (Work in progress).The specification is split into two parts, Core and Validation. We also publish
the Relative JSON Pointers spec although it's not currently used by Core or
Validation in any significant way.           JSON Schema Core    defines the basic foundation of JSON Schema    JSON Schema Validation    defines the validation keywords of JSON Schema     Relative JSON Pointers    extends the JSON Pointer syntax for relative pointers   Meta-schemasThe meta-schemas are schemas against which other schemas can be validated. It is self-descriptive: the JSON Schema meta-schema validates itself.The latest meta-schema is 2020-12.  For an explanation of the change to date-based identifiers, see the Specification Links page.If you are accessing these JSON document links from a web browser, you will need to save the file then open it as a JSON document.  This is due to limitations with GitHub Pages.General-purpose meta-schemaPlease note, additional vocabulary specific schema files are needed to fully construct and use the Core/Validation Dialect meta-schema.                                                                                                                                                                         Core/Validation Dialect meta-schema     Used for schemas written for pure validation.                                   Hyper-Schema Dialect meta-schema  Used for schemas written for validation (2020-12) and hyper-linking (2019-09).  Recommended Output meta-schema   Recommended output structure of the application process.                       Single-vocabulary meta-schemasThese are relevant primarily to people who want to write their own meta-schemas that build on specific parts of the existing specification.Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaUnevaluated Vocabulary meta-schemaFormat Annotation Vocabulary meta-schemaFormat Assertion Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaOutput schemas and examplesJSON Schema recommended output schemaJSON Schema verbose output exampleMigrating from older draftsThe release notes discuss the changes impacting users and implementers:JSON Schema Core and Validation
  Draft 2019-09 to Draft 2020-12Draft-07 to Draft 2019-09Draft-06 to Draft-07Draft-04 to Draft-06JSON Hyper-Schema
  There was no JSON Hyper-Schema draft for 2020-12 releases.Draft-07 to 2019-09Draft-04 to Draft-07Draft-04 to Draft-06Older draftsPlease see Specification Links for older drafts and the latest unreleased version of the specification.Go BackJSON Schema referenceUp NextSpecification LinksNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaWelcomeJSON Schema is a declarative language for annotating and validating JSON documents' structure, constraints, and data types. It helps you standardize and define expectations for JSON data.Our documentation will guide you through the basics and beyond of defining and validating JSON data.Explore the docsIntroductionDiscover JSON Schema: its purpose and role in data validation.Read MoreGet startedNew to JSON Schema? Learn the basics of schema design.Read MoreGuidesMaster advanced skills such as validation with our hands-on guides.Read MoreReferenceDive deeper into JSON Schema keywords with our clear explanations and usage examples.Read MoreSpecificationUnderstand the evolution of JSON Schema through its different versionsRead MoreNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHub195 Tools195ToolsLanguage.NETCC#C++ClojureCoffeeScriptCommon LispDartDelphiElixirElmErlangGoHaskellHelmJavaJavaScriptJuliaKotlinLua/LuaJITObjective-COpenAPIOrderlyPerlPHPPostgreSQLProtocol BuffersPythonRAMLRubyRustScalaSwiftTypeScriptXSDTooling TypeAnnotationsBenchmarksBundlerCode To SchemaData To SchemaDocumentationEditorEditor PluginsHyper SchemaLDO UtilityLinterLinter PluginsModel To SchemaSchema RepositorySchema To CodeSchema To DataSchema To TypesSchema To Web UIUtil Draft MigrationUtil Format ConversionUtil General ProcessingUtil Schema To SchemaUtil TestingValidatorEnvironmentCOM/ActiveXCommand LineEmbedded platformGithub ActionsiOSLinuxmacOSMicrosoft WindowstvOSvisionOSwatchOSWeb (Online)WindowsDialect2020-122019-097654License(MIT AND Apache-2.0)AFL-2.1 OR BSD-3-ClauseAGPL-3.0AGPL-3.0 and CommercialAGPL-3.0-onlyApache License 2.0Apache-2.0Artistic-2.0BSD-2-ClauseBSD-3-ClauseBSL-1.0CC0-1.0EPL-1.0GPL-1.0+ OR Artistic-1.0GPL-2.0GPL-3.0GPL-3.0-onlyISCLGPL 2.1 or laterLGPL-2.1LGPL-2.1-onlyLGPL-3.0MITMPL-2.0Ms-PLPostgreSQLProprietaryProprietary and FreewareShow obsoleteApply FiltersClear FiltersJSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.JSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on Slack\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubCase StudyHow Oracle is Bridging the Gap Between JSON Schema and Relational DatabasesLoïc Lefèvre2025-02-07 · 22 min readWelcome to the JSON Schema Blog!Want to publish a blog post? Check out the guidelines and submit yours!RSS FeedAllCase StudyCommunityUpdateDocumentationEngineeringOpinionFilter blog posts by category...Case StudyHow Oracle is Bridging the Gap Between JSON Schema and Relational DatabasesAs modern multi-model databases increasingly support JSON, it's time to explore what role JSON schema will play.Loïc LefèvreFebruary 7, 2025 · 22 min readCase StudyHow RxDB embraces JSON Schema to build its NoSQL DatabaseRxDB embraces JSON Schema for flexible data modeling, type safety, and advanced features like compression, all in an offline-first database.Daniel MeyerJanuary 30, 2025 · 11 min readCommunityCelebrating JSON Schema’s Google Summer of Code 2024 JourneyDiscover the projects, mentors, and contributors that shaped Google Summer of Code (GSoC) 2024!Onyedikachi Hope Amaechi-OkorieJanuary 17, 2025 · 6 min readUpdateMoving Toward a Stable SpecAmidst all of the change at JSON Schema, what's happening with the spec?Greg DennisJanuary 13, 2025 · 8 min readCommunityJSON Schema conference: A milestone event at Apidays Paris 2024Apidays Paris 2024 was the venue for a significant milestone for our project: the first-ever JSON Schema Conference.Valeria HernandezDecember 19, 2024 · 5 min readDocumentationUpdate from the Google Season of Docs 2024 ProjectAn announcement blog post to share the JSON Schema documentation efforts from the GSOD team.Blessing Ene Anyebe & Valeria Hernandez...September 3, 2024 · 2 min readCommunityJSON Schema Ambassadors Are Here!Just what is a JSON Schema Ambassador? And how can I help? Keep reading!Ben HuttonJune 20, 2024 · 8 min readEngineeringUnderstanding JSON Schema Lexical and Dynamic ScopesA deep dive on lexical and dynamic scopes, essential for understanding more advanced topics like dynamic referencingJuan Cruz ViottiFebruary 15, 2024 · 15 min readCase StudyTransforming the technical recruiting industry with JSON SchemaLearn how Manfred used JSON Schema to transform the technical recruiting industry.Benjamin Granados & Yeray DariasFebruary 6, 2024 · 4 min readCase StudyTransformando la industria de la contratación técnica con JSON SchemaDescubre cómo Manfred ha usado JSON Schema para transformar la industria de la contratación técnica.Benjamin Granados & Yeray DariasFebruary 5, 2024 · 5 min readCommunityAPI Days Paris 2023 - RecapAPI Days Paris 2023 has been an amazing experience for JSON SchemaBenjamin GranadosDecember 18, 2023 · 4 min readEngineeringInterpreting JSON Schema OutputWhy does my passing validation contain errors?Greg DennisNovember 8, 2023 · 7 min readCommunityIntroducing the JSON Schema AdoptersExplore our Adopters list to discover organizations successfully leveraging JSON SchemaBenjamin GranadosNovember 7, 2023 · 2 min readCommunityAnnouncing our new websiteWe are so pleased to announce the launch of our new website!Benjamin GranadosOctober 2, 2023 · 3 min readEngineering50+ million requests in 7 days on json-schema.orgSee what we discovered when looking at over 50 million requests to the JSON Schema org domain from the last 7 daysBen HuttonSeptember 15, 2023 · 12 min readEngineeringModelling Inheritance with JSON SchemaCan it be done?  Well, sort of.Greg DennisSeptember 13, 2023 · 7 min readCase StudyHow JSON Schema Was an Obvious Choice at GitHubAt GitHub's Docs Engineering team, while shipping releases to production 20 times per day or more, JSON Schema is critical in increasing confidence in changes to data, content and APIs.Julian BermanSeptember 9, 2023 · 5 min readEngineeringStatic Analysis of JSON SchemaWhat can we know about a schema without having an instance to evaluate?Greg DennisAugust 2, 2023 · 8 min readCase StudyHow Postman uses JSON SchemaLearn how JSON Schema continues to be a crucial component of the Postman API Platform and the API ecosystem.Juan Cruz ViottiJuly 17, 2023 · 6 min readCase StudyHow 6 River Systems saves time and boosts collaboration with JSON SchemaExplore the powerful impact of JSON Schema on 6 River Systems' fulfillment operations. Discover how they enabled enhanced collaboration, time savings, and data quality assurance, propelling their successful scaling journey.Melinda Gutermuth & Ben HuttonMay 8, 2023 · 9 min readCase StudyUsing JSON Schema at Remote to scale forms and data validationsUsing JSON Schema at Remote was the first step to solving data validation and form generation problems across all levels at Remote.Ben HuttonMay 6, 2023 · 8 min readEngineeringThe Last Breaking ChangeWe need to make a breaking change so that we can promise we won't again.Greg DennisFebruary 23, 2023 · 5 min readEngineeringCustom Annotations Will ContinueCustom annotations are one of JSON Schemas most-used features.  Here's how we're still supporting them.Greg DennisFebruary 22, 2023 · 7 min readCommunityHello 2023, Hello JSON Schema CommunityI am excited to announce that I am joining as Developer Advocate with a focus on serving the CommunityBenjamin GranadosJanuary 10, 2023 · 2 min readEngineeringIntroducing: BowtieA new tool for executing JSON Schema implementations & a call to help improve itJulian BermanNovember 16, 2022 · 12 min readCase StudyHow the W3C Web of Things brings JSON Schema to the Internet of ThingsUsing JSON Schema at the W3C Web of Things to create an interoperability layer so that different IoT platforms, protocols and standards can operate togetherJuan Cruz ViottiNovember 1, 2022 · 6 min readUpdateTowards a stable JSON SchemaAbout this time last year, I hosted a discussion at the API Specification Conference about the future of JSON Schema. The most popular topic of discussion was, when JSON Schema is going to be 'done'. Of course we've heard that question a lot. The question stems from the 'draft' label we put on your releases. The term 'draft' has led to quite a bit of confusion for our community over the years, so let's take a moment to understand where it comes from.Jason DesrosiersOctober 21, 2022 · 6 min readEngineeringUsing Dynamic References to Support Generic TypesA step in the right direction for modelling data with JSON SchemaGreg DennisAugust 31, 2022 · 6 min readEngineeringFixing JSON Schema OutputI have a problem: when I read GitHub issues, they occasionally resonate with me, and I obsess about them until they're resolved.  That may not sound like a problem to some, but when that resolution causes JSON Schema implementation developers to ask fundamental design questions for three years... yeah, that's a problem.Greg DennisJuly 23, 2022 · 11 min readOpinionThe Architectural Scope of JSON SchemaWhat actually is JSON Schema?!Greg DennisJuly 15, 2022 · 5 min readCommunityJoining PostmanIn the last couple of weeks, you may have seen that Postman has been investing heavily in JSON Schema's future by hiring some of its top contributors giving them the opportunity to work full time on improving the JSON Schema specification and tooling ecosystem. I'm happy to announce that I'm the next addition to that team.Jason DesrosiersJuly 3, 2022 · 5 min readCommunityAnd Then There Were ThreeMore full-time contributors is better, right?Greg DennisJune 23, 2022 · 7 min readCommunityHello World, Hello PostmanOh hello there! A second person is now working full-time on JSON Schema.Julian BermanJune 16, 2022 · 7 min readEngineeringAstonishing Serializations & Schemas of HyperboreaUsing JSON Schema for validating role-playing character sheets.Yanick ChampouxMay 18, 2022 · 14 min readEngineeringGet started with JSON Schema in Node.jsLearn how to use JSON Schema for validation in your Node.js applications.Simon PlenderleithMay 16, 2022 · 7 min readCase StudyHow Tyler Technologies reduced its client feedback loop with JSON SchemaUsing JSON Schema at Tyler Technologies meant showing added value to clients could take minutes rather than days or in some cases weeks.Ben HuttonMay 9, 2022 · 5 min readEngineeringIt all starts with applicability - JSON Schema Fundamentals part 1We explore the fundamental JSON Schema concepts: Applicability, Subschemas, and Assertion Boolean Logic - Everyone needs good fundamentals.Ben HuttonMarch 21, 2022 · 16 min readUpdateJSON Schema joins the OpenJS Foundation and 2022 updatesFind out what we've been doing in 2021 and read about our biggest development yet... joining the OpenJS Foundation. Oh, and WE'RE HIRING!Ben HuttonFebruary 11, 2022 · 8 min readEngineeringJSON Schema in 5 minutesEveryone needs good fundamentals, and understanding the basics of JSON Schema changes how you read, reason, and develop Schemas.Ben HuttonJanuary 21, 2022 · 9 min readCase Studyクックパッド株式会社におけるJSON Schemaの活用事例クックパッド株式会社ではJSON Schemaを活用することによって、クックパッドマートにおける販売者の商品登録時の正確性と体験を改善し、商品審査にかかる運営上の負担を大幅に軽減することができました。Ben HuttonJanuary 17, 2022 · 11 min readCase StudyJSON Schema deduplicated complex logic and validation at CookpadUsing JSON Schema at Cookpad improved the accuracy and experience when registering products, and has greatly reduced the operational burden of product screening.Ben HuttonDecember 9, 2021 · 6 min readEngineeringValidating OpenAPI and JSON SchemaDynamic references make it possible to validate the schemas in an OpenAPI document even though OpenAPI does not constrain which JSON Schema dialects can be used.Jason DesrosiersDecember 8, 2021 · 8 min readCommunityWhy JSON Schema needs a Code of ConductThe community of JSON Schema is growing, and the community needs a culture for interactions to avoid past mistakes.Ben HuttonNovember 24, 2021 · 10 min readEngineeringJSON Schema bundling finally formalisedExisting tooling developers have created their own approaches to bundling JSON Schema and OpenAPI documents, but that can lead to errors. Bundling is now standardised.Ben Hutton & Mike RalphsonAugust 4, 2021 · 10 min readOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWelcome to theJSON Schema CommunityJoin the Community to learn, share ideas, ask questions, build JSON Schema tooling, and get involved in the future of the specifications.Join DiscussionsRoadmapExplore our exciting plans and upcoming milestones. 🚀Read MoreContributeWe are looking forward to working with you. Welcome aboard!Read MoreAmbassadors ProgramThe JSON Schema Ambassadors Program recognize the people who drive adoption, innovation and knowledge sharing in the JSON Schema community.Become an ambassadorJoin the JSON Schema Slack workspace!Join our Slack to ask questions, get feedback on your projects, and connect with +5000 practitioners and experts.Join SlackJSON Schema Community Meetings & EventsWe hold monthly Office Hours and weekly Open Community Working Meetings. Office Hours are every first Tuesday of the month at 15:00 BST, and by appointment. Open Community Working Meetings are every Monday at 14:00 PT.Open Community Working MeetingsOffice HoursUpcoming events17JSON Schema Open Community Working MeetingMarch 17th 2025, 20:00(UTC)26GSoC Office HoursMarch 26th 2025, 19:00(UTC)1JSON Schema Office Hours (Europe/Americas)April 1st 2025, 14:00(UTC)21JSON Schema Open Community Working MeetingApril 21st 2025, 19:00(UTC)6JSON Schema Office Hours (APAC/Americas)May 6th 2025, 22:00(UTC)19JSON Schema Open Community Working MeetingMay 19th 2025, 19:00(UTC)3JSON Schema Office Hours (Europe/Americas)June 3rd 2025, 14:00(UTC)Welcome tothe JSON Schema Blog!Want to publish a blog post? Check out the guidelines and submit yours!Read blogHow Oracle is Bridging the Gap Between JSON Schema and Relational DatabasesAs modern multi-model databases increasingly support JSON, it's time to explore what role JSON schema will play.Loïc Lefèvre2025-02-07 ·22 min min readRead more postsOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaWhat is JSON Schema?JSON Schema is a declarative language for defining structure and constraints for JSON data.

How does JSON Schema work?When it comes to data exchange, JSON Schema stands out as a powerful standard for defining the structure and rules of JSON data. It uses a set of keywords to define the properties of your data.While JSON Schema provides the language, validating a JSON instance against a schema requires a JSON Schema validator. The JSON validator checks if the JSON documents conform to the schema.JSON Schema Validators are tools that implement the JSON Schema specification. Such tooling enables easy integration of JSON Schema into projects of any size.Benefits of JSON Schema for DevelopersJSON Schema empowers developers in the following ways:Structured Data Description: JSON Schema allows developers to describe the structure, constraints, and data types of existing JSON data.Rule Definition and Enforcement: By adhering to JSON schema constraints, it becomes easier to exchange structured data between applications as it maintains a consistent pattern.Produce clear documentation: JSON Schema supports the creation of machine and human readable documentation.Extensibility: JSON Schema offers high adaptability to developers' needs. Custom keywords, formats, and validation rules can be created to tailor schemas according to specific requirements.Data Validation: JSON Schema ensures data validity through:
 Automated Testing: Validation enables automated testing, ensuring data consistently complies with specified rules and constraints.Improved Data Quality: By enforcing validation rules, JSON Schema aids in maintaining the quality of client-submitted data, reducing inconsistencies, errors, and potential security vulnerabilities.Rich Tooling Ecosystem: The JSON Schema community offers a wealth of tools and resources across various programming languages to help developers create, validate, and integrate schemas.Benefits of JSON Schema for OrganizationsJSON Schema empowers organizations by:Simplifying Testing and Validation: JSON Schema reduces code complexity and development time by simplifying validation logic. It defines constraints for data structures, enabling the detection and prevention of errors, inconsistencies, and invalid data.Facilitating Seamless Data Exchange: JSON Schema establishes a common language for data exchange, no matter the complexity of your project. It defines precise validation rules for your data structures to create a shared understanding and increase interoperability across different systems and platforms.Enhancing Data Documentation: JSON Schema enables the creation of clear and standardized representations of data. This improves understanding and collaboration among developers, stakeholders, and collaborators, enhancing organizational efficiency.Access to a Vibrant Tooling Ecosystem: JSON Schema is supported by a diverse array of languages, libraries, and frameworks with community-driven tools. This vibrant ecosystem enhances development productivity and provides resources for effective schema implementation and utilization.History of JSON SchemaJSON Schema dates back to the first JSON Schema proposal submitted by Kris Zyp to json.com on October 2nd, 2007.The latest version of JSON Schema is 2020-12, which represents the latest advancements and has expanded capabilities compared with the previous versions, draft-04, draft-06, and draft-07.We recommend using the newest version of JSON Schema and taking advantage of its benefits.For more information regarding JSON Schema history, refer to this article by Henry Andrews.
What Next?Intrigued by JSON Schema's potential? Dive right in! Learning is by doing, and creating your first schema is the perfect starting point. Check out the guide on Creating your first schema to begin crafting your data validation tool.Learn moreLearn more about the specification:Understanding JSON SchemaJSON Schema Specification 2020-12Join the communityTo get involved with our community, please make sure you are familiar with the project's Code of Conduct.Join JSON Schema Slack. This is the best place to ask questions, learn, get help, or discuss all things JSON Schema.Attend our public JSON Schema meetings. We hold Office Hours every first Tuesday at 15:00 BST (and by appointment) and Open Community Working Meetings every Monday at 14:00 PT.Follow our YouTube channel. Find recordings of our public community meetings and JSON Schema learning resources.Read our blog. Find the latest and greatest stories from our community.Up NextRoadmapNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema RoadmapOur "Roadmap" section displays our key objectives for the long term. While this roadmap provides a detailed outlook for the near future, please note that it might be subject to change. In fact, we are currently discussing the new priorities for the next 24-month cycle, which will lead to relevant changes. Please consider joining the discussion to become an active part of JSON Schema's future!EcosystemStrategy for engaging implementersEffort: MediumImpact: HighIn ProgressSpecificationComplete the new version of the SpecEffort: HighImpact: HighIn ProgressOperationsComplete OpenJSF onboardEffort: MediumImpact: Medium-highPausedEcosystemResearch of existing implementations by languageEffort: LowImpact: HighIn ProgressOperationsReport on projects financial sustainability requirementsEffort: Low-mediumImpact: Low-mediumPlannedOperationsImplement and scale the new governance modelEffort: LowImpact: MediumIn ProgressCommunicationsEnhance public communications strategyEffort: LowImpact: MediumDeferredEcosystemIdentify a list of critical interfaces that implementations should have and empower implementers with better resourcesEffort: LowImpact: HighDoneUser ExperienceComplete and publish the new websiteEffort: LowImpact: HighDoneUser ExperienceDefine the JSON Schema Documentation StrategyEffort: HighImpact: MediumDoneUser ExperienceRefine the contributor journeyEffort: HighImpact: Medium-highDoneGo BackWhat is JSON SchemaUp NextSponsorsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSponsorsJSON Schema uses OpenCollective and GitHub Sponsors to gather money. This money is used to cover project expenses in a transparent way (See the OpenCollective documentation), and your donation will help to sustain and grow the Project.While donations can be made to both OpenCollective and GitHub Sponsors, the JSON Schema funds are fully managed in OpenCollective, therefore the donations received in GitHub Sponsors will be transferred to OpenCollective.Please go to our OpenCollective page or GitHub Sponsors page to become a backer or a sponsor.Benefits of being an individual backerIndividual backers donate $5 per month to the project, and get the following benefits:Visibility on the GitHub main project page in the "sponsors" section.Benefits of being a community sponsorCommunity sponsors is a special tier for companies under 20 employees. Community sponsors donate $20 per month to the project, and get the following benefits:Visibility on the GitHub main project page in the "sponsors" section."Thank you" tweet from @jsonschema."Thank you" post in Linkedin from @jsonschema.A dedicated slack channel in our organization.Benefits of being a bronze sponsorBronze sponsors donate $100 per month to the project, and get the following benefits:Visibility on the front page of https://json-schema.org in the "sponsors" section (about 110,000 views/month on November, 2023).Visibility on the GitHub main project page in the "sponsors" section."Thank you" tweet from @jsonschema."Thank you" post in Linkedin from @jsonschema.Benefits of being a silver sponsorThere is a limit to 10 silver sponsors.Silver sponsors donate $500 per month to the project, and get the following benefits:Same benefits as bronze sponsors.A mention on the Newsletter.Possibility of getting expert advice from the team.Get a Swag Kit.Benefits of being a gold sponsorThere is a limit to 3 gold sponsors.Gold sponsors donate $1,000 per month to the project, and get the following benefits:Same benefits as silver sponsors.Company logo in the footer of the Newsletter.Company logo on all https://json-schema.org page footers.What will the project do with the money?As you can read in the OpenCollective documentation, the way your money will be used will be public and totally transparent.Money will first be used to cover direct project costs:Infrastructure and hostingNew feature developmentAny administrative or legal costsThen, money will be used for:MerchandisingMentoring and Contributing programsAcceptance policyWe don't accept sponsorship from the following types of companies: Adult websites, affiliate and review websites, fake news services, fake social media engagement services, casinos and gambling, insurance & financial products (credit), pharmacy products (weight loss, anti-aging), and essay writing services.Please, contact us if you have further questions.References:JHipster - SponsorsMUI Code - Sponsors and BackersGo BackRoadmapUp NextUse CasesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaUse CasesDiscover everything you can do with JSON Schema. This section presents the most common use cases for JSON Schema, but there may be many more applications waiting to be discovered.Structural validationStructural validation refers to the structure that a JSON document is supposed to follow, such as which properties must exist, what types of values are expected where, and what they must look like.Semantic annotationThere is a need to annotate values within a JSON document: for machine readability, and for documentation purposes.Domain-specific languageDevelopers may write an application that uses a JSON Schema internally as a domain-specific language, so that the schema is only used inside a single application by a single party. By using a declarative language, the application requirements can be optimized better than a human could do.A common vocabularyA development team maintains two similar applications, but for different platforms, in different languages. The application downloads and reads from a common repository of JSON documents. They want to make sure that both applications accept or reject JSON with identical behavior, so they write a single JSON Schema and deploy it to both applications.Model-Driven UI constraintsWhen a server declares constraints that a submission must meet, there is a need for the user interface to receive these constraints to provide model-driven validation of permissible values, making the form more accessible to the user.UI GenerationJSON Schema can be used to automatically generate user interfaces that adhere to a given schema.Data SerializationCompress JSON data for storage/transmission. For example: JSON Bin PackFuzzing, enumeration, and generationSecurity applications need to generate examples of JSON documents within the valid set, and outside the valid set.Partial validationDue to technical limitations, some JSON parsers may only be able to understand a subset of the JSON value space, and it makes sense to validate the value read by the application, instead of the JSON document provided to the JSON parser.Automated TestingGood definitions of input/output that schemas provide enable contract and property-based testing scenarios. For example: SchemathesisMachine-readable profiles of Web resourcesA Web server that offers a JSON document should be able to link to a profile document that describes the meaning of the data in a machine-readable form.Schema InferenceThis is pretty useful in data science. You may have huge JSON datasets and don't know the structure well. You can use tools that will derive a JSON Schema from the data for you to better understand it and act on it.HypermediaGeneric user-agents must be able to make use of the schema as it evolves, including Web browsers, spiders, and automated tooling. It should support loose coupling (like an HTML homepage); so a schema should be able to change, add, and remove features with minimal breakage for compatible clients.Results and ReportingThe party that is providing the schema and input may not be the same party that is performing the validation; in this case, there should be a standard way to abstract away the validator interface, and report the results of a validation operation (validation result, annotations, and errors).External validationAuthors may embed resources of other media types, such as text documents, or base64 or hex-encoded binary documents; and may wish to pass off validation of these documents to another software tool.Intra-document data consistency validationA JSON document may carry relational data that must be internally consistent.Inter-database consistency validationA JSON document may carry relational data that must be verified against outside data sources.LintingSometimes it's desirable to require formatting that does not impact the application-level meaning of the document, but instead specifies requirements purely for aesthetic or compatibility reasons.Go BackSponsorsUp NextCase StudiesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCase StudiesLearn how organizations are adopting JSON Schema to improve data management, ensure consistency, and streamline workflows across systems.How RxDB embraces JSON Schema to build its NoSQL DatabaseRxDB embraces JSON Schema for flexible data modeling, type safety, and advanced features like compression, all in an offline-first database.Read MoreHow JSON Schema Was an Obvious Choice at GitHubAt GitHub's Docs Engineering team, while shipping releases to production 20 times per day or more, JSON Schema is critical in increasing confidence in changes to data, content and APIs.Read MoreHow 6 River Systems saves time and boosts collaboration with JSON SchemaExplore the powerful impact of JSON Schema on 6 River Systems' fulfillment operations. Discover how they enabled enhanced collaboration, time savings, and data quality assurance, propelling their successful scaling journey.Read MoreTransforming the technical recruiting industry with JSON SchemaLearn how Manfred used JSON Schema to transform the technical recruiting industry.Read MoreHow Postman uses JSON SchemaLearn how JSON Schema continues to be a crucial component of the Postman API Platform and the API ecosystem.Read MoreUsing JSON Schema at Remote to scale forms and data validationsUsing JSON Schema at Remote was the first step to solving data validation and form generation problems across all levels at Remote.Read MoreHow Tyler Technologies reduced its client feedback loop with JSON SchemaUsing JSON Schema at Tyler Technologies meant showing added value to clients could take minutes rather than days or in some cases weeks.Read MoreHow the W3C Web of Things brings JSON Schema to the Internet of ThingsUsing JSON Schema at the W3C Web of Things to create an interoperability layer so that different IoT platforms, protocols and standards can operate together.Read MoreJSON Schema deduplicated complex logic and validation at CookpadLearn how Cookpad used JSON Schema to reduce incomplete input of newly registered items from 10% to 0%.Read MoreGo BackUse CasesUp NextFAQsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaNeed pro help with JSON Schema?Whether you need training, personalized advice, or custom JSON Schema solutions, some members of the JSON Schema Technical Steering Committee (TSC) and Ambassadors programs offer pro services beyond community support. Don't hesitate in reaching out to discuss further.Hiring our top contributors also helps funding the JSON Schema open-source organization, and as a consequence, the specifications that build on top of it, such as OpenAPI,AsyncAPI,RAML,W3C WoT, and many more.Available MembersJuan Cruz Viotti tscReach OutJuan Cruz ViottitscWebsiteLinkedInGitHubReach OutI'm a TSC member of JSON Schema, did award-winning research at the University of Oxford in the space of binary serialization and compression using JSON Schema, co-authored an O'Reilly book covering JSON Schema, and own several projects in the ecosystem, ranging educational material like LearnJSONSchema.com to a high-performance C++ JSON Schema compiler and validator. I have experience helping organizations be successful with JSON Schema in the Data, API, and IoT spaces all the way from architecture, ontology design, and XML migrations to training and custom development. I'm eager to help you take your JSON Schema integrations to the next level!Previous Work & Relevant LinksO'Reilly Book: Unifying Business, Data, and Code: Designing Data Products with JSON SchemaJSON Schema CLI: The CLI for working with JSON Schema. Covers formatting, linting, testing, bundling, and more for both local development and CI/CD pipelinesJSON BinPack: binary serialization with JSON Schema, more space-efficient than Protocol Buffers and similar alternatives (work in progress)AlterSchema: Automatic upgrades between versions of JSON Schema (downgrades coming soon)Blaze: the ultra high-performance JSON Schema validator, providing validation in the nano-second range, along with perfect compliance scores. Supports Draft 4, Draft 6, Draft 7, 2019-09 and 2020-12Blog post: A deep dive on lexical and dynamic scopes, essential for understanding more advanced topics like dynamic referencingJulian Berman tscReach OutJulian BermantscLinkedInGitHubReach OutJulian is an experienced engineering leader, JSON Schema TSC member and a member of the JSON Schema core team for over 10 years. He founded the JSON Schema Test Suite and Bowtie projects, helping countless implementers (and users) of all JSON Schema implementations ensure compliance with the specification. He also wrote and maintains the most widely used Python implementation of JSON Schema, along with a large number of projects in its orbit, and is a long-time contributor to the wider open source Python ecosystem. He has deep experience running engineering teams (in previous lives in the context of machine learning for large-enterprise consumer experience marketing). He also is a lecturer at Columbia University, who cares deeply about ensuring technology is accessible and easy to understand for all. Let him help your organization get smarter about how you use JSON Schema, how you collaborate with it across teams, and how you effectively build reliable production systems which leverage JSON Schema.Previous Work & Relevant Linkspython-jsonschema, the most widely used Python implementation of JSON Schema for over 10 yearsBowtie, a meta-validator for using JSON Schema implementations across every programming language in the worldThe official JSON Schema Test Suite, a large collection of compliance tests for the JSON Schema specification used by many or most implementations of JSON SchemaJason Desrosiers tscReach OutJason DesrosierstscLinkedInGitHubReach OutJason is a recognized expert and active contributor to the JSON Schema community with over a decade of experience. As a member of the Technical Steering Committee (TSC), he has helped shape the specification and establish best practices. In addition, Jason has developed innovative techniques for writing complex schemas that are scalable, maintainable, efficient, and produce error messages that are clear and helpful.As the author and maintainer of the @hyperjump/json-schema validator, Jason has created an implementation that is widely regarded as a trusted reference for understanding and verifying correct behavior in complex scenarios.Jason is also highly knowledgeable in using JSON Schema and JSON Hyper-Schema to design APIs that are easy to use, well-documented, and adaptable over time. He helps teams build APIs that not only meet immediate needs but also ensure smooth evolution as business requirements change, making it easier to maintain and scale them as the organization grows.In addition to his JSON Schema expertise, Jason holds a Master's degree in Software Engineering and brings extensive experience in Pair/Mob Programming, Test-Driven Development, and coaching teams to improve their coding skills and productivity. He specializes in hands-on collaboration, working alongside teams to teach practical skills in the context of their real-world projects.If you need expert guidance on JSON Schema, API design, schema development, or improving your team’s development practices, reach out to Jason to discuss your needs.Previous Work & Relevant Links@hyperjump/json-schema -- A JSON Schema implementation with support for every validation, annotations, bundling, and more in every JSON Schema dialect since draft-04.Blog post -- Validating OpenAPI and JSON SchemaBlog post -- Towards a stable JSON SchemaAPI Specifications Conference 2021 - Maintaining JSON Schemas at ScaleGo BackFAQUp NextSimilar TechnologiesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSimilar TechnologiesWhile we think that JSON Schema has a unique value proposition, we'd like to provide visibility to other technologies that share similar goals:
JSON Constraint Rules (JCR): JCR aims to provide a more expressive way to define constraints on JSON data compared to JSON Schema. While still under development, you can learn more about it on GitHub: http://codalogic.github.io/jcr/.CBOR Constrained Data Description Language (CBL): Similar to JCR, CBL focuses on describing constraints, but specifically for the CBOR data format. Dive deeper into CBL in the CBL IETF draft: https://datatracker.ietf.org/doc/draft-cordell-jcr-co-constraints/.CBOR Data Definition Language (Cddl): While not strictly focused on constraints, Cddl allows defining the structure of CBOR data. Check out the Cddl IETF draft: https://tools.ietf.org/html/draft-greevenbosch-appsawg-cbor-cddl-08 for more information.Contributing to the CommunityDo you know of any other relevant technologies that we should add to this list? Please submit a pull request. We encourage contributions!Go BackPro HelpUp NextCode of ConductNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema Organizational Code of ConductOur (The JSON Schema Organization) Code of Conduct is a combination of:The IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154)The "Contributor Covenant Code of Conduct" 2.1The OpenJS Foundation Code of ConductApplicable sectionsWe take the whole of the Contributor Covenant Code of Conduct 2.1 as is.We reference the IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154) as a guideline. We do not subscribe to its defined Reporting Transgressions of the Guidelines (Appendix A), as JSON Schema is not part of any IETF working group.We subscribe to the OpenJS Foundation Code of Conduct in full. The OpenJS Foundation Code of Conduct consists of the Contributor Covenant Code of Conduct, commitments relating to reports, and an escalation process.IETF Guidelines for ConductWhile the JSON Schema project is not formally part of the IETF, historically the project was initially published and updated as "personal drafts" through the IETF process. The project members have found the approach and assumptions defined as Guidelines for Conduct to be well informed and a good foundation of behaviour and expectations.The IETF defined BCP 54 (Best Current Practice), also assinged RFC 7154.
Some extracts are provided which are found to be key principles.
Please see BCP 54/RFC 7154 document for full details.BCP 54 provides a set of guidelines for personal interaction in the Internet Engineering Task Force.  The guidelines recognize the diversity of IETF participants, emphasize the value of mutual respect, and stress the broad applicability of our work.The work of the IETF relies on cooperation among a diverse range of people with different ideas and communication styles.  The IETF strives, through these guidelines for conduct, to create and maintain an environment in which every person is treated with dignity, decency, and respect.We dispute ideas by using reasoned argument rather than through intimidation or personal attack.The IETF puts its emphasis on technical competence, rough consensus, and individual participation, and it needs to be open to competent input from any source.IETF participants use their best engineering judgment to find the best solution for the whole Internet, not just the best solution for any particular network, technology, vendor, or user.Some thoughts on "consensus": https://datatracker.ietf.org/doc/html/rfc7282Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our
community include:Demonstrating empathy and kindness toward other peopleBeing respectful of differing opinions, viewpoints, and experiencesGiving and gracefully accepting constructive feedbackAccepting responsibility and apologizing to those affected by our mistakes,
and learning from the experienceFocusing on what is best not just for us as individuals, but for the
overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or
advances of any kindTrolling, insulting or derogatory comments, and personal or political attacksPublic or private harassmentPublishing others' private information, such as a physical or email
address, without their explicit permissionOther conduct which could reasonably be considered inappropriate in a
professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[email protected].
All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the
reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series
of actions.Consequence: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including
sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within
the community.Conflicts of InterestIn the event of any conflict of interest, a community leader must immediately notify the other leaders, and recuse themselves if necessary.The OpenJS Foundation Code of ConductThe OpenJS Foundation Code of Conduct is mostly formed from the Contributor Covenant Code of Conduct.
Significantly, we copy here the defined issue escalation process.Privacy ExpectationsAs per Code of Conduct requirements set out by the OpenJS Foundation, recipients of reports will maintain the confidentiality with regard to the reporter of an incident.
For the purposes of tracking between Code of Conduct review members, incidents may be tracked in a private organizational GitHub Repository.
In addition to any Code of Conduct review team, GitHub organizational owners will have access to view details of reports by way of having full GitHub organizational admin access.EscalationThe OpenJS Foundation provides an escalation path should you feel your report has not been handled appropriatly. Recipients of reports commit to participate in the defined path of escalation when required, as required by the OpenJS Foundation Code of Conduct.The OpenJS Foundation maintains a Code of Conduct Panel (CoCP). This is a foundation-wide team established to manage escalation when a reporter believes that a report to a member project or the CPC has not been properly handled. In order to escalate to the CoCP send an email to [email protected].
Enforcement responsabilitiesIf a Code of Conduct report involves a community leader, that member will not participate in the investigation or any decisions related to that report. If the report involves multiple community leaders, mediation will defer to the OpenJS Code of Conduct Panel (CoCP).For more information, refer to the full
Code of Conduct governance document.AttributionThis Code of Conduct is adapted from the Contributor Covenant,
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.Community Impact Guidelines were inspired by
Mozilla's code of conduct enforcement ladder.For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.Go BackSimilar-TechnologiesUp NextGetting StartedNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaGet StartedNew to JSON Schema and don't know where to start? Explore our learning resources and get started with JSON Schema.What is a schema?Let us start by defining what is a SchemaRead MoreJSON Schema basicsLearn what JSON Schema is, essential keywords, and the basics of data validationRead MoreCreate your first schemaFollow our step by step guide and create your first JSON SchemaRead MoreTour of JSON SchemaMaster JSON Schema through engaging lessons and hands-on exercises. Complete the course to earn your JSON Schema certification and prove your expertise.Read MoreJSON Schema glossaryExplore a curated glossary of common terms used in the JSON Schema ecosystemRead MoreJSON Schema examplesBrowse real-world JSON Schema examples across different domains, with detailed annotations.Read MoreGo BackCode of conductUp NextCreating your first SchemaNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaWhat is a schema?If you've ever used XML Schema, RelaxNG or ASN.1 you probably already
know what a schema is and you can happily skip along to the next
section. If all that sounds like gobbledygook to you, you've come to
the right place. To define what JSON Schema is, we should probably first
define what JSON is.JSON stands for "JavaScript Object Notation", a simple data
interchange format. It began as a notation for the world wide web. Since
JavaScript exists in most web browsers, and JSON is based on JavaScript,
it's very easy to support there. However, it has proven useful enough
and simple enough that it is now used in many other contexts that don't
involve web surfing.At its heart, JSON is built on the following data structures:objectdata{ "key1": "value1", "key2": "value2" }﻿
arraydata[ "first", "second", "third" ]﻿
numberdata423.1415926﻿ 
stringdata"This is a string"﻿
booleandata  true  false﻿
nulldata  null﻿
These types have analogs in most programming languages.
With these simple data types, all kinds of structured data can be
represented. With that great flexibility comes great responsibility,
however, as the same concept could be represented in myriad ways. For
example, you could imagine representing information about a person in
JSON in different ways:data{  "name": "George Washington",  "birthday": "February 22, 1732",  "address": "Mount Vernon, Virginia, United States"} ﻿
data{  "first_name": "George",  "last_name": "Washington",  "birthday": "1732-02-22",  "address": {    "street_address": "3200 Mount Vernon Memorial Highway",    "city": "Mount Vernon",    "state": "Virginia",    "country": "United States"  }}﻿
Both representations are equally valid, though one is clearly more
formal than the other. The design of a record will largely depend on its
intended use within the application, so there's no right or wrong
answer here. However, when an application says "give me a JSON record
for a person", it's important to know exactly how that record should
be organized. For example, we need to know what fields are expected, and
how the values are represented. That's where JSON Schema comes in. The
following JSON Schema fragment describes how the second example above is
structured. Don't worry too much about the details for now. They are
explained in subsequent chapters. schema{  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "birthday": { "type": "string", "format": "date" },    "address": {       "type": "object",       "properties": {         "street_address": { "type": "string" },         "city": { "type": "string" },         "state": { "type": "string" },         "country": { "type" : "string" }       }    }  }}﻿
By "validating" the first example against this schema, you can see that it fails:data{  "name": "George Washington",  "birthday": "February 22, 1732",  "address": "Mount Vernon, Virginia, United States"}﻿not compliant to schema
However, the second example passes:data{  "first_name": "George",  "last_name": "Washington",  "birthday": "1732-02-22",  "address": {    "street_address": "3200 Mount Vernon Memorial Highway",    "city": "Mount Vernon",    "state": "Virginia",    "country": "United States"  }}﻿compliant to schema
You may have noticed that the JSON Schema itself is written in JSON. It
is data itself, not a computer program. It's just a declarative format
for "describing the structure of other data". This is both its
strength and its weakness (which it shares with other similar schema
languages). It is easy to concisely describe the surface structure of
data, and automate validating data against it. However, since a JSON
Schema can't contain arbitrary code, there are certain constraints on
the relationships between data elements that can't be expressed. Any
"validation tool" for a sufficiently complex data format, therefore,
will likely have two phases of validation: one at the schema (or
structural) level, and one at the semantic level. The latter check will
likely need to be implemented using a more general-purpose programming
language.Go BackGet StartedUp NextThe basicsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaThe basicsIn What is a schema?, we described what a schema is,
and hopefully justified the need for schema languages. Here, we proceed
to write a simple JSON Schema.Hello, World!When learning any new language, it's often helpful to start with the
simplest thing possible. In JSON Schema, an empty object is a completely
valid schema that will accept any valid JSON. schema{}﻿
This accepts anything, as long as it's valid JSONdata42﻿compliant to schema
data"I'm a string"﻿compliant to schema
data{ "an": [ "arbitrarily", "nested" ], "data": "structure" }﻿compliant to schema
New in draft 6You can also use true in place of the empty object to represent a
schema that matches anything, or false for a schema that matches
nothing.This accepts anything, as long as it's valid JSON: schematrue﻿
data42﻿compliant to schemadata"I'm a string"﻿compliant to schemadata{ "an": [ "arbitrarily", "nested" ], "data": "structure" }﻿compliant to schema
Documents for this schema will always be invalid: schemafalse﻿
data"Resistance is futile...  This will always fail!!!"﻿not compliant to schema
The type keywordOf course, we wouldn't be using JSON Schema if we wanted to just accept
any JSON document. The most common thing to do in a JSON Schema is to
restrict to a specific type. The type keyword is used for that.When this book refers to JSON Schema "keywords", it means the
"key" part of the key/value pair in an object.  Most of the work
of writing a JSON Schema involves mapping a special "keyword" to a
value within an object.
For example, in the following, only strings are
accepted: schema{ "type": "string" }﻿data"I'm a string"﻿compliant to schemadata42﻿not compliant to schema
The type keyword is described in more detail in here.Declaring a JSON SchemaIt's not always easy to tell which draft a JSON Schema is using. You
can use the $schema keyword to declare which version of the JSON
Schema specification the schema is written to. See $schema
for more information. It's generally good practice to include it,
though it is not required.For brevity, the $schema keyword isn't included in most of the
examples in this book, but it should always be used in the real world.
 schema{ "$schema": "https://json-schema.org/draft/2020-12/schema" }﻿
Draft-specific infoIn Draft 4, a $schema value of
http://json-schema.org/schema# referred to the latest version
of JSON Schema. This usage has since been deprecated and the use
of specific version URIs is required.
Declaring a unique identifierNew in draft 6It is also best practice to include an $id property as a unique
identifier for each schema. For now, just set it to a URL at a domain
you control, for example: schema{ "$id": "http://yourdomain.com/schemas/myschema.json" }﻿
The details of $id become more apparent when you start structuring a complex schema.Draft-specific infoIn Draft 4, $id is just id (without the dollar-sign).
Go BackWhat is a Schema?Up NextCreating your first SchemaNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaMiscellaneous ExamplesIn this page, you will find miscellaneous examples illustrating different use cases to help you get the most out of your JSON Schemas. Each example comes with accompanying JSON data and explanation.A typical minimum schemaArrays of thingsEnumerated valuesRegular expression patternComplex object with nested propertiesConditional validation with dependentRequiredConditional validation with dependentSchemasConditional validation with if-elseBasicThis example provides a typical minimum you are likely to see in JSON Schema. It contains:$id keyword$schema keywordtitle annotation keywordtype instance data modelproperties validation keywordThree keys: firstName, lastName and age each with their own:
description annotation keyword.type instance data model (see above).minimum validation keyword on the age key. schema{  "$id": "https://example.com/person.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Person",  "type": "object",  "properties": {    "firstName": {      "type": "string",      "description": "The person's first name."    },    "lastName": {      "type": "string",      "description": "The person's last name."    },    "age": {      "description": "Age in years which must be equal to or greater than zero.",      "type": "integer",      "minimum": 0    }  }}﻿
Datadata{  "firstName": "John",  "lastName": "Doe",  "age": 21}﻿
In the data example, we provide values for the firstName, lastName, and age properties. The values match the defined schema, where firstName is a string, lastName is a string, and age is an integer greater than or equal to zero.
Arrays of thingsArrays are fundamental structures in JSON -- here we demonstrate a couple of ways they can be described:An array of string values.An array of objects.We also introduce the following with this example:$defs keyword$ref keywordFor the fruits property:type is set to "array" to indicate it's an array.items describes the items within the array. In this case, they should be of type "string".For the vegetables property:type is also set to "array" to indicate it's an array.items references the $defs/veggie definition, indicating that the items in the array should conform to the "veggie" schema defined in the $defs section. schema{  "$id": "https://example.com/arrays.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Arrays of strings and objects",  "title": "Arrays",  "type": "object",  "properties": {    "fruits": {      "type": "array",      "items": {        "type": "string"      }    },    "vegetables": {      "type": "array",      "items": { "$ref": "#/$defs/veggie" }    }  },  "$defs": {    "veggie": {      "type": "object",      "required": [ "veggieName", "veggieLike" ],      "properties": {        "veggieName": {          "type": "string",          "description": "The name of the vegetable."        },        "veggieLike": {          "type": "boolean",          "description": "Do I like this vegetable?"        }      }    }  }}﻿
Datadata{  "fruits": [ "apple", "orange", "pear" ],  "vegetables": [    {      "veggieName": "potato",      "veggieLike": true    },    {      "veggieName": "broccoli",      "veggieLike": false    }  ]}﻿
The data example shows the usage of arrays. The fruits property contains an array of strings, while the vegetables property contains an array of objects, each adhering to the "veggie" schema definition.
Enumerated valuesThis example introduces the enum validation keyword which is used with an array of values that includes an integer (42), a boolean (true), a string ("hello"), null, and an array ([1, 2, 3]). This demonstrates how enum can be used to specify a set of allowed values of different types. schema{  "$id": "https://example.com/enumerated-values.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Enumerated Values",  "type": "object",  "properties": {    "data": {      "enum": [42, true, "hello", null, [1, 2, 3]]    }  }}﻿
Datadata{  "data": [1, 2, 3]}﻿
The provided data adheres to the schema by using the exact values specified in the enum array: [1, 2, 3].
Regular expression patternThis example introduces the pattern keyword and defines an object with a property called code that must match a specific regular expression pattern: ^[A-Z]{3}-\d{3}$. The pattern here requires three uppercase letters followed by a hyphen and three digits. schema{  "$id": "https://example.com/regex-pattern.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Regular Expression Pattern",  "type": "object",  "properties": {    "code": {      "type": "string",      "pattern": "^[A-Z]{3}-\\d{3}$"    }  }}﻿
Datadata{  "code": "ABC-123"}﻿
The provided data, "ABC-123", satisfies this pattern defined in the schema.
Complex object with nested propertiesThe schema below represents a complex object with various properties including name, age, address, and hobbies. The address property is an object with nested properties, and the hobbies property is an array of strings. The name and age properties are required. schema{  "$id": "https://example.com/complex-object.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Complex Object",  "type": "object",  "properties": {    "name": {      "type": "string"    },    "age": {      "type": "integer",      "minimum": 0    },    "address": {      "type": "object",      "properties": {        "street": {          "type": "string"        },        "city": {          "type": "string"        },        "state": {          "type": "string"        },        "postalCode": {          "type": "string",          "pattern": "\\d{5}"        }      },      "required": ["street", "city", "state", "postalCode"]    },    "hobbies": {      "type": "array",      "items": {        "type": "string"      }    }  },  "required": ["name", "age"]}﻿
Datadata{  "name": "John Doe",  "age": 25,  "address": {    "street": "123 Main St",    "city": "New York",    "state": "NY",    "postalCode": "10001"  },  "hobbies": ["reading", "running"]}﻿
The provided data conforms to the schema by including values for the required properties and ensuring the age is an integer greater than or equal to zero. The address object contains all the necessary properties, and the hobbies property is an array of strings.
Conditional validation with dependentRequiredIn this example, the dependentRequired keyword is used to specify that the property bar is required when the property foo is present. The schema enforces the condition that if foo exists, then bar must also be present. schema{  "$id": "https://example.com/conditional-validation-dependentRequired.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Conditional Validation with dependentRequired",  "type": "object",  "properties": {    "foo": {      "type": "boolean"    },    "bar": {      "type": "string"    }  },  "dependentRequired": {    "foo": ["bar"]  }}﻿
Datadata{  "foo": true,  "bar": "Hello World"}﻿
As per the schema, when the foo property is present (true), the bar property becomes required. The bar property is provided with the value "Hello World", satisfying the requirement of being a string and ensuring compliance with the dependentRequired condition.data{}﻿
Since both foo and bar are missing, the instance is still valid and in compliance with the dependentRequired condition as well.data{  "foo": true}﻿
The above schema is invalid, since the foo property is present, but bar is not, which invalidates the condition of the dependentRequired keyword.
Conditional validation with dependentSchemasThe given schema showcases the use of the dependentSchemas keyword. It allows defining a subschema that must be satisfied if a certain property is present.In this example, the schema defines an object with two properties: foo and propertiesCount. The foo property is of boolean type, while the propertiesCount property is of integer type with a minimum value of 0.According to the subschema, when the foo property is present, the propertiesCount property becomes required, and must be an integer with a minimum value of 7. schema{  "$id": "https://example.com/conditional-validation-dependentSchemas.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Conditional Validation with dependentSchemas",  "type": "object",  "properties": {    "foo": {      "type": "boolean"    },    "propertiesCount": {      "type": "integer",      "minimum": 0    }  },  "dependentSchemas": {    "foo": {      "required": ["propertiesCount"],      "properties": {        "propertiesCount": {          "minimum": 7        }      }    }  }}﻿
Datadata{  "foo": true,  "propertiesCount": 10}﻿
Here, the foo property is set to true, indicating its presence. As per the schema, when foo is present, the propertiesCount property becomes required. In this case, the propertiesCount property is provided with a value of 10, which satisfies the requirement of being an integer and having a minimum value of 7.data{  "propertiesCount": 5}﻿
In the above data, propertiesCount is 5 but since foo is missing, propertiesCount does not need to be 7 or more than 7, it only needs to be greater than or equal to 0. Hence, this instance is valid.data{  "foo": true,  "propertiesCount": 5}﻿
In this, we have foo as true, but propertiesCount is 5, and in the schema, propertiesCount is set to have minimum 7 as the input according to the dependentSchemas. Hence, this is an invalid instance.
Conditional validation with if-elseIn this schema, we have two properties: isMember and membershipNumber. The conditional validation is based on the value of the isMember property. The validation keywords if, then, and else.Here's how the validation works in this example:If the value of isMember is true:The then block is applied, which specifies that the membershipNumber property should be a string with a minimum length of 10 and a maximum length of 10.If the value of isMember is anything other than true:The else block is applied, which specifies that the membershipNumber property can be any string. schema{  "$id": "https://example.com/conditional-validation-if-else.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Conditional Validation with If-Else",  "type": "object",  "properties": {    "isMember": {      "type": "boolean"    },    "membershipNumber": {      "type": "string"    }  },  "required": ["isMember"],  "if": {    "properties": {      "isMember": {        "const": true      }    }  },  "then": {    "properties": {      "membershipNumber": {        "type": "string",        "minLength": 10,        "maxLength": 10      }    }  },  "else": {    "properties": {      "membershipNumber": {        "type": "string",        "minLength": 15      }    }  }}﻿﻿
Datadata{  "isMember": true,  "membershipNumber": "1234567890"}﻿
In this case, the isMember property is set to true, so the then block is applied. The membershipNumber property is a string with a length of 10 characters, satisfying the validation.data{  "isMember": false,  "membershipNumber": "GUEST1234567890"}﻿
In this case, the isMember property is false, so the else block is applied. The membershipNumber property can be any string with minimum length greater than or equal to 15, so it satisfies the validation.Go BackCreating your first SchemaUp NextModelling a file systemNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaModeling a file system with JSON SchemaIn this step-by-step guide you will learn how to design a JSON Schema that mirrors the structure of an /etc/fstab file.This guide is divided into the following sections:IntroductionCreating the fstab schemaStarting the entry schemaConstraining an entryThe diskDevice definitionThe diskUUID definitionThe nfs definitionThe tmpfs definitionThe full entry schemaReferencing the entry schema in the fstab schemaIntroductionNot all constraints to an fstab file can be modeled using JSON Schema alone; however, it can represent a good number of them and the exercise is useful to demonstrate how constraints work. The examples provided are illustrative of the JSON Schema concepts rather than a real, working schema for an fstab file.
This example shows a possible JSON Schema representation of file system mount points as represented in an /etc/fstab file.An entry in an fstab file can have many different forms; Here is an example:data{  "/": {    "storage": {      "type": "disk",      "device": "/dev/sda1"    },    "fstype": "btrfs",    "readonly": true  },  "/var": {    "storage": {      "type": "disk",      "label": "8f3ba6f4-5c70-46ec-83af-0d5434953e5f"    },    "fstype": "ext4",    "options": [ "nosuid" ]  },  "/tmp": {    "storage": {      "type": "tmpfs",      "sizeInMB": 64    }  },  "/var/www": {    "storage": {      "type": "nfs",      "server": "my.nfs.server",      "remotePath": "/exports/mypath"    }  }}﻿
Creating the fstab schemaWe will start with a base JSON Schema expressing the following constraints:the list of entries is a JSON object;the member names (or property names) of this object must all be valid, absolute paths;there must be an entry for the root filesystem (ie, /).Building out our JSON Schema from top to bottom:The $id keyword.The $schema keyword.The type validation keyword.The required validation keyword.The properties validation keyword.
The / key is empty now; We will fill it out later.The patternProperties validation keyword.
This matches other property names via a regular expression. Note: it does not match /.The ^(/[^/]+)+$ key is empty now; We will fill it out later.The additionalProperties validation keyword.
The value here is false to constrain object properties to be either / or to match the regular expression.You will notice that the regular expression is explicitly anchored (with ^ and $): in JSON Schema, regular expressions (in patternProperties and in pattern) are not anchored by default.
 schema{  "$id": "https://example.com/fstab",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "object",  "required": [ "/" ],  "properties": {    "/": {}  },  "patternProperties": {    "^(/[^/]+)+$": {}  },  "additionalProperties": false}﻿
Starting the entry schemaWe will start with an outline of the JSON schema which adds new concepts to what we've already demonstrated.We saw these keywords in the prior exercise: $id, $schema, type, required and properties.To this we add:The description annotation keyword.The oneOf keyword.The $ref keyword.
In this case, all references used are local to the schema using a relative fragment URI (#/...).The $defs keyword.
Including several key names which we will define later. schema{  "$id": "https://example.com/entry-schema",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "JSON Schema for an fstab entry",  "type": "object",  "required": [ "storage" ],  "properties": {    "storage": {      "type": "object",      "oneOf": [        { "$ref": "#/$defs/diskDevice" },        { "$ref": "#/$defs/diskUUID" },        { "$ref": "#/$defs/nfs" },        { "$ref": "#/$defs/tmpfs" }      ]    }  },  "$defs": {    "diskDevice": {},    "diskUUID": {},    "nfs": {},    "tmpfs": {}  }}﻿
Constraining an entryLet's now extend this skeleton to add constraints to some of the properties.Our fstype key uses the enum validation keyword.Our options key uses the following:
The type validation keyword (see above).The minItems validation keyword.The items validation keyword.The uniqueItems validation keyword.Together these say: options must be an array, and the items therein must be strings, there must be at least one item, and all items should be unique.We have a readonly key.With these added constraints, the schema now looks like this: schema{  "$id": "https://example.com/entry-schema",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "JSON Schema for an fstab entry",  "type": "object",  "required": [ "storage" ],  "properties": {    "storage": {      "type": "object",      "oneOf": [        { "$ref": "#/$defs/diskDevice" },        { "$ref": "#/$defs/diskUUID" },        { "$ref": "#/$defs/nfs" },        { "$ref": "#/$defs/tmpfs" }      ]    },    "fstype": {      "enum": [ "ext3", "ext4", "btrfs" ]    },    "options": {      "type": "array",      "minItems": 1,      "items": {        "type": "string"      },      "uniqueItems": true    },    "readonly": {      "type": "boolean"    }  },  "$defs": {    "diskDevice": {},    "diskUUID": {},    "nfs": {},    "tmpfs": {}  }}﻿
The diskDevice definitionOne new keyword is introduced here:The pattern validation keyword notes the device key must be an absolute path starting with /dev.data{  "diskDevice": {    "properties": {      "type": {        "enum": [ "disk" ]      },      "device": {        "type": "string",        "pattern": "^/dev/[^/]+(/[^/]+)*$"      }    },    "required": [ "type", "device" ],    "additionalProperties": false  }}﻿
The diskUUID definitionNo new keywords are introduced here.We do have a new key: label and the pattern validation keyword states it must be a valid UUID.data{  "diskUUID": {    "properties": {      "type": {        "enum": [ "disk" ]      },      "label": {        "type": "string",        "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"      }    },    "required": [ "type", "label" ],    "additionalProperties": false  }}﻿
The nfs definitionWe find another new keyword:The format annotation and assertion keyword.data{  "nfs": {    "properties": {      "type": { "enum": [ "nfs" ] },      "remotePath": {        "type": "string",        "pattern": "^(/[^/]+)+$"      },      "server": {        "type": "string",        "oneOf": [          { "format": "hostname" },          { "format": "ipv4" },          { "format": "ipv6" }        ]      }    },    "required": [ "type", "server", "remotePath" ],    "additionalProperties": false  }}﻿
The tmpfs definitionOur last definition introduces two new keywords:The minimum validation keyword.The maximum validation keyword.Together these require the size be between 16 and 512, inclusive.data{  "tmpfs": {    "properties": {      "type": { "enum": [ "tmpfs" ] },      "sizeInMB": {        "type": "integer",        "minimum": 16,        "maximum": 512      }    },    "required": [ "type", "sizeInMB" ],    "additionalProperties": false  }}﻿
The full entry schemaThe resulting schema is quite large: schema{  "$id": "https://example.com/entry-schema",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "JSON Schema for an fstab entry",  "type": "object",  "required": [ "storage" ],  "properties": {    "storage": {      "type": "object",      "oneOf": [        { "$ref": "#/$defs/diskDevice" },        { "$ref": "#/$defs/diskUUID" },        { "$ref": "#/$defs/nfs" },        { "$ref": "#/$defs/tmpfs" }      ]    },    "fstype": {      "enum": [ "ext3", "ext4", "btrfs" ]    },    "options": {      "type": "array",      "minItems": 1,      "items": {        "type": "string"      },      "uniqueItems": true    },    "readonly": {      "type": "boolean"    }  },  "$defs": {    "diskDevice": {      "properties": {        "type": {          "enum": [ "disk" ]        },        "device": {          "type": "string",          "pattern": "^/dev/[^/]+(/[^/]+)*$"        }      },      "required": [ "type", "device" ],      "additionalProperties": false    },    "diskUUID": {      "properties": {        "type": {          "enum": [ "disk" ]        },        "label": {          "type": "string",          "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"        }      },      "required": [ "type", "label" ],      "additionalProperties": false    },    "nfs": {      "properties": {        "type": { "enum": [ "nfs" ] },        "remotePath": {          "type": "string",          "pattern": "^(/[^/]+)+$"        },        "server": {          "type": "string",          "oneOf": [            { "format": "hostname" },            { "format": "ipv4" },            { "format": "ipv6" }          ]        }      },      "required": [ "type", "server", "remotePath" ],      "additionalProperties": false    },    "tmpfs": {      "properties": {        "type": { "enum": [ "tmpfs" ] },        "sizeInMB": {          "type": "integer",          "minimum": 16,          "maximum": 512        }      },      "required": [ "type", "sizeInMB" ],      "additionalProperties": false    }  }}﻿
Referencing the entry schema in the fstab schemaComing full circle we use the $ref keyword to add our entry schema into the keys left empty at the start of the exercise:The / key.The ^(/[^/]+)+$ key. schema{  "$id": "https://example.com/fstab",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "object",  "required": [ "/" ],  "properties": {    "/": { "$ref": "https://example.com/entry-schema" }  },  "patternProperties": {    "^(/[^/]+)+$":  { "$ref": "https://example.com/entry-schema" }  },  "additionalProperties": false}﻿Go BackMiscellaneous examplesUp NextOther examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema examplesIn this page, you will find examples illustrating different use cases to help you get the most out of your JSON Schemas. These examples cover a wide range of scenarios, and each example comes with accompanying JSON data and explanation, showcasing how JSON Schemas can be applied to various domains. You can modify these examples to suit your specific needs, as this is just one of the many ways you can utilize JSON Schemas.AddressBlog postCalendarDevice TypeEcommerce SystemGeographical locationHealth recordJob postingMovieUser profileAddressA schema representing an address, with optional properties for different address components which enforces that locality, region, and countryName are required, and if postOfficeBox or extendedAddress is provided, streetAddress must also be provided. schema{  "$id": "https://example.com/address.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "An address similar to http://microformats.org/wiki/h-card",  "type": "object",  "properties": {    "postOfficeBox": {      "type": "string"    },    "extendedAddress": {      "type": "string"    },    "streetAddress": {      "type": "string"    },    "locality": {      "type": "string"    },    "region": {      "type": "string"    },    "postalCode": {      "type": "string"    },    "countryName": {      "type": "string"    }  },  "required": [ "locality", "region", "countryName" ],  "dependentRequired": {    "postOfficeBox": [ "streetAddress" ],    "extendedAddress": [ "streetAddress" ]  }}﻿
Datadata{  "postOfficeBox": "123",  "streetAddress": "456 Main St",  "locality": "Cityville",  "region": "State",  "postalCode": "12345",  "countryName": "Country"}﻿
Blog postA schema representing a blog post, including properties like title, content, publishedDate, author, and tags. schema{  "$id": "https://example.com/blog-post.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "A representation of a blog post",  "type": "object",  "required": ["title", "content", "author"],  "properties": {    "title": {      "type": "string"    },    "content": {      "type": "string"    },    "publishedDate": {      "type": "string",      "format": "date-time"    },    "author": {      "$ref": "https://example.com/user-profile.schema.json"    },    "tags": {      "type": "array",      "items": {        "type": "string"      }    }  }}﻿
Datadata{  "title": "New Blog Post",  "content": "This is the content of the blog post...",  "publishedDate": "2023-08-25T15:00:00Z",  "author": {    "username": "authoruser",    "email": "[email protected]"  },  "tags": ["Technology", "Programming"]}﻿
CalendarA schema representing an event in a calendar, including properties like startDate, endDate, summary, location, and recurrenceDate details. The geo property is a reference ($ref) to another schema defined at a different location which represents a geographical location with latitude and longitude values. schema{  "$id": "https://example.com/calendar.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "A representation of an event",  "type": "object",  "required": [ "dtstart", "summary" ],  "properties": {    "startDate": {      "type": "string",      "description": "Event starting time"    },    "endDate": {      "type": "string",      "description": "Event ending time"    },    "summary": {      "type": "string"    },    "location": {      "type": "string"    },    "url": {      "type": "string"    },    "duration": {      "type": "string",      "description": "Event duration"    },    "recurrenceDate": {      "type": "string",      "description": "Recurrence date"    },    "recurrenceDule": {      "type": "string",      "description": "Recurrence rule"    },    "category": {      "type": "string"    },    "description": {      "type": "string"    },    "geo": {      "$ref": "https://example.com/geographical-location.schema.json"    }  }}﻿
Datadata{  "startDate": "2023-08-25T10:00:00Z",  "endDate": "2023-08-25T12:00:00Z",  "summary": "Conference Presentation",  "location": "Conference Center",  "recurrenceDule": "FREQ=DAILY;COUNT=5"}﻿
Device typeThis schema represents electronic devices with a deviceType property that determines the device's category, such as smartphone or laptop. It employs the oneOf keyword to dynamically reference schemas based on the deviceType property. This flexible schema structure allows data to conform to the appropriate device schema based on the deviceType specified, making it easy to describe different electronic devices with their unique characteristics. When deviceType is set to smartphone, the schema enforces properties specific to smartphones, and when deviceType is set to laptop, it enforces properties specific to laptops.data{  "$id": "https://example.com/device.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "object",  "properties": {    "deviceType": {      "type": "string"    }  },  "required": ["deviceType"],  "oneOf": [    {      "properties": {        "deviceType": { "const": "smartphone" }      },      "$ref": "https://example.com/smartphone.schema.json"    },    {      "properties": {        "deviceType": { "const": "laptop" }      },      "$ref": "https://example.com/laptop.schema.json"    }  ]}﻿{  "$id": "https://example.com/smartphone.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "object",  "properties": {    "brand": {      "type": "string"    },    "model": {      "type": "string"    },    "screenSize": {      "type": "number"    }  },  "required": ["brand", "model", "screenSize"]}﻿{  "$id": "https://example.com/laptop.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "object",  "properties": {    "brand": {      "type": "string"    },    "model": {      "type": "string"    },    "processor": {      "type": "string"    },    "ramSize": {      "type": "number"    }  },  "required": ["brand", "model", "processor", "ramSize"]}﻿
Datadata{  "deviceType": "smartphone",  "brand": "Samsung",  "model": "Galaxy S21",  "screenSize": 6.2}﻿
Ecommerce systemA schema representing an ecommerce system, where $anchor is used within the definitions of product and order schemas to define anchor points: ProductSchema and OrderSchema, respectively. schema{  "$id": "https://example.com/ecommerce.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$defs": {    "product": {      "$anchor": "ProductSchema",      "type": "object",      "properties": {        "name": { "type": "string" },        "price": { "type": "number", "minimum": 0 }      }    },    "order": {      "$anchor": "OrderSchema",      "type": "object",      "properties": {        "orderId": { "type": "string" },        "items": {          "type": "array",          "items": { "$ref": "#ProductSchema" }        }      }    }  }}﻿
Datadata{  "order": {    "orderId": "ORD123",    "items": [      {        "name": "Product A",        "price": 50      },      {        "name": "Product B",        "price": 30      }    ]  }}﻿
Geographical locationA schema representing geographical coordinates with latitude and longitude values within specified ranges. schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude Values",  "description": "A geographical coordinate.",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
Datadata{  "latitude": 48.858093,  "longitude": 2.294694}﻿
Health recordA schema representing a health record, including patientName, dateOfBirth, bloodType, allergies, conditions, medications, and emergencyContact. schema{  "$id": "https://example.com/health-record.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Schema for representing a health record",  "type": "object",  "required": ["patientName", "dateOfBirth", "bloodType"],  "properties": {    "patientName": {      "type": "string"    },    "dateOfBirth": {      "type": "string",      "format": "date"    },    "bloodType": {      "type": "string"    },    "allergies": {      "type": "array",      "items": {        "type": "string"      }    },    "conditions": {      "type": "array",      "items": {        "type": "string"      }    },    "medications": {      "type": "array",      "items": {        "type": "string"      }    },    "emergencyContact": {      "$ref": "https://example.com/user-profile.schema.json"    }  }}﻿
Datadata{  "patientName": "Jane Doe",  "dateOfBirth": "1985-02-15",  "bloodType": "A+",  "allergies": ["Pollen", "Penicillin"],  "conditions": ["Hypertension", "Diabetes"],  "medications": ["Lisinopril", "Metformin"],  "emergencyContact": {    "username": "emergencyuser",    "email": "[email protected]"  }}﻿
Job postingA schema representing a job posting, including properties like title, company, location, description, employmentType, salary, and applicationDeadline. It also uses the $anchor keyword for defining an anchor. schema{  "$id": "https://example.com/job-posting.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "A representation of a job posting",  "type": "object",  "required": ["title", "company", "location", "description"],  "properties": {    "title": {      "type": "string"    },    "company": {      "type": "string"    },    "location": {      "type": "string"    },    "description": {      "type": "string"    },    "employmentType": {      "type": "string"    },    "salary": {      "type": "number",      "minimum": 0    },    "applicationDeadline": {      "type": "string",      "format": "date"    }  }}﻿
Datadata{  "title": "Software Engineer",  "company": "Tech Solutions Inc.",  "location": "Cityville",  "description": "Join our team as a software engineer...",  "employmentType": "Full-time",  "salary": 80000,  "applicationDeadline": "2023-09-15"}﻿
MovieA schema representing a movie, including properties such as title, director, release date, genre, duration, and cast members. schema{  "$id": "https://example.com/movie.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "A representation of a movie",  "type": "object",  "required": ["title", "director", "releaseDate"],  "properties": {    "title": {      "type": "string"    },    "director": {      "type": "string"    },    "releaseDate": {      "type": "string",      "format": "date"    },    "genre": {      "type": "string",      "enum": ["Action", "Comedy", "Drama", "Science Fiction"]    },    "duration": {      "type": "string"    },    "cast": {      "type": "array",      "items": {        "type": "string"      },      "additionalItems": false    }  }}﻿
Datadata{  "title": "Sample Movie",  "director": "John Director",  "releaseDate": "2023-07-01",  "genre": "Action",  "duration": "2h 15m",  "cast": ["Actor A", "Actress B", "Actor C"]}﻿
User profileA schema representing a user profile, including properties like username, email, fullName, age, location, and interests. schema{  "$id": "https://example.com/user-profile.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "A representation of a user profile",  "type": "object",  "required": ["username", "email"],  "properties": {    "username": {      "type": "string"    },    "email": {      "type": "string",      "format": "email"    },    "fullName": {      "type": "string"    },    "age": {      "type": "integer",      "minimum": 0    },    "location": {      "type": "string"    },    "interests": {      "type": "array",      "items": {        "type": "string"      }    }  }}﻿
Datadata{  "username": "user123",  "email": "[email protected]",  "fullName": "John Doe",  "age": 30,  "location": "Cityville",  "interests": ["Travel", "Technology"]}﻿Go BackModeling a file systemUp NextJSON Schema GlossaryNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGuidesIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaGuidesWelcome to our new Guides section!For ImplementersDive into the technical details of implementing JSON SchemaRead MoreGo BackOther examplesUp NextFor ImplementersNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGuidesIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaImplement JSON SchemaDive into the technical details of implementing JSON Schema. 
This section is for developers building tools and libraries that work with JSON Schema.Understand common interfacesBuild interoperable JSON Schema tools using shared interfaces.Read MoreValidate with BowtieValidate your JSON Schema tools with the Bowtie meta-validator.Read MoreGo BackGuidesUp NextUnderstanding common interfacesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGuidesIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCommon interfaces across JSON Schema implementationsJSON Schema is extremely widely used and nearly equally widely implemented.
There are implementations of JSON Schema validation for over 20 languages or environments.
This prevalence is fantastic for user choice -- as someone wishing to use JSON Schema you can be almost certain you'll find an implementation suitable for your target environment.But when it comes to community support, it can be challenging to know how to perform various JSON Schema operations in a particular library or implementation, as each may have slightly differing (or more than slightly differing) APIs.
This can become particularly challenging when considering behavior not necessarily prescribed or required by the specification itself, but which is nonetheless common, useful, or even required behavior in practice in order to use JSON Schema.
This page serves to document a number of these common operations, documenting the interfaces offered by many implementations across the existing JSON Schema ecosystem.For each, we first name and describe the operation using terminology from the specification where available, or otherwise using terminology that is aimed to be succinct but precise.
The intention of this page is partially to be a reference of important JSON Schema operations as well as a way of tailoring help for a particular language and implementation.
We therefore include examples of each interface or piece of functionality across implementations, when known.
The ordering of sections on this page is not necessarily indicative of their importance relative to each other.
Omission of functionality (i.e. if you do not find the way to do something below with a given implementation) is not necessarily a sign that the implementation does not support the functionality, though it might mean it could not be easily found by the page authors.
Contributions and corrections from implementers are particularly welcome, as are documentation links!For purposes of making some sections of this page more precise, we assume the existence of a set of abstract types all of which may be referenced below, and which will have specific concrete types within a given programming language or implementation.
In addition to placeholder types like String, Number, Boolean, Mapping, Callable and the like, the JSON Schema-related types include:SchemaThe type of JSON Schemas, which may also differ across dialects of JSON Schema.
For common or modern versions of JSON Schema this type must essentially be able to represent both arbitrary JSON objects as well as booleans.InstanceThe type of JSON instances.
This type should essentially be Any or a type capable of representing all JSON values, given JSON Schema's applicability to any representable JSON.DialectThe type of JSON dialects or dialect identifiers.
This type may simply be String if the dialect is represented within the implementation by its URI or by some short name.EvaluationOptionsThe type of "fully ready" schemas and instances along with any additional implementation-specific customizable behavior.
At minimum, this type is either Schema → Instance or Schema × Instance (depending on whether the implementation takes both schema and instance together or compiles schemas and then produces a separate function taking the instance to validate).
It is highly likely to be richer in at least some of the following ways:Given likely support for some form of schema registry in order to support referencing external schemas, this type will likely include a registry of some sort, i.e. Mapping<URI, Schema> → Schema → ...If an implementation supports customizing which JSON types match to which language types (such as discussed below) then this type likely includes some representation of this mapping, i.e. Mapping<String, Callable[...]> → Schema → ... encapsulating what each type is mapped to during this evaluation.Similarly, if there is a specific API for format assertion enablement, some representation of the format keyword's behavior is present in the contextIf the implementation supports the creation or customization of dialects, and especially if schemas can contain subschemas across different dialects, then the context will contain some representation of dialects, e.g. Dialect → Schema → ...ResultThe type of JSON Schema validation results, i.e. an object which encapsulates the validity of a given Instance under a Schema.
This type may simply be Boolean in some implementations or languages.ResultWithAnnotationsThe type of JSON Schema validation results that include JSON Schema annotations collected during validation.
URIThe type of RFC 3986 compliant URIs.
This type should not generally be the same as String, as URIs have multiple possible string representations and require normalization to
have correct semantics.Because this page deals with concerns which cross language barriers, and different programming languages have different capabilities particularly around how they represent out of band errors (via exceptions, option types, wrapper return types, sentinel values or some other mechanism), this page also introduces1 specific notation for representing the types of functions which include explicit representation for their out-of-band errors.
Interpreting these types will depend on the programming language.
It's easier to explain the above with an example:
Consider a division function on floats, represented as x / y.We will write the type of this function as Float → Float → Float <!> DivideByZeroError, where the interpretation of this signature is that the function takes 2 floats and returns a float, but the <!> signals it may also propagate a DivideByZeroError (in this case when the function is asked to divide by zero).The specific manifestation of DivideByZeroError will depend on the programming language.
In a language with exceptions, this function may raise a DivideByZeroError-equivalent as an exception, which must or may be handled by the caller.
In a language with option types, the "correct" type signature may really be wrapped in an Option type which represents the division by zero case (so the "true" signature in such a language would be Option[Float → Float → Float]).
In a language with wrapper return types, the true type signature may be Result<Float, DivideByZeroError> where the returned value must be inspected to ensure it contains a successful result, and where the divide by zero error is instead a possible error value.
In a language with a convention to return "junk" values, the true type may be precisely Float → Float → Float where some arbitrary float value is
returned when dividing by zero, with no further indication.In all cases above, when an exception (corresp. error or junk value) is raised (corresp. returned), we by convention assume that any normal return value is either completely not present by the mechanisms of the programming language, or else is considered meaningless.In addition, this page will not, in general, consider or mention the possibility that an error might be raised for reasons other than those discussed in a particular section.
For example, the division example mentioned above may raise other kinds of errors if provided with strings, in a dynamically typed language where such possibilities exist at runtime, such that the "real" division function may look more like Float → Float → Float <!> DivideByZeroError | TypeError or even further error possibilities.
In the case of JSON Schema, this may mean every interface mentioned below has a type containing <!> InvalidSchema | NotValidJSON | ... representing cases where they are provided with schemas that are not valid according to the specification, or which do not fit the JSON data model, etc., but we consider these to be implicit and will not mention them explicitly unless directly relevant to the interface being discussed.Instance ValidationInstance validation is one of the key capabilities of JSON Schema.
It is the process in which a given piece of data is deemed valid or invalid under a specific schema.
Implementations may offer one or more of the specific interfaces below in order to perform this validation.Exception-Driven ValidationType: EvaluationOptions → None <!> ValidationError or EvaluationOptions → Result <!> ValidationErrorA validation API which causes a language-specific failure or exception when validation itself fails.
If it succeeds, this API may return a result with further detail, or may simply continue execution silently.Boolean ValidationType: EvaluationOptions → BooleanAn API which produces a simple boolean result indicating an instance's validity under a schema.Two-Argument ValidationType: Schema × Instance → ResultAn API which takes a schema and instance simultaneously and produces a result indicating whether the instance is valid under the given schema.In some sense, two argument validation is the simplest possible API for JSON Schema validation; it asks simply whether a given instance is valid under a given schema with no presumptions of repeated use (of the schema) or additional calculation.Repeated Validation / Schema CompilationType: Schema → Instance → ResultAn API which attempts to prepare a schema for repeated use.
It may (and likely will) perform some form of preoptimization, performing some set of work ahead of time such that it will not be necessary to repeat when validating many instances.Subschema ValidationType: Schema × String × Instance → ResultAn API which supports validating an instance against a subschema contained within the given schema.The subschema is typically identified via a JSON Pointer, or equivalent syntax, and is as opposed to validation using a new schema referencing the subschema via the $ref keyword.Annotation CollectionType: EvaluationOptions → ResultWithAnnotationsAn API which collects annotations produced when processing a given schema and instance.Schema ValidationType: Schema → ResultAn API which validates a schema itself under the dialect it is written for.
This API likely makes use of a corresponding metaschema (or metaschemas) for the dialect, but generally must do additional work to ensure the schema is not invalid even under conditions not checked for within the metaschema.Explicit Version SelectionType: Dialect → EvaluationOptions → ResultAn API which controls which dialect the implementation will assume when given a schema which does not otherwise indicate its dialect (i.e. which does not declare a $schema property).Version DetectionType: Schema → DialectAn API which identifies which dialect a given schema is written for, returning either the dialect itself or otherwise a dialect-specific validation function.Type CustomizationAn API which allows (re-)configuring which language-level types correspond to which JSON Schema types, and additionally potentially allowing for the definition of new types.String ValidationType: String → String → ResultAn API which directly validates instances using schemas where both are represented as strings -- serialized JSON -- as opposed to deserialized JSON.Language Object ValidationType: EvaluationOptions → ResultAn API which validates instances using schemas where both have been deserialized into language-level objects, or potentially built up programmatically directly as language-level objects.format ValidationFormat Assertion EnablementAn API which configures the behavior of the format keyword, in dialects where this behavior is not solely controlled by JSON Schema vocabulary enablement.Format RegistrationType: String × (Instance → Boolean)→EvaluationOptions`An API which allows registering a new format and its implementation for use with the format keyword, typically when it is used to assert.Some implementations may further allow registering different sets of available formats for different dialects.Format QueryingAn API which queries or lists the set of available formats which have been registered.Direct Format ValidationType: String × Instance → BooleanAn API which allows directly checking whether a JSON-like value satisfies a specific format, without the presence of a schema.Schema Registry PopulationAn API which configures the bundle of schemas available for referencing during the validation process.Externally Identified SchemasAn API which allows associating one or more URIs with a schema where the URIs are not internally indicated by an $id keyword (or a dialect-specific equivalent).Internally Identified SchemasAn API which allows associating URIs with a schema where the URI is internally indicated by the presence of an $id keyword (or a dialect-specific equivalent) in the schema.Schema DiscoveryAn API which (recursively) crawls a root schema or schemas, discovering any subresources (subschemas) which are present and identifiable, and making those subresources' URIs available for further referencing.Dynamic URI ResolutionAn API which allows for arbitrary dynamic lookup behavior for any reference not prepopulated in the registry.Output Format Selection / GenerationAn API which configures which of JSON Schema's output format(s) are used when producing results, or which allows generating a particular output format given a Result.Vocabulary RegistrationAn API which facilitates the creation of new JSON Schema vocabularies, typically for use when later building new dialects.Dialect CreationAn API which facilitates the creation of new JSON Schema dialects, typically registering them in some way such that they can be further used inside the implementation.Failure DetailsAn API which allows for programmatic introspection of the causes of a particular validation failure, at minimum containing the failing keyword(s), value(s) and individual message(s) which led to the failure.Go BackFor ImplementersUp NextReferenceNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema referenceMaster the full power of JSON Schema with our reference documentation.From basic data types to advanced techniques like conditional validation and schema composition, you will learn everything about JSON Schema keywords through clear explanations and examples. By learning best practices for building clear, scalable, and easy-to-maintain schemas, you will ensure that your JSON data is both robust and flexible.KeywordsBrowse our comprehensive index of JSON Schema keywords, each linking to detailed documentation.Read MoreType-specific KeywordsBecome profficient at using the type keyword to validate your data.Read MoreDialect and vocabulary declarationLearn how to declare the JSON Schema dialect and vocabulary your schema uses, ensuring compatibility and proper validation.Read MoreEnumerated and Constant ValuesEnsure data consistency and accuracy, by defining value sets and fixed values for your JSON properties.Read MoreAnnotations and commentsEnhance your JSON Schemas with annotations and comments. Learn how to add descriptions, defaults, examples, and more to improve readability and maintainability.Read MoreConditional schema validationControl validation based on property presence and values using conditional subschemas.Read MoreSchema compositionLearn how to combine JSON Schemas using modular and boolean techniques to create flexible and maintainable data models.Read MoreString-encoding non-JSON dataDescribe and handle non-JSON data within JSON strings using media type and encoding information.Read MoreLearn JSON SchemaImprove your JSON Schema skills with this reference, crafted by our TSC members, offering practical examples, best practices, and common pitfalls.Read MoreGo BackUnderstanding common interfacesUp NextJSON Schema keywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema keywordsKeywords are the building blocks of JSON Schema and they are used to define the structure of a JSON document.Below is a list of JSON Schema keywords with links to their respective documentation.$anchorStructuring a complex schema ($anchor)Ecommerce system exampleDraft 2020-12$commentGeneric Keywords ($comment)Draft 2020-12$defsMiscellaneous examplesStructuring a complex schema ($defs)Draft 2020-12$dynamicAnchorDraft 2020-12$dynamicRefDraft 2020-12$idCreate a schema definitionDeclaring a unique identifierDraft 2020-12$refDeclaring a JSON SchemaCreate a schema definitionUnevaluated ItemsStructuring a complex schema ($ref)Draft 2020-12$schemaDeclaring a dialect ($schema)Draft 2020-12$vocabularyDraft 2020-12additionalPropertiesModeling a file system with JSON SchemaAdditional PropertiesDraft 2020-12allOfUnevaluated ItemsSchema CompositionDraft 2020-12anyOfUnevaluated ItemsSchema CompositionDraft 2020-12constMiscellaneous ExamplesDraft 2020-12containsContainsDraft 2020-12contentEncodingcontentEncodingDraft 2020-12contentMediaTypecontentMediaTypeDraft 2020-12contentSchemacontentschemaDraft 2020-12defaultAnnotationsDraft 2020-12dependentRequiredMiscellaneous ExamplesApplying Subschemas ConditionallyDraft 2020-12dependentSchemasDependent SchemasDraft 2020-12deprecatedAnnotationsDraft 2020-12descriptionAnnotationsCreate a schema definitionDraft 2020-12elseMiscellaneous ExamplesIf-Then-ElseDraft 2020-12enumMiscellaneous ExamplesEnumerated ValuesDraft 2020-12examplesAnnotationsDraft 2020-12exclusiveMaximumRangeDraft 2020-12exclusiveMinimumRangeDraft 2020-12formatDraft 2020-12Format AnnotationformatDraft 2020-12Format AssertionifMiscellaneous ExamplesIf-Then-ElseDraft 2020-12itemsModeling a file system with JSON SchemaItemsDraft 2020-12maxContainsMincontains / MaxcontainsDraft 2020-12maximumModeling a file system with JSON SchemaRangeDraft 2020-12maxItemsLengthDraft 2020-12maxLengthLengthDraft 2020-12maxPropertiesSizemaxPropertiesDraft 2020-12minContainsMincontains / MaxcontainsDraft 2020-12minimumModeling a file system with JSON SchemaRangeDraft 2020-12minItemsModeling a file system with JSON SchemaLengthDraft 2020-12minLengthLengthDraft 2020-12minPropertiesSizeminPropertiesDraft 2020-12multipleOfMultiplesDraft 2020-12notSchema CompositionDraft 2020-12oneOfModeling a file system with JSON SchemaUnevaluated ItemsSchema CompositionDraft 2020-12patternMiscellaneous ExamplesRegular ExpressionsDraft 2020-12patternPropertiesModeling a file system with JSON SchemaPattern PropertiesDraft 2020-12prefixItemsTuple ValidationDraft 2020-12propertiesPropertiesSchema DefinitionDraft 2020-12propertyNamesProperty namesDraft 2020-12readOnlyAnnotationsDraft 2020-12requiredModeling a file system with JSON SchemaExtending Closed SchemasDraft 2020-12thenMiscellaneous ExamplesIf-Then-ElseDraft 2020-12titleAnnotationsCreate a schema definitionDraft 2020-12typeType-specific keywordsThe type keywordCreate a Schema DefinitionDraft 2020-12unevaluatedItemsUnevaluated ItemsDraft 2020-12unevaluatedPropertiesUnevaluated PropertiesDraft 2020-12uniqueItemsModeling a file system with JSON SchemaUniquenessDraft 2020-12writeOnlyAnnotationsDraft 2020-12Go BackJSON Schema referenceUp NextType-specific KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaType-specific KeywordsThe type keyword is fundamental to JSON Schema because it specifies the data type that a schema should expect.At its core, JSON Schema defines the following basic types:arraybooleannullnumeric typesobjectregular expressionsstringThese types have analogs in most programming languages, though they may
go by different names.Language-specific info:PythonRubyPerlObjective-CSwiftThe following table maps from the names of JSON types to their
analogous types in Python: JSON     Python        string   string [1]    number   int/float [2] object   dict          array    list          boolean  bool          null     None         Footnotes[1] Since JSON strings always support unicode, they are
analogous to unicode on Python 2.x and str on
Python 3.x.[2] JSON does not have separate types for integer and
floating-point.The type keyword can take two forms:A single string. When it is a single string, it must be one of the types mentioned above (array, boolean, integer, number, null, object, regular expressions, or string). This specifies that the instance data is only valid when it matches that specific type.Here is an example of using the string keyword as a single string: schema{ "type": "number" }﻿
data42﻿compliant to schemadata42.0﻿compliant to schema
data"42"﻿not compliant to schema
An array of strings. When type is used as an array, it contains more than one string specifying the types mentioned above. In this case, the instance data is valid if it matches any of the given types.Here is an example using the type keyword as an array of strings, where instance data of the type string and number are valid but array isn't: schema{ "type": ["number", "string"] }﻿data42﻿compliant to schemadata"Life, the universe, and everything"﻿compliant to schemadata["Life", "the universe", "and everything"]﻿not compliant to schema
JSON Schema offers a variety of keywords to validate data against specific types. The following table outlines keywords that are specifically designed for each basic data type: Type Keyword  Specific Keywords  Description  array         items, additionalItems, minItems, maxItems, uniqueItems  Define item schemas, additional item handling, item count constraints, and uniqueness.  number        minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf  Define numeric ranges, including exclusive bounds and divisibility.  object       required, properties, additionalProperties, patternProperties, minProperties, maxProperties, dependencies  Define required properties, property schemas, additional property handling, pattern-based property matching, and property count constraints.  string        minLength, maxLength, pattern, format Restrict string length, pattern matching, and format validation (e.g., email, date). 
Understanding these basic data types gives you a strong foundation for building more complex JSON Schemas.
Dive deeper into our reference and explore JSON Schema's flexibility for creating complex data structures:Value restrictions. Define precise limitations for data, ensuring accuracy and consistency.Conditional schema validation. Validate schemas dynamically based on specific conditions.Schema composition. Build modular and reusable schemas, making your validation process more efficient and maintainable.By utilizing these advanced features, you can create robust and flexible JSON Schemas that meet your exact needs.FormatThe format keyword conveys semantic information for values that may be difficult or impossible to describe using JSON Schema. Typically, this semantic information is described by other documents. The JSON Schema Validation specification defines several formats, but this keyword also allows schema authors to define their own formats.For example, because JSON doesn't have a "DateTime" type, dates need to be encoded as strings. format allows the schema author to indicate that the string value should be interpreted as a date. By default, format is just an annotation and does not affect validation.Optionally, validator implementations can provide a configuration option to enable format to function as an assertion rather than just an annotation. That means that validation fails when, for example, a value with a date format isn't in a form that can be parsed as a date. This allows values to be constrained beyond what other tools in JSON Schema, including Regular Expressions, can do.Implementations may provide validation for only a subset of the built-in formats or do partial validation for a given format. For example, some implementations may consider a string an email if it contains an @, while others might perform additional checks for other aspects of a well-formed email address.
The JSON Schema specification has a bias toward networking-related formats due to its roots in web technologies. However, custom formats may also be used if the parties exchanging the JSON documents share information about the custom format types. A JSON Schema validator will ignore any format type it does not understand.Built-in FormatsIt should be noted that format is not limited to a specific set of valid values or types. Users may define their own custom keywords including ones that work with JSON data types other than string, such as number. Below, we cover the formats specified in the JSON Schema specification.Dates and TimesDates and times are represented in RFC 3339, section 5.6. RFC 3339 is a specification from the Internet Engineering Task Force (IETF)."date-time": Date and time together, for example, 2018-11-13T20:20:39+00:00."time": New in draft 7 Time, for example, 20:20:39+00:00."date": New in draft 7 Date, for example, 2018-11-13."duration": New in draft 2019-09 A duration as defined by the ISO 8601 ABNF for "duration". For example, P3D expresses a duration of 3 days.Email Addresses"email": Internet email address, see RFC 5321, section 4.1.2."idn-email": New in draft 7 The internationalized form of an Internet email address, see RFC 6531.Hostnames"hostname": Internet host name, see RFC 1123, section 2.1."idn-hostname": New in draft 7 An internationalized Internet host name, see RFC5890, section 2.3.2.3.IP Addresses"ipv4": IPv4 address, according to dotted-quad ABNF syntax as defined in RFC 2673, section 3.2."ipv6": IPv6 address, as defined in RFC 2373, section 2.2.Resource Identifiers"uuid": New in draft 2019-09 A Universally Unique Identifier as defined by RFC 4122. Example: 3e4666bf-d5e5-4aa7-b8ce-cefe41c7568a."uri": A universal resource identifier (URI), according to RFC3986."uri-reference": New in draft 6 A URI Reference (either a URI or a relative-reference), according to RFC3986, section 4.1."iri": New in draft 7 The internationalized equivalent of a "uri", according to RFC3987."iri-reference": New in draft 7 The internationalized equivalent of a "uri-reference", according to RFC3987.URI Template"uri-template": New in draft 6 A URI Template (of any level) according to RFC6570. If you don't already know what a URI Template is, you probably don't need this value.JSON Pointer"json-pointer": New in draft 6 A JSON Pointer, according to RFC6901. There is more discussion on using JSON Pointer within JSON Schema in Structuring a complex schema. Note that this should be used only when the entire string contains only JSON Pointer content, e.g., /foo/bar. JSON Pointer URI fragments, e.g., #/foo/bar/ should use "uri-reference"."relative-json-pointer": New in draft 7 A relative JSON pointer.Regular Expressions"regex": New in draft 7 A regular expression that should be valid according to the ECMA 262 dialect. Be careful, in practice, JSON Schema validators are only required to accept the safe subset of regular expressions described elsewhere in this document.Go BackJSON Schema KeywordsUp NextArrayNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaarrayArrays are used for ordered elements. In JSON, each element in an array
may be of a different type.Language-specific info:PythonRubyObjective-CSwiftIn Python, "array" is analogous to the list or tuple type,
depending on usage.  However, the json module in the Python
standard library will always use Python lists to represent JSON
arrays. schema{ "type": "array" }﻿data[1, 2, 3, 4, 5]﻿compliant to schemadata[3, "different", { "types": "of values" }]﻿compliant to schemadata{"Not": "an array"}﻿not compliant to schema
There are two ways in which arrays are generally used in JSON:List validation: a sequence of arbitrary length where each item
  matches the same schema.Tuple validation: a sequence of fixed length where each item may
  have a different schema. In this usage, the index (or location) of
  each item is meaningful as to how the value is interpreted. (This
  usage is often given a whole separate type in some programming
  languages, such as Python's tuple).ItemsList validation is useful for arrays of arbitrary length where each item
matches the same schema. For this kind of array, set the items keyword
to a single schema that will be used to validate all of the items in the
array.In the following example, we define that each item in an array is a
number: schema{  "type": "array",  "items": {    "type": "number"  }}﻿data[1, 2, 3, 4, 5]﻿compliant to schemaA single "non-number" causes the whole array to be invalid:data[1, 2, "3", 4, 5]﻿not compliant to schemaThe empty array is always valid:data[]﻿compliant to schema
Tuple validationTuple validation is useful when the array is a collection of items where
each has a different schema and the ordinal index of each item is
meaningful.For example, you may represent a street address such as 1600 Pennsylvania Avenue NW as a 4-tuple of the form:data[number, street_name, street_type, direction]﻿
[number, street_name, street_type, direction]
Each of these fields will have a different schema:number: The address number. Must be a number.street_name: The name of the street. Must be a string.street_type: The type of street. Should be a string from a fixed
set of values.direction: The city quadrant of the address. Should be a string
from a different set of values.To do this, we use the prefixItems keyword. prefixItems is an array,
where each item is a schema that corresponds to each index of the
document's array. That is, an array where the first element validates
the first element of the input array, the second element validates the
second element of the input array, etc.Draft-specific infoIn Draft 4 - 2019-09, tuple validation was handled by an alternate
   form of the items keyword. When items was an array of
   schemas instead of a single schema, it behaved the way
   prefixItems behaves.
Here's the example schema: schema{  "type": "array",  "prefixItems": [    { "type": "number" },    { "type": "string" },    { "enum": ["Street", "Avenue", "Boulevard"] },    { "enum": ["NW", "NE", "SW", "SE"] }  ]}﻿data[1600, "Pennsylvania", "Avenue", "NW"]﻿compliant to schema"Drive" is not one of the acceptable street types:data[24, "Sussex", "Drive"]﻿not compliant to schemaThis address is missing a street number:data["Palais de l'Élysée"]﻿not compliant to schemaIt's okay to not provide all of the items:data[10, "Downing", "Street"]﻿compliant to schemaAnd, by default, it's also okay to add additional items to end:data[1600, "Pennsylvania", "Avenue", "NW", "Washington"]﻿compliant to schema
Additional ItemsThe items keyword can be used to control whether it's valid to have
additional items in a tuple beyond what is defined in prefixItems. The
value of the items keyword is a schema that all additional items must
pass in order for the keyword to validate.Draft 4 - 2019-09Before to Draft 2020-12, you would use the additionalItems
keyword to constrain additional items on a tuple. It works the same
as items, only the name has changed.
Draft 6 - 2019-09In Draft 6 - 2019-09, the additionalItems keyword is ignored if
there is not a "tuple validation" items keyword present in the
same schema.
Here, we'll reuse the example schema above, but set items to false,
which has the effect of disallowing extra items in the tuple. schema{  "type": "array",  "prefixItems": [    { "type": "number" },    { "type": "string" },    { "enum": ["Street", "Avenue", "Boulevard"] },    { "enum": ["NW", "NE", "SW", "SE"] }  ],  "items": false}﻿data[1600, "Pennsylvania", "Avenue", "NW"]﻿compliant to schemaIt's ok to not provide all of the items:data[1600, "Pennsylvania", "Avenue"]﻿compliant to schemaBut, since items is false, we can't provide extra items:data[1600, "Pennsylvania", "Avenue", "NW", "Washington"]﻿not compliant to schema
You can express more complex constraints by using a non-boolean schema
to constrain what value additional items can have. In that case, we
could say that additional items are allowed, as long as they are all
strings: schema{  "type": "array",  "prefixItems": [    { "type": "number" },    { "type": "string" },    { "enum": ["Street", "Avenue", "Boulevard"] },    { "enum": ["NW", "NE", "SW", "SE"] }  ],  "items": { "type": "string" }}﻿Extra string items are ok ...data[1600, "Pennsylvania", "Avenue", "NW", "Washington"]﻿compliant to schema... but not anything elsedata[1600, "Pennsylvania", "Avenue", "NW", 20500]﻿not compliant to schema
Unevaluated ItemsNew in draft 2019-09The unevaluatedItems keyword is useful mainly when you want to add
or disallow extra items to an array.unevaluatedItems applies to any values not evaluated by an items, 
prefixItems, or contains keyword. Just as unevaluatedProperties
affects only properties in an object, unevaluatedItems affects
only items in an array.Watch out! The word "unevaluated" does not mean "not evaluated by
items, prefixItems, or contains." "Unevaluated" means
"not successfully evaluated", or "does not evaluate to true".
Like with items, if you set unevaluatedItems to false, you
can disallow extra items in the array. schema{  "prefixItems": [    { "type": "string" }, { "type": "number" }  ],  "unevaluatedItems": false}﻿
Here, all the values are evaluated. The schema passes validation.data["foo", 42]﻿compliant to schema
But here, the schema fails validation because "unevaluatedItems": false
specifies that no extra values should exist.data["foo", 42, null]﻿not compliant to schema
Note that items doesn't "see inside" any instances of allOf,
anyOf, or oneOf in the same subschema. So in this next example,
items ignores allOf and thus fails to validate. schema{  "allOf": [{ "prefixItems": [{ "type": "boolean" }, { "type": "string" }] }],  "items": { "const": 2 }}﻿
data[true, "a", 2]﻿not compliant to schema
But if you replace items with unevaluatedItems, then the same
array validates. schema{  "allOf": [{ "prefixItems": [{ "type": "boolean" }, { "type": "string" }] }],  "unevaluatedItems": { "const": 2 }}﻿
data[true, "a", 2]﻿compliant to schema
You can also make a "half-closed" schema: something useful when you
want to keep the first two arguments, but also add more in certain
situations. ("Closed" to two arguments in some places, "open" to
more arguments when you need it to be.) schema{  "$id": "https://example.com/my-tuple",  "type": "array",  "prefixItems": [    { "type": "boolean" },    { "type": "string" }  ],﻿  "$defs": {    "closed": {      "$anchor": "closed",      "$ref": "#",      "unevaluatedItems": false    }  }}﻿
Here the schema is "closed" to two array items. You can then later
use $ref and add another item like this: schema{  "$id": "https://example.com/my-extended-tuple",  "$ref": "https://example.com/my-tuple",  "prefixItems": [    { "type": "boolean" },    { "type": "string" },    { "type": "number" }  ],﻿  "$defs": {    "closed": {      "$anchor": "closed",      "$ref": "#",      "unevaluatedItems": false    }  }}﻿
Thus, you would reference my-tuple#closed when you need only two
items and reference my-tuple#extended when you need three items.ContainsNew in draft 6While the items schema must be valid for every item in the array, the
contains schema only needs to validate against one or more items in
the array. schema{  "type": "array",  "contains": {    "type": "number"  }}﻿A single "number" is enough to make this pass:data["life", "universe", "everything", 42]﻿compliant to schemaBut if we have no number, it fails:data["life", "universe", "everything", "forty-two"]﻿not compliant to schemaAll numbers is, of course, also okay:data[1, 2, 3, 4, 5]﻿compliant to schema
minContains / maxContainsNew in draft 2019-09minContains and maxContains can be used with contains to further
specify how many times a schema matches a contains constraint. These
keywords can be any non-negative number including zero. schema{  "type": "array",  "contains": {    "type": "number"  },  "minContains": 2,  "maxContains": 3}﻿Fails minContainsdata["apple", "orange", 2]﻿not compliant to schemadata["apple", "orange", 2, 4]﻿compliant to schemadata["apple", "orange", 2, 4, 8]﻿compliant to schemaFails maxContainsdata["apple", "orange", 2, 4, 8, 16]﻿not compliant to schema
LengthThe length of the array can be specified using the minItems and
maxItems keywords. The value of each keyword must be a non-negative
number. These keywords work whether doing list validation or tuple-validation. schema{  "type": "array",  "minItems": 2,  "maxItems": 3}﻿data[]﻿not compliant to schemadata[1]﻿not compliant to schemadata[1, 2]﻿compliant to schemadata[1, 2, 3]﻿compliant to schemadata[1, 2, 3, 4]﻿not compliant to schema
UniquenessA schema can ensure that each of the items in an array is unique. Simply
set the uniqueItems keyword to true. schema{  "type": "array",  "uniqueItems": true}﻿data[1, 2, 3, 4, 5]﻿compliant to schemadata[1, 2, 3, 3, 4]﻿not compliant to schemaThe empty array always passes:data[]﻿compliant to schemaGo BackType-specific keywordsUp NextBooleanNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemabooleanThe boolean type matches only two special values: true and false.
Note that values that evaluate to true or false, such as 1 and 0,
are not accepted by the schema.Language-specific info:PythonRubyObjective-CSwiftIn Python, "boolean" is analogous to bool.  Note that in JSON,
true and false are lower case, whereas in Python they are
capitalized (True and False). schema{ "type": "boolean" }﻿datatrue﻿compliant to schemadatafalse﻿compliant to schemadata"true"﻿not compliant to schemaValues that evaluate to true or false are still not accepted by the schema:data0﻿not compliant to schemaGo BackArrayUp NextNullNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemanullWhen a schema specifies a type of null, it has only one acceptable value: null.It's important to remember that in JSON, null isn't equivalent to something being absent. See Required Properties for an example.Language-specific info:PythonRubyObjective-CSwiftIn Python, null is analogous to None. schema{ "type": "null" }﻿datanull﻿compliant to schemadatafalse﻿not compliant to schemadata0﻿not compliant to schemadata""﻿not compliant to schemadata⠀﻿not compliant to schemaGo BackbooleanUp NextNumeric TypesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaNumeric typesThere are two numeric types in JSON Schema: integer and number.
They share the same validation keywords.JSON has no standard way to represent complex numbers, so there is no
way to test for them in JSON Schema.
integerThe integer type is used for integral numbers. JSON does not have
distinct types for integers and floating-point values. Therefore, the
presence or absence of a decimal point is not enough to distinguish
between integers and non-integers. For example, 1 and 1.0 are two
ways to represent the same value in JSON. JSON Schema considers that
value an integer no matter which representation was used.Language-specific info:PythonRubyObjective-CSwiftIn Python, "integer" is analogous to the int type. schema{ "type": "integer" }﻿data42﻿compliant to schemadata-1﻿compliant to schemaNumbers with a zero fractional part are considered integers:data1.0﻿compliant to schemaFloating point numbers are rejected:data3.1415926﻿not compliant to schemaNumbers as strings are rejected:data"42"﻿not compliant to schema
numberThe number type is used for any numeric type, either integers or
floating point numbers.Language-specific info:PythonRubyObjective-CSwiftIn Python, "number" is analogous to the float type. schema{ "type": "number" }﻿data42﻿compliant to schemadata-1﻿compliant to schemaSimple floating point number:data5.0﻿compliant to schemaExponential notation also works:data2.99792458e8﻿compliant to schemaNumbers as strings are rejected:data"42"﻿not compliant to schema
MultiplesNumbers can be restricted to a multiple of a given number, using the
multipleOf keyword. It may be set to any positive number. schema{  "type": "number",  "multipleOf" : 10}﻿data0﻿compliant to schemadata10﻿compliant to schemadata20﻿compliant to schemadata23﻿not compliant to schema
The multiple can be a floating point number: schema{  "type": "number",  "multipleOf" : 0.01}﻿data4.02﻿compliant to schemadata4.021﻿not compliant to schema
NoteThe JSON Specification defines numerical precision independently of the IEEE 754 standard. This means developers do not need to worry about the typical limitations of floating-point arithmetic, such as precision loss or representation errors, which are common in most programming languages. RangeRanges of numbers are specified using a combination of the minimum and
maximum keywords, (or exclusiveMinimum and exclusiveMaximum for
expressing exclusive range).If x is the value being validated, the following must hold true:x ≥ minimumx > exclusiveMinimumx ≤ maximumx < exclusiveMaximum
While you can specify both of minimum and exclusiveMinimum or both
of maximum and exclusiveMaximum, it doesn't really make sense to do
so. schema{  "type": "number",  "minimum": 0,  "exclusiveMaximum": 100}﻿Less than minimum:data-1﻿not compliant to schemaminimum is inclusive, so 0 is valid:data0﻿compliant to schemadata10﻿compliant to schemadata99﻿compliant to schemaexclusiveMaximum is exclusive, so 100 is not valid:data100﻿not compliant to schemaGreater than maximum:data101﻿not compliant to schemaDraft-specific info:Draft 4In JSON Schema Draft 4, exclusiveMinimum and exclusiveMaximum work
differently. There they are boolean values, that indicate whether
minimum and maximum are exclusive of the value. For example:if exclusiveMinimum is false, x ≥ minimumif exclusiveMinimum is true, x > minimum.
This was changed to have better keyword independence.Here is an example using the older Draft 4 convention: schema{  "type": "number",  "minimum": 0,  "maximum": 100,  "exclusiveMaximum": true}﻿Less than minimum:data-1﻿not compliant to schemaexclusiveMinimum was not specified, so 0 is included:data0﻿compliant to schemadata10﻿compliant to schemadata99﻿compliant to schemaexclusiveMaximum is true, so 100 is not included:data100﻿not compliant to schemaGreater than maximum:data101﻿not compliant to schemaGo BacknullUp NextObjectNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaobjectObjects are the mapping type in JSON. They map "keys" to "values".
In JSON, the "keys" must always be strings. Each of these pairs is
conventionally referred to as a "property".Language-specific info:PythonRubyObjective-CSwiftIn Python, "objects" are analogous to the dict type.  An
important difference, however, is that while Python dictionaries
may use anything hashable as a key, in JSON all the keys
must be strings.Try not to be confused by the two uses of the word "object" here:
Python uses the word object to mean the generic base class for
everything, whereas in JSON it is used only to mean a mapping from
string keys to values. schema{ "type": "object" }﻿data{  "key": "value",  "another_key": "another_value"}﻿compliant to schemadata{  "Sun": 1.9891e30,  "Jupiter": 1.8986e27,  "Saturn": 5.6846e26,  "Neptune": 10.243e25,  "Uranus": 8.6810e25,  "Earth": 5.9736e24,  "Venus": 4.8685e24,  "Mars": 6.4185e23,  "Mercury": 3.3022e23,  "Moon": 7.349e22,  "Pluto": 1.25e22}﻿compliant to schemaUsing non-strings as keys is invalid JSON:data{  0.01: "cm",  1: "m",  1000: "km"}﻿not compliant to schemadata"Not an object"﻿not compliant to schemadata["An", "array", "not", "an", "object"]﻿not compliant to schema
PropertiesThe properties (key-value pairs) on an object are defined using the
properties keyword. The value of properties is an object, where each
key is the name of a property and each value is a schema used to
validate that property. Any property that doesn't match any of the
property names in the properties keyword is ignored by this keyword.See Additional Properties and
Unevaluated Properties for how to disallow properties that
don't match any of the property names in properties.
For example, let's say we want to define a simple schema for an address
made up of a number, street name and street type: schema{  "type": "object",  "properties": {    "number": { "type": "number" },    "street_name": { "type": "string" },    "street_type": { "enum": ["Street", "Avenue", "Boulevard"] }  }}﻿data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue" }﻿compliant to schema// If we provide the number in the wrong type, it is invalid:data{ "number": "1600", "street_name": "Pennsylvania", "street_type": "Avenue" }﻿not compliant to schemaBy default, leaving out properties is valid. See Required Properties.data{ "number": 1600, "street_name": "Pennsylvania" }﻿compliant to schemaBy extension, even an empty object is valid:data{ }﻿compliant to schemaBy default, providing additional properties is valid:data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue", "direction": "NW" }﻿compliant to schema
Pattern Properties Sometimes you want to say that, given a particular kind of property
name, the value should match a particular schema. That's where
patternProperties comes in: it maps regular expressions to schemas. If
a property name matches the given regular expression, the property value
must validate against the corresponding schema.Regular expressions are not anchored. This means that when defining the
regular expressions for patternProperties, it's important to note
that the expression may match anywhere within the property name. For
example, the regular expression "p" will match any property name with
a p in it, such as "apple", not just a property whose name is simply
"p". It's therefore usually less confusing to surround the regular
expression in ^...$, for example, "^p$".
In this example, any properties whose names start with the prefix S_
must be strings, and any with the prefix I_ must be integers. Any
properties that do not match either regular expression are ignored. schema{  "type": "object",  "patternProperties": {    "^S_": { "type": "string" },    "^I_": { "type": "integer" }  }}﻿data{ "S_25": "This is a string" }﻿compliant to schemadata{ "I_0": 42 }﻿compliant to schemaIf the name starts with S_, it must be a stringdata{ "S_0": 42 }﻿not compliant to schemaIf the name starts with I_, it must be an integerdata{ "I_42": "This is a string" }﻿not compliant to schemaThis is a key that doesn't match any of the regular expressions:data{ "keyword": "value" }﻿compliant to schema
Additional Properties The additionalProperties keyword is used to control the handling of
extra stuff, that is, properties whose names are not listed in the
properties keyword or match any of the regular expressions in the
patternProperties keyword. By default any additional properties are
allowed.The value of the additionalProperties keyword is a schema that will be
used to validate any properties in the instance that are not matched by
properties or patternProperties. Setting the additionalProperties
schema to false means no additional properties will be allowed.Reusing the example from Properties, but this time setting
additionalProperties to false. schema{  "type": "object",  "properties": {    "number": { "type": "number" },    "street_name": { "type": "string" },    "street_type": { "enum": ["Street", "Avenue", "Boulevard"] }  },  "additionalProperties": false}﻿data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue" }﻿compliant to schemaSince additionalProperties is false, this extra property "direction" makes the object invalid:data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue", "direction": "NW" }﻿not compliant to schema
You can use non-boolean schemas to put more complex constraints on the
additional properties of an instance. For example, one can allow
additional properties, but only if their values are each a string: schema{  "type": "object",  "properties": {    "number": { "type": "number" },    "street_name": { "type": "string" },    "street_type": { "enum": ["Street", "Avenue", "Boulevard"] }  },  "additionalProperties": { "type": "string" }}﻿data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue" }﻿compliant to schemaThis is valid, since the additional property's value is a string:data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue", "direction": "NW" }﻿compliant to schemaThis is invalid, since the additional property's value is not a string:data{ "number": 1600, "street_name": "Pennsylvania", "street_type": "Avenue", "office_number": 201 }﻿not compliant to schema
You can use additionalProperties with a combination of properties
and patternProperties. In the following example, based on the example
from patternProperties, we add a "builtin" property,
which must be a number, and declare that all additional properties (that
are neither defined by properties nor matched by patternProperties)
must be strings: schema{  "type": "object",  "properties": {    "builtin": { "type": "number" }  },  "patternProperties": {    "^S_": { "type": "string" },    "^I_": { "type": "integer" }  },  "additionalProperties": { "type": "string" }}﻿data{ "builtin": 42 }﻿compliant to schemaThis is a key that doesn't match any of the regular expressions:data{ "keyword": "value" }﻿compliant to schemaIt must be a string:data{ "keyword": 42 }﻿not compliant to schema
Extending Closed SchemasIt's important to note that additionalProperties only recognizes
properties declared in the same subschema as itself. So,
additionalProperties can restrict you from "extending" a schema
using combining keywords such as allOf. In
the following example, we can see how the additionalProperties can
cause attempts to extend the address schema example to fail. schema{  "allOf": [    {      "type": "object",      "properties": {        "street_address": { "type": "string" },        "city": { "type": "string" },        "state": { "type": "string" }      },      "required": ["street_address", "city", "state"],      "additionalProperties": false    }  ],﻿  "properties": {    "type": { "enum": [ "residential", "business" ] }  },  "required": ["type"]}﻿Fails additionalProperties. "type" is considered additional.data{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "business"}﻿not compliant to schemaFails required. "type" is required.data{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC"}﻿not compliant to schema
Because additionalProperties only recognizes properties declared in
the same subschema, it considers anything other than
"street_address", "city", and "state" to be additional. Combining
the schemas with allOf doesn't change that. A workaround
you can use is to move additionalProperties to the extending schema
and redeclare the properties from the extended schema. schema{  "allOf": [    {      "type": "object",      "properties": {        "street_address": { "type": "string" },        "city": { "type": "string" },        "state": { "type": "string" }      },      "required": ["street_address", "city", "state"]    }  ],﻿  "properties": {    "street_address": true,    "city": true,    "state": true,    "type": { "enum": [ "residential", "business" ] }  },  "required": ["type"],  "additionalProperties": false}﻿data{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "business"}﻿compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "business",  "something that doesn't belong": "hi!"}﻿not compliant to schema
Now the additionalProperties keyword is able to recognize all the
necessary properties and the schema works as expected. Keep reading to
see how the unevaluatedProperties keyword solves this problem without
needing to redeclare properties.Unevaluated Properties New in draft 2019-09In the previous section we saw the challenges with using
additionalProperties when "extending" a schema using
combining. The unevaluatedProperties keyword is similar
to additionalProperties except that it can recognize properties
declared in subschemas. So, the example from the previous section can be
rewritten without the need to redeclare properties. schema{  "allOf": [    {      "type": "object",      "properties": {        "street_address": { "type": "string" },        "city": { "type": "string" },        "state": { "type": "string" }      },      "required": ["street_address", "city", "state"]    }  ],﻿  "properties": {    "type": { "enum": ["residential", "business"] }  },  "required": ["type"],  "unevaluatedProperties": false}﻿data{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "business"}﻿compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "business",  "something that doesn't belong": "hi!"}﻿not compliant to schema
unevaluatedProperties works by collecting any properties that are
successfully validated when processing the schemas and using those as
the allowed list of properties. This allows you to do more complex
things like conditionally adding properties. The following example
allows the "department" property only if the "type" of address is
"business". schema{  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" },    "type": { "enum": ["residential", "business"] }  },  "required": ["street_address", "city", "state", "type"],﻿  "if": {    "type": "object",    "properties": {      "type": { "const": "business" }    },    "required": ["type"]  },  "then": {    "properties": {      "department": { "type": "string" }    }  },﻿  "unevaluatedProperties": false}﻿data{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "business",  "department": "HR"}﻿compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "city": "Washington",  "state": "DC",  "type": "residential",  "department": "HR"}﻿not compliant to schema
In this schema, the properties declared in the then schema only count
as "evaluated" properties if the "type" of the address is
"business".Required PropertiesBy default, the properties defined by the properties keyword are not
required. However, one can provide a list of required properties using
the required keyword.The required keyword takes an array of zero or more strings. Each of
these strings must be unique.Draft-specific infoIn Draft 4, required must contain at least one string.
In the following example schema defining a user record, we require that
each user has a name and e-mail address, but we don't mind if they
don't provide their address or telephone number: schema{  "type": "object",  "properties": {    "name": { "type": "string" },    "email": { "type": "string" },    "address": { "type": "string" },    "telephone": { "type": "string" }  },  "required": ["name", "email"]}﻿data{  "name": "William Shakespeare",  "email": "[email protected]"}﻿compliant to schemaProviding extra properties is fine, even properties not defined in the schema:data{  "name": "William Shakespeare",  "email": "[email protected]",  "address": "Henley Street, Stratford-upon-Avon, Warwickshire, England",  "authorship": "in question"}﻿compliant to schemaMissing the required "email" property makes the JSON document invalid:data{  "name": "William Shakespeare",  "address": "Henley Street, Stratford-upon-Avon, Warwickshire, England",}﻿not compliant to schemaIn JSON a property with value null is not equivalent to the property not being present. This fails because null is not of type "string", it's of type "null"data{  "name": "William Shakespeare",  "address": "Henley Street, Stratford-upon-Avon, Warwickshire, England",  "email": null}﻿not compliant to schema
Property names New in draft 6The names of properties can be validated against a schema, irrespective
of their values. This can be useful if you don't want to enforce
specific properties, but you want to make sure that the names of those
properties follow a specific convention. You might, for example, want to
enforce that all names are valid ASCII tokens so they can be used as
attributes in a particular programming language. schema{  "type": "object",  "propertyNames": {    "pattern": "^[A-Za-z_][A-Za-z0-9_]*$"  }}﻿data{  "_a_proper_token_001": "value"}﻿compliant to schemadata{  "001 invalid": "value"}﻿not compliant to schema
Since object keys must always be strings anyway, it is implied that the
schema given to propertyNames is always at least: schema{ "type": "string" }﻿
SizeThe number of properties on an object can be restricted using the
minProperties and maxProperties keywords. Each of these must be a
non-negative integer. schema{  "type": "object",  "minProperties": 2,  "maxProperties": 3}﻿data{}﻿not compliant to schemadata{ "a": 0 }﻿not compliant to schemadata{ "a": 0, "b": 1 }﻿compliant to schemadata{ "a": 0, "b": 1, "c": 2 }﻿compliant to schemadata{ "a": 0, "b": 1, "c": 2, "d": 3 }﻿not compliant to schemaGo BackNumeric TypesUp NextRegular expressionsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaRegular ExpressionsThe pattern and
patternProperties keywords use regular expressions to
express constraints. The regular expression syntax used is from
JavaScript (ECMA 262,
specifically). However, that complete syntax is not widely supported,
therefore it is recommended that you stick to the subset of that syntax
described below.A single unicode character (other than the special characters below)
matches itself..: Matches any character except line break characters. (Be aware
that what constitutes a line break character is somewhat dependent
on your platform and language environment, but in practice this
rarely matters). To include newlines use the (.|\r?\n)* pattern
which avoids the use of regex flags/modifiers and has good support
across regex libraries.^: Matches only at the beginning of the string.$: Matches only at the end of the string.(...): Group a series of regular expressions into a single regular
expression.|: Matches either the regular expression preceding or following
the | symbol.[abc]: Matches any of the characters inside the square brackets.[a-z]: Matches the range of characters.[^abc]: Matches any character not listed.[^a-z]: Matches any character outside of the range.+: Matches one or more repetitions of the preceding regular
expression.*: Matches zero or more repetitions of the preceding regular
expression.?: Matches zero or one repetitions of the preceding regular
expression.+?, *?, ??: The *, +, and ? qualifiers are all greedy;
they match as much text as possible. Sometimes this behavior isn't
desired and you want to match as few characters as possible.(?!x), (?=x): Negative and positive lookahead.{x}: Match exactly x occurrences of the preceding regular
expression.{x,y}: Match at least x and at most y occurrences of the
preceding regular expression.{x,}: Match x occurrences or more of the preceding regular
expression.{x,y}?, {x,}?: Non-greedy versions of the above expressions.Use only standard escapes like \n, \r, \t and keep 
in mind that you also need to do JSON escaping.ExampleThe following example matches a simple North American telephone number
with an optional area code: schema{  "type": "string",  "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"}﻿data"555-1212"﻿compliant to schemadata"(888)555-1212"﻿compliant to schemadata"(888)555-1212 ext. 532"﻿not compliant to schemadata"(800)FLOWERS"﻿not compliant to schema
The following example checks that the string starts with {{ and ends with }}
and that it also allows multiline strings. schema{  "type": "string",  "pattern": "^\\{\\{(.|[\\r\\n])*\\}\\}$",}﻿data"{{ foo\nbar }}"﻿compliant to schemadata"{ foo }"﻿not compliant to schemaGo BackobjectUp NextstringNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemastringThe string type is used for strings of text. It may contain Unicode characters.Language-specific info:PythonRubyObjective-CSwiftIn Python, "string" is analogous to the unicode type on Python schema{ "type": "string" }﻿data"Déjà vu"﻿compliant to schemadata""﻿compliant to schemadata"42"﻿compliant to schemadata42﻿not compliant to schema
LengthThe length of a string can be constrained using the minLength and
maxLength keywords. For both keywords, the value must be a
non-negative number. schema{  "type": "string",  "minLength": 2,  "maxLength": 3}﻿data"A"﻿not compliant to schemadata"AB"﻿compliant to schemadata"ABC"﻿compliant to schemadata"ABCD"﻿not compliant to schema
Regular ExpressionsThe pattern keyword is used to restrict a string to a particular
regular expression. The regular expression syntax is the one defined in
JavaScript (ECMA 262
specifically) with Unicode support. See
Regular Expressions for more information.When defining the regular expressions, it's important to note that the
string is considered valid if the expression matches anywhere within the
string. For example, the regular expression "p" will match any string
with a p in it, such as "apple" not just a string that is simply
"p". Therefore, it is usually less confusing, as a matter of course,
to surround the regular expression in ^...$, for example, "^p$",
unless there is a good reason not to do so.
The following example matches a simple North American telephone number
with an optional area code: schema{  "type": "string",  "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"}﻿data"555-1212"﻿compliant to schemadata"(888)555-1212"﻿compliant to schemadata"(888)555-1212 ext. 532"﻿not compliant to schemadata"(800)FLOWERS"﻿not compliant to schemaGo BackRegular expressionsUp NextDialect and vocabulary declarationNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDialect and vocabulary declarationA version of JSON Schema is called a dialect. A dialect represents the
set of keywords and semantics that can be used to evaluate a schema.
Each JSON Schema release is a new dialect of JSON Schema. JSON Schema
provides a way for you to declare which dialect a schema conforms to and
provides ways to describe your own custom dialects.$schemaThe $schema keyword is used to declare which dialect of JSON Schema
the schema was written for. The value of the $schema keyword is also
the identifier for a schema that can be used to verify that the schema
is valid according to the dialect $schema identifies. A schema that
describes another schema is called a "meta-schema".$schema applies to the entire document and must be at the root level.
It does not apply to externally referenced ($ref, $dynamicRef)
documents. Those schemas need to declare their own $schema.If $schema is not used, an implementation might allow you to specify a
value externally or it might make assumptions about which specification
version should be used to evaluate the schema. It's recommended that
all JSON Schemas have a $schema keyword to communicate to readers and
tooling which specification version is intended. Therefore most of the
time, you'll want this at the root of your schema:1"$schema": "https://json-schema.org/draft/2020-12/schema"
2Draft-specific info:Draft 4Draft 6Draft 7Draft 2019-09The identifier for Draft 4 is http://json-schema.org/draft-04/schema#.Draft 4 defined a value for $schema without a specific dialect
(http://json-schema.org/schema#) which meant, use the latest
dialect. This has since been deprecated and should no longer be
used.You might come across references to Draft 5. There is no Draft 5
release of JSON Schema. Draft 5 refers to a no-change revision of
the Draft 4 release. It does not add, remove, or change any
functionality. It only updates references, makes clarifications,
and fixes bugs. Draft 5 describes the Draft 4 release. If you came
here looking for information about Draft 5, you'll find it under
Draft 4. We no longer use the "draft" terminology to refer to
patch releases to avoid this confusion.VocabulariesNew in draft 2019-09Documentation Coming SoonDraft-specific infoBefore the introduction of Vocabularies, you could still extend
   JSON Schema with your custom keywords but the process was much less
   formalized. The first thing you'll need is a meta-schema that
   includes your custom keywords. The best way to do this is to make a
   copy of the meta-schema for the version you want to extend and make
   your changes to your copy. You will need to choose a custom URI to
   identify your custom version. This URI must not be one of the URIs
   used to identify official JSON Schema specification drafts and
   should probably include a domain name you own. You can use this URI
   with the $schema keyword to declare that your schemas use your
   custom version.

Not all implementations support custom meta-schemas and custom
keyword implementations.
GuidelinesOne of the strengths of JSON Schema is that it can be written in JSON
and used in a variety of environments. For example, it can be used for
both front-end and back-end HTML Form validation. The problem with using
custom vocabularies is that every environment where you want to use your
schemas needs to understand how to evaluate your vocabulary's keywords.
Meta-schemas can be used to ensure that schemas are written correctly,
but each implementation will need custom code to understand how to
evaluate the vocabulary's keywords.Meta-data keywords are the most interoperable because they don't affect
validation. For example, you could add a units keyword. This will
always work as expecting with an compliant validator. schema{  "type": "number",  "units": "kg"}﻿data42﻿compliant to schemadata"42"﻿not compliant to schema
The next best candidates for custom keywords are keywords that don't
apply other schemas and don't modify the behavior of existing keywords.
An isEven keyword is an example. In contexts where some validation is
better than no validation such as validating an HTML Form in the
browser, this schema will perform as well as can be expected. Full
validation would still be required and should use a validator that
understands the custom keyword. schema{  "type": "integer",  "isEven": true}﻿data2﻿compliant to schemaThis passes because the validator doesn't understand isEvendata3﻿compliant to schemaThe schema isn't completely impaired because it doesn't understand isEvendata"3"﻿not compliant to schema
The least interoperable type of custom keyword is one that applies other
schemas or modifies the behavior of existing keywords. An example would
be something like requiredProperties that declares properties and
makes them required. This example shows how the schema becomes almost
completely useless when evaluated with a validator that doesn't
understand the custom keyword. That doesn't necessarily mean that
requiredProperties is a bad idea for a keyword, it's just not the
right choice if the schema might need to be used in a context that
doesn't understand custom keywords. schema{  "type": "object",  "requiredProperties": {    "foo": { "type": "string" }  }}﻿data{ "foo": "bar" }﻿compliant to schemaThis passes because requiredProperties is not understooddata{}﻿compliant to schemaThis passes because requiredProperties is not understooddata{ "foo": 42 }﻿compliant to schemaGo BackstringUp NextValue restrictionsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaEnumerated and constant valuesThe enum and const keywords contribute to data validation by defining limits on the values a property can hold.Define a set of values. Use the enum keyword to specify a finite set of acceptable values for a property. This ensures that only predefined options are valid.Define a fixed, single value. Use the const keyword to force a property to have a single, fixed value. This keyword is more restrictive than enum.Learn more about how to use these keywords with the following resources:Enumerated valuesConstant valuesBy effectively utilizing these keywords, you can significantly enhance the reliability and accuracy of your JSON data.Go BackDialect and vocabulary declarationUp NextEnumerated valuesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaEnumerated valuesThe enum keyword is used to restrict a value to a fixed set of values.
It must be an array with at least one element, where each element is
unique.The following is an example for validating street light colors: schema{  "enum": ["red", "amber", "green"]}﻿data"red"﻿compliant to schemadata"blue"﻿not compliant to schema
You can use enum even without a type, to accept values of different
types. Let's extend the example to use null to indicate "off", and
also add 42, just for fun. schema{  "enum": ["red", "amber", "green", null, 42]}﻿data"red"﻿compliant to schemadatanull﻿compliant to schemadata42﻿compliant to schemadata0﻿not compliant to schemaGo BackEnumerated and Constant ValuesUp NextConstant valuesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaConstant valuesNew in draft 6The const keyword is used to restrict a value to a single value.For example, if you only support shipping to the United States for
export reasons: schema{  "properties": {    "country": {      "const": "United States of America"    }  }}﻿data{ "country": "United States of America" }﻿compliant to schemadata{ "country": "Canada" }﻿not compliant to schemaGo BackEnumerated valuesUp NextSchema annotations and commentsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSchema annotations and commentsAnnotations and comments are not directly related to the core structure and constraints of the JSON Schema itself. As such, keywords for annotations and comments are not required, however, using them can improve the maintainability of your schemas.Annotations are optional pieces of information that provide additional context or meaning to a JSON Schema. They are not used for data validation but can serve various purposes, such as:Descriptions. Adding human-readable descriptions to properties or the entire schema.Defaults. Specifying default values for properties.Examples. Providing example JSON objects that validate against the schema.ReadOnly/WriteOnly. Indicating read-only or write-only properties (often used in API contexts).Deprecated.  Marking properties or features that are discouraged from use and might be removed in the future.While annotations don't enforce data validation, they play a valuable role in enhancing the clarity, usability, and maintainability of JSON Schemas.Unlike some programming languages, JSON Schema itself doesn't natively support comments. However, it provides the keyword $comment, which allows schema authors to add comments within their schema. These comments enhance the clarity and maintainability of your schemas; they're intended for schema maintainers and are invisible to applications using the schema for validation.By incorporating annotations and comments into your schemas you can improve their clarity, maintainability, and overall quality. This will ensure your schemas are easier to understand and managed over time.To get started, explore the following resources:AnnotationsCommentsGo BackConstant valuesUp NextAnnotationsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaAnnotationsJSON Schema includes a few keywords, that aren't strictly used for
validation, but are used to describe parts of a schema. None of these
"annotation" keywords are required, but they are encouraged for good
practice, and can make your schema "self-documenting".Annotation keywords can be used in any schema or sub-schemas. Like other keywords, they may be used once.The title and description keywords must be strings. A "title" will
preferably be short, whereas a "description" will provide a more
lengthy explanation about the purpose of the data described by the
schema.The default keyword specifies a default value. This value is not used
to fill in missing values during the validation process. Non-validation
tools such as documentation generators or form generators may use this
value to give hints to users about how to use a value. However,
default is typically used to express that if a value is missing, then
the value is semantically the same as if the value was present with the
default value. The value of default should validate against the schema
in which it resides, but that isn't required.New in draft 6The examples keyword is a place to provide an array of examples that
validate against the schema. This isn't used for validation, but may
help with explaining the effect and purpose of the schema to a reader.
Each entry should validate against the schema in which it resides, but
that isn't strictly required. There is no need to duplicate the
default value in the examples array, since default will be treated
as another example.New in draft 7The boolean keywords readOnly and writeOnly are typically used in an
API context. readOnly indicates that a value should not be modified.
It could be used to indicate that a PUT request that changes a value
would result in a 400 Bad Request response. writeOnly indicates that
a value may be set, but will remain hidden. In could be used to indicate
you can set a value with a PUT request, but it would not be included
when retrieving that record with a GET request.New in draft 2019-09The deprecated keyword is a boolean that indicates that the instance
value the keyword applies to should not be used and may be removed in
the future. schema{  "title": "Match anything",  "description": "This is a schema that matches anything.",  "default": "Default value",  "examples": [    "Anything",    4035  ],  "deprecated": true,  "readOnly": true,  "writeOnly": false}﻿Go BackSchema annotations and commentsUp NextCommentsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCommentsNew in draft 7The $comment keyword is strictly intended for adding comments to a
schema. Its value must always be a string. Unlike the annotations
title, description, and examples, JSON schema implementations
aren't allowed to attach any meaning or behavior to it whatsoever, and
may even strip them at any time. Therefore, they are useful for leaving
notes to future editors of a JSON schema, but should not be used to
communicate to users of the schema.data    {      "$comment": "Created by John Doe",      "type": "object",      "properties": {        "country": {          "$comment": "TODO: add enum of countries"        }      }    }﻿Go BackAnnotationsUp NextEnumerated valuesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaConditional schema validationdependentRequiredThe dependentRequired keyword conditionally requires that certain
properties must be present if a given property is present in an object.
For example, suppose we have a schema representing a customer. If you
have their credit card number, you also want to ensure you have a
billing address. If you don't have their credit card number, a billing
address would not be required. We represent this dependency of one
property on another using the dependentRequired keyword. The value of
the dependentRequired keyword is an object. Each entry in the object
maps from the name of a property, p, to an array of strings listing
properties that are required if p is present.In the following example, whenever a credit_card property is provided,
a billing_address property must also be present: schema{  "type": "object",﻿  "properties": {    "name": { "type": "string" },    "credit_card": { "type": "number" },    "billing_address": { "type": "string" }  },﻿  "required": ["name"],﻿  "dependentRequired": {    "credit_card": ["billing_address"]  }}﻿data{  "name": "John Doe",  "credit_card": 5555555555555555,  "billing_address": "555 Debtor's Lane"}﻿compliant to schemaThis instance has a credit_card, but it's missing a billing_address.data{  "name": "John Doe",  "credit_card": 5555555555555555}﻿not compliant to schemaThis is okay, since we have neither a credit_card, or a billing_address.data{  "name": "John Doe"}﻿compliant to schemaNote that dependencies are not bidirectional.  It's okay to have a billing address without a credit card number.data{  "name": "John Doe",  "billing_address": "555 Debtor's Lane"}﻿compliant to schema
To fix the last issue above (that dependencies are not bidirectional),
you can, of course, define the bidirectional dependencies explicitly: schema{  "type": "object",﻿  "properties": {    "name": { "type": "string" },    "credit_card": { "type": "number" },    "billing_address": { "type": "string" }  },﻿  "required": ["name"],﻿  "dependentRequired": {    "credit_card": ["billing_address"],    "billing_address": ["credit_card"]  }}﻿This instance has a credit_card, but it's missing a billing_address.data{  "name": "John Doe",  "credit_card": 5555555555555555}﻿not compliant to schemaThis has a billing_address, but is missing a credit_card.data{  "name": "John Doe",  "billing_address": "555 Debtor's Lane"}﻿not compliant to schema
Draft-specific infoPreviously to Draft 2019-09, dependentRequired and
   dependentSchemas were one keyword called dependencies. If
   the dependency value was an array, it would behave like
   dependentRequired and if the dependency value was a schema, it
   would behave like dependentSchema.
dependentSchemas The dependentSchemas keyword conditionally applies a subschema when a
given property is present. This schema is applied in the same way
allOf applies schemas. Nothing is merged or extended. Both
schemas apply independently.For example, here is another way to write the above: schema{  "type": "object",  "properties": {    "name": { "type": "string" },    "credit_card": { "type": "number" }  },  "required": ["name"],  "dependentSchemas": {    "credit_card": {      "properties": {        "billing_address": { "type": "string" }      },      "required": ["billing_address"]    }  }}﻿
data{  "name": "John Doe",  "credit_card": 5555555555555555,  "billing_address": "555 Debtor's Lane"}﻿compliant to schemaThis instance has a credit_card, but it's missing a billing_address:data{  "name": "John Doe",  "credit_card": 5555555555555555}﻿not compliant to schemaThis has a billing_address, but is missing a credit_card.  This passes, because here billing_address just looks like an additional property:data{  "name": "John Doe",  "billing_address": "555 Debtor's Lane"}﻿compliant to schema
Draft-specific infoPreviously to Draft 2019-09, dependentRequired and
   dependentSchemas were one keyword called dependencies. If
   the dependency value was an array, it would behave like
   dependentRequired and if the dependency value was a schema, it
   would behave like dependentSchema.
If-Then-ElseNew in draft 7The if, then and else keywords allow the application of a subschema based
on the outcome of another schema, much like the if/then/else constructs
you've probably seen in traditional programming languages.If if is valid, then must also be valid (and else is ignored.) If if is
invalid, else must also be valid (and then is ignored).If then or else is not defined, if behaves as if they have a value of
true.If then and/or else appear in a schema without if, then and else are
ignored.We can put this in the form of a truth table, showing the combinations of when
if, then, and else are valid and the resulting validity of the entire
schema: if    then  else  whole schema  T     T     n/a   T             T     F     n/a   F             F     n/a   T     T             F     n/a   F     F             n/a   n/a   n/a   T            For example, let's say you wanted to write a schema to handle addresses in the
United States and Canada. These countries have different postal code formats,
and we want to select which format to validate against based on the country. If
the address is in the United States, the postal_code field is a "zipcode":
five numeric digits followed by an optional four digit suffix. If the address is
in Canada, the postal_code field is a six digit alphanumeric string where
letters and numbers alternate. schema{  "type": "object",  "properties": {    "street_address": {      "type": "string"    },    "country": {      "default": "United States of America",      "enum": ["United States of America", "Canada"]    }  },  "if": {    "properties": {      "country": { "const": "United States of America" }    }  },  "then": {    "properties": {      "postal_code": { "pattern": "[0-9]{5}(-[0-9]{4})?" }    }  },  "else": {    "properties": {      "postal_code": { "pattern": "[A-Z][0-9][A-Z] [0-9][A-Z][0-9]" }    }  }}﻿data{  "street_address": "1600 Pennsylvania Avenue NW",  "country": "United States of America",  "postal_code": "20500"}﻿compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "postal_code": "20500"}﻿compliant to schemadata{  "street_address": "24 Sussex Drive",  "country": "Canada",  "postal_code": "K1M 1M4"}﻿compliant to schemadata{  "street_address": "24 Sussex Drive",  "country": "Canada",  "postal_code": "10000"}﻿not compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "postal_code": "K1M 1M4"}﻿not compliant to schema
In this example, "country" is not a required property. Because the
if schema also doesn't require the "country" property, it will pass and the
"then" schema will apply. Therefore, if the "country" property is not defined,
the default behavior is to validate "postal_code" as a USA postal code. The
"default" keyword doesn't have an effect, but is nice to include for readers of
the schema to more easily recognize the default behavior.
Unfortunately, the approach above doesn't scale to more than two countries. You
can, however, wrap pairs of if and then inside an allOf to create
something that would scale. In this example, we'll use United States and
Canadian postal codes, but also add Netherlands postal codes, which are 4 digits
followed by two letters. It's left as an exercise to the reader to expand this
to the remaining postal codes of the world. schema{  "type": "object",  "properties": {    "street_address": {      "type": "string"    },    "country": {      "default": "United States of America",      "enum": ["United States of America", "Canada", "Netherlands"]    }  },  "allOf": [    {      "if": {        "properties": {          "country": { "const": "United States of America" }        }      },      "then": {        "properties": {          "postal_code": { "pattern": "[0-9]{5}(-[0-9]{4})?" }        }      }    },    {      "if": {        "properties": {          "country": { "const": "Canada" }        },        "required": ["country"]      },      "then": {        "properties": {          "postal_code": { "pattern": "[A-Z][0-9][A-Z] [0-9][A-Z][0-9]" }        }      }    },    {      "if": {        "properties": {          "country": { "const": "Netherlands" }        },        "required": ["country"]      },      "then": {        "properties": {          "postal_code": { "pattern": "[0-9]{4} [A-Z]{2}" }        }      }    }  ]}﻿data{  "street_address": "1600 Pennsylvania Avenue NW",  "country": "United States of America",  "postal_code": "20500"}﻿compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "postal_code": "20500"}﻿compliant to schemadata{  "street_address": "24 Sussex Drive",  "country": "Canada",  "postal_code": "K1M 1M4"}﻿compliant to schemadata{  "street_address": "Adriaan Goekooplaan",  "country": "Netherlands",  "postal_code": "2517 JX"}﻿compliant to schemadata{  "street_address": "24 Sussex Drive",  "country": "Canada",  "postal_code": "10000"}﻿not compliant to schemadata{  "street_address": "1600 Pennsylvania Avenue NW",  "postal_code": "K1M 1M4"}﻿not compliant to schema
The required keyword is necessary in the if schemas or they would all
apply if the "country" is not defined. Leaving required off of the "United
States of America" if schema makes it effectively the default if no "country"
is defined.
Even if "country" was a required field, it's still recommended to have the
required keyword in each if schema. The validation result will be the same
because required will fail, but not including it could add noise to error
results because it will validate the "postal_code" against all three of the
then schemas leading to irrelevant errors.
ImplicationBefore Draft 7, you can express an "if-then" conditional using the
Schema composition keywords and a boolean algebra concept called
"implication". A -> B (pronounced, A implies B) means that if A is
true, then B must also be true. It can be expressed as !A || B which
can be expressed as a JSON Schema. schema{  "type": "object",  "properties": {    "restaurantType": { "enum": ["fast-food", "sit-down"] },    "total": { "type": "number" },    "tip": { "type": "number" }  },  "anyOf": [    {      "not": {        "properties": { "restaurantType": { "const": "sit-down" } },        "required": ["restaurantType"]      }    },    { "required": ["tip"] }  ]}﻿data{  "restaurantType": "sit-down",  "total": 16.99,  "tip": 3.4}﻿compliant to schemadata{  "restaurantType": "sit-down",  "total": 16.99}﻿not compliant to schemadata{  "restaurantType": "fast-food",  "total": 6.99}﻿compliant to schemadata{ "total": 5.25 }﻿compliant to schema
Variations of implication can be used to express the same things you can
express with the if/then/else keywords. if/then can be
expressed as A -> B, if/else can be expressed as !A -> B, and
if/then/else can be expressed as A -> B AND !A -> C.Since this pattern is not very intuitive, it's recommended to put your
conditionals in $defs with a descriptive name and $ref it into your
schema with
"allOf": [{ "$ref": "#/$defs/sit-down-restaurant-implies-tip-is-required" }].Go BackCommentsUp NextSchema compositionNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSchema compositionJSON Schema offers powerful features for constructing complex and flexible schema structures. The main approaches to combining JSON schemas are the following:Modular combination. This approach allows you to break down your data model into reusable components, fostering modularity, and maintainability. In Modular JSON Schema combination you will learn about creating and utilizing reusable schemas, subschemas, and even self-referential (recursive) schemas.Boolean combination. This approach allows you to validate a single data value against multiple criteria at the same time. JSON Schema provides a set of keywords that act like boolean operators (AND, OR, NOT) to achieve this. To enhance your understanding of these keywords and learn how to leverage them for complex validations, see Boolean JSON Schema combination.By mastering these techniques you will make your JSON schemas more scalable, flexible, and easy to maintain.Go BackConditional schema validationUp NextBoolean JSON Schema combinationNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaBoolean JSON Schema combinationIntroductionJSON Schema includes a few keywords for combining schemas together. Note
that this doesn't necessarily mean combining schemas from multiple
files or JSON trees. To learn how to combine reusable JSON Schemas, see Modular JSON Schema combination.Here you will learn to combine schemas by allowing a value to be validated against multiple criteria at the same time. This task requires using keywords that correspond to well known boolean algebra concepts like
AND, OR, XOR, and NOT. The keywords used to combine schemas are the following:allOf: (AND) Must be valid against all of the subschemasanyOf: (OR) Must be valid against any of the subschemasoneOf: (XOR) Must be valid against exactly one of the
  subschemasnot: (NOT) Must not be valid against the given schemaAll of these keywords must be set to an array, where each item is a
schema. Be careful with recursive schemas as they can exponentially increase processing times.In the following sections you will learn to use these keywords to express
complex constraints that can't otherwise be expressed with standard
JSON Schema keywords.allOfTo validate against allOf, the given data must be valid against all of the given subschemas. schema{  "allOf": [    { "type": "string" },    { "maxLength": 5 }  ]}﻿
data"short"﻿compliant to schemadata"too long"﻿not compliant to schema
allOf can not be used to "extend" a schema to add more
details to it in the sense of object-oriented inheritance. Instances
must independently be valid against "all of" the schemas in the
allOf. See the section on Extending Closed Schemas for more
information.
anyOfTo validate against anyOf, the given data must be valid against any
(one or more) of the given subschemas. schema{  "anyOf": [    { "type": "string", "maxLength": 5 },    { "type": "number", "minimum": 0 }  ]}﻿
data"short"﻿compliant to schemadata"too long"﻿not compliant to schemadata12﻿compliant to schemadata-5﻿not compliant to schema
oneOf To validate against oneOf, the given data must be valid against
exactly one of the given subschemas. schema{  "oneOf": [    { "type": "number", "multipleOf": 5 },    { "type": "number", "multipleOf": 3 }  ]}﻿data10﻿compliant to schemadata9﻿compliant to schemaNot a multiple of either 5 or 3.data2﻿not compliant to schemaMultiple of both 5 and 3 is rejected.data15﻿not compliant to schema
Careful consideration should be taken when using oneOf entries as the nature of it requires verification of every sub-schema which can lead to increased processing times. Prefer anyOf where possible.
notThe not keyword declares that an instance validates if it doesn't
validate against the given subschema.For example, the following schema validates against anything that is not
a string: schema{ "not": { "type": "string" } }﻿data42﻿compliant to schemadata{ "key": "value" }﻿compliant to schemadata"I am a string"﻿not compliant to schema
Properties of Schema CompositionIllogical Schemas Note that it's quite easy to create schemas that are logical
impossibilities with these keywords. The following example creates a
schema that won't validate against anything (since something may not be
both a string and a number at the same time): schema{  "allOf": [    { "type": "string" },    { "type": "number" }  ]}﻿data"No way"﻿not compliant to schemadata-1﻿not compliant to schema
Factoring Schemas Note that it's possible to "factor" out the common parts of the
subschemas. The following two schemas are equivalent. schema{  "oneOf": [    { "type": "number", "multipleOf": 5 },    { "type": "number", "multipleOf": 3 }  ]}﻿ schema{  "type": "number",  "oneOf": [    { "multipleOf": 5 },    { "multipleOf": 3 }  ]}﻿Go BackSchema compositionUp NextModular JSON Schema combinationNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaModular JSON Schema combinationIntroductionWhen writing computer programs of even moderate complexity, it's
commonly accepted that "structuring" the program into reusable
functions is better than duplicating code. Similarly, in JSON Schema, structuring your schema into reusable components is highly beneficial for anything beyond the most trivial cases.Here, you will learn about the keywords used to combine JSON schemas modularly and see examples of their application.Schema IdentificationLike any other code, schemas are easier to maintain if they can be
broken down into logical units that reference each other as necessary.
In order to reference a schema, we need a way to identify a schema.
Schema documents are identified by non-relative URIs.Schema documents are not required to have an identifier, but you will
need one if you want to reference one schema from another. In this
documentation, we will refer to schemas with no identifier as
"anonymous schemas".In the following sections we will see how the "identifier" for a
schema is determined.URI terminology can sometimes be unintuitive. In this document, the
following definitions are used.URI
  [1] or
  non-relative URI: A full URI containing a scheme (https). It
  may contain a URI fragment (#foo). Sometimes this document will
  use "non-relative URI" to make it extra clear that relative URIs
  are not allowed.relative reference
  [2]:
  A partial URI that does not contain a scheme (https). It may
  contain a fragment (#foo).URI-reference
  [3]:
  A relative reference or non-relative URI. It may contain a URI
  fragment (#foo).absolute URI
 [4] A
 full URI containing a scheme (https) but not a URI fragment
 (#foo).

Even though schemas are identified by URIs, those identifiers are not
necessarily network-addressable. They are just identifiers. Generally,
implementations don't make HTTP requests (https://) or read from the
file system (file://) to fetch schemas. Instead, they provide a way to
load schemas into an internal schema database. When a schema is
referenced by it's URI identifier, the schema is retrieved from the
internal schema database.
Base URIUsing non-relative URIs can be cumbersome, so any URIs used in JSON
Schema can be URI-references that resolve against the schema's base URI
resulting in a non-relative URI. This section describes how a schema's
base URI is determined.Base URI determination and relative reference resolution is defined by
RFC-3986. If
you are familiar with how this works in HTML, this section should feel
very familiar.
Retrieval URIThe URI used to fetch a schema is known as the "retrieval URI". It's
often possible to pass an anonymous schema to an implementation in which
case that schema would have no retrieval URI.Let's assume a schema is referenced using the URI
https://example.com/schemas/address and the following schema is
retrieved. schema{  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
The base URI for this schema is the same as the retrieval URI, https://example.com/schemas/address.$idYou can set the base URI by using the $id keyword at the root of the
schema. The value of $id is a URI-reference without a fragment that
resolves against the retrieval-uri. The resulting URI is
the base URI for the schema.Draft-specific info:Draft 4Draft 4-7In Draft 4, $id is just id (without the dollar sign).This is analogous to the <base> tag in HTML.
When the $id keyword appears in a subschema, it means something slightly different. See the bundling section for more.
Let's assume the URIs https://example.com/schema/address and
https://example.com/schema/billing-address both identify the following
schema. schema{  "$id": "/schemas/address",﻿  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
No matter which of the two URIs is used to retrieve this schema, the
base URI will be https://example.com/schemas/address, which is the
result of the $id URI-reference resolving against the
Retrieval URI.However, using a relative reference when setting a base URI can be
problematic. For example, we couldn't use this schema as an anonymous
schema because there would be no Retrieval URI and you
can't resolve a relative reference against nothing. For this and other
reasons, it's recommended that you always use an absolute URI when
declaring a base URI with $id.The base URI of the following schema will always be
https://example.com/schemas/address no matter what the
Retrieval URI was or if it's used as an anonymous schema. schema{  "$id": "https://example.com/schemas/address",﻿  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
JSON PointerIn addition to identifying a schema document, you can also identify
subschemas. The most common way to do that is to use a JSON
Pointer in the URI fragment that
points to the subschema.A JSON Pointer describes a slash-separated path to traverse the keys in
the objects in the document. Therefore, /properties/street_address
means:1)  find the value of the key properties2)  within that object, find the value of the key street_addressThe URI https://example.com/schemas/address#/properties/street_address
identifies the highlighted subschema in the following schema. schema{  "$id": "https://example.com/schemas/address",  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
$anchorA less common way to identify a subschema is to create a named anchor in
the schema using the $anchor keyword and using that name in the URI
fragment. Anchors must start with a letter followed by any number of
letters, digits, -, _, :, or ..Draft-specific info:Draft 4Draft 6-7In Draft 4, you declare an anchor the same way you do in Draft 6-7
except that $id is just id (without the dollar sign).If a named anchor is defined that doesn't follow these naming rules,
then behavior is undefined. Your anchors might work in some
implementation, but not others.
The URI https://example.com/schemas/address#street_address identifies
the subschema on the highlighted part of the following schema. schema{  "$id": "https://example.com/schemas/address",  "type": "object",  "properties": {    "street_address": { "$anchor": "street_address", "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },   "required": ["street_address", "city", "state"]}﻿
$refA schema can reference another schema using the $ref keyword. The
value of $ref is a URI-reference that is resolved against the
schema's Base URI. When evaluating a $ref, an
implementation uses the resolved identifier to retrieve the referenced
schema and applies that schema to the instance.
Draft-specific infoIn Draft 4-7, $ref behaves a little differently. When an
   object contains a $ref property, the object is considered a
   reference, not a schema. Therefore, any other properties you put
   in that object will not be treated as JSON Schema keywords and will
   be ignored by the validator. $ref can only be used where a
   schema is expected.
For this example, let's say we want to define a customer record, where
each customer may have both a shipping and a billing address. Addresses
are always the same — they have a street address, city and
state — so we don't want to duplicate that part of the schema
everywhere we want to store an address. Not only would that make the
schema more verbose, but it makes updating it in the future more
difficult. If our imaginary company were to start doing international
business in the future and we wanted to add a country field to all the
addresses, it would be better to do this in a single place rather than
everywhere that addresses are used. schema{  "$id": "https://example.com/schemas/customer",﻿  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "shipping_address": { "$ref": "/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"]}﻿
The URI-references in $ref resolve against the schema's
Base URI (https://example.com/schemas/customer) which
results in https://example.com/schemas/address. The implementation
retrieves that schema and uses it to evaluate the "shipping_address"
and "billing_address" properties.When using $ref in an anonymous schema, relative references may not be
resolvable. Let's assume this example is used as an anonymous schema
 schema{  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "shipping_address": { "$ref": "https://example.com/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"]}﻿  
The $ref at /properties/shipping_address can resolve just fine
without a non-relative base URI to resolve against, but the $ref at
/properties/billing_address can't resolve to a non-relative URI and
therefore can't be used to retrieve the address schema.
$defsSometimes we have small subschemas that are only intended for use in the
current schema and it doesn't make sense to define them as separate
schemas. Although we can identify any subschema using JSON Pointers or
named anchors, the $defs keyword gives us a standardized place to keep
subschemas intended for reuse in the current schema document.Let's extend the previous customer schema example to use a common
schema for the name properties. It doesn't make sense to define a new
schema for this and it will only be used in this schema, so it's a good
candidate for using $defs. schema{  "$id": "https://example.com/schemas/customer",﻿  "type": "object",  "properties": {    "first_name": { "$ref": "#/$defs/name" },    "last_name": { "$ref": "#/$defs/name" },    "shipping_address": { "$ref": "/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"],﻿  "$defs": {    "name": { "type": "string" }  }}﻿
$defs isn't just good for avoiding duplication. It can also be useful
for writing schemas that are easier to read and maintain. Complex parts
of the schema can be defined in $defs with descriptive names and
referenced where it's needed. This allows readers of the schema to more
quickly and easily understand the schema at a high level before diving
into the more complex parts.It's possible to reference an external subschema, but generally you
want to limit a $ref to referencing either an external schema or an
internal subschema defined in $defs.
RecursionThe $ref keyword may be used to create recursive schemas that refer to
themselves. For example, you might have a person schema that has an
array of children, each of which are also person instances. schema{  "type": "object",  "properties": {    "name": { "type": "string" },    "children": {      "type": "array",      "items": { "$ref": "#" }    }  }}﻿A snippet of the British royal family treedata{  "name": "Elizabeth",  "children": [    {      "name": "Charles",      "children": [        {          "name": "William",          "children": [            { "name": "George" },            { "name": "Charlotte" }          ]        },        {          "name": "Harry"        }      ]    }  ]}﻿compliant to schema
Above, we created a schema that refers to itself, effectively creating a
"loop" in the validator, which is both allowed and useful. Note,
however, that a $ref referring to another $ref could cause an
infinite loop in the resolver, and is explicitly disallowed. schema{  "$defs": {    "alice": { "$ref": "#/$defs/bob" },    "bob": { "$ref": "#/$defs/alice" }  }}﻿
Extending Recursive SchemasNew in draft 2019-09Documentation Coming SoonBundlingWorking with multiple schema documents is convenient for development,
but it's often more convenient for distribution to bundle all of your
schemas into a single schema document. This can be done using the $id
keyword in a subschema. When $id is used in a subschema, it indicates
an embedded schema. The identifier for the embedded schema is the value
of $id resolved against the Base URI of the schema it
appears in. A schema document that includes embedded schemas is called a
Compound Schema Document. Each schema with an $id in a Compound Schema
Document is called a Schema Resource.Draft-specific info:Draft 4Draft 4-7In Draft 4, $id is just id (without the dollar sign).This is analogous to the <iframe> tag in HTML.
It is unusual to use embedded schemas when developing schemas. It's
generally best not to use this feature explicitly and use schema
bundling tools to construct bundled schemas if such a thing is needed.
:::
This example shows the customer schema example and the address schema
example bundled into a Compound Schema Document. schema{  "$id": "https://example.com/schemas/customer",  "$schema": "https://json-schema.org/draft/2020-12/schema",﻿  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "shipping_address": { "$ref": "/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"],﻿  "$defs": {    "address": {      "$id": "https://example.com/schemas/address",      "$schema": "http://json-schema.org/draft-07/schema#",﻿      "type": "object",      "properties": {        "street_address": { "type": "string" },        "city": { "type": "string" },        "state": { "$ref": "#/definitions/state" }      },      "required": ["street_address", "city", "state"],﻿      "definitions": {        "state": { "enum": ["CA", "NY", "... etc ..."] }      }    }  }}﻿
All references in a Compound Schema Document need to be the same whether
the Schema Resources are bundled or not. Notice that the $ref keywords
from the customer schema have not changed. The only difference is that
the address schema is now defined at /$defs/address instead of a
separate schema document. You couldn't use #/$defs/address to
reference the address schema because if you unbundled the schema, that
reference would no longer point to the address schema.Draft-specific infoIn Draft 4-7, both of these URIs are valid because a subschema
   $id only represented a base URI change, not an embedded schema.
   However, even though it's allowed, it's still highly recommended
   that JSON Pointers don't cross a schema with a base URI change.
You should also see that "$ref": "#/definitions/state" resolves to the
definitions keyword in the address schema rather than the one at the
top level schema like it would if the embedded schema wasn't used.Each Schema Resource is evaluated independently and may use different
JSON Schema dialects. The example above has the address Schema Resource
using Draft 7 while the customer Schema Resource uses Draft 2020-12. If
no $schema is declared in an embedded schema, it defaults to using the
dialect of the parent schema.Draft-specific infoIn Draft 4-7, a subschema $id is just a base URI change and not
   considered an independent Schema Resource. Because $schema is
   only allowed at the root of a Schema Resource, all schemas bundled
   using subschema $id must use the same dialect.
Draft-specific infoIn Draft 2020-12, support for changing dialects in an embedded schema 
   (using $schema with a different value than the parent schema) was added.Go BackBoolean JSON Schema combinationUp NextMedia: string-encoding non-JSON dataNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaMedia: string-encoding non-JSON dataNew in draft 7JSON schema has a set of keywords to describe and optionally validate non-JSON data stored inside JSON strings. Due to the difficulty in writing validators for all media types, JSON schema validators are not required to validate the contents of JSON strings based on these keywords. However, applications that consume validated JSON use these keywords to encode and decode data during the storage and transmission of media types.contentMediaType and contentEncodingThe contentMediaType keyword specifies the media type of the content of a string, as described in RFC 2046. The Internet Assigned Numbers Authority (IANA) has officially registered a comprehensive list of media types, but the set of supported types depends on the application and operating system. Mozilla Developer Network maintains a shorter list of media types that are important for the webExampleThe following schema specifies a string containing an HTML file using the document's default encoding. schema{  "type": "string",  "contentMediaType": "text/html"}﻿data"<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head></html>"﻿compliant to schema
The contentEncoding keyword specifies the encoding used to store the contents, as specified in RFC 2054, part 6.1 and RFC 4648.The acceptable values are the following:quoted-printablebase16base32base64If not specified, the encoding is the same as the containing JSON document.There are two main scenarios:Same encoding as JSON document: Leave contentEncoding unspecified and include the content in a string as-is. This is suitable for text-based content types (e.g., text/html, application/xml) and assumes UTF-8 encoding in most cases.Binary data: Set contentEncoding to base64 and encode the content using Base64. This is appropriate for binary content types such as images (image/png) or audio files (audio/mpeg).ExampleThe following schema indicates that a string contains a PNG file and is encoded using Base64: schema{  "type": "string",  "contentEncoding": "base64",  "contentMediaType": "image/png"}﻿data"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAA..."﻿compliant to schema
To better understand how contentEncoding and contentMediaType are applied in practice, let's consider the process of transmitting non-JSON data:
1block-beta
2   columns 9
3   A space B space C space D space E
4   F space:5 G space:2
5
6   A{{"Sender"}} --> F{"contentEncoding
7contentMediaType"}
8   F{"contentEncoding
9contentMediaType"} --> B{{"Encoded data"}}
10   B{{"Encoded data"}} --> C(["Transmission"])
11   C(["Transmission"]) --> D{{"Consumer application"}}
12   D{{"Consumer application"}} --> G{"contentEncoding
13contentMediaType"}
14    G{"contentEncoding
15contentMediaType"} --> E{{"Decoded data"}}
16
The sender encodes the content, using contentEncoding to specify the encoding method (e.g., base64) and contentMediaType to indicate the media type of the original content.The encoded data is then transmitted.Upon receiving the data, the consumer application uses the contentEncoding and contentMediaType information to select the appropriate decoding method.Finally, the consumer application decodes the data, restoring it to its original form.This process ensures that the non-JSON content is properly encoded for transmission and accurately decoded by the recipient, maintaining the integrity of the data throughout the process.contentSchemaNew in draft 2019-09The value of contentSchema must be a valid JSON schema that you can use to define the structure and constraints of the content. It is used in conjunction with contentMediaType when the instance is a string. If contentMediaType is absent, the value of contentSchema is ignored.Full exampleThe following schema indicates that a string contains a JSON object encoded using Base64: schema{    "$schema": "https://json-schema.org/draft/2020-12/schema",    "type": "object",    "properties": {        "data": {            "type": "string",            "contentMediaType": "application/json",            "contentEncoding": "base64",            "contentSchema": {                "type": "object",                "properties": {                    "name": {                        "type": "string"                    },                    "age": {                        "type": "integer"                    }                },                "required": ["name", "age"]            }        }    }}﻿data"eyJuYW1lIjoiSm9obiBEb2UiLCJ0b21lIjoiMjUifQ=="﻿compliant to schema
data{  "name": "John Doe",  "age": 25}﻿compliant to schemaGo BackModular JSON Schema combination¶Up NextSpecificationNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft 2020-12Specification DetailsSpecificationhttps://json-schema.org/draft/2020-12/json-schema-core.htmlPublished16 June 2022AuthorsAustin Wright, Henry Andrews, Ben Hutton, Greg DennisMetaschemahttps://json-schema.org/draft/2020-12/schemaIntroductionThe JSON Schema Draft 2020-12 is a comprehensive update to the previous draft 2019-09, addressing feedback and implementation experiences. This draft introduces features to simplify creating and validating JSON schemas.Here's an overview of updates to Draft 2020-12;Redesigned Array and Tuple Keywords: The items and additionalItems keywords have been replaced by prefixItems and items.Dynamic References: The introduction of $dynamicRef and $dynamicAnchor replaces the older $recursiveRef and $recursiveAnchor.Contains and UnevaluatedItems: Specifies how the contains keyword affects the unevaluatedItems keyword.Regular Expressions: Now expected to support Unicode characters, addressing inconsistencies in previous drafts.Media Type Changes: Drops the schema media type parameter.Embedded Schemas and Bundling: Provides guidance on bundling schemas into a Compound Schema Document.Vocabulary Changes: Separates the format vocabulary into format-annotation and format-assertion.Draft 2020-12 DocumentsSpecifications
Core: draft-bhutton-json-schema-01 (changes)Validation: draft-bhutton-json-schema-validation-01 (changes)Relative JSON Pointer: draft-bhutton-relative-json-pointer-00 (changes)Published: 16-June-2022General use meta-schemas
JSON Schema meta-schemaJSON Hyper-Schema meta-schema (2019-09 Hyper-Schema with 2020-12 Validation)JSON Hyper-Schema Link Description Object meta-schemaIndividual vocabulary meta-schemas
Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaUnevaluated Vocabulary meta-schemaFormat Annotation Vocabulary meta-schemaFormat Assertion Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaOutput schemas
JSON Schema recommended output schemaOutput examples
JSON Schema verbose output exampleObsolete Draft 2020-12 DocumentsThese were updated without changing functionality or meta-schemas due to a few errors and unclear sections.Core: draft-bhutton-json-schema-00 (changes)Validation: draft-bhutton-json-schema-validation-00 (changes)Release NotesDraft 2020-12 Release NotesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft 2019-09Specification DetailsSpecificationhttps://json-schema.org/draft/2019-09/draft-handrews-json-schema-02.htmlPublished17 September 2019AuthorsAustin Wright, Henry Andrews, Ben Hutton, Greg DennisMetaschemahttps://json-schema.org/draft/2019-09/schemaIntroductionThe JSON Schema Draft 2019-09 introduces updates and changes to improve the reliability of JSON Schema specifications. This draft builds upon previous versions.One significant update is the shift to HTTPS for all meta-schema URIs. While the URIs remain accessible over HTTP due to certain limitations, the recommended standard is now firmly HTTPS.Draft 2019-09 Documents*NOTE: All meta-schema URIs now use https://. While currently also available over plain HTTP due to the limitations of GitHub pages and the need to keep prior drafts available over HTTP, only the HTTPS URIs should be used.*Specifications
Core: draft-handrews-json-schema-02 (changes)Validation: draft-handrews-json-schema-validation-02 (changes)Hyper-Schema: draft-handrews-json-schema-hyperschema-02 (changes)Relative JSON Pointer: draft-handrews-relative-json-pointer-02 (changes)Published: 17-September-2019General use meta-schemas
JSON Schema meta-schemaJSON Hyper-Schema meta-schemaJSON Hyper-Schema Link Description Object meta-schemaIndividual vocabulary meta-schemas
Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaFormat Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaHyper-Schema Vocabulary meta-schemaOutput schemas
JSON Schema recommended output schemaJSON Hyper-Schema recommended output schemaOutput examplesJSON Schema verbose output exampleRelease NotesDraft 2019-09 Release NotesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft-07Specification DetailsSpecificationhttps://json-schema.org/draft-07/draft-handrews-json-schema-01.htmlPublished19 March 2018AuthorsAustin Wright, Henry AndrewsMetaschemahttps://json-schema.org/draft-07/schemaIntroductionThe JSON Schema Draft-07 introduces various updates to enhance the functionality of JSON Schemas in contrast to maintaining backward compatibility with Draft-06.Draft-07 DocumentsCore: draft-handrews-json-schema-01 (changes)Validation: draft-handrews-json-schema-validation-01 (changes)Hyper-Schema: draft-handrews-json-schema-hyperschema-01 (changes)JSON Schema meta-schemaJSON Hyper-Schema meta-schemaJSON Hyper-Schema Link Description Object meta-schemaJSON Hyper-Schema recommended output schemaRelative JSON Pointer: draft-handrews-relative-json-pointer-01 (changes)Published: 19-March-2018Obsolete Draft 7 DocumentsThese were updated without changing functionality or meta-schemas due to a few errors and unclear sections.Core: draft-handrews-json-schema-00 (changes)Validation: draft-handrews-json-schema-validation-00 (changes)Hyper-Schema: draft-handrews-json-schema-hyperschema-00 (changes)Relative JSON Pointer: draft-handrews-relative-json-pointer-00 (changes)Release NotesJSON Schema Release NotesJSON Hyper-Schema Release NotesNote that the draft-handrews-*-00 versions of JSON Hyper-Schema and Relative JSON Pointer had confusing bugs, and have been replaced by draft-handrews-*-01 versions. The -00 versions may be found in the obsolete directory.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft-06Specification DetailsSpecificationhttps://json-schema.org/draft-06/draft-wright-json-schema-01.htmlPublished21 April 2017AuthorsAustin Wright, Henry AndrewsMetaschemahttps://json-schema.org/draft-06/schemaDraft-06 DocumentsValidation: draft-wright-json-schema-validation-01 (changes) (schema migration FAQ)Hyper-Schema: draft-wright-json-schema-hyperschema-01 (changes) (hyper-schema migration FAQ)JSON Schema meta-schemaJSON Hyper-Schema meta-schemaRelease NotesJSON Schema Release NotesJSON Hyper-Schema Release NotesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft-05Specification DetailsSpecificationhttps://json-schema.org/draft-05/draft-wright-json-schema-00.pdfPublished13 October 2016AuthorsAustin WrightMetaschemahttps://json-schema.org/draft-04/schemaDraft-05 DocumentsCore: draft-wright-json-schema-00 (changes)Validation: draft-wright-json-schema-validation-00 (changes)Hyper-Schema: draft-wright-json-schema-hyperschema-00 (changes)Draft 5 was primarily a cleanup of Draft 4 and continued to use the Draft 4 meta-schemas.Published: 13-October-2016Explanation for lack of draft-05 meta-schemas“Draft-05” in the sequential meta-schema numbering would have referred to the draft-wright-jsonschema*-00 specifications.These specifications were intended as modernized and tidied versions of the specifications referenced by the “Draft-04” meta-schemas, so those draft-04 meta-schemas should continue to be used.“Draft-06” meta-schemas will be published for the next set of specifications.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSpecification Links
You can find the latest released draft on the Specification page.  The complex numbering and naming system for drafts and meta-schemas is fully explained here as well.Table of Contents
●Understanding draft names and numbers——●Table of All Versions of Everything●Published Drafts——●2020-12————●Obsolete Draft 2020-12 Documents——●Draft 2019-09 (formerly known as Draft 8)——●Draft 7————●Obsolete Draft 7 Documents——●Draft 6——●Draft 5——●Draft 4——●Draft 3——●Draft 2——●Draft 1——●Draft 0●Latest Snapshot (work in progress)Understanding draft names and numbersIETF Internet-Drafts (I-Ds) are named with the editor's name and a sequential number which resets with each new editor.  Meta-schemas were more-or-less numbered sequentially up through Draft 7, but the increasingly confusing mismatch between "draft-nn" versions on the meta-schemas and the IETF documents has made that unsustainable.  The practice of fixing meta-schema bugs in place to preserve the sequential numbering has also been controversial.Starting with what had been called "Draft 8" while it was being written, meta-schemas are identified by the year and month of publication.  This allows for bug fixes to be published with new URIs (as long as it is not more than once a month).Table of All Versions of EverythingFor links to the somewhat more readably formatted versions on this web site, and for links to the various meta-schemas and other supplemental documents, see the the following sections.common namepublishedmeta-schema identifiersIETF identifiersnotesDraft 2021-NN
(TBD)(TBD)(TBD)Milestone:
Draft 2021-NN
Draft 2020-12
16-June-20222020-12draft-bhutton-json-schema-00
draft-bhutton-json-schema-validation-00
draft-bhutton-relative-json-pointer-00
Milestone:
draft-08-patch-1Changes and fixes as a result of discussion with the OpenAPI community. (Includes breaking changes.)
draft-bhutton-json-schema-01
draft-bhutton-json-schema-validation-01
Draft 2019-09
17-September-2019
2019-09draft-handrews-json-schema-02
draft-handrews-json-schema-validation-02
draft-handrews-json-schema-hyperschema-02
draft-handrews-relative-json-pointer-02
Milestone:
draft-08Draft 7
  19-March-2018
  draft-07  draft-handrews-json-schema-00
draft-handrews-json-schema-validation-00
draft-handrews-json-schema-hyperschema-00
draft-handrews-relative-json-pointer-00
  the draft-handrews-*-01 drafts were
bugfixes and/or clarifications without meta-schema or functional changes
Milestone:
draft-07  draft-handrews-json-schema-01
draft-handrews-json-schema-validation-01
draft-handrews-json-schema-hyperschema-01
draft-handrews-relative-json-pointer-01
Draft 6
21-April-2017
draft-06draft-wright-json-schema-01
draft-wright-json-schema-validation-01
draft-wright-json-schema-hyperschema-01
Milestones:
draft-6,
Meta-schema draft-06Draft 5
13-October-2016
draft-04draft-wright-json-schema-00
draft-wright-json-schema-validation-00
draft-wright-json-schema-hyperschema-00
meta-schemas not changed, so
"draft-05" is really
draft-04Milestone: draft-5 (2016-10-13)Draft 4
31-January-2013
draft-zyp-json-schema-04
draft-fge-json-schema-validation-00
draft-luff-json-hyper-schema-00
draft-pbryan-zyp-json-ref-03
json-ref drafts
00-02 were all published between
json-schema-03 and
json-schema-04Draft 3
22-November-2010
draft-03draft-zyp-json-schema-03
Draft 2
23-March-2010
draft-02draft-zyp-json-schema-02
Draft 1
05-December-2009
draft-01draft-zyp-json-schema-01
Draft 0
05-December-2009
draft-00draft-zyp-json-schema-00
due to a markup error, this draft was replaced by
draft-01 on the same dayPublished Drafts2020-12Specifications
  Core: draft-bhutton-json-schema-01 (changes)Validation: draft-bhutton-json-schema-validation-01 (changes)Relative JSON Pointer: draft-bhutton-relative-json-pointer-00 (changes)Published: 16-June-2022General use meta-schemas
  JSON Schema meta-schemaJSON Hyper-Schema meta-schema (2019-09 Hyper-Schema with 2020-12 Validation)JSON Hyper-Schema Link Description Object meta-schemaIndividual vocabulary meta-schemas
Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaUnevaluated Vocabulary meta-schemaFormat Annotation Vocabulary meta-schemaFormat Assertion Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaOutput schemas
  JSON Schema recommended output schemaOutput examples
  JSON Schema verbose output exampleObsolete Draft 2020-12 DocumentsThese were updated without changing functionality or meta-schemas due to a few errors and unclear sections.Core:
draft-bhutton-json-schema-00 (changes)Validation:
draft-bhutton-json-schema-validation-00 (changes)Draft 2019-09 (formerly known as Draft 8)NOTE: All meta-schema URIs now use https://.  While currently also available over plain HTTP due to the limitations of GitHub pages and the need to keep prior drafts available over HTTP, only the HTTPS URIs should be used.Specifications
  Core: draft-handrews-json-schema-02 (changes)Validation: draft-handrews-json-schema-validation-02 (changes)Hyper-Schema: draft-handrews-json-schema-hyperschema-02 (changes)Relative JSON Pointer: draft-handrews-relative-json-pointer-02 (changes)Published: 17-September-2019General use meta-schemas
  JSON Schema meta-schemaJSON Hyper-Schema meta-schemaJSON Hyper-Schema Link Description Object meta-schemaIndividual vocabulary meta-schemas
  Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaFormat Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaHyper-Schema Vocabulary meta-schemaOutput schemas
  JSON Schema recommended output schemaJSON Hyper-Schema recommended output schemaOutput examples
  JSON Schema verbose output exampleDraft 7Core: draft-handrews-json-schema-01 (changes)Validation: draft-handrews-json-schema-validation-01 (changes)Hyper-Schema: draft-handrews-json-schema-hyperschema-01 (changes)JSON Schema meta-schemaJSON Hyper-Schema meta-schemaJSON Hyper-Schema Link Description Object meta-schemaJSON Hyper-Schema recommended output schemaRelative JSON Pointer: draft-handrews-relative-json-pointer-01 (changes)Published: 19-March-2018Obsolete Draft 7 DocumentsThese were updated without changing functionality or meta-schemas due to a few errors and unclear sections.Core: draft-handrews-json-schema-00 (changes)Validation: draft-handrews-json-schema-validation-00 (changes)Hyper-Schema: draft-handrews-json-schema-hyperschema-00 (changes)Relative JSON Pointer: draft-handrews-relative-json-pointer-00 (changes)Draft 6Core: draft-wright-json-schema-01 (changes)Validation: draft-wright-json-schema-validation-01 (changes) (schema migration FAQ)Hyper-Schema: draft-wright-json-schema-hyperschema-01 (changes) (hyper-schema migration FAQ)JSON Schema meta-schemaJSON Hyper-Schema meta-schemaPublished: 21-April-2017Draft 5Core: draft-wright-json-schema-00 (changes)Validation: draft-wright-json-schema-validation-00 (changes)Hyper-Schema: draft-wright-json-schema-hyperschema-00 (changes)Draft 5 was primarily a cleanup of Draft 4 and continued to use the Draft 4 meta-schemas.Published: 13-October-2016Draft 4Core: draft-zyp-json-schema-04 (changes)Validation: draft-fge-json-schema-validation-00 (changes)Hyper-Schema: draft-luff-json-hyper-schema-00 (changes)JSON Reference: draft-pbryan-zyp-json-ref-03 (changes)JSON Schema meta-schemaJSON Hyper-Schema meta-schemaPublished: 31-January-2013Draft 3Complete Specification: draft-zyp-json-schema-03 (changes)
JSON Schema meta-schemaJSON Hyper-Schema meta-schemaPublished: 22-November-2010Draft 2Complete Specification: draft-zyp-json-schema-02 (changes: Appendix-A)
JSON Schema meta-schemaJSON Hyper-Schema meta-schemaPublished: 23-March-2010Draft 1Complete Specification: draft-zyp-json-schema-01 (changes)
JSON Schema meta-schemaJSON Hyper-Schema meta-schemaPublished: 05-December-2009Draft 0Note that Draft 0 erroneously claimed to update another RFC, and was replaced the same day by Draft 1.  It is included here for completeness only.Specification: draft-zyp-json-schema-00 (changes: Appendix-A))
JSON Schema meta-schemaJSON Hyper-Schema meta-schemaPublished: 05-December-2009Latest Snapshot (work in progress)The next unreleased draft is a work in progress.  You can give feedback and get involved on GitHub.The specification links here link to the raw sources.  We do not provide rendered work-in-progress drafts except near the very end of a publication cycle, during the final review period.Core: jsonschema-core.mdValidation: jsonschema-validation.mdHyper-Schema: jsonschema-hyperschema.xml
Relative JSON Pointer: relative-json-pointer.xmlJSON Schema meta-schemaJSON Hyper-Schema meta-schemaJSON Hyper-Schema Link Description Object meta-schemaJSON Schema Vocabulary meta-schemasJSON Schema Output schemas and examplesGo BackSpecificationUp NextMigrationNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaMigrating from older draftsThe release notes discuss the changes impacting users and implementers:Draft 2019-09 to Draft 2020-12Details for migrations from Draft 2019-09 to 2020-12.Read MoreDraft-07 to Draft 2019-09Details for migrations from Draft-07 to 2019-09.Read MoreDraft-06 to Draft-07Details for migrations from Draft-6 to Draft-07.Read MoreDraft-05 to Draft-06Details for migrations from Draft-05 to Draft-06.Read MoreGo BackSpecification LinksUp NextRelease NotesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaRelease notesFind below the Release Notes of all JSON Schema drafts:Draft 2020-12Draft 2020-12 release notes.Read MoreDraft 2019-09Draft 2019-09 release notes.Read MoreDraft 07Draft 07 release notes.Read MoreDraft 06Draft 06 release notes.Read MoreDraft 05Draft 05 release notes.Read MoreGo BackMigrationUp NextJSON Hyper-SchemaNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Hyper-SchemaIntroductionJSON Hyper-Schema is an extension of JSON Schema that allows for the definition of hypermedia-driven APIs. The hyper-schema vocabulary shows how to annotate JSON documents with hypermedia controls by enabling the description of links and actions that can be executed on JSON data. Consecutively, it helps provide a more interactive and dynamic representation of JSON data. It also enhances API discoverability using the description features of actions and links within the JSON documents.JSON Hyper-Schema seamlessly integrates with existing JSON HTTP APIs and offers functionalities to describe complex resource relationships, facilitate client-side validation, and promote better interaction patterns. It makes APIs more intuitive, self-descriptive, and efficient, particularly in RESTful architectures.In essence:JSON Hyper-Schema is helpful in complex APIs where clients need to define and explicitly understand the relationships between resources and actions, especially when navigating resources without prior knowledge of the API structure.It helps create more discoverable and self-documenting APIs, making it easier for clients to interact with them.Hyper Schema SpecificationHyper-Schema: draft-handrews-json-schema-hyperschema-02Relative JSON Pointer: draft-bhutton-relative-json-pointer-00Schemas:JSON Hyper-Schema meta-schemaJSON Hyper-Schema vocabulary schemaJSON Hyper-Schema Link Description Object meta-schemaJSON Schema Output schemas and examplesRelease NotesDraft-07 to 2019-09Draft-04 to Draft-07Draft-04 to Draft-06Go BackRelease NotesUp NextWhat is JSON Schema?Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nExpires 18 December 2022\nWorkgroup:
Internet Engineering Task Force
Internet-Draft:
draft-bhutton-json-schema-01
Published:

16 June 2022
    
Intended Status:
Informational
Expires:
18 December 2022
Authors:


      A. Wright, Ed.



      H. Andrews, Ed.



      B. Hutton, Ed.

Postman


      G. Dennis\nB. Hutton, Ed.

Postman\nJSON Schema: A Media Type for Describing JSON Documents\nJSON Schema defines the media type "application/schema+json", a JSON-based format
                for describing the structure of JSON data.
                JSON Schema asserts what a JSON document must look like,
                ways to extract information from it,
                and how to interact with it.
                The "application/schema-instance+json" media type provides additional
                feature-rich integration with "application/schema+json" beyond what can be offered
                for "application/json" documents.¶\nThe issues list for this draft can be found at
                https://github.com/json-schema-org/json-schema-spec/issues.¶\nhttps://github.com/json-schema-org/json-schema-spec/issues\nhttps://github.com/json-schema-org/json-schema-spec/issues\nFor additional information, see https://json-schema.org/.¶\nhttps://json-schema.org/\nhttps://json-schema.org/\nTo provide feedback, use this issue tracker, the communication methods listed on the
                homepage, or email the document editors.¶\nStatus of This Memo
        

        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.¶

        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at https://datatracker.ietf.org/drafts/current/.¶

        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."¶

        This Internet-Draft will expire on 18 December 2022.¶\nThis Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.¶\nInternet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at https://datatracker.ietf.org/drafts/current/.¶\nhttps://datatracker.ietf.org/drafts/current/\nhttps://datatracker.ietf.org/drafts/current/\nInternet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."¶\nThis Internet-Draft will expire on 18 December 2022.¶\nCopyright Notice
        

            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶

            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶\nCopyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶\nThis document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶\nhttps://trustee.ietf.org/license-info\nhttps://trustee.ietf.org/license-info\n▲
Table of Contents
        


            1.  Introduction

          
            2.  Conventions and Terminology

          
            3.  Overview

          
            4.  Definitions


                4.1.  JSON Document

              
                4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances

                

              
                4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources

                

            

          
            5.  Fragment Identifiers

          
            6.  General Considerations


                6.1.  Range of JSON Values

              
                6.2.  Programming Language Independence

              
                6.3.  Mathematical Integers

              
                6.4.  Regular Expressions

              
                6.5.  Extending JSON Schema

            

          
            7.  Keyword Behaviors


                7.1.  Lexical Scope and Dynamic Scope

              
                7.2.  Keyword Interactions

              
                7.3.  Default Behaviors

              
                7.4.  Identifiers

              
                7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas

                

              
                7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types

                

              
                7.7.  Annotations


                    7.7.1.  Collecting Annotations

                

              
                7.8.  Reserved Locations

              
                7.9.  Loading Instance Data

            

          
            8.  The JSON Schema Core Vocabulary


                8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs

                

              
                8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"

                

              
                8.3.  Comments With "$comment"

            

          
            9.  Loading and Processing Schemas


                9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema

                

              
                9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources

                

              
                9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating

                

              
                9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas

                

              
                9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia

                

            

          
            10. A Vocabulary for Applying Subschemas


                10.1.  Keyword Independence

              
                10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally

                

              
                10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects

                

            

          
            11. A Vocabulary for Unevaluated Locations


                11.1.  Keyword Independence

              
                11.2.  unevaluatedItems

              
                11.3.  unevaluatedProperties

            

          
            12. Output Formatting


                12.1.  Format

              
                12.2.  Output Formats

              
                12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results

                

              
                12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas

                

            

          
            13. Security Considerations

          
            14. IANA Considerations


                14.1.  application/schema+json

              
                14.2.  application/schema-instance+json

            

          
            15. References


                15.1.  Normative References

              
                15.2.  Informative References

            

          
            Appendix A.  Schema identification examples

          
            Appendix B.  Manipulating schema documents and references


                B.1.  Bundling schema resources into a single document

              
                B.2.  Reference removal is not always safe

            

          
            Appendix C.  Example of recursive schema extension

          
            Appendix D.  Working with vocabularies


                D.1.  Best practices for vocabulary and meta-schema authors

              
                D.2.  Example meta-schema with vocabulary declarations

            

          
            Appendix E.  References and generative use cases

          
            Appendix F.  Acknowledgments

          
            Appendix G.  ChangeLog

          
            Authors' Addresses\n2.  Conventions and Terminology\n2.  Conventions and Terminology\nConventions and Terminology\n4.  Definitions


                4.1.  JSON Document

              
                4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances

                

              
                4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources\n4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances\n4.2.1.  Instance Data Model\n4.2.1.  Instance Data Model\n4.2.2.  Instance Equality\n4.2.2.  Instance Equality\n4.2.3.  Non-JSON Instances\n4.2.3.  Non-JSON Instances\n4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources\n4.3.  JSON Schema Documents\nJSON Schema Documents\n4.3.1.  JSON Schema Objects and Keywords\n4.3.1.  JSON Schema Objects and Keywords\nJSON Schema Objects and Keywords\n4.3.2.  Boolean JSON Schemas\n4.3.2.  Boolean JSON Schemas\n4.3.3.  Schema Vocabularies\n4.3.3.  Schema Vocabularies\n4.3.5.  Root Schema and Subschemas and Resources\n4.3.5.  Root Schema and Subschemas and Resources\nRoot Schema and Subschemas and Resources\n5.  Fragment Identifiers\n5.  Fragment Identifiers\n6.  General Considerations


                6.1.  Range of JSON Values

              
                6.2.  Programming Language Independence

              
                6.3.  Mathematical Integers

              
                6.4.  Regular Expressions

              
                6.5.  Extending JSON Schema\n6.  General Considerations\nGeneral Considerations\n6.1.  Range of JSON Values\n6.1.  Range of JSON Values\n6.2.  Programming Language Independence\n6.2.  Programming Language Independence\nProgramming Language Independence\n6.3.  Mathematical Integers\n6.3.  Mathematical Integers\nMathematical Integers\n6.4.  Regular Expressions\n6.4.  Regular Expressions\n6.5.  Extending JSON Schema\n6.5.  Extending JSON Schema\nExtending JSON Schema\n7.  Keyword Behaviors


                7.1.  Lexical Scope and Dynamic Scope

              
                7.2.  Keyword Interactions

              
                7.3.  Default Behaviors

              
                7.4.  Identifiers

              
                7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas

                

              
                7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types

                

              
                7.7.  Annotations


                    7.7.1.  Collecting Annotations

                

              
                7.8.  Reserved Locations

              
                7.9.  Loading Instance Data\n7.  Keyword Behaviors\n7.1.  Lexical Scope and Dynamic Scope\n7.1.  Lexical Scope and Dynamic Scope\nLexical Scope and Dynamic Scope\n7.2.  Keyword Interactions\n7.2.  Keyword Interactions\n7.3.  Default Behaviors\n7.3.  Default Behaviors\n7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas\n7.5.1.  Referenced and Referencing Schemas\n7.5.1.  Referenced and Referencing Schemas\nReferenced and Referencing Schemas\n7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types\n7.6.1.  Assertions and Instance Primitive Types\n7.6.1.  Assertions and Instance Primitive Types\nAssertions and Instance Primitive Types\n7.7.  Annotations


                    7.7.1.  Collecting Annotations\n7.7.1.  Collecting Annotations\n7.7.1.  Collecting Annotations\nCollecting Annotations\n7.8.  Reserved Locations\n7.8.  Reserved Locations\n7.9.  Loading Instance Data\n7.9.  Loading Instance Data\nLoading Instance Data\n8.  The JSON Schema Core Vocabulary


                8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs

                

              
                8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"

                

              
                8.3.  Comments With "$comment"\n8.  The JSON Schema Core Vocabulary\nThe JSON Schema Core Vocabulary\n8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs\n8.1.  Meta-Schemas and Vocabularies\nMeta-Schemas and Vocabularies\n8.1.1.  The "$schema" Keyword\n8.1.1.  The "$schema" Keyword\nThe "$schema" Keyword\n8.1.2.  The "$vocabulary" Keyword\n8.1.2.  The "$vocabulary" Keyword\nThe "$vocabulary" Keyword\n8.1.3.  Updates to Meta-Schema and Vocabulary URIs\n8.1.3.  Updates to Meta-Schema and Vocabulary URIs\nUpdates to Meta-Schema and Vocabulary URIs\n8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"\n8.2.  Base URI, Anchors, and Dereferencing\nBase URI, Anchors, and Dereferencing\n8.2.1.  The "$id" Keyword\n8.2.1.  The "$id" Keyword\n8.2.2.  Defining location-independent identifiers\n8.2.2.  Defining location-independent identifiers\nDefining location-independent identifiers\n8.2.3.  Schema References\n8.2.3.  Schema References\n8.2.4.  Schema Re-Use With "$defs"\n8.2.4.  Schema Re-Use With "$defs"\nSchema Re-Use With "$defs"\n8.3.  Comments With "$comment"\n8.3.  Comments With "$comment"\nComments With "$comment"\n9.  Loading and Processing Schemas


                9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema

                

              
                9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources

                

              
                9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating

                

              
                9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas

                

              
                9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia\n9.  Loading and Processing Schemas\nLoading and Processing Schemas\n9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema\n9.1.  Loading a Schema\n9.1.1.  Initial Base URI\n9.1.1.  Initial Base URI\n9.1.2.  Loading a referenced schema\n9.1.2.  Loading a referenced schema\nLoading a referenced schema\n9.1.3.  Detecting a Meta-Schema\n9.1.3.  Detecting a Meta-Schema\nDetecting a Meta-Schema\n9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources\n9.2.1.  JSON Pointer fragments and embedded schema resources\n9.2.1.  JSON Pointer fragments and embedded schema resources\nJSON Pointer fragments and embedded schema resources\n9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating\n9.3.  Compound Documents\n9.3.2.  Differing and Default Dialects\n9.3.2.  Differing and Default Dialects\nDiffering and Default Dialects\n9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas\n9.4.1.  Guarding Against Infinite Recursion\n9.4.1.  Guarding Against Infinite Recursion\nGuarding Against Infinite Recursion\n9.4.2.  References to Possible Non-Schemas\n9.4.2.  References to Possible Non-Schemas\nReferences to Possible Non-Schemas\n9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia\n9.5.  Associating Instances and Schemas\nAssociating Instances and Schemas\n9.5.1.  Usage for Hypermedia\n9.5.1.  Usage for Hypermedia\n10. A Vocabulary for Applying Subschemas


                10.1.  Keyword Independence

              
                10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally

                

              
                10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects\n10. A Vocabulary for Applying Subschemas\nA Vocabulary for Applying Subschemas\n10.1.  Keyword Independence\n10.1.  Keyword Independence\n10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally\n10.2.  Keywords for Applying Subschemas in Place\nKeywords for Applying Subschemas in Place\n10.2.1.  Keywords for Applying Subschemas With Logic\n10.2.1.  Keywords for Applying Subschemas With Logic\nKeywords for Applying Subschemas With Logic\n10.2.2.  Keywords for Applying Subschemas Conditionally\n10.2.2.  Keywords for Applying Subschemas Conditionally\nKeywords for Applying Subschemas Conditionally\n10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects\n10.3.  Keywords for Applying Subschemas to Child Instances\nKeywords for Applying Subschemas to Child Instances\n10.3.1.  Keywords for Applying Subschemas to Arrays\n10.3.1.  Keywords for Applying Subschemas to Arrays\nKeywords for Applying Subschemas to Arrays\n10.3.2.  Keywords for Applying Subschemas to Objects\n10.3.2.  Keywords for Applying Subschemas to Objects\nKeywords for Applying Subschemas to Objects\n11. A Vocabulary for Unevaluated Locations


                11.1.  Keyword Independence

              
                11.2.  unevaluatedItems

              
                11.3.  unevaluatedProperties\n11. A Vocabulary for Unevaluated Locations\nA Vocabulary for Unevaluated Locations\n11.1.  Keyword Independence\n11.1.  Keyword Independence\n11.2.  unevaluatedItems\n11.2.  unevaluatedItems\n11.3.  unevaluatedProperties\n11.3.  unevaluatedProperties\nunevaluatedProperties\n12. Output Formatting


                12.1.  Format

              
                12.2.  Output Formats

              
                12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results

                

              
                12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas\n12. Output Formatting\n12.2.  Output Formats\n12.2.  Output Formats\n12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results\n12.3.  Minimum Information\n12.3.1.  Keyword Relative Location\n12.3.1.  Keyword Relative Location\nKeyword Relative Location\n12.3.2.  Keyword Absolute Location\n12.3.2.  Keyword Absolute Location\nKeyword Absolute Location\n12.3.3.  Instance Location\n12.3.3.  Instance Location\n12.3.4.  Error or Annotation\n12.3.4.  Error or Annotation\n12.3.5.  Nested Results\n12.3.5.  Nested Results\n12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas\n12.4.  Output Structure\n12.4.5.  Output validation schemas\n12.4.5.  Output validation schemas\nOutput validation schemas\n13. Security Considerations\n13. Security Considerations\nSecurity Considerations\n14. IANA Considerations


                14.1.  application/schema+json

              
                14.2.  application/schema-instance+json\n14. IANA Considerations\n14.1.  application/schema+json\n14.1.  application/schema+json\napplication/schema+json\n14.2.  application/schema-instance+json\n14.2.  application/schema-instance+json\napplication/schema-instance+json\n15. References


                15.1.  Normative References

              
                15.2.  Informative References\n15.1.  Normative References\n15.1.  Normative References\n15.2.  Informative References\n15.2.  Informative References\nInformative References\nAppendix A.  Schema identification examples\nAppendix A.  Schema identification examples\nSchema identification examples\nAppendix B.  Manipulating schema documents and references


                B.1.  Bundling schema resources into a single document

              
                B.2.  Reference removal is not always safe\nAppendix B.  Manipulating schema documents and references\nManipulating schema documents and references\nB.1.  Bundling schema resources into a single document\nB.1.  Bundling schema resources into a single document\nBundling schema resources into a single document\nB.2.  Reference removal is not always safe\nB.2.  Reference removal is not always safe\nReference removal is not always safe\nAppendix C.  Example of recursive schema extension\nAppendix C.  Example of recursive schema extension\nExample of recursive schema extension\nAppendix D.  Working with vocabularies


                D.1.  Best practices for vocabulary and meta-schema authors

              
                D.2.  Example meta-schema with vocabulary declarations\nAppendix D.  Working with vocabularies\nWorking with vocabularies\nD.1.  Best practices for vocabulary and meta-schema authors\nD.1.  Best practices for vocabulary and meta-schema authors\nBest practices for vocabulary and meta-schema authors\nD.2.  Example meta-schema with vocabulary declarations\nD.2.  Example meta-schema with vocabulary declarations\nExample meta-schema with vocabulary declarations\nAppendix E.  References and generative use cases\nAppendix E.  References and generative use cases\nReferences and generative use cases\nAppendix F.  Acknowledgments\nAppendix F.  Acknowledgments\nAppendix G.  ChangeLog\nAppendix G.  ChangeLog\nJSON Schema is a JSON media type for defining the structure of JSON data. JSON Schema
                is intended to define validation, documentation, hyperlink navigation, and interaction
                control of JSON data.¶\nThis specification defines JSON Schema core terminology and mechanisms, including
                pointing to another JSON Schema by reference,
                dereferencing a JSON Schema reference,
                specifying the dialect being used,
                specifying a dialect's vocabulary requirements,
                and defining the expected output.¶\nOther specifications define the vocabularies that perform assertions about validation,
                linking, annotation, navigation, and interaction.¶\n2. Conventions and Terminology\nConventions and Terminology\nThe key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in RFC 2119 [RFC2119].¶\nThe terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in RFC 8259 [RFC8259].¶\nThis document proposes a new media type "application/schema+json" to identify a JSON
                Schema for describing JSON data.
                It also proposes a further optional media type, "application/schema-instance+json",
                to provide additional integration features.
                JSON Schemas are themselves JSON documents.
                This, and related specifications, define keywords allowing authors to describe JSON
                data in several ways.¶\nJSON Schema uses keywords to assert constraints on JSON instances or annotate those
                instances with additional information.  Additional keywords are used to apply
                assertions and annotations to more complex JSON data structures, or based on
                some sort of condition.¶\nTo facilitate re-use, keywords can be organized into vocabularies. A vocabulary
                consists of a list of keywords, together with their syntax and semantics.
                A dialect is defined as a set of vocabularies and their required support
                identified in a meta-schema.¶\nJSON Schema can be extended either by defining additional vocabularies,
                or less formally by defining additional keywords outside of any vocabulary.
                Unrecognized individual keywords simply have their values collected as annotations,
                while the behavior with respect to an unrecognized vocabulary can be controlled
                when declaring which vocabularies are in use.¶\nThis document defines a core vocabulary that MUST be supported by any
                implementation, and cannot be disabled.  Its keywords are each prefixed
                with a "$" character to emphasize their required nature.  This vocabulary
                is essential to the functioning of the "application/schema+json" media
                type, and is used to bootstrap the loading of other vocabularies.¶\nAdditionally, this document defines a RECOMMENDED vocabulary of keywords
                for applying subschemas conditionally, and for applying subschemas to
                the contents of objects and arrays.  Either this vocabulary or one very
                much like it is required to write schemas for non-trivial JSON instances,
                whether those schemas are intended for assertion validation, annotation,
                or both.  While not part of the required core vocabulary, for maximum
                interoperability this additional vocabulary is included in this document
                and its use is strongly encouraged.¶\nFurther vocabularies for purposes such as structural validation or
                hypermedia annotation are defined in other documents.  These other
                documents each define a dialect collecting the standard sets of
                vocabularies needed to write schemas for that document's purpose.¶\nA JSON document is an information resource (series of octets) described by the
                    application/json media type.¶\nIn JSON Schema, the terms "JSON document", "JSON text", and "JSON value" are
                    interchangeable because of the data model it defines.¶\nJSON Schema is only defined over JSON documents. However, any document or memory
                    structure that can be parsed into or processed according to the JSON Schema data
                    model can be interpreted against a JSON Schema, including media types like
                    CBOR [RFC7049].¶\nA JSON document to which a schema is applied is known as an "instance".¶\nJSON Schema is defined over "application/json" or compatible documents,
                    including media types with the "+json" structured syntax suffix.¶\nAmong these, this specification defines the "application/schema-instance+json"
                    media type which defines handling for fragments in the URI.¶\n4.2.1. Instance Data Model\nJSON Schema interprets documents according to a data model. A JSON value
                        interpreted according to this data model is called an "instance".¶\nAn instance has one of six primitive types, and a range of possible values
                        depending on the type:¶\nWhitespace and formatting concerns, including different lexical
                        representations of numbers that are equal within the data model, are thus
                        outside the scope of JSON Schema.  JSON Schema
                        vocabularies (Section 8.1) that wish
                        to work with such differences in lexical representations SHOULD define
                        keywords to precisely interpret formatted strings within the data model
                        rather than relying on having the original JSON representation Unicode
                        characters available.¶\nvocabularies (Section 8.1)\nSince an object cannot have two properties with the same key, behavior for a
                        JSON document that tries to define two properties with
                        the same key in a single object is undefined.¶\nNote that JSON Schema vocabularies are free to define their own extended
                        type system.  This should not be confused with the core data model types
                        defined here.  As an example, "integer" is a reasonable type for a
                        vocabulary to define as a value for a keyword, but the data model
                        makes no distinction between integers and other numbers.¶\n4.2.2. Instance Equality\nTwo JSON instances are said to be equal if and only if they are of the same type
                        and have the same value according to the data model. Specifically, this means:¶\nboth are strings, and are the same codepoint-for-codepoint; or¶\nboth are numbers, and have the same mathematical value; or¶\nboth are arrays, and have an equal value item-for-item; or¶\nboth are objects, and each property in one has exactly one property with
                                a key equal to the other's, and that other property has an equal
                                value.¶\nImplied in this definition is that arrays must be the same length,
                        objects must have the same number of members,
                        properties in objects are unordered,
                        there is no way to define multiple properties with the same key,
                        and mere formatting differences (indentation, placement of commas, trailing
                        zeros) are insignificant.¶\n4.2.3. Non-JSON Instances\nIt is possible to use JSON Schema with a superset of the JSON Schema data model,
                        where an instance may be outside any of the six JSON data types.¶\nIn this case, annotations still apply; but most validation keywords will not be useful,
                        as they will always pass or always fail.¶\nA custom vocabulary may define support for a superset of the core data model.
                        The schema itself may only be expressible in this superset;
                        for example, to make use of the "const" keyword.¶\n4.3. JSON Schema Documents
        

                    A JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema can itself be interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".¶

                    A JSON Schema MUST be an object or a boolean.¶

          
4.3.1. JSON Schema Objects and Keywords
          

                        Object properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of five categories:¶

            identifiers:
            
                                control schema identification through setting a URI
                                for the schema and/or changing how the base URI is determined¶

            
assertions:
            
                                produce a boolean result when applied to an instance¶

            
annotations:
            
                                attach information to an instance for application use¶

            
applicators:
            
                                apply one or more subschemas to a particular location
                                in the instance, and combine or modify their results¶

            
reserved locations:
            
                                do not directly affect results, but reserve a place
                                for a specific purpose to ensure interoperability¶

          


                        Keywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.¶

                        Keywords which are properties within the same schema object are referred to as adjacent keywords.¶

                        Extension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.¶

                        A JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be treated as annotations, where the value
                        of the keyword is the value of the annotation.¶

                        An empty schema is a JSON Schema with no properties, or only unknown
                        properties.¶


          
4.3.2. Boolean JSON Schemas
          

                        The boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertion results, regardless of the
                        instance value.  They never produce annotation results.¶

                        These boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).¶

            true:
            
                                Always passes validation, as if the empty schema {}¶

            
false:
            
                                Always fails validation, as if the schema { "not": {} }¶

          


                        While the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.¶


          
4.3.3. Schema Vocabularies
          

                        A schema vocabulary, or simply a vocabulary, is a set of keywords,
                        their syntax, and their semantics.  A vocabulary is generally organized
                        around a particular purpose.  Different uses of JSON Schema, such
                        as validation, hypermedia, or user interface generation, will
                        involve different sets of vocabularies.¶

                        Vocabularies are the primary unit of re-use in JSON Schema, as schema
                        authors can indicate what vocabularies are required or optional in
                        order to process the schema.  Since vocabularies are identified by URIs
                        in the meta-schema, generic implementations can load extensions to support
                        previously unknown vocabularies.  While keywords can be supported outside
                        of any vocabulary, there is no analogous mechanism to indicate individual
                        keyword usage.¶

                        A schema vocabulary can be defined by anything from an informal description
                        to a standards proposal, depending on the audience and interoperability
                        expectations.  In particular, in order to facilitate vocabulary use within
                        non-public organizations, a vocabulary specification need not be published
                        outside of its scope of use.¶


          
4.3.4. Meta-Schemas
          

                        A schema that itself describes a schema is called a meta-schema.
                        Meta-schemas are used to validate JSON Schemas and specify which vocabularies
                        they are using.¶

                        Typically, a meta-schema will specify a set of vocabularies, and validate
                        schemas that conform to the syntax of those vocabularies.  However, meta-schemas
                        and vocabularies are separate in order to allow meta-schemas to validate
                        schema conformance more strictly or more loosely than the vocabularies'
                        specifications call for.  Meta-schemas may also describe and validate
                        additional keywords that are not part of a formal vocabulary.¶



          
4.3.5. Root Schema and Subschemas and Resources
          

                        A JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶

                        The root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶

                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:¶


{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶


                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶

                        As with the root schema, a subschema is either an object or a boolean.¶

                        As discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶

                        Whether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n4.3. JSON Schema Documents\nJSON Schema Documents\nA JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema can itself be interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".¶\nA JSON Schema MUST be an object or a boolean.¶\n4.3.1. JSON Schema Objects and Keywords\nJSON Schema Objects and Keywords\nObject properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of five categories:¶\nKeywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.¶\nKeywords which are properties within the same schema object are referred to as adjacent keywords.¶\nExtension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.¶\nA JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be treated as annotations, where the value
                        of the keyword is the value of the annotation.¶\nAn empty schema is a JSON Schema with no properties, or only unknown
                        properties.¶\n4.3.2. Boolean JSON Schemas\nThe boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertion results, regardless of the
                        instance value.  They never produce annotation results.¶\nThese boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).¶\nWhile the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.¶\n4.3.3. Schema Vocabularies\nA schema vocabulary, or simply a vocabulary, is a set of keywords,
                        their syntax, and their semantics.  A vocabulary is generally organized
                        around a particular purpose.  Different uses of JSON Schema, such
                        as validation, hypermedia, or user interface generation, will
                        involve different sets of vocabularies.¶\nVocabularies are the primary unit of re-use in JSON Schema, as schema
                        authors can indicate what vocabularies are required or optional in
                        order to process the schema.  Since vocabularies are identified by URIs
                        in the meta-schema, generic implementations can load extensions to support
                        previously unknown vocabularies.  While keywords can be supported outside
                        of any vocabulary, there is no analogous mechanism to indicate individual
                        keyword usage.¶\nA schema vocabulary can be defined by anything from an informal description
                        to a standards proposal, depending on the audience and interoperability
                        expectations.  In particular, in order to facilitate vocabulary use within
                        non-public organizations, a vocabulary specification need not be published
                        outside of its scope of use.¶\nA schema that itself describes a schema is called a meta-schema.
                        Meta-schemas are used to validate JSON Schemas and specify which vocabularies
                        they are using.¶\nTypically, a meta-schema will specify a set of vocabularies, and validate
                        schemas that conform to the syntax of those vocabularies.  However, meta-schemas
                        and vocabularies are separate in order to allow meta-schemas to validate
                        schema conformance more strictly or more loosely than the vocabularies'
                        specifications call for.  Meta-schemas may also describe and validate
                        additional keywords that are not part of a formal vocabulary.¶\n4.3.5. Root Schema and Subschemas and Resources
          

                        A JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶

                        The root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶

                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:¶


{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶


                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶

                        As with the root schema, a subschema is either an object or a boolean.¶

                        As discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶

                        Whether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n4.3.5. Root Schema and Subschemas and Resources\nRoot Schema and Subschemas and Resources\nA JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶\ncanonically [RFC6596]\nabsolute URI [RFC3986]\nsection 3.5 of RFC 3986 [RFC3986]\nsection 3.5 of RFC 3986\nThe root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶\nNote that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.\nSome keywords take schemas themselves, allowing JSON Schemas to be nested:¶\n{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶\nIn this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶\nAs with the root schema, a subschema is either an object or a boolean.¶\nAs discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶\nWhether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n5. Fragment Identifiers
      

                In accordance with section 3.1 of RFC 6839 [RFC6839],
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)¶

                Additionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.¶

                The use of JSON Pointers as URI fragment identifiers is described in
                RFC 6901 [RFC6901].
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.¶

                Per the W3C's
                best practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025],
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.¶

                Defining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the "$anchor" keyword (Section 8.2.2) section.¶\n5. Fragment Identifiers\nIn accordance with section 3.1 of RFC 6839 [RFC6839],
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)¶\nAdditionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.¶\nThe use of JSON Pointers as URI fragment identifiers is described in
                RFC 6901 [RFC6901].
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.¶\nPer the W3C's
                best practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025],
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.¶\nbest practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025]\nbest practices for fragment identifiers\nW3C.WD-fragid-best-practices-20121025\nDefining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the "$anchor" keyword (Section 8.2.2) section.¶\n"$anchor" keyword (Section 8.2.2)\n6. General Considerations\nGeneral Considerations\n6.1. Range of JSON Values\nAn instance may be any valid JSON value as defined by JSON [RFC8259].
                    JSON Schema imposes no restrictions on type: JSON Schema can describe any JSON
                    value, including, for example, null.¶\n6.2. Programming Language Independence
        

                    JSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.¶\n6.2. Programming Language Independence\nProgramming Language Independence\nJSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.¶\n6.3. Mathematical Integers
        

                    Some programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.¶

                    For consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.¶\n6.3. Mathematical Integers\nMathematical Integers\nSome programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.¶\nFor consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.¶\n6.4. Regular Expressions
        

                    Keywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                    These regular expressions SHOULD be valid according to the regular expression
                    dialect described in ECMA-262, section 21.2.1 [ecma262].¶

                    Regular expressions SHOULD be built with the "u" flag (or equivalent) to provide
                    Unicode support, or processed in such a way which provides Unicode support as
                    defined by ECMA-262.¶

                    Furthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:¶

individual Unicode characters, as defined by the JSON specification [RFC8259];¶

          simple character classes ([abc]), range character classes ([a-z]);¶

          complemented character classes ([^abc], [^a-z]);¶

          simple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");¶

          range quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;¶

          the beginning-of-input ("^") and end-of-input ("$") anchors;¶

          simple grouping ("(...)") and alternation ("|").¶

        

                    Finally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".¶\n6.4. Regular Expressions\nKeywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                    These regular expressions SHOULD be valid according to the regular expression
                    dialect described in ECMA-262, section 21.2.1 [ecma262].¶\nECMA-262, section 21.2.1 [ecma262]\nECMA-262, section 21.2.1\nRegular expressions SHOULD be built with the "u" flag (or equivalent) to provide
                    Unicode support, or processed in such a way which provides Unicode support as
                    defined by ECMA-262.¶\nFurthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:¶\nindividual Unicode characters, as defined by the JSON specification [RFC8259];¶\nJSON specification [RFC8259]\nsimple character classes ([abc]), range character classes ([a-z]);¶\ncomplemented character classes ([^abc], [^a-z]);¶\nsimple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");¶\nrange quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;¶\nthe beginning-of-input ("^") and end-of-input ("$") anchors;¶\nsimple grouping ("(...)") and alternation ("|").¶\nFinally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".¶\n6.5. Extending JSON Schema
        

                    Additional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD treat keywords they do not support as annotations,
                    where the value of the keyword is the value of the annotation.¶

                    Implementations MAY provide the ability to register or load handlers
                    for vocabularies that they do not support directly.  The exact mechanism
                    for registering and implementing such handlers is implementation-dependent.¶\n6.5. Extending JSON Schema\nExtending JSON Schema\nAdditional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD treat keywords they do not support as annotations,
                    where the value of the keyword is the value of the annotation.¶\nImplementations MAY provide the ability to register or load handlers
                    for vocabularies that they do not support directly.  The exact mechanism
                    for registering and implementing such handlers is implementation-dependent.¶\nJSON Schema keywords fall into several general behavior categories.
                Assertions validate that an instance satisfies constraints, producing
                a boolean result.  Annotations attach information that applications
                may use in any way they see fit.
                Applicators apply subschemas to parts of the instance and combine
                their results.¶\nExtension keywords SHOULD stay within these categories, keeping in mind
                that annotations in particular are extremely flexible.  Complex behavior
                is usually better delegated to applications on the basis of annotation
                data than implemented directly as schema keywords.  However, extension
                keywords MAY define other behaviors for specialized purposes.¶\nEvaluating an instance against a schema involves processing all of the
                keywords in the schema against the appropriate locations within the instance.
                Typically, applicator keywords are processed until a schema object with no
                applicators (and therefore no subschemas) is reached.  The appropriate
                location in the instance is evaluated against the assertion and
                annotation keywords in the schema object, and their results are gathered
                into the parent schema according to the rules of the applicator.¶\nEvaluation of a parent schema object can complete once all of its
                subschemas have been evaluated, although in some circumstances evaluation
                may be short-circuited due to assertion results.  When annotations are
                being collected, some assertion result short-circuiting is not possible
                due to the need to examine all subschemas for annotation collection, including
                those that cannot further change the assertion result.¶\n7.1. Lexical Scope and Dynamic Scope
        

                    While most JSON Schema keywords can be evaluated on their own,
                    or at most need to take into account the values or results of
                    adjacent keywords in the same schema object, a few have more
                    complex behavior.¶

                    The lexical scope of a keyword is determined by the nested JSON
                    data structure of objects and arrays.  The largest such scope
                    is an entire schema document.  The smallest scope is a single
                    schema object with no subschemas.¶

                    Keywords MAY be defined with a partial value, such as a URI-reference,
                    which must be resolved against another value, such as another
                    URI-reference or a full URI, which is found through the lexical
                    structure of the JSON document.  The "$id", "$ref", and
                    "$dynamicRef" core keywords, and the "base" JSON Hyper-Schema
                    keyword, are examples of this sort of behavior.¶

                    Note that some keywords, such as "$schema", apply to the lexical
                    scope of the entire schema resource, and therefore MUST only
                    appear in a schema resource's root schema.¶

                    Other keywords may take into account the dynamic scope that
                    exists during the evaluation of a schema, typically together
                    with an instance document.
                    The outermost dynamic scope is the schema object at
                    which processing begins, even if it is not a schema resource root.
                    The path from this root schema to any particular keyword (that
                    includes any "$ref" and "$dynamicRef" keywords that may have
                    been resolved) is considered the keyword's "validation path."¶

                    Lexical and dynamic scopes align until a reference keyword
                    is encountered.  While following the reference keyword moves processing
                    from one lexical scope into a different one, from the perspective
                    of dynamic scope, following a reference is no different from descending
                    into a subschema present as a value.  A keyword on the far side of
                    that reference that resolves information through the dynamic scope
                    will consider the originating side of the reference to be their
                    dynamic parent, rather than examining the local lexically enclosing parent.¶

                    The concept of dynamic scope is primarily used with "$dynamicRef" and
                    "$dynamicAnchor", and should be considered an advanced feature
                    and used with caution when defining additional keywords.  It also appears
                    when reporting errors and collected annotations, as it may be possible
                    to revisit the same lexical scope repeatedly with different dynamic
                    scopes.  In such cases, it is important to inform the user of the
                    dynamic path that produced the error or annotation.¶\n7.1. Lexical Scope and Dynamic Scope\nLexical Scope and Dynamic Scope\nWhile most JSON Schema keywords can be evaluated on their own,
                    or at most need to take into account the values or results of
                    adjacent keywords in the same schema object, a few have more
                    complex behavior.¶\nThe lexical scope of a keyword is determined by the nested JSON
                    data structure of objects and arrays.  The largest such scope
                    is an entire schema document.  The smallest scope is a single
                    schema object with no subschemas.¶\nKeywords MAY be defined with a partial value, such as a URI-reference,
                    which must be resolved against another value, such as another
                    URI-reference or a full URI, which is found through the lexical
                    structure of the JSON document.  The "$id", "$ref", and
                    "$dynamicRef" core keywords, and the "base" JSON Hyper-Schema
                    keyword, are examples of this sort of behavior.¶\nNote that some keywords, such as "$schema", apply to the lexical
                    scope of the entire schema resource, and therefore MUST only
                    appear in a schema resource's root schema.¶\nOther keywords may take into account the dynamic scope that
                    exists during the evaluation of a schema, typically together
                    with an instance document.
                    The outermost dynamic scope is the schema object at
                    which processing begins, even if it is not a schema resource root.
                    The path from this root schema to any particular keyword (that
                    includes any "$ref" and "$dynamicRef" keywords that may have
                    been resolved) is considered the keyword's "validation path."¶\nLexical and dynamic scopes align until a reference keyword
                    is encountered.  While following the reference keyword moves processing
                    from one lexical scope into a different one, from the perspective
                    of dynamic scope, following a reference is no different from descending
                    into a subschema present as a value.  A keyword on the far side of
                    that reference that resolves information through the dynamic scope
                    will consider the originating side of the reference to be their
                    dynamic parent, rather than examining the local lexically enclosing parent.¶\nThe concept of dynamic scope is primarily used with "$dynamicRef" and
                    "$dynamicAnchor", and should be considered an advanced feature
                    and used with caution when defining additional keywords.  It also appears
                    when reporting errors and collected annotations, as it may be possible
                    to revisit the same lexical scope repeatedly with different dynamic
                    scopes.  In such cases, it is important to inform the user of the
                    dynamic path that produced the error or annotation.¶\n7.2. Keyword Interactions\nKeyword behavior MAY be defined in terms of the annotation results
                    of subschemas (Section 4.3.5) and/or adjacent keywords
                    (keywords within the same schema object) and their subschemas.
                    Such keywords MUST NOT result in a circular dependency.
                    Keywords MAY modify their behavior based on the presence or absence
                    of another keyword in the same
                    schema object (Section 4.3).¶\nsubschemas (Section 4.3.5)\nschema object (Section 4.3)\n7.3. Default Behaviors\nA missing keyword MUST NOT produce a false assertion result, MUST
                    NOT produce annotation results, and MUST NOT cause any other schema
                    to be evaluated as part of its own behavioral definition.
                    However, given that missing keywords do not contribute annotations,
                    the lack of annotation results may indirectly change the behavior
                    of other keywords.¶\nIn some cases, the missing keyword assertion behavior of a keyword is
                    identical to that produced by a certain value, and keyword definitions
                    SHOULD note such values where known.  However, even if the value which
                    produces the default behavior would produce annotation results if
                    present, the default behavior still MUST NOT result in annotations.¶\nBecause annotation collection can add significant cost in terms of both
                    computation and memory, implementations MAY opt out of this feature.
                    Keywords that are specified in terms of collected annotations SHOULD
                    describe reasonable alternate approaches when appropriate.
                    This approach is demonstrated by the
                    "items" and
                    "additionalProperties" keywords in this
                    document.¶\nNote that when no such alternate approach is possible for a keyword,
                    implementations that do not support annotation collections will not
                    be able to support those keywords or vocabularies that contain them.¶\nIdentifiers define URIs for a schema, or affect how such URIs are
                    resolved in references (Section 8.2.3), or both.
                    The Core vocabulary defined in this document defines several
                    identifying keywords, most notably "$id".¶\nreferences (Section 8.2.3)\nCanonical schema URIs MUST NOT change while processing an instance, but
                    keywords that affect URI-reference resolution MAY have behavior that
                    is only fully determined at runtime.¶\nWhile custom identifier keywords are possible, vocabulary designers should
                    take care not to disrupt the functioning of core keywords. For example,
                    the "$dynamicAnchor" keyword in this specification limits its URI resolution
                    effects to the matching "$dynamicRef" keyword, leaving the behavior
                    of "$ref" undisturbed.¶\n7.5. Applicators
        

                    Applicators allow for building more complex schemas than can be accomplished
                    with a single schema object.  Evaluation of an instance against a
                    schema document (Section 4.3) begins by applying
                    the root schema (Section 4.3.5) to the complete instance
                    document.  From there, keywords known as applicators are used to determine
                    which additional schemas are applied.  Such schemas may be applied in-place
                    to the current location, or to a child location.¶

                    The schemas to be applied may be present as subschemas comprising all or
                    part of the keyword's value.  Alternatively, an applicator may refer to
                    a schema elsewhere in the same schema document, or in a different one.
                    The mechanism for identifying such referenced schemas is defined by the
                    keyword.¶

                    Applicator keywords also define how subschema or referenced schema
                    boolean assertion (Section 7.6)
                    results are modified and/or combined to produce the boolean result
                    of the applicator.  Applicators may apply any boolean logic operation
                    to the assertion results of subschemas, but MUST NOT introduce new
                    assertion conditions of their own.¶

                    Annotation (Section 7.7) results are
                    preserved along with the instance location and the location of
                    the schema keyword, so that applications can decide how to
                    interpret multiple values.¶


          
7.5.1. Referenced and Referencing Schemas
          

                        As noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶

                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶

                        For some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\nApplicators allow for building more complex schemas than can be accomplished
                    with a single schema object.  Evaluation of an instance against a
                    schema document (Section 4.3) begins by applying
                    the root schema (Section 4.3.5) to the complete instance
                    document.  From there, keywords known as applicators are used to determine
                    which additional schemas are applied.  Such schemas may be applied in-place
                    to the current location, or to a child location.¶\nschema document (Section 4.3)\nroot schema (Section 4.3.5)\nThe schemas to be applied may be present as subschemas comprising all or
                    part of the keyword's value.  Alternatively, an applicator may refer to
                    a schema elsewhere in the same schema document, or in a different one.
                    The mechanism for identifying such referenced schemas is defined by the
                    keyword.¶\nApplicator keywords also define how subschema or referenced schema
                    boolean assertion (Section 7.6)
                    results are modified and/or combined to produce the boolean result
                    of the applicator.  Applicators may apply any boolean logic operation
                    to the assertion results of subschemas, but MUST NOT introduce new
                    assertion conditions of their own.¶\nassertion (Section 7.6)\nAnnotation (Section 7.7) results are
                    preserved along with the instance location and the location of
                    the schema keyword, so that applications can decide how to
                    interpret multiple values.¶\nAnnotation (Section 7.7)\n7.5.1. Referenced and Referencing Schemas
          

                        As noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶

                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶

                        For some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\n7.5.1. Referenced and Referencing Schemas\nReferenced and Referencing Schemas\nAs noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶\nWhile root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶\nFor some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\n"$ref" (Section 8.2.3.1)\n7.6. Assertions
        

                    JSON Schema can be used to assert constraints on a JSON document, which
                    either passes or fails the assertions.  This approach can be used to validate
                    conformance with the constraints, or document what is needed to satisfy them.¶

                    JSON Schema implementations produce a single boolean result when evaluating
                    an instance against schema assertions.¶

                    An instance can only fail an assertion that is present in the schema.¶

          
7.6.1. Assertions and Instance Primitive Types
          

                        Most assertions only constrain values within a certain
                        primitive type.  When the type of the instance is not of the type
                        targeted by the keyword, the instance is considered to conform
                        to the assertion.¶

                        For example, the "maxLength" keyword from the companion
                        validation vocabulary [json-schema-validation]:
                        will only restrict certain strings
                        (that are too long) from being valid.  If the instance is a number,
                        boolean, null, array, or object, then it is valid against this assertion.¶

                        This behavior allows keywords to be used more easily with instances
                        that can be of multiple primitive types.  The companion validation
                        vocabulary also includes a "type" keyword which can independently
                        restrict the instance to one or more primitive types.  This allows
                        for a concise expression of use cases such as a function that might
                        return either a string of a certain length or a null value:¶


{
    "type": ["string", "null"],
    "maxLength": 255
}

¶


                            If "maxLength" also restricted the instance type to be a string,
                            then this would be substantially more cumbersome to express because
                            the example as written would not actually allow null values.
                            Each keyword is evaluated separately unless explicitly specified
                            otherwise, so if "maxLength" restricted the instance to strings,
                            then including "null" in "type" would not have any useful effect.¶\nJSON Schema can be used to assert constraints on a JSON document, which
                    either passes or fails the assertions.  This approach can be used to validate
                    conformance with the constraints, or document what is needed to satisfy them.¶\nJSON Schema implementations produce a single boolean result when evaluating
                    an instance against schema assertions.¶\nAn instance can only fail an assertion that is present in the schema.¶\n7.6.1. Assertions and Instance Primitive Types\nAssertions and Instance Primitive Types\nMost assertions only constrain values within a certain
                        primitive type.  When the type of the instance is not of the type
                        targeted by the keyword, the instance is considered to conform
                        to the assertion.¶\nFor example, the "maxLength" keyword from the companion
                        validation vocabulary [json-schema-validation]:
                        will only restrict certain strings
                        (that are too long) from being valid.  If the instance is a number,
                        boolean, null, array, or object, then it is valid against this assertion.¶\nvalidation vocabulary [json-schema-validation]\nvalidation vocabulary\njson-schema-validation\nThis behavior allows keywords to be used more easily with instances
                        that can be of multiple primitive types.  The companion validation
                        vocabulary also includes a "type" keyword which can independently
                        restrict the instance to one or more primitive types.  This allows
                        for a concise expression of use cases such as a function that might
                        return either a string of a certain length or a null value:¶\n{
    "type": ["string", "null"],
    "maxLength": 255
}

¶\nIf "maxLength" also restricted the instance type to be a string,
                            then this would be substantially more cumbersome to express because
                            the example as written would not actually allow null values.
                            Each keyword is evaluated separately unless explicitly specified
                            otherwise, so if "maxLength" restricted the instance to strings,
                            then including "null" in "type" would not have any useful effect.¶\n7.7. Annotations
        

                    JSON Schema can annotate an instance with information, whenever the instance
                    validates against the schema object containing the annotation, and all of its
                    parent schema objects.  The information can be a simple value, or can be
                    calculated based on the instance contents.¶

                    Annotations are attached to specific locations in an instance.
                    Since many subschemas can be applied to any single
                    location, applications may need to decide how to handle differing
                    annotation values being attached to the same instance location by
                    the same schema keyword in different schema objects.¶

                    Unlike assertion results, annotation data can take a wide variety of forms,
                    which are provided to applications to use as they see fit.  JSON Schema
                    implementations are not expected to make use of the collected information
                    on behalf of applications.¶

                    Unless otherwise specified, the value of an annotation keyword
                    is the keyword's value.  However, other behaviors are possible.
                    For example, JSON Hyper-Schema's [json-hyper-schema]
                    "links" keyword is a complex annotation that produces a value based
                    in part on the instance data.¶

                    While "short-circuit" evaluation is possible for assertions, collecting
                    annotations requires examining all schemas that apply to an instance
                    location, even if they cannot change the overall assertion result.
                    The only exception is that subschemas of a schema object that has
                    failed validation MAY be skipped, as annotations are not retained
                    for failing schemas.¶

          
7.7.1. Collecting Annotations
          

                        Annotations are collected by keywords that explicitly define
                        annotation-collecting behavior.  Note that boolean schemas cannot
                        produce annotations as they do not make use of keywords.¶

                        A collected annotation MUST include the following information:¶


                                The name of the keyword that produces the annotation¶

            
                                The instance location to which it is attached, as a JSON Pointer¶

            
                                The schema location path, indicating how reference keywords
                                such as "$ref" were followed to reach the absolute schema location.¶

            
                                The absolute schema location of the attaching keyword, as a URI.
                                This MAY be omitted if it is the same as the schema location path
                                from above.¶

            
                                The attached value(s)¶

          

            
7.7.1.1. Distinguishing Among Multiple Values
            

                            Applications MAY make decisions on which of multiple annotation values
                            to use based on the schema location that contributed the value.
                            This is intended to allow flexible usage.  Collecting the schema location
                            facilitates such usage.¶

                            For example, consider this schema, which uses annotations and assertions from
                            the Validation specification [json-schema-validation]:¶

                                Note that some lines are wrapped for clarity.¶


{
    "title": "Feature list",
    "type": "array",
    "prefixItems": [
        {
            "title": "Feature A",
            "properties": {
                "enabled": {
                    "$ref": "#/$defs/enabledToggle",
                    "default": true
                }
            }
        },
        {
            "title": "Feature B",
            "properties": {
                "enabled": {
                    "description": "If set to null, Feature B
                                    inherits the enabled
                                    value from Feature A",
                    "$ref": "#/$defs/enabledToggle"
                }
            }
        }
    ],
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}

¶


                            In this example, both Feature A and Feature B make use of the re-usable
                            "enabledToggle" schema.  That schema uses the "title", "description",
                            and "default" annotations.  Therefore the application has to decide how
                            to handle the additional "default" value for Feature A, and the additional
                            "description" value for Feature B.¶

                            The application programmer and the schema author need to agree on the
                            usage.  For this example, let's assume that they agree that the most
                            specific "default" value will be used, and any additional, more generic
                            "default" values will be silently ignored.  Let's also assume that they
                            agree that all "description" text is to be used, starting with the most
                            generic, and ending with the most specific.  This requires the schema
                            author to write descriptions that work when combined in this way.¶

                            The application can use the schema location path to determine which
                            values are which.  The values in the feature's immediate "enabled"
                            property schema are more specific, while the values under the re-usable
                            schema that is referenced to with "$ref" are more generic.  The schema
                            location path will show whether each value was found by crossing a
                            "$ref" or not.¶

                            Feature A will therefore use a default value of true, while Feature B
                            will use the generic default value of null.  Feature A will only
                            have the generic description from the "enabledToggle" schema, while
                            Feature B will use that description, and also append its locally
                            defined description that explains how to interpret a null value.¶

                            Note that there are other reasonable approaches that a different application
                            might take.  For example, an application may consider the presence of
                            two different values for "default" to be an error, regardless of their
                            schema locations.¶


            
7.7.1.2. Annotations and Assertions
            

                            Schema objects that produce a false assertion result MUST NOT
                            produce any annotation results, whether from their own keywords
                            or from keywords in subschemas.¶

                            Note that the overall schema results may still include annotations
                            collected from other schema locations.  Given this schema:¶


{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}

¶


                            Against the instance "This is a string", the
                            title annotation "Integer Value" is discarded because the type assertion
                            in that schema object fails.  The title annotation "String Value"
                            is kept, as the instance passes the string type assertions.¶


            
7.7.1.3. Annotations and Applicators
            

                            In addition to possibly defining annotation results of their own,
                            applicator keywords aggregate the annotations collected in their
                            subschema(s) or referenced schema(s).¶\nJSON Schema can annotate an instance with information, whenever the instance
                    validates against the schema object containing the annotation, and all of its
                    parent schema objects.  The information can be a simple value, or can be
                    calculated based on the instance contents.¶\nAnnotations are attached to specific locations in an instance.
                    Since many subschemas can be applied to any single
                    location, applications may need to decide how to handle differing
                    annotation values being attached to the same instance location by
                    the same schema keyword in different schema objects.¶\nUnlike assertion results, annotation data can take a wide variety of forms,
                    which are provided to applications to use as they see fit.  JSON Schema
                    implementations are not expected to make use of the collected information
                    on behalf of applications.¶\nUnless otherwise specified, the value of an annotation keyword
                    is the keyword's value.  However, other behaviors are possible.
                    For example, JSON Hyper-Schema's [json-hyper-schema]
                    "links" keyword is a complex annotation that produces a value based
                    in part on the instance data.¶\nJSON Hyper-Schema's [json-hyper-schema]\nWhile "short-circuit" evaluation is possible for assertions, collecting
                    annotations requires examining all schemas that apply to an instance
                    location, even if they cannot change the overall assertion result.
                    The only exception is that subschemas of a schema object that has
                    failed validation MAY be skipped, as annotations are not retained
                    for failing schemas.¶\n7.7.1. Collecting Annotations\nCollecting Annotations\nAnnotations are collected by keywords that explicitly define
                        annotation-collecting behavior.  Note that boolean schemas cannot
                        produce annotations as they do not make use of keywords.¶\nA collected annotation MUST include the following information:¶\nThe name of the keyword that produces the annotation¶\nThe instance location to which it is attached, as a JSON Pointer¶\nThe schema location path, indicating how reference keywords
                                such as "$ref" were followed to reach the absolute schema location.¶\nThe absolute schema location of the attaching keyword, as a URI.
                                This MAY be omitted if it is the same as the schema location path
                                from above.¶\nThe attached value(s)¶\n7.7.1.1. Distinguishing Among Multiple Values\nDistinguishing Among Multiple Values\nApplications MAY make decisions on which of multiple annotation values
                            to use based on the schema location that contributed the value.
                            This is intended to allow flexible usage.  Collecting the schema location
                            facilitates such usage.¶\nFor example, consider this schema, which uses annotations and assertions from
                            the Validation specification [json-schema-validation]:¶\nValidation specification [json-schema-validation]\nValidation specification\njson-schema-validation\nNote that some lines are wrapped for clarity.¶\n{
    "title": "Feature list",
    "type": "array",
    "prefixItems": [
        {
            "title": "Feature A",
            "properties": {
                "enabled": {
                    "$ref": "#/$defs/enabledToggle",
                    "default": true
                }
            }
        },
        {
            "title": "Feature B",
            "properties": {
                "enabled": {
                    "description": "If set to null, Feature B
                                    inherits the enabled
                                    value from Feature A",
                    "$ref": "#/$defs/enabledToggle"
                }
            }
        }
    ],
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}

¶\nIn this example, both Feature A and Feature B make use of the re-usable
                            "enabledToggle" schema.  That schema uses the "title", "description",
                            and "default" annotations.  Therefore the application has to decide how
                            to handle the additional "default" value for Feature A, and the additional
                            "description" value for Feature B.¶\nThe application programmer and the schema author need to agree on the
                            usage.  For this example, let's assume that they agree that the most
                            specific "default" value will be used, and any additional, more generic
                            "default" values will be silently ignored.  Let's also assume that they
                            agree that all "description" text is to be used, starting with the most
                            generic, and ending with the most specific.  This requires the schema
                            author to write descriptions that work when combined in this way.¶\nThe application can use the schema location path to determine which
                            values are which.  The values in the feature's immediate "enabled"
                            property schema are more specific, while the values under the re-usable
                            schema that is referenced to with "$ref" are more generic.  The schema
                            location path will show whether each value was found by crossing a
                            "$ref" or not.¶\nFeature A will therefore use a default value of true, while Feature B
                            will use the generic default value of null.  Feature A will only
                            have the generic description from the "enabledToggle" schema, while
                            Feature B will use that description, and also append its locally
                            defined description that explains how to interpret a null value.¶\nNote that there are other reasonable approaches that a different application
                            might take.  For example, an application may consider the presence of
                            two different values for "default" to be an error, regardless of their
                            schema locations.¶\n7.7.1.2. Annotations and Assertions\nAnnotations and Assertions\nSchema objects that produce a false assertion result MUST NOT
                            produce any annotation results, whether from their own keywords
                            or from keywords in subschemas.¶\nNote that the overall schema results may still include annotations
                            collected from other schema locations.  Given this schema:¶\n{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}

¶\nAgainst the instance "This is a string", the
                            title annotation "Integer Value" is discarded because the type assertion
                            in that schema object fails.  The title annotation "String Value"
                            is kept, as the instance passes the string type assertions.¶\n7.7.1.3. Annotations and Applicators\nAnnotations and Applicators\nIn addition to possibly defining annotation results of their own,
                            applicator keywords aggregate the annotations collected in their
                            subschema(s) or referenced schema(s).¶\n7.8. Reserved Locations\nA fourth category of keywords simply reserve a location to hold re-usable
                    components or data of interest to schema authors that is not suitable
                    for re-use.  These keywords do not affect validation or annotation results.
                    Their purpose in the core vocabulary is to ensure that locations are
                    available for certain purposes and will not be redefined by extension
                    keywords.¶\nWhile these keywords do not directly affect results, as explained in section
                    9.4.2 unrecognized
                    extension keywords that reserve locations for re-usable schemas may have
                    undesirable interactions with references in certain circumstances.¶\n7.9. Loading Instance Data\nLoading Instance Data\nWhile none of the vocabularies defined as part of this or the associated documents
                    define a keyword which may target and/or load instance data, it is possible that
                    other vocabularies may wish to do so.¶\nKeywords MAY be defined to use JSON Pointers or Relative JSON Pointers to examine
                    parts of an instance outside the current evaluation location.¶\nKeywords that allow adjusting the location using a Relative JSON Pointer SHOULD
                    default to using the current location if a default is desireable.¶\n8. The JSON Schema Core Vocabulary\nThe JSON Schema Core Vocabulary\nKeywords declared in this section, which all begin with "$", make up
                the JSON Schema Core vocabulary.  These keywords are either required in
                order to process any schema or meta-schema, including those split across
                multiple documents, or exist to reserve keywords for purposes that
                require guaranteed interoperability.¶\nThe Core vocabulary MUST be considered mandatory at all times, in order
                to bootstrap the processing of further vocabularies.  Meta-schemas
                that use the "$vocabulary" (Section 8.1) keyword
                to declare the vocabularies in use MUST explicitly list the Core vocabulary,
                which MUST have a value of true indicating that it is required.¶\n"$vocabulary" (Section 8.1)\nThe behavior of a false value for this vocabulary (and only this
                vocabulary) is undefined, as is the behavior when "$vocabulary"
                is present but the Core vocabulary is not included.  However, it
                is RECOMMENDED that implementations detect these cases and raise
                an error when they occur.  It is not meaningful to declare that
                a meta-schema optionally uses Core.¶\nMeta-schemas that do not use "$vocabulary" MUST be considered to
                require the Core vocabulary as if its URI were present with a value of true.¶\nThe current URI for the Core vocabulary is:
                <https://json-schema.org/draft/2020-12/vocab/core>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/core.¶\nhttps://json-schema.org/draft/2020-12/meta/core\nhttps://json-schema.org/draft/2020-12/meta/core\nWhile the "$" prefix is not formally reserved for the Core vocabulary,
                it is RECOMMENDED that extension keywords (in vocabularies or otherwise)
                begin with a character other than "$" to avoid possible future collisions.¶\n8.1. Meta-Schemas and Vocabularies
        

                    Two concepts, meta-schemas and vocabularies, are used to inform an implementation
                    how to interpret a schema.  Every schema has a meta-schema, which can be declared
                    using the "$schema" keyword.¶

                    The meta-schema serves two purposes:¶

          Declaring the vocabularies in use
          
                            The "$vocabulary" keyword, when it appears in a meta-schema, declares
                            which vocabularies are available to be used in schemas that refer
                            to that meta-schema.  Vocabularies define keyword semantics,
                            as well as their general syntax.¶

          
Describing valid schema syntax
          
                            A schema MUST successfully validate against its meta-schema, which
                            constrains the syntax of the available keywords.  The syntax described
                            is expected to be compatible with the vocabularies declared; while
                            it is possible to describe an incompatible syntax, such a meta-schema
                            would be unlikely to be useful.¶

        


                    Meta-schemas are separate from vocabularies to allow for
                    vocabularies to be combined in different ways, and for meta-schema authors
                    to impose additional constraints such as forbidding certain keywords, or
                    performing unusually strict syntactical validation, as might be done
                    during a development and testing cycle.  Each vocabulary typically identifies
                    a meta-schema consisting only of the vocabulary's keywords.¶

                    Meta-schema authoring is an advanced usage of JSON Schema, so the design of
                    meta-schema features emphasizes flexibility over simplicity.¶


          
8.1.1. The "$schema" Keyword
          

                        The "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶

                        The value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶

                        If this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶

                        The "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶

                        Values for this property are defined elsewhere in this and other documents,
                        and by other parties.¶



          
8.1.2. The "$vocabulary" Keyword
          

                        The "$vocabulary" keyword is used in meta-schemas to identify the
                        vocabularies available for use in schemas described by that meta-schema.
                        It is also used to indicate whether each vocabulary is required or optional,
                        in the sense that an implementation MUST understand the required vocabularies
                        in order to successfully process the schema. Together, this information forms
                        a dialect. Any vocabulary that is understood by the implementation MUST be
                        processed in a manner consistent with the semantic definitions contained
                        within the vocabulary.¶

                        The value of this keyword MUST be an object.  The property names in the
                        object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                        Each URI that appears as a property name identifies a specific set of
                        keywords and their semantics.¶

                        The URI MAY be a URL, but the nature of the retrievable resource is
                        currently undefined, and reserved for future use.  Vocabulary authors
                        MAY use the URL of the vocabulary specification, in a human-readable
                        media type such as text/html or text/plain, as the vocabulary URI.
                        
                            Vocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.
            ¶

                        The values of the object properties MUST be booleans.
                        If the value is true, then implementations that do not recognize
                        the vocabulary MUST refuse to process any schemas that declare
                        this meta-schema with "$schema".  If the value is false, implementations
                        that do not recognize the vocabulary SHOULD proceed with processing
                        such schemas.  The value has no impact if the implementation
                        understands the vocabulary.¶

                        Per 6.5, unrecognized
                        keywords SHOULD be treated as annotations.
                        This remains the case for keywords defined
                        by unrecognized vocabularies.  It is not currently possible to distinguish
                        between unrecognized keywords that are defined in vocabularies from
                        those that are not part of any vocabulary.¶

                        The "$vocabulary" keyword SHOULD be used in the root schema of any schema
                        document intended for use as a meta-schema.  It MUST NOT appear in subschemas.¶

                        The "$vocabulary" keyword MUST be ignored in schema documents that
                        are not being processed as a meta-schema.  This allows validating
                        a meta-schema M against its own meta-schema M' without requiring
                        the validator to understand the vocabularies declared by M.¶

            
8.1.2.1. Default vocabularies
            

                            If "$vocabulary" is absent, an implementation MAY determine
                            behavior based on the meta-schema if it is recognized from the
                            URI value of the referring schema's "$schema" keyword.
                            This is how behavior (such as Hyper-Schema usage) has been
                            recognized prior to the existence of vocabularies.¶

                            If the meta-schema, as referenced by the schema, is not recognized,
                            or is missing, then the behavior is implementation-defined.
                            If the implementation
                            proceeds with processing the schema, it MUST assume the use of the
                            core vocabulary.  If the implementation is built for a specific purpose,
                            then it SHOULD assume the use of all of the most relevant vocabularies
                            for that purpose.¶

                            For example, an implementation that is a validator
                            SHOULD assume the use of all vocabularies in this
                            specification and the companion Validation specification.¶


            
8.1.2.2. Non-inheritability of vocabularies
            

                            Note that the processing restrictions on "$vocabulary" mean that
                            meta-schemas that reference other meta-schemas using "$ref" or
                            similar keywords do not automatically inherit the vocabulary
                            declarations of those other meta-schemas.  All such declarations
                            must be repeated in the root of each schema document intended
                            for use as a meta-schema.  This is demonstrated in
                            the example meta-schema (Appendix D.2).
                            
                                This requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.
              ¶



          
8.1.3. Updates to Meta-Schema and Vocabulary URIs
          

                        Updated vocabulary and meta-schema URIs MAY be published between
                        specification drafts in order to correct errors.  Implementations
                        SHOULD consider URIs dated after this specification draft and
                        before the next to indicate the same syntax and semantics
                        as those listed here.¶\n8.1. Meta-Schemas and Vocabularies\nMeta-Schemas and Vocabularies\nTwo concepts, meta-schemas and vocabularies, are used to inform an implementation
                    how to interpret a schema.  Every schema has a meta-schema, which can be declared
                    using the "$schema" keyword.¶\nThe meta-schema serves two purposes:¶\nMeta-schemas are separate from vocabularies to allow for
                    vocabularies to be combined in different ways, and for meta-schema authors
                    to impose additional constraints such as forbidding certain keywords, or
                    performing unusually strict syntactical validation, as might be done
                    during a development and testing cycle.  Each vocabulary typically identifies
                    a meta-schema consisting only of the vocabulary's keywords.¶\nMeta-schema authoring is an advanced usage of JSON Schema, so the design of
                    meta-schema features emphasizes flexibility over simplicity.¶\n8.1.1. The "$schema" Keyword
          

                        The "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶

                        The value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶

                        If this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶

                        The "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶

                        Values for this property are defined elsewhere in this and other documents,
                        and by other parties.¶\n8.1.1. The "$schema" Keyword\nThe "$schema" Keyword\nThe "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶\nThe value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶\nIf this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶\nThe "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶\nValues for this property are defined elsewhere in this and other documents,
                        and by other parties.¶\n8.1.2. The "$vocabulary" Keyword\nThe "$vocabulary" Keyword\nThe "$vocabulary" keyword is used in meta-schemas to identify the
                        vocabularies available for use in schemas described by that meta-schema.
                        It is also used to indicate whether each vocabulary is required or optional,
                        in the sense that an implementation MUST understand the required vocabularies
                        in order to successfully process the schema. Together, this information forms
                        a dialect. Any vocabulary that is understood by the implementation MUST be
                        processed in a manner consistent with the semantic definitions contained
                        within the vocabulary.¶\nThe value of this keyword MUST be an object.  The property names in the
                        object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                        Each URI that appears as a property name identifies a specific set of
                        keywords and their semantics.¶\nThe URI MAY be a URL, but the nature of the retrievable resource is
                        currently undefined, and reserved for future use.  Vocabulary authors
                        MAY use the URL of the vocabulary specification, in a human-readable
                        media type such as text/html or text/plain, as the vocabulary URI.
                        
                            Vocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.
            ¶\nVocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.\nThe values of the object properties MUST be booleans.
                        If the value is true, then implementations that do not recognize
                        the vocabulary MUST refuse to process any schemas that declare
                        this meta-schema with "$schema".  If the value is false, implementations
                        that do not recognize the vocabulary SHOULD proceed with processing
                        such schemas.  The value has no impact if the implementation
                        understands the vocabulary.¶\nPer 6.5, unrecognized
                        keywords SHOULD be treated as annotations.
                        This remains the case for keywords defined
                        by unrecognized vocabularies.  It is not currently possible to distinguish
                        between unrecognized keywords that are defined in vocabularies from
                        those that are not part of any vocabulary.¶\nThe "$vocabulary" keyword SHOULD be used in the root schema of any schema
                        document intended for use as a meta-schema.  It MUST NOT appear in subschemas.¶\nThe "$vocabulary" keyword MUST be ignored in schema documents that
                        are not being processed as a meta-schema.  This allows validating
                        a meta-schema M against its own meta-schema M' without requiring
                        the validator to understand the vocabularies declared by M.¶\n8.1.2.1. Default vocabularies\nIf "$vocabulary" is absent, an implementation MAY determine
                            behavior based on the meta-schema if it is recognized from the
                            URI value of the referring schema's "$schema" keyword.
                            This is how behavior (such as Hyper-Schema usage) has been
                            recognized prior to the existence of vocabularies.¶\nIf the meta-schema, as referenced by the schema, is not recognized,
                            or is missing, then the behavior is implementation-defined.
                            If the implementation
                            proceeds with processing the schema, it MUST assume the use of the
                            core vocabulary.  If the implementation is built for a specific purpose,
                            then it SHOULD assume the use of all of the most relevant vocabularies
                            for that purpose.¶\nFor example, an implementation that is a validator
                            SHOULD assume the use of all vocabularies in this
                            specification and the companion Validation specification.¶\n8.1.2.2. Non-inheritability of vocabularies\nNon-inheritability of vocabularies\nNote that the processing restrictions on "$vocabulary" mean that
                            meta-schemas that reference other meta-schemas using "$ref" or
                            similar keywords do not automatically inherit the vocabulary
                            declarations of those other meta-schemas.  All such declarations
                            must be repeated in the root of each schema document intended
                            for use as a meta-schema.  This is demonstrated in
                            the example meta-schema (Appendix D.2).
                            
                                This requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.
              ¶\nthe example meta-schema (Appendix D.2)\nthe example meta-schema\nThis requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.\n8.1.3. Updates to Meta-Schema and Vocabulary URIs\nUpdates to Meta-Schema and Vocabulary URIs\nUpdated vocabulary and meta-schema URIs MAY be published between
                        specification drafts in order to correct errors.  Implementations
                        SHOULD consider URIs dated after this specification draft and
                        before the next to indicate the same syntax and semantics
                        as those listed here.¶\n8.2. Base URI, Anchors, and Dereferencing\nBase URI, Anchors, and Dereferencing\nTo differentiate between schemas in a vast ecosystem, schemas are
                    identified by URI [RFC3986], and can embed references
                    to other schemas by specifying their URI.¶\nSeveral keywords can accept a relative URI-reference [RFC3986],
                    or a value used to construct a relative URI-reference.  For these keywords,
                    it is necessary to establish a base URI in order to resolve the reference.¶\nURI-reference [RFC3986]\n8.2.1. The "$id" Keyword
          

                        The "$id" keyword identifies a schema resource with its
                        canonical [RFC6596] URI.¶

                        Note that this URI is an identifier and not necessarily a network locator.
                        In the case of a network-addressable URL, a schema need not be downloadable
                        from its canonical URI.¶

                        If present, the value for this keyword MUST be a string, and MUST represent a
                        valid URI-reference [RFC3986].  This URI-reference
                        SHOULD be normalized, and MUST resolve to an
                        absolute-URI [RFC3986] (without a fragment),
                        or to a URI with an empty fragment.¶

                        The empty fragment form is NOT RECOMMENDED and is retained only
                        for backwards compatibility, and because the
                        application/schema+json media type defines that a URI with an
                        empty fragment identifies the same resource as the same URI
                        with the fragment removed.  However, since this equivalence is not
                        part of the RFC 3986 normalization process [RFC3986],
                        implementers and schema authors cannot rely on generic URI libraries
                        understanding it.¶

                        Therefore, "$id" MUST NOT contain a non-empty fragment, and SHOULD NOT
                        contain an empty fragment.  The absolute-URI form MUST be considered
                        the canonical URI, regardless of the presence or absence of an empty fragment.
                        
                            An empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".
            ¶

                        The absolute-URI also serves as the base URI for relative URI-references
                        in keywords within the schema resource, in accordance with
                        RFC 3986 section 5.1.1 [RFC3986] regarding base URIs
                        embedded in content.¶

                        The presence of "$id" in a subschema indicates that the subschema constitutes
                        a distinct schema resource within a single schema document.  Furthermore,
                        in accordance with RFC 3986 section 5.1.2 [RFC3986]
                        regarding encapsulating entities, if an "$id" in a subschema is a relative
                        URI-reference, the base URI for resolving that reference is the URI of
                        the parent schema resource.¶

                        If no parent schema object explicitly identifies itself as a resource
                        with "$id", the base URI is that of the entire document, as established
                        by the steps given in the previous section. (Section 9.1.1)¶

            
8.2.1.1. Identifying the root schema
            

                            The root schema of a JSON Schema document SHOULD contain an "$id" keyword
                            with an absolute-URI [RFC3986] (containing a scheme,
                            but no fragment).¶\n8.2.1. The "$id" Keyword\nThe "$id" keyword identifies a schema resource with its
                        canonical [RFC6596] URI.¶\nNote that this URI is an identifier and not necessarily a network locator.
                        In the case of a network-addressable URL, a schema need not be downloadable
                        from its canonical URI.¶\nIf present, the value for this keyword MUST be a string, and MUST represent a
                        valid URI-reference [RFC3986].  This URI-reference
                        SHOULD be normalized, and MUST resolve to an
                        absolute-URI [RFC3986] (without a fragment),
                        or to a URI with an empty fragment.¶\nURI-reference [RFC3986]\nabsolute-URI [RFC3986]\nThe empty fragment form is NOT RECOMMENDED and is retained only
                        for backwards compatibility, and because the
                        application/schema+json media type defines that a URI with an
                        empty fragment identifies the same resource as the same URI
                        with the fragment removed.  However, since this equivalence is not
                        part of the RFC 3986 normalization process [RFC3986],
                        implementers and schema authors cannot rely on generic URI libraries
                        understanding it.¶\nRFC 3986 normalization process [RFC3986]\nRFC 3986 normalization process\nTherefore, "$id" MUST NOT contain a non-empty fragment, and SHOULD NOT
                        contain an empty fragment.  The absolute-URI form MUST be considered
                        the canonical URI, regardless of the presence or absence of an empty fragment.
                        
                            An empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".
            ¶\nAn empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".\nThe absolute-URI also serves as the base URI for relative URI-references
                        in keywords within the schema resource, in accordance with
                        RFC 3986 section 5.1.1 [RFC3986] regarding base URIs
                        embedded in content.¶\nRFC 3986 section 5.1.1 [RFC3986]\nRFC 3986 section 5.1.1\nThe presence of "$id" in a subschema indicates that the subschema constitutes
                        a distinct schema resource within a single schema document.  Furthermore,
                        in accordance with RFC 3986 section 5.1.2 [RFC3986]
                        regarding encapsulating entities, if an "$id" in a subschema is a relative
                        URI-reference, the base URI for resolving that reference is the URI of
                        the parent schema resource.¶\nRFC 3986 section 5.1.2 [RFC3986]\nRFC 3986 section 5.1.2\nIf no parent schema object explicitly identifies itself as a resource
                        with "$id", the base URI is that of the entire document, as established
                        by the steps given in the previous section. (Section 9.1.1)¶\nprevious section. (Section 9.1.1)\n8.2.1.1. Identifying the root schema\nIdentifying the root schema\nThe root schema of a JSON Schema document SHOULD contain an "$id" keyword
                            with an absolute-URI [RFC3986] (containing a scheme,
                            but no fragment).¶\nabsolute-URI [RFC3986]\n8.2.2. Defining location-independent identifiers
          

                        Using JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.¶

                        The "$anchor" and "$dynamicAnchor" keywords are used to specify such
                        fragments.  They are identifier keywords that can only be used to create
                        plain name fragments, rather than absolute URIs as seen with "$id".¶

                        The base URI to which the resulting fragment is appended is the canonical
                        URI of the schema resource containing the "$anchor" or "$dynamicAnchor"
                        in question.  As discussed in the previous section, this is either the
                        nearest "$id" in the same or parent schema object, or the base URI
                        for the document as determined according to RFC 3986.¶

                        Separately from the usual usage of URIs, "$dynamicAnchor"
                        indicates that the fragment is an extension point when used with
                        the "$dynamicRef" keyword.  This low-level, advanced feature
                        makes it easier to extend recursive schemas such as the meta-schemas,
                        without imposing any particular semantics on that extension.
                        See the section on "$dynamicRef" (Section 8.2.3.2)
                        for details.¶

                        In most cases, the normal fragment behavior both suffices and
                        is more intuitive.  Therefore it is RECOMMENDED that "$anchor"
                        be used to create plain name fragments unless there is a clear
                        need for "$dynamicAnchor".¶

                        If present, the value of this keyword MUST be a string and MUST start with
                        a letter ([A-Za-z]) or underscore ("_"), followed by any number of letters,
                        digits ([0-9]), hyphens ("-"), underscores ("_"), and periods (".").
                        This matches the US-ASCII part of XML's
                        NCName production [xml-names].
                        
                            Note that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.
            ¶

                        The effect of specifying the same fragment name multiple times within
                        the same resource, using any combination of "$anchor" and/or
                        "$dynamicAnchor", is undefined.  Implementations MAY
                        raise an error if such usage is detected.¶\n8.2.2. Defining location-independent identifiers\nDefining location-independent identifiers\nUsing JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.¶\nThe "$anchor" and "$dynamicAnchor" keywords are used to specify such
                        fragments.  They are identifier keywords that can only be used to create
                        plain name fragments, rather than absolute URIs as seen with "$id".¶\nThe base URI to which the resulting fragment is appended is the canonical
                        URI of the schema resource containing the "$anchor" or "$dynamicAnchor"
                        in question.  As discussed in the previous section, this is either the
                        nearest "$id" in the same or parent schema object, or the base URI
                        for the document as determined according to RFC 3986.¶\nSeparately from the usual usage of URIs, "$dynamicAnchor"
                        indicates that the fragment is an extension point when used with
                        the "$dynamicRef" keyword.  This low-level, advanced feature
                        makes it easier to extend recursive schemas such as the meta-schemas,
                        without imposing any particular semantics on that extension.
                        See the section on "$dynamicRef" (Section 8.2.3.2)
                        for details.¶\n"$dynamicRef" (Section 8.2.3.2)\nIn most cases, the normal fragment behavior both suffices and
                        is more intuitive.  Therefore it is RECOMMENDED that "$anchor"
                        be used to create plain name fragments unless there is a clear
                        need for "$dynamicAnchor".¶\nIf present, the value of this keyword MUST be a string and MUST start with
                        a letter ([A-Za-z]) or underscore ("_"), followed by any number of letters,
                        digits ([0-9]), hyphens ("-"), underscores ("_"), and periods (".").
                        This matches the US-ASCII part of XML's
                        NCName production [xml-names].
                        
                            Note that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.
            ¶\nNCName production [xml-names]\nNote that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.\nThe effect of specifying the same fragment name multiple times within
                        the same resource, using any combination of "$anchor" and/or
                        "$dynamicAnchor", is undefined.  Implementations MAY
                        raise an error if such usage is detected.¶\n8.2.3. Schema References
          

                        Several keywords can be used to reference a schema which is to be applied to the
                        current instance location. "$ref" and "$dynamicRef" are applicator
                        keywords, applying the referenced schema to the instance.¶

                        As the values of "$ref" and "$dynamicRef" are URI References, this allows
                        the possibility to externalise or divide a schema across multiple files,
                        and provides the ability to validate recursive structures through
                        self-reference.¶

                        The resolved URI produced by these keywords is not necessarily a network
                        locator, only an identifier. A schema need not be downloadable from the
                        address if it is a network-addressable URL, and implementations SHOULD NOT
                        assume they should perform a network operation when they encounter
                        a network-addressable URI.¶


            
8.2.3.1. Direct References with "$ref"
            

                            The "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶

                            The value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶




            
8.2.3.2. Dynamic References with "$dynamicRef"
            

                            The "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶

                            Together with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶

                            The value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶

                            If the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶

                            Otherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶

                            For a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\n8.2.3. Schema References\nSeveral keywords can be used to reference a schema which is to be applied to the
                        current instance location. "$ref" and "$dynamicRef" are applicator
                        keywords, applying the referenced schema to the instance.¶\nAs the values of "$ref" and "$dynamicRef" are URI References, this allows
                        the possibility to externalise or divide a schema across multiple files,
                        and provides the ability to validate recursive structures through
                        self-reference.¶\nThe resolved URI produced by these keywords is not necessarily a network
                        locator, only an identifier. A schema need not be downloadable from the
                        address if it is a network-addressable URL, and implementations SHOULD NOT
                        assume they should perform a network operation when they encounter
                        a network-addressable URI.¶\n8.2.3.1. Direct References with "$ref"
            

                            The "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶

                            The value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶\n8.2.3.1. Direct References with "$ref"\nDirect References with "$ref"\nThe "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶\nNote that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.\nThe value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶\n8.2.3.2. Dynamic References with "$dynamicRef"
            

                            The "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶

                            Together with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶

                            The value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶

                            If the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶

                            Otherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶

                            For a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\n8.2.3.2. Dynamic References with "$dynamicRef"\nDynamic References with "$dynamicRef"\nThe "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶\nTogether with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶\nThe value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶\nIf the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶\ndynamic scope (Section 7.1)\nOtherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶\nFor a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\nThe difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.\n8.2.4. Schema Re-Use With "$defs"
          

                        The "$defs" keyword reserves a location for schema
                        authors to inline re-usable JSON Schemas into a more general schema.
                        The keyword does not directly affect the validation result.¶

                        This keyword's value MUST be an object.
                        Each member value of this object MUST be a valid JSON Schema.¶

                        As an example, here is a schema describing an array of positive
                        integers, where the positive integer constraint is a subschema in
                        "$defs":¶


{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}

¶\n8.2.4. Schema Re-Use With "$defs"\nSchema Re-Use With "$defs"\nThe "$defs" keyword reserves a location for schema
                        authors to inline re-usable JSON Schemas into a more general schema.
                        The keyword does not directly affect the validation result.¶\nThis keyword's value MUST be an object.
                        Each member value of this object MUST be a valid JSON Schema.¶\nAs an example, here is a schema describing an array of positive
                        integers, where the positive integer constraint is a subschema in
                        "$defs":¶\n{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}

¶\n8.3. Comments With "$comment"\nComments With "$comment"\nThis keyword reserves a location for comments from schema authors
                    to readers or maintainers of the schema.¶\nThe value of this keyword MUST be a string. Implementations MUST NOT present this
                    string to end users.  Tools for editing schemas SHOULD support displaying and
                    editing this keyword.  The value of this keyword MAY be used in debug or error
                    output which is intended for developers making use of schemas.¶\nSchema vocabularies SHOULD allow "$comment" within any object containing
                    vocabulary keywords.  Implementations MAY assume "$comment" is allowed
                    unless the vocabulary specifically forbids it.  Vocabularies MUST NOT
                    specify any effect of "$comment" beyond what is described in this
                    specification.¶\nTools that translate other media types or programming languages
                    to and from application/schema+json MAY choose to convert that media type or
                    programming language's native comments to or from "$comment" values.
                    The behavior of such translation when both native comments and "$comment"
                    properties are present is implementation-dependent.¶\nImplementations MAY strip "$comment" values at any point during processing.
                    In particular, this allows for shortening schemas when the size of deployed
                    schemas is a concern.¶\nImplementations MUST NOT take any other action based on the presence, absence,
                    or contents of "$comment" properties.  In particular, the value of "$comment"
                    MUST NOT be collected as an annotation result.¶\n9. Loading and Processing Schemas\nLoading and Processing Schemas\n9.1. Loading a Schema\n9.1.1. Initial Base URI
          

                        RFC3986 Section 5.1 [RFC3986] defines how to determine the
                        default base URI of a document.¶

                        Informatively, the initial base URI of a schema is the URI at which it was
                        found, whether that was a network location, a local filesystem, or any other
                        situation identifiable by a URI of any known scheme.¶

                        If a schema document defines no explicit base URI with "$id"
                        (embedded in content), the base URI is that determined per
                        RFC 3986 section 5 [RFC3986].¶

                        If no source is known, or no URI scheme is known for the source, a suitable
                        implementation-specific default URI MAY be used as described in
                        RFC 3986 Section 5.1.4 [RFC3986].  It is RECOMMENDED
                        that implementations document any default base URI that they assume.¶

                        If a schema object is embedded in a document of another media type, then
                        the initial base URI is determined according to the rules of that
                        media type.¶

                        Unless the "$id" keyword described in an earlier section is present in the
                        root schema, this base URI SHOULD be considered the canonical URI of the
                        schema document's root schema resource.¶\n9.1.1. Initial Base URI\nRFC3986 Section 5.1 [RFC3986] defines how to determine the
                        default base URI of a document.¶\nRFC3986 Section 5.1 [RFC3986]\nInformatively, the initial base URI of a schema is the URI at which it was
                        found, whether that was a network location, a local filesystem, or any other
                        situation identifiable by a URI of any known scheme.¶\nIf a schema document defines no explicit base URI with "$id"
                        (embedded in content), the base URI is that determined per
                        RFC 3986 section 5 [RFC3986].¶\nRFC 3986 section 5 [RFC3986]\nIf no source is known, or no URI scheme is known for the source, a suitable
                        implementation-specific default URI MAY be used as described in
                        RFC 3986 Section 5.1.4 [RFC3986].  It is RECOMMENDED
                        that implementations document any default base URI that they assume.¶\nRFC 3986 Section 5.1.4 [RFC3986]\nRFC 3986 Section 5.1.4\nIf a schema object is embedded in a document of another media type, then
                        the initial base URI is determined according to the rules of that
                        media type.¶\nUnless the "$id" keyword described in an earlier section is present in the
                        root schema, this base URI SHOULD be considered the canonical URI of the
                        schema document's root schema resource.¶\n9.1.2. Loading a referenced schema\nLoading a referenced schema\nThe use of URIs to identify remote schemas does not necessarily mean anything is downloaded,
                        but instead JSON Schema implementations SHOULD understand ahead of time which schemas they will be using,
                        and the URIs that identify them.¶\nWhen schemas are downloaded,
                        for example by a generic user-agent that does not know until runtime which schemas to download,
                        see Usage for Hypermedia (Section 9.5.1).¶\nUsage for Hypermedia (Section 9.5.1)\nImplementations SHOULD be able to associate arbitrary URIs with an arbitrary
                        schema and/or automatically associate a schema's "$id"-given URI, depending
                        on the trust that the validator has in the schema.  Such URIs and schemas
                        can be supplied to an implementation prior to processing instances, or may
                        be noted within a schema document as it is processed, producing associations
                        as shown in appendix A.¶\nA schema MAY (and likely will) have multiple URIs, but there is no way for a
                        URI to identify more than one schema. When multiple schemas try to identify
                        as the same URI, validators SHOULD raise an error condition.¶\n9.1.3. Detecting a Meta-Schema\nDetecting a Meta-Schema\nImplementations MUST recognize a schema as a meta-schema if it
                        is being examined because it was identified as such by another
                        schema's "$schema" keyword.  This means that a single schema
                        document might sometimes be considered a regular schema, and
                        other times be considered a meta-schema.¶\nIn the case of examining a schema which is its own meta-schema,
                        when an implementation begins processing it as a regular schema,
                        it is processed under those rules.  However, when loaded a second
                        time as a result of checking its own "$schema" value, it is treated
                        as a meta-schema.  So the same document is processed both ways in
                        the course of one session.¶\nImplementations MAY allow a schema to be explicitly passed as a meta-schema,
                        for implementation-specific purposes, such as pre-loading a commonly
                        used meta-schema and checking its vocabulary support requirements
                        up front.  Meta-schema authors MUST NOT expect such features to be
                        interoperable across implementations.¶\nSchemas can be identified by any URI that has been given to them, including
                    a JSON Pointer or their URI given directly by "$id".  In all cases,
                    dereferencing a "$ref" reference involves first resolving its value as a
                    URI reference against the current base URI per
                    RFC 3986 [RFC3986].¶\nIf the resulting URI identifies a schema within the current document, or
                    within another schema document that has been made available to the implementation,
                    then that schema SHOULD be used automatically.¶\nFor example, consider this schema:¶\n{
    "$id": "https://example.net/root.json",
    "items": {
        "type": "array",
        "items": { "$ref": "#item" }
    },
    "$defs": {
        "single": {
            "$anchor": "item",
            "type": "object",
            "additionalProperties": { "$ref": "other.json" }
        }
    }
}

¶\nWhen an implementation encounters the <#/$defs/single> schema,
                    it resolves the "$anchor" value as a fragment name against the current
                    base URI to form <https://example.net/root.json#item>.¶\nWhen an implementation then looks inside the <#/items> schema, it
                    encounters the <#item> reference, and resolves this to
                    <https://example.net/root.json#item>, which it has seen defined in
                    this same document and can therefore use automatically.¶\nWhen an implementation encounters the reference to "other.json", it resolves
                    this to <https://example.net/other.json>, which is not defined in this
                    document.  If a schema with that identifier has otherwise been supplied to
                    the implementation, it can also be used automatically.
                    
                        What should implementations do when the referenced schema is not known?
                        Are there circumstances in which automatic network dereferencing is
                        allowed?  A same origin policy?  A user-configurable option?  In the
                        case of an evolving API described by Hyper-Schema, it is expected that
                        new schemas will be added to the system dynamically, so placing an
                        absolute requirement of pre-loading schema documents is not feasible.
          ¶\nWhat should implementations do when the referenced schema is not known?
                        Are there circumstances in which automatic network dereferencing is
                        allowed?  A same origin policy?  A user-configurable option?  In the
                        case of an evolving API described by Hyper-Schema, it is expected that
                        new schemas will be added to the system dynamically, so placing an
                        absolute requirement of pre-loading schema documents is not feasible.\n9.2.1. JSON Pointer fragments and embedded schema resources
          

                        Since JSON Pointer URI fragments are constructed based on the structure
                        of the schema document, an embedded schema resource and its subschemas
                        can be identified by JSON Pointer fragments relative to either its own
                        canonical URI, or relative to any containing resource's URI.¶

                        Conceptually, a set of linked schema resources should behave
                        identically whether each resource is a separate document connected with
                        schema references (Section 8.2.3), or is structured as
                        a single document with one or more schema resources embedded as
                        subschemas.¶

                        Since URIs involving JSON Pointer fragments relative to the parent
                        schema resource's URI cease to be valid when the embedded schema
                        is moved to a separate document and referenced, applications and schemas
                        SHOULD NOT use such URIs to identify embedded schema resources or
                        locations within them.¶

                            Consider the following schema document that contains another
                            schema resource embedded within it:¶


{
    "$id": "https://example.com/foo",
    "items": {
        "$id": "https://example.com/bar",
        "additionalProperties": { }
    }
}

¶


                        The URI "https://example.com/foo#/items" points to the "items" schema,
                        which is an embedded resource.  The canonical URI of that schema
                        resource, however, is "https://example.com/bar".¶

                        For the "additionalProperties" schema within that embedded resource,
                        the URI "https://example.com/foo#/items/additionalProperties" points
                        to the correct object, but that object's URI relative to its resource's
                        canonical URI is "https://example.com/bar#/additionalProperties".¶

                            Now consider the following two schema resources linked by reference
                            using a URI value for "$ref":¶


{
    "$id": "https://example.com/foo",
    "items": {
        "$ref": "bar"
    }
}

{
    "$id": "https://example.com/bar",
    "additionalProperties": { }
}

¶


                            Here we see that "https://example.com/bar#/additionalProperties",
                            using a JSON Pointer fragment appended to the canonical URI of
                            the "bar" schema resource, is still valid, while
                            "https://example.com/foo#/items/additionalProperties", which relied
                            on a JSON Pointer fragment appended to the canonical URI of the
                            "foo" schema resource, no longer resolves to anything.¶

                        Note also that "https://example.com/foo#/items" is valid in both
                        arrangements, but resolves to a different value.  This URI ends up
                        functioning similarly to a retrieval URI for a resource.  While this URI
                        is valid, it is more robust to use the "$id" of the embedded or referenced
                        resource unless it is specifically desired to identify the object containing
                        the "$ref" in the second (non-embedded) arrangement.¶

                        An implementation MAY choose not to support addressing schema resource
                        contents by URIs using a base other than the resource's canonical URI,
                        plus a JSON Pointer fragment relative to that base.  Therefore, schema
                        authors SHOULD NOT rely on such URIs, as using them may reduce interoperability.
                        
                            This is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)
            ¶

                        Further examples of such non-canonical URI construction, as well as
                        the appropriate canonical URI-based fragments to use instead,
                        are provided in appendix A.¶\n9.2.1. JSON Pointer fragments and embedded schema resources\nJSON Pointer fragments and embedded schema resources\nSince JSON Pointer URI fragments are constructed based on the structure
                        of the schema document, an embedded schema resource and its subschemas
                        can be identified by JSON Pointer fragments relative to either its own
                        canonical URI, or relative to any containing resource's URI.¶\nConceptually, a set of linked schema resources should behave
                        identically whether each resource is a separate document connected with
                        schema references (Section 8.2.3), or is structured as
                        a single document with one or more schema resources embedded as
                        subschemas.¶\nschema references (Section 8.2.3)\nSince URIs involving JSON Pointer fragments relative to the parent
                        schema resource's URI cease to be valid when the embedded schema
                        is moved to a separate document and referenced, applications and schemas
                        SHOULD NOT use such URIs to identify embedded schema resources or
                        locations within them.¶\nConsider the following schema document that contains another
                            schema resource embedded within it:¶\n{
    "$id": "https://example.com/foo",
    "items": {
        "$id": "https://example.com/bar",
        "additionalProperties": { }
    }
}

¶\nThe URI "https://example.com/foo#/items" points to the "items" schema,
                        which is an embedded resource.  The canonical URI of that schema
                        resource, however, is "https://example.com/bar".¶\nFor the "additionalProperties" schema within that embedded resource,
                        the URI "https://example.com/foo#/items/additionalProperties" points
                        to the correct object, but that object's URI relative to its resource's
                        canonical URI is "https://example.com/bar#/additionalProperties".¶\nNow consider the following two schema resources linked by reference
                            using a URI value for "$ref":¶\n{
    "$id": "https://example.com/foo",
    "items": {
        "$ref": "bar"
    }
}

{
    "$id": "https://example.com/bar",
    "additionalProperties": { }
}

¶\nHere we see that "https://example.com/bar#/additionalProperties",
                            using a JSON Pointer fragment appended to the canonical URI of
                            the "bar" schema resource, is still valid, while
                            "https://example.com/foo#/items/additionalProperties", which relied
                            on a JSON Pointer fragment appended to the canonical URI of the
                            "foo" schema resource, no longer resolves to anything.¶\nNote also that "https://example.com/foo#/items" is valid in both
                        arrangements, but resolves to a different value.  This URI ends up
                        functioning similarly to a retrieval URI for a resource.  While this URI
                        is valid, it is more robust to use the "$id" of the embedded or referenced
                        resource unless it is specifically desired to identify the object containing
                        the "$ref" in the second (non-embedded) arrangement.¶\nAn implementation MAY choose not to support addressing schema resource
                        contents by URIs using a base other than the resource's canonical URI,
                        plus a JSON Pointer fragment relative to that base.  Therefore, schema
                        authors SHOULD NOT rely on such URIs, as using them may reduce interoperability.
                        
                            This is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)
            ¶\nThis is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)\nFurther examples of such non-canonical URI construction, as well as
                        the appropriate canonical URI-based fragments to use instead,
                        are provided in appendix A.¶\n9.3. Compound Documents\nA Compound Schema Document is defined as a JSON document (sometimes called a "bundled" schema)
                    which has multiple embedded JSON Schema Resources bundled into the same document to
                    ease transportation.¶\nEach embedded Schema Resource MUST be treated as an individual Schema Resource, following standard
                    schema loading and processing requirements, including determining vocabulary support.¶\nThe bundling process for creating a Compound Schema Document is defined as taking
                        references (such as "$ref") to an external Schema Resource and embedding the referenced
                        Schema Resources within the referring document. Bundling SHOULD be done in such a way that
                        all URIs (used for referencing) in the base document and any referenced/embedded
                        documents do not require altering.¶\nEach embedded JSON Schema Resource MUST identify itself with a URI using the "$id" keyword,
                        and SHOULD make use of the "$schema" keyword to identify the dialect it is using, in the root of the
                        schema resource. It is RECOMMENDED that the URI identifier value of "$id" be an Absolute URI.¶\nWhen the Schema Resource referenced by a by-reference applicator is bundled, it is RECOMMENDED that
                        the Schema Resource be located as a value of a "$defs" object at the containing schema's root.
                        The key of the "$defs" for the now embedded Schema Resource MAY be the "$id" of the bundled schema
                        or some other form of application defined unique identifier (such as a UUID). This key is not
                        intended to be referenced in JSON Schema, but may be used by an application to aid the
                        bundling process.¶\nA Schema Resource MAY be embedded in a location other than "$defs" where the location is defined
                        as a schema value.¶\nA Bundled Schema Resource MUST NOT be bundled by replacing the schema object from which it was
                        referenced, or by wrapping the Schema Resource in other applicator keywords.¶\nIn order to produce identical output, references in the containing schema document to the
                        previously external Schema Resources MUST NOT be changed, and now resolve to a schema using the
                        "$id" of an embedded Schema Resource. Such identical output includes validation evaluation and URIs
                        or paths used in resulting annotations or errors.¶\nWhile the bundling process will often be the main method for creating a Compound Schema Document,
                        it is also possible and expected that some will be created by hand, potentially without individual
                        Schema Resources existing on their own previously.¶\n9.3.2. Differing and Default Dialects\nDiffering and Default Dialects\nWhen multiple schema resources are present in a single document,
                        schema resources which do not define with which dialect they should be processed
                        MUST be processed with the same dialect as the enclosing resource.¶\nSince any schema that can be referenced can also be embedded, embedded schema resources MAY
                        specify different processing dialects using the "$schema" values from their enclosing resource.¶\nGiven that a Compound Schema Document may have embedded resources which identify as using different
                        dialects, these documents SHOULD NOT be validated by applying a meta-schema
                        to the Compound Schema Document as an instance. It is RECOMMENDED that an alternate
                        validation process be provided in order to validate Schema Documents. Each Schema Resource
                        SHOULD be separately validated against its associated meta-schema.
                        
                            If you know a schema is what's being validated, you can identify if the schemas
                            is a Compound Schema Document or not, by way of use of "$id", which identifies an
                            embedded resource when used not at the document's root.
            ¶\nIf you know a schema is what's being validated, you can identify if the schemas
                            is a Compound Schema Document or not, by way of use of "$id", which identifies an
                            embedded resource when used not at the document's root.\nA Compound Schema Document in which all embedded resources identify as using the same
                        dialect, or in which "$schema" is omitted and therefore defaults to that of the enclosing resource,
                        MAY be validated by applying the appropriate meta-schema.¶\n9.4.1. Guarding Against Infinite Recursion\nGuarding Against Infinite Recursion\nA schema MUST NOT be run into an infinite loop against an instance. For
                        example, if two schemas "#alice" and "#bob" both have an "allOf" property
                        that refers to the other, a naive validator might get stuck in an infinite
                        recursive loop trying to validate the instance.  Schemas SHOULD NOT make
                        use of infinite recursive nesting like this; the behavior is undefined.¶\n9.4.2. References to Possible Non-Schemas
          

                        Subschema objects (or booleans) are recognized by their use with known
                        applicator keywords or with location-reserving keywords such as
                        "$defs" (Section 8.2.4) that take one or more subschemas
                        as a value.  These keywords may be "$defs" and the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.¶

                        Multi-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
            ¶

                        Note that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.¶\n9.4.2. References to Possible Non-Schemas\nReferences to Possible Non-Schemas\nSubschema objects (or booleans) are recognized by their use with known
                        applicator keywords or with location-reserving keywords such as
                        "$defs" (Section 8.2.4) that take one or more subschemas
                        as a value.  These keywords may be "$defs" and the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.¶\n"$defs" (Section 8.2.4)\nMulti-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
            ¶\nThese scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.\nNote that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.¶\n9.5. Associating Instances and Schemas\nAssociating Instances and Schemas\n9.5.1. Usage for Hypermedia
          

                        JSON has been adopted widely by HTTP servers for automated APIs and robots. This
                        section describes how to enhance processing of JSON documents in a more RESTful
                        manner when used with protocols that support media types and
                        Web linking [RFC8288].¶

            
9.5.1.1. Linking to a Schema
            

                            It is RECOMMENDED that instances described by a schema provide a link to
                            a downloadable JSON Schema using the link relation "describedby", as defined by
                            Linked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226].¶

                            In HTTP, such links can be attached to any response using the
                            Link header [RFC8288]. An example of such a header would be:¶


        Link: <https://example.com/my-hyper-schema>; rel="describedby"

¶



            
9.5.1.2. Usage Over HTTP
            

                            When used for hypermedia systems over a network,
                            HTTP [RFC7231] is frequently the protocol of choice for
                            distributing schemas. Misbehaving clients can pose problems for server
                            maintainers if they pull a schema over the network more frequently than
                            necessary, when it's instead possible to cache a schema for a long period of
                            time.¶

                            HTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                            HTTP clients SHOULD observe caching headers and not re-request documents within
                            their freshness period.
                            Distributed systems SHOULD make use of a shared cache and/or caching proxy.¶

                            Clients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                            implementation or software product. Since symbols are listed in decreasing order
                            of significance, the JSON Schema library name/version should precede the more
                            generic HTTP library name (if any). For example:¶


        User-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

¶


                            Clients SHOULD be able to make requests with a "From" header so that server
                            operators can contact the owner of a potentially misbehaving script.¶\n9.5.1. Usage for Hypermedia\nJSON has been adopted widely by HTTP servers for automated APIs and robots. This
                        section describes how to enhance processing of JSON documents in a more RESTful
                        manner when used with protocols that support media types and
                        Web linking [RFC8288].¶\nWeb linking [RFC8288]\n9.5.1.1. Linking to a Schema\nIt is RECOMMENDED that instances described by a schema provide a link to
                            a downloadable JSON Schema using the link relation "describedby", as defined by
                            Linked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226].¶\nLinked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226]\nLinked Data Protocol 1.0, section 8.1\nIn HTTP, such links can be attached to any response using the
                            Link header [RFC8288]. An example of such a header would be:¶\nLink header [RFC8288]\nLink: <https://example.com/my-hyper-schema>; rel="describedby"

¶\n9.5.1.2. Usage Over HTTP\nWhen used for hypermedia systems over a network,
                            HTTP [RFC7231] is frequently the protocol of choice for
                            distributing schemas. Misbehaving clients can pose problems for server
                            maintainers if they pull a schema over the network more frequently than
                            necessary, when it's instead possible to cache a schema for a long period of
                            time.¶\nHTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                            HTTP clients SHOULD observe caching headers and not re-request documents within
                            their freshness period.
                            Distributed systems SHOULD make use of a shared cache and/or caching proxy.¶\nClients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                            implementation or software product. Since symbols are listed in decreasing order
                            of significance, the JSON Schema library name/version should precede the more
                            generic HTTP library name (if any). For example:¶\nUser-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

¶\nClients SHOULD be able to make requests with a "From" header so that server
                            operators can contact the owner of a potentially misbehaving script.¶\n10. A Vocabulary for Applying Subschemas\nA Vocabulary for Applying Subschemas\nThis section defines a vocabulary of applicator keywords that
                are RECOMMENDED for use as the basis of other vocabularies.¶\nMeta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.¶\nThe current URI for this vocabulary, known as the Applicator vocabulary, is:
                <https://json-schema.org/draft/2020-12/vocab/applicator>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/applicator.¶\nhttps://json-schema.org/draft/2020-12/meta/applicator\nhttps://json-schema.org/draft/2020-12/meta/applicator\n10.1. Keyword Independence\nSchema keywords typically operate independently, without
                    affecting each other's outcomes.¶\nFor schema author convenience, there are some exceptions among the
                    keywords in this vocabulary:¶\n"additionalProperties", whose behavior is defined in terms of
                            "properties" and "patternProperties"¶\n"items", whose behavior is defined in terms of "prefixItems"¶\n"contains", whose behavior is affected by the presence and value of
                            "minContains", in the Validation vocabulary¶\n10.2. Keywords for Applying Subschemas in Place
        

                    These keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.¶

                    Subschemas of these keywords evaluate the instance completely independently
                    such that the results of one such subschema MUST NOT impact the results of sibling
                    subschemas.  Therefore subschemas may be applied in
                    any order.¶


          
10.2.1. Keywords for Applying Subschemas With Logic
          

                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶


            
10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶



            
10.2.1.2. anyOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶


            
10.2.1.3. oneOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶



            
10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶






          
10.2.2. Keywords for Applying Subschemas Conditionally
          

                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶

                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶

                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶

            
10.2.2.1. if
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶

                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶

                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶

                            If annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶


            
10.2.2.2. then
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.3. else
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.4. dependentSchemas
            

                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶

                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶

                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶

                            Omitting this keyword has the same behavior as an empty object.¶\n10.2. Keywords for Applying Subschemas in Place\nKeywords for Applying Subschemas in Place\nThese keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.¶\nSubschemas of these keywords evaluate the instance completely independently
                    such that the results of one such subschema MUST NOT impact the results of sibling
                    subschemas.  Therefore subschemas may be applied in
                    any order.¶\n10.2.1. Keywords for Applying Subschemas With Logic
          

                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶


            
10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶



            
10.2.1.2. anyOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶


            
10.2.1.3. oneOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶



            
10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\n10.2.1. Keywords for Applying Subschemas With Logic\nKeywords for Applying Subschemas With Logic\nThese keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶\n10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶\n10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nAn instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\n10.2.2. Keywords for Applying Subschemas Conditionally
          

                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶

                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶

                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶

            
10.2.2.1. if
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶

                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶

                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶

                            If annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶


            
10.2.2.2. then
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.3. else
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.4. dependentSchemas
            

                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶

                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶

                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶

                            Omitting this keyword has the same behavior as an empty object.¶\n10.2.2. Keywords for Applying Subschemas Conditionally\nKeywords for Applying Subschemas Conditionally\nThree of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶\n"if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶\nThere is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nThis validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶\nInstances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶\nInstances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶\nIf annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶\nannotations (Section 7.7)\nThis keyword's value MUST be a valid JSON Schema.¶\nWhen "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶\nThis keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nWhen "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶\nThis keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶\n10.2.2.4. dependentSchemas\nThis keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶\nThis keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶\nIf the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶\nOmitting this keyword has the same behavior as an empty object.¶\n10.3. Keywords for Applying Subschemas to Child Instances\nKeywords for Applying Subschemas to Child Instances\nEach of these keywords defines a rule for applying its
                    subschema(s) to child instances, specifically object
                    properties and array items, and combining their results.¶\n10.3.1. Keywords for Applying Subschemas to Arrays\nKeywords for Applying Subschemas to Arrays\n10.3.1.1. prefixItems\nThe value of "prefixItems" MUST be a non-empty array of valid JSON Schemas.¶\nValidation succeeds if each element of the instance validates
                            against the schema at the same position, if any.  This keyword
                            does not constrain the length of the array.  If the array is longer
                            than this keyword's value, this keyword validates only the
                            prefix of matching length.¶\nThis keyword produces an annotation value which is the largest
                            index to which this keyword applied a subschema.  The value
                            MAY be a boolean true if a subschema was applied to every
                            index of the instance, such as is produced by the "items" keyword.
                            This annotation affects the behavior of "items" and "unevaluatedItems".¶\nOmitting this keyword has the same assertion behavior as
                            an empty array.¶\n10.3.1.2. items
            

                            The value of "items" MUST be a valid JSON Schema.¶

                            This keyword applies its subschema to all instance elements
                            at indexes greater than the length of the "prefixItems" array
                            in the same schema object, as reported by the annotation result
                            of that "prefixItems" keyword.  If no such annotation
                            result exists, "items" applies its subschema to all instance
                            array elements.
                            
                                Note that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.
              ¶

                            If the "items" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, indicating that all remaining array
                            elements have been evaluated against this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary.¶

                            Omitting this keyword has the same assertion behavior as
                            an empty schema.¶

                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of a "prefixItems" array.
                            Implementations that do not support annotation collection MUST do so.¶\nThe value of "items" MUST be a valid JSON Schema.¶\nThis keyword applies its subschema to all instance elements
                            at indexes greater than the length of the "prefixItems" array
                            in the same schema object, as reported by the annotation result
                            of that "prefixItems" keyword.  If no such annotation
                            result exists, "items" applies its subschema to all instance
                            array elements.
                            
                                Note that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.
              ¶\nNote that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.\nIf the "items" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, indicating that all remaining array
                            elements have been evaluated against this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty schema.¶\nImplementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of a "prefixItems" array.
                            Implementations that do not support annotation collection MUST do so.¶\nThe value of this keyword MUST be a valid JSON Schema.¶\nAn array instance is valid against "contains" if at least one of
                            its elements is valid against the given schema,
                            except when "minContains" is present and has a value of 0, in which
                            case an array instance MUST be considered valid against the "contains" keyword,
                            even if none of its elements is valid against the given schema.¶\nThis keyword produces an annotation value which is an array of
                            the indexes to which this keyword validates successfully when applying
                            its subschema, in ascending order. The value MAY be a boolean "true" if
                            the subschema validates successfully when applied to every index of the
                            instance. The annotation MUST be present if the instance array to which
                            this keyword's schema applies is empty.¶\nThis annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary, and MAY also be used to implement the
                            "minContains" and "maxContains" keywords in the Validation vocabulary.¶\nThe subschema MUST be applied to every array element even after the first
                            match has been found, in order to collect annotations for use by other
                            keywords. This is to ensure that all possible annotations are collected.¶\n10.3.2. Keywords for Applying Subschemas to Objects\nKeywords for Applying Subschemas to Objects\nThe value of "properties" MUST be an object.
                            Each value of this object MUST be a valid JSON Schema.¶\nValidation succeeds if, for each name that appears in both
                            the instance and as a name within this keyword's value, the child
                            instance for that name successfully validates against the
                            corresponding schema.¶\nThe annotation result of this keyword is the set of instance
                            property names matched by this keyword.
                            This annotation affects the behavior of "additionalProperties" (in
                            this vocabulary) and "unevaluatedProperties" in the Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty object.¶\n10.3.2.2. patternProperties\nThe value of "patternProperties" MUST be an object. Each property name
                            of this object SHOULD be a valid regular expression, according to the
                            ECMA-262 regular expression dialect. Each property value of this object
                            MUST be a valid JSON Schema.¶\nValidation succeeds if, for each instance name that matches any
                            regular expressions that appear as a property name in this keyword's value,
                            the child instance for that name successfully validates against each
                            schema that corresponds to a matching regular expression.¶\nThe annotation result of this keyword is the set of instance
                            property names matched by this keyword.
                            This annotation affects the behavior of "additionalProperties" (in this
                            vocabulary) and "unevaluatedProperties" (in the Unevaluated vocabulary).¶\nOmitting this keyword has the same assertion behavior as
                            an empty object.¶\n10.3.2.3. additionalProperties
            

                            The value of "additionalProperties" MUST be a valid JSON Schema.¶

                            The behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".¶

                            For all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.¶

                            The annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedProperties"
                            in the Unevaluated vocabulary.¶

                            Omitting this keyword has the same assertion behavior as
                            an empty schema.¶

                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                            
                                In defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.
              ¶\n10.3.2.3. additionalProperties\nThe value of "additionalProperties" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".¶\nFor all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.¶\nThe annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedProperties"
                            in the Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty schema.¶\nImplementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                            
                                In defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.
              ¶\nIn defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.\n10.3.2.4. propertyNames\nThe value of "propertyNames" MUST be a valid JSON Schema.¶\nIf the instance is an object, this keyword validates if every property name in
                            the instance validates against the provided schema.
                            Note the property name that the schema is testing will always be a string.¶\nOmitting this keyword has the same behavior as an empty schema.¶\n11. A Vocabulary for Unevaluated Locations\nA Vocabulary for Unevaluated Locations\nThe purpose of these keywords is to enable schema authors to apply
                subschemas to array items or object properties that have not been
                successfully evaluated against any dynamic-scope subschema of any
                adjacent keywords.¶\nThese instance items or properties may have been unsuccessfully evaluated
                against one or more adjacent keyword subschemas, such as when an assertion
                in a branch of an "anyOf" fails.  Such failed evaluations are not considered
                to contribute to whether or not the item or property has been evaluated.
                Only successful evaluations are considered.¶\nIf an item in an array or an object property is "successfully evaluated", it
                is logically considered to be valid in terms of the representation of the
                object or array that's expected. For example if a subschema represents a car,
                which requires between 2-4 wheels, and the value of "wheels" is 6, the instance
                object is not "evaluated" to be a car, and the "wheels" property is considered
                "unevaluated (successfully as a known thing)", and does not retain any annotations.¶\nRecall that adjacent keywords are keywords within the same schema object,
                and that the dynamic-scope subschemas include reference targets as well as
                lexical subschemas.¶\nThe behavior of these keywords depend on the annotation results of
                adjacent keywords that apply to the instance location being validated.¶\nMeta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.¶\nThe current URI for this vocabulary, known as the Unevaluated Applicator
                vocabulary, is:
                <https://json-schema.org/draft/2020-12/vocab/unevaluated>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/unevaluated.¶\nhttps://json-schema.org/draft/2020-12/meta/unevaluated\nhttps://json-schema.org/draft/2020-12/meta/unevaluated\n11.1. Keyword Independence\nSchema keywords typically operate independently, without
                    affecting each other's outcomes. However, the keywords in this
                    vocabulary are notable exceptions:¶\n"unevaluatedItems", whose behavior is defined in terms of annotations
                            from "prefixItems", "items", "contains", and itself¶\n"unevaluatedProperties", whose behavior is defined in terms of
                            annotations from "properties", "patternProperties",
                            "additionalProperties" and itself¶\n11.2. unevaluatedItems
        

                    The value of "unevaluatedItems" MUST be a valid JSON Schema.¶

                    The behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "prefixItems", "items", and "contains",
                    which can come from those keywords when they are adjacent to the
                    "unevaluatedItems" keyword. Those three annotations, as well as
                    "unevaluatedItems", can also result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶

                    If no relevant annotations are present, the "unevaluatedItems"
                    subschema MUST be applied to all locations in the array.
                    If a boolean true value is present from any of the relevant annotations,
                    "unevaluatedItems" MUST be ignored.  Otherwise, the subschema
                    MUST be applied to any index greater than the largest annotation
                    value for "prefixItems", which does not appear in any annotation
                    value for "contains".¶

                    This means that "prefixItems", "items", "contains", and all in-place
                    applicators MUST be evaluated before this keyword can be evaluated.
                    Authors of extension keywords MUST NOT define an in-place applicator
                    that would need to be evaluated after this keyword.¶

                    If the "unevaluatedItems" subschema is applied to any
                    positions within the instance array, it produces an
                    annotation result of boolean true, analogous to the
                    behavior of "items".
                    This annotation affects the behavior of "unevaluatedItems" in parent schemas.¶

                    Omitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.2. unevaluatedItems\nThe value of "unevaluatedItems" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "prefixItems", "items", and "contains",
                    which can come from those keywords when they are adjacent to the
                    "unevaluatedItems" keyword. Those three annotations, as well as
                    "unevaluatedItems", can also result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶\nin-place applicator (Section 10.2)\nIf no relevant annotations are present, the "unevaluatedItems"
                    subschema MUST be applied to all locations in the array.
                    If a boolean true value is present from any of the relevant annotations,
                    "unevaluatedItems" MUST be ignored.  Otherwise, the subschema
                    MUST be applied to any index greater than the largest annotation
                    value for "prefixItems", which does not appear in any annotation
                    value for "contains".¶\nThis means that "prefixItems", "items", "contains", and all in-place
                    applicators MUST be evaluated before this keyword can be evaluated.
                    Authors of extension keywords MUST NOT define an in-place applicator
                    that would need to be evaluated after this keyword.¶\nIf the "unevaluatedItems" subschema is applied to any
                    positions within the instance array, it produces an
                    annotation result of boolean true, analogous to the
                    behavior of "items".
                    This annotation affects the behavior of "unevaluatedItems" in parent schemas.¶\nOmitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.3. unevaluatedProperties
        

                    The value of "unevaluatedProperties" MUST be a valid JSON Schema.¶

                    The behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "properties", "patternProperties",
                    and "additionalProperties", which can come from those keywords when
                    they are adjacent to the "unevaluatedProperties" keyword.  Those
                    three annotations, as well as "unevaluatedProperties", can also
                    result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶

                    Validation with "unevaluatedProperties" applies only to the child
                    values of instance names that do not appear in the "properties",
                    "patternProperties", "additionalProperties", or
                    "unevaluatedProperties" annotation results that apply to the
                    instance location being validated.¶

                    For all such properties, validation succeeds if the child instance
                    validates against the "unevaluatedProperties" schema.¶

                    This means that "properties", "patternProperties", "additionalProperties",
                    and all in-place applicators MUST be evaluated before this keyword can
                    be evaluated.  Authors of extension keywords MUST NOT define an in-place
                    applicator that would need to be evaluated after this keyword.¶

                    The annotation result of this keyword is the set of instance
                    property names validated by this keyword's subschema.
                    This annotation affects the behavior of "unevaluatedProperties" in parent schemas.¶

                    Omitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.3. unevaluatedProperties\nunevaluatedProperties\nThe value of "unevaluatedProperties" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "properties", "patternProperties",
                    and "additionalProperties", which can come from those keywords when
                    they are adjacent to the "unevaluatedProperties" keyword.  Those
                    three annotations, as well as "unevaluatedProperties", can also
                    result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶\nin-place applicator (Section 10.2)\nValidation with "unevaluatedProperties" applies only to the child
                    values of instance names that do not appear in the "properties",
                    "patternProperties", "additionalProperties", or
                    "unevaluatedProperties" annotation results that apply to the
                    instance location being validated.¶\nFor all such properties, validation succeeds if the child instance
                    validates against the "unevaluatedProperties" schema.¶\nThis means that "properties", "patternProperties", "additionalProperties",
                    and all in-place applicators MUST be evaluated before this keyword can
                    be evaluated.  Authors of extension keywords MUST NOT define an in-place
                    applicator that would need to be evaluated after this keyword.¶\nThe annotation result of this keyword is the set of instance
                    property names validated by this keyword's subschema.
                    This annotation affects the behavior of "unevaluatedProperties" in parent schemas.¶\nOmitting this keyword has the same assertion behavior as
                    an empty schema.¶\n12. Output Formatting
      

                JSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.¶

        
12.1. Format
        

                    JSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.¶


        
12.2. Output Formats
        

                    This specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.¶


                            Flag - A boolean which simply indicates the overall validation result
                            with no further details.¶

          
                            Basic - Provides validation information in a flat list structure.¶

          
                            Detailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.¶

          
                            Verbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.¶

        

                    An implementation SHOULD provide at least one of the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    "detailed" or "verbose" formats, it MUST also provide the "flag" format.
                    Implementations SHOULD specify in their documentation which formats they support.¶


        
12.3. Minimum Information
        

                    Beyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.¶

                    A single object that contains all of these components is considered an
                    output unit.¶

                    Implementations MAY elect to provide additional information.¶

          
12.3.1. Keyword Relative Location
          

                        The relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$dynamicRef".¶


/properties/width/$ref/minimum

¶


                    Note that this pointer may not be resolvable by the normal JSON Pointer process
                    due to the inclusion of these by-reference applicator keywords.¶

                        The JSON key for this information is "keywordLocation".¶


          
12.3.2. Keyword Absolute Location
          

                        The absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as a full URI using the canonical URI of the relevant schema resource
                        with a JSON Pointer fragment, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$dynamicRef" as non-terminal path components.
                        It MAY end in such keywords if the error or annotation is for that
                        keyword, such as an unresolvable reference.
                        
                            Note that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.
            ¶


https://example.com/schemas/common#/$defs/count/minimum

¶


                        This information MAY be omitted only if either the dynamic scope did not pass
                        over a reference or if the schema does not declare an absolute URI as its "$id".¶

                        The JSON key for this information is "absoluteKeywordLocation".¶


          
12.3.3. Instance Location
          

                        The location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.¶

                        The JSON key for this information is "instanceLocation".¶


          
12.3.4. Error or Annotation
          

                        The error or annotation that is produced by the validation.¶

                        For errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.¶

                        For annotations, each keyword that produces an annotation specifies its
                        format.  By default, it is the keyword's value.¶

                        The JSON key for failed validations is "error"; for successful validations
                        it is "annotation".¶


          
12.3.5. Nested Results
          

                        For the two hierarchical structures, this property will hold nested errors
                        and annotations.¶

                        The JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".  Note the plural forms, as
                        a keyword with nested results can also have a local error or annotation.¶



        
12.4. Output Structure
        

                    The output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.¶


                            "valid" - a boolean value indicating the overall validation success or
                            failure¶

          
                            "errors" - the collection of errors or annotations produced by a failed
                            validation¶

          
                            "annotations" - the collection of errors or annotations produced by a
                            successful validation¶

        

                    For these examples, the following schema and instance will be used.¶


{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3
  },
  {
    "x": 1,
    "z": 6.7
  }
]

¶


                    This instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.¶

                    Specifically, the errors it will produce are:¶


                            The second object is missing a "y" property.¶

          
                            The second object has a disallowed "z" property.¶

          
                            There are only two objects, but three are required.¶

        

                    Note that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.¶

          
12.4.1. Flag
          

                        In the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.¶


{
  "valid": false
}

¶


                        Because no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.¶


          
12.4.2. Basic
          

                        The "Basic" structure is a flat list of output units.¶


{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "",
      "instanceLocation": "",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref/required",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/required",
      "instanceLocation": "/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/additionalProperties",
      "instanceLocation": "/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶



          
12.4.3. Detailed
          

                        The "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correlation is more easily identified.¶

                        The following rules govern the construction of the results object:¶


                                All applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.¶

            
                                Nodes that have no children are removed.¶

            
                                Nodes that have a single child are replaced by the child.¶

          

                        Branch nodes do not require an error message or an annotation.¶


{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/items/$ref/required",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/required",
          "instanceLocation": "/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/additionalProperties",
          "instanceLocation": "/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶



          
12.4.4. Verbose
          

                        The "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.¶

                        The primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.¶

                        Because this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        https://json-schema.org/draft/2020-12/output/verbose-example.¶


// schema
{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "/type",
      "instanceLocation": ""
    },
    {
      "valid": true,
      "keywordLocation": "/properties",
      "instanceLocation": ""
    },
    {
      "valid": false,
      "keywordLocation": "/additionalProperties",
      "instanceLocation": "",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/additionalProperties",
          "instanceLocation": "/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}

¶



          
12.4.5. Output validation schemas
          

                        For convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        https://json-schema.org/draft/2020-12/output/schema.¶\n12. Output Formatting\nJSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.¶\nJSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.¶\nThis specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.¶\nFlag - A boolean which simply indicates the overall validation result
                            with no further details.¶\nBasic - Provides validation information in a flat list structure.¶\nDetailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.¶\nVerbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.¶\nAn implementation SHOULD provide at least one of the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    "detailed" or "verbose" formats, it MUST also provide the "flag" format.
                    Implementations SHOULD specify in their documentation which formats they support.¶\n12.3. Minimum Information\nBeyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.¶\nA single object that contains all of these components is considered an
                    output unit.¶\nImplementations MAY elect to provide additional information.¶\n12.3.1. Keyword Relative Location\nKeyword Relative Location\nThe relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$dynamicRef".¶\n/properties/width/$ref/minimum

¶\nNote that this pointer may not be resolvable by the normal JSON Pointer process
                    due to the inclusion of these by-reference applicator keywords.¶\nThe JSON key for this information is "keywordLocation".¶\n12.3.2. Keyword Absolute Location\nKeyword Absolute Location\nThe absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as a full URI using the canonical URI of the relevant schema resource
                        with a JSON Pointer fragment, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$dynamicRef" as non-terminal path components.
                        It MAY end in such keywords if the error or annotation is for that
                        keyword, such as an unresolvable reference.
                        
                            Note that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.
            ¶\nNote that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.\nhttps://example.com/schemas/common#/$defs/count/minimum

¶\nThis information MAY be omitted only if either the dynamic scope did not pass
                        over a reference or if the schema does not declare an absolute URI as its "$id".¶\nThe JSON key for this information is "absoluteKeywordLocation".¶\n12.3.3. Instance Location\nThe location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.¶\nThe JSON key for this information is "instanceLocation".¶\n12.3.4. Error or Annotation\nThe error or annotation that is produced by the validation.¶\nFor errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.¶\nFor annotations, each keyword that produces an annotation specifies its
                        format.  By default, it is the keyword's value.¶\nThe JSON key for failed validations is "error"; for successful validations
                        it is "annotation".¶\n12.3.5. Nested Results\nFor the two hierarchical structures, this property will hold nested errors
                        and annotations.¶\nThe JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".  Note the plural forms, as
                        a keyword with nested results can also have a local error or annotation.¶\n12.4. Output Structure\nThe output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.¶\n"valid" - a boolean value indicating the overall validation success or
                            failure¶\n"errors" - the collection of errors or annotations produced by a failed
                            validation¶\n"annotations" - the collection of errors or annotations produced by a
                            successful validation¶\nFor these examples, the following schema and instance will be used.¶\n{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3
  },
  {
    "x": 1,
    "z": 6.7
  }
]

¶\nThis instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.¶\nSpecifically, the errors it will produce are:¶\nThe second object is missing a "y" property.¶\nThe second object has a disallowed "z" property.¶\nThere are only two objects, but three are required.¶\nNote that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.¶\nIn the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.¶\n{
  "valid": false
}

¶\nBecause no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.¶\nThe "Basic" structure is a flat list of output units.¶\n{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "",
      "instanceLocation": "",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref/required",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/required",
      "instanceLocation": "/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/additionalProperties",
      "instanceLocation": "/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶\nThe "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correlation is more easily identified.¶\nThe following rules govern the construction of the results object:¶\nAll applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.¶\nNodes that have no children are removed.¶\nNodes that have a single child are replaced by the child.¶\nBranch nodes do not require an error message or an annotation.¶\n{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/items/$ref/required",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/required",
          "instanceLocation": "/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/additionalProperties",
          "instanceLocation": "/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶\nThe "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.¶\nThe primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.¶\nBecause this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        https://json-schema.org/draft/2020-12/output/verbose-example.¶\nhttps://json-schema.org/draft/2020-12/output/verbose-example\nhttps://json-schema.org/draft/2020-12/output/verbose-example\n// schema
{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "/type",
      "instanceLocation": ""
    },
    {
      "valid": true,
      "keywordLocation": "/properties",
      "instanceLocation": ""
    },
    {
      "valid": false,
      "keywordLocation": "/additionalProperties",
      "instanceLocation": "",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/additionalProperties",
          "instanceLocation": "/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}

¶\n12.4.5. Output validation schemas\nOutput validation schemas\nFor convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        https://json-schema.org/draft/2020-12/output/schema.¶\nhttps://json-schema.org/draft/2020-12/output/schema\nhttps://json-schema.org/draft/2020-12/output/schema\n13. Security Considerations
      

                Both schemas and instances are JSON values. As such, all security considerations
                defined in RFC 8259 [RFC8259] apply.¶

                Instances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas does not consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.¶

                A malicious party could cause an implementation to repeatedly collect a copy
                of a very large value as an annotation.  Implementations SHOULD guard against
                excessive consumption of system resources in such a scenario.¶

                Servers MUST ensure that malicious parties cannot change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".¶

                Individual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.¶

                Schema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.¶

                A malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.¶\n13. Security Considerations\nSecurity Considerations\nBoth schemas and instances are JSON values. As such, all security considerations
                defined in RFC 8259 [RFC8259] apply.¶\nInstances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas does not consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.¶\nA malicious party could cause an implementation to repeatedly collect a copy
                of a very large value as an annotation.  Implementations SHOULD guard against
                excessive consumption of system resources in such a scenario.¶\nServers MUST ensure that malicious parties cannot change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".¶\nIndividual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.¶\nSchema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.¶\nA malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.¶\n14. IANA Considerations\n14.1. application/schema+json\napplication/schema+json\nThe proposed MIME media type for JSON Schema is defined as follows:¶\nType name: application¶\nSubtype name: schema+json¶\nRequired parameters: N/A¶\nEncoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See JSON [RFC8259].¶\nSecurity considerations: See Section
                            13 above.¶\nInteroperability considerations: See Sections
                            6.2,
                            6.3, and
                            6.4 above.¶\nFragment identifier considerations: See Section
                            5¶\n14.2. application/schema-instance+json\napplication/schema-instance+json\nThe proposed MIME media type for JSON Schema Instances that require
                    a JSON Schema-specific media type is defined as follows:¶\nType name: application¶\nSubtype name: schema-instance+json¶\nRequired parameters: N/A¶\nEncoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See JSON [RFC8259].¶\nSecurity considerations: See Section
                            13 above.¶\nInteroperability considerations: See Sections
                            6.2,
                            6.3, and
                            6.4 above.¶\nFragment identifier considerations: See Section
                            5¶\n15.1. Normative References\n"Key words for use in RFCs to Indicate Requirement Levels"\n<https://www.rfc-editor.org/info/rfc2119>\nhttps://www.rfc-editor.org/info/rfc2119\n"Uniform Resource Identifier (URI): Generic Syntax"\n<https://www.rfc-editor.org/info/rfc3986>\nhttps://www.rfc-editor.org/info/rfc3986\n"Additional Media Type Structured Syntax Suffixes"\n<https://www.rfc-editor.org/info/rfc6839>\nhttps://www.rfc-editor.org/info/rfc6839\n"JavaScript Object Notation (JSON) Pointer"\n<https://www.rfc-editor.org/info/rfc6901>\nhttps://www.rfc-editor.org/info/rfc6901\n"The JavaScript Object Notation (JSON) Data Interchange Format"\n<https://www.rfc-editor.org/info/rfc8259>\nhttps://www.rfc-editor.org/info/rfc8259\n"Linked Data Platform 1.0"\nWorld Wide Web Consortium Recommendation REC-ldp-20150226\n<https://www.w3.org/TR/2015/REC-ldp-20150226>\nhttps://www.w3.org/TR/2015/REC-ldp-20150226\n"ECMA-262, 11th edition specification"\n<https://www.ecma-international.org/ecma-262/11.0/index.html>\nhttps://www.ecma-international.org/ecma-262/11.0/index.html\n15.2. Informative References\nInformative References\n"The Canonical Link Relation"\n<https://www.rfc-editor.org/info/rfc6596>\nhttps://www.rfc-editor.org/info/rfc6596\n"Concise Binary Object Representation (CBOR)"\n<https://www.rfc-editor.org/info/rfc7049>\nhttps://www.rfc-editor.org/info/rfc7049\n"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"\n<https://www.rfc-editor.org/info/rfc7231>\nhttps://www.rfc-editor.org/info/rfc7231\n<https://www.rfc-editor.org/info/rfc8288>\nhttps://www.rfc-editor.org/info/rfc8288\n"Best Practices for Fragment Identifiers and Media Type Definitions"\nWorld Wide Web Consortium WD WD-fragid-best-practices-20121025\n<https://www.w3.org/TR/2012/WD-fragid-best-practices-20121025>\nhttps://www.w3.org/TR/2012/WD-fragid-best-practices-20121025\n"JSON Schema Validation: A Vocabulary for Structural Validation of JSON"\nInternet-Draft, draft-bhutton-json-schema-validation-01\n<https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01>\nhttps://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01\n"JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON"\nInternet-Draft, draft-handrews-json-schema-hyperschema-02\n<https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-02>\nhttps://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-02\n"Namespaces in XML 1.1 (Second Edition)"\n<http://www.w3.org/TR/2006/REC-xml-names11-20060816>\nhttp://www.w3.org/TR/2006/REC-xml-names11-20060816\nAppendix A. Schema identification examples
      

                    Consider the following schema, which shows "$id" being used to identify
                    both the root schema and various subschemas, and "$anchor" being used
                    to define plain name fragment identifiers.¶


{
    "$id": "https://example.com/root.json",
    "$defs": {
        "A": { "$anchor": "foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$anchor": "bar" },
                "Y": {
                    "$id": "t/inner.json",
                    "$anchor": "bar"
                }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

¶


                The schemas at the following URI-encoded JSON
                Pointers [RFC6901] (relative to the root schema) have the following
                base URIs, and are identifiable by any listed URI in accordance with
                sections 5 and
                9.2.1 above.¶

        # (document root)
        
          
            canonical (and base) URI
            
                                https://example.com/root.json¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/root.json#¶

          


        
#/$defs/A
        
          
            base URI
            https://example.com/root.json¶

            
canonical resource URI plus plain fragment
            
                                https://example.com/root.json#foo¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/root.json#/$defs/A¶

          


        
#/$defs/B
        
          
            canonical (and base) URI
            https://example.com/other.json¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/other.json#¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B¶

          


        
#/$defs/B/$defs/X
        
          
            base URI
            https://example.com/other.json¶

            
canonical resource URI plus plain fragment
            
                                https://example.com/other.json#bar¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/other.json#/$defs/X¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B/$defs/X¶

          


        
#/$defs/B/$defs/Y
        
          
            canonical (and base) URI
            https://example.com/t/inner.json¶

            
canonical URI plus plain fragment
            
                                https://example.com/t/inner.json#bar¶

            
canonical URI plus pointer fragment
            
                                https://example.com/t/inner.json#¶

            
base URI of enclosing (other.json) resource plus fragment
            
                                https://example.com/other.json#/$defs/Y¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B/$defs/Y¶

          


        
#/$defs/C
        
          
            canonical (and base) URI
            
                                urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f¶

            
canonical URI plus pointer fragment
            
                                urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f#¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/C¶

          


      


                Note: The fragment part of the URI does not make it canonical or non-canonical,
                rather, the base URI used (as part of the full URI with any fragment) is what
                determines the canonical nature of the resulting full URI.
                
                    Multiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.
        ¶\nAppendix A. Schema identification examples\nSchema identification examples\nConsider the following schema, which shows "$id" being used to identify
                    both the root schema and various subschemas, and "$anchor" being used
                    to define plain name fragment identifiers.¶\n{
    "$id": "https://example.com/root.json",
    "$defs": {
        "A": { "$anchor": "foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$anchor": "bar" },
                "Y": {
                    "$id": "t/inner.json",
                    "$anchor": "bar"
                }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

¶\nThe schemas at the following URI-encoded JSON
                Pointers [RFC6901] (relative to the root schema) have the following
                base URIs, and are identifiable by any listed URI in accordance with
                sections 5 and
                9.2.1 above.¶\nJSON
                Pointers [RFC6901]\nJSON
                Pointers\nNote: The fragment part of the URI does not make it canonical or non-canonical,
                rather, the base URI used (as part of the full URI with any fragment) is what
                determines the canonical nature of the resulting full URI.
                
                    Multiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.
        ¶\nMultiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.\nJSON Pointer fragments and embedded schema resources (Section 9.2.1)\nJSON Pointer fragments and embedded schema resources\nAppendix B. Manipulating schema documents and references\nManipulating schema documents and references\nVarious tools have been created to rearrange schema documents
                based on how and where references ("$ref") appear.  This appendix discusses
                which use cases and actions are compliant with this specification.¶\nB.1. Bundling schema resources into a single document\nBundling schema resources into a single document\nA set of schema resources intended for use together can be organized
                    with each in its own schema document, all in the same schema document,
                    or any granularity of document grouping in between.¶\nNumerous tools exist to perform various sorts of reference removal.
                    A common case of this is producing a single file where all references
                    can be resolved within that file.  This is typically done to simplify
                    distribution, or to simplify coding so that various invocations
                    of JSON Schema libraries do not have to keep track of and load
                    a large number of resources.¶\nThis transformation can be safely and reversibly done as long as
                    all static references (e.g. "$ref") use URI-references that resolve
                    to URIs using the canonical resource URI as the base, and all schema
                    resources have an absolute-URI as the "$id" in their root schema.¶\nWith these conditions met, each external resource can be copied
                    under "$defs", without breaking any references among the resources'
                    schema objects, and without changing any aspect of validation or
                    annotation results.  The names of the schemas under "$defs" do
                    not affect behavior, assuming they are each unique, as they
                    do not appear in the canonical URIs for the embedded resources.¶\nB.2. Reference removal is not always safe\nReference removal is not always safe\nAttempting to remove all references and produce a single schema document does not,
                    in all cases, produce a schema with identical behavior to the original form.¶\nSince "$ref" is now treated like any other keyword, with other keywords allowed
                    in the same schema objects, fully supporting non-recursive "$ref" removal in
                    all cases can require relatively complex schema manipulations.  It is beyond
                    the scope of this specification to determine or provide a set of safe "$ref"
                    removal transformations, as they depend not only on the schema structure
                    but also on the intended usage.¶\nAppendix C. Example of recursive schema extension
      

                    Consider the following two schemas describing a simple
                    recursive tree structure, where each node in the tree
                    can have a "data" field of any type.  The first schema
                    allows and ignores other instance properties.  The second is
                    more strict and only allows the "data" and "children" properties.
                    An example instance with "data" misspelled as "daat" is also shown.¶


// tree schema, extensible
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/tree",
    "$dynamicAnchor": "node",

    "type": "object",
    "properties": {
        "data": true,
        "children": {
            "type": "array",
            "items": {
                "$dynamicRef": "#node"
            }
        }
    }
}

// strict-tree schema, guards against misspelled properties
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/strict-tree",
    "$dynamicAnchor": "node",

    "$ref": "tree",
    "unevaluatedProperties": false
}

// instance with misspelled field
{
    "children": [ { "daat": 1 } ]
}

¶


                When we load these two schemas, we will notice the "$dynamicAnchor"
                named "node" (note the lack of "#" as this is just the name)
                present in each, resulting in the following full schema URIs:¶

"https://example.com/tree#node"¶

        "https://example.com/strict-tree#node"¶

      

                In addition, JSON Schema implementations keep track of the fact
                that these fragments were created with "$dynamicAnchor".¶

                If we apply the "strict-tree" schema to the instance, we will follow
                the "$ref" to the "tree" schema, examine its "children" subschema,
                and find the "$dynamicRef": to "#node" (note the "#" for URI fragment syntax)
                in its "items" subschema.  That reference resolves to
                "https://example.com/tree#node", which is a URI with a fragment
                created by "$dynamicAnchor".  Therefore we must examine the dynamic
                scope before following the reference.¶

                At this point, the dynamic path is
                "#/$ref/properties/children/items/$dynamicRef", with a dynamic scope
                containing (from the outermost scope to the innermost):¶

"https://example.com/strict-tree#"¶

        "https://example.com/tree#"¶

        "https://example.com/tree#/properties/children"¶

        "https://example.com/tree#/properties/children/items"¶

      

                Since we are looking for a plain name fragment, which can be
                defined anywhere within a schema resource, the JSON Pointer fragments
                are irrelevant to this check.  That means that we can remove those
                fragments and eliminate consecutive duplicates, producing:¶

"https://example.com/strict-tree"¶

        "https://example.com/tree"¶

      

                In this case, the outermost resource also has a "node" fragment
                defined by "$dynamicAnchor".  Therefore instead of resolving the
                "$dynamicRef" to "https://example.com/tree#node", we resolve it to
                "https://example.com/strict-tree#node".¶

                This way, the recursion in the "tree" schema recurses to the root
                of "strict-tree", instead of only applying "strict-tree" to the
                instance root, but applying "tree" to instance children.¶

                This example shows both "$dynamicAnchor"s in the same place
                in each schema, specifically the resource root schema.
                Since plain-name fragments are independent of the JSON structure,
                this would work just as well if one or both of the node schema objects
                were moved under "$defs".  It is the matching "$dynamicAnchor" values
                which tell us how to resolve the dynamic reference, not any sort of
                correlation in JSON structure.¶\nAppendix C. Example of recursive schema extension\nExample of recursive schema extension\nConsider the following two schemas describing a simple
                    recursive tree structure, where each node in the tree
                    can have a "data" field of any type.  The first schema
                    allows and ignores other instance properties.  The second is
                    more strict and only allows the "data" and "children" properties.
                    An example instance with "data" misspelled as "daat" is also shown.¶\n// tree schema, extensible
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/tree",
    "$dynamicAnchor": "node",

    "type": "object",
    "properties": {
        "data": true,
        "children": {
            "type": "array",
            "items": {
                "$dynamicRef": "#node"
            }
        }
    }
}

// strict-tree schema, guards against misspelled properties
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/strict-tree",
    "$dynamicAnchor": "node",

    "$ref": "tree",
    "unevaluatedProperties": false
}

// instance with misspelled field
{
    "children": [ { "daat": 1 } ]
}

¶\nWhen we load these two schemas, we will notice the "$dynamicAnchor"
                named "node" (note the lack of "#" as this is just the name)
                present in each, resulting in the following full schema URIs:¶\n"https://example.com/tree#node"¶\n"https://example.com/strict-tree#node"¶\nIn addition, JSON Schema implementations keep track of the fact
                that these fragments were created with "$dynamicAnchor".¶\nIf we apply the "strict-tree" schema to the instance, we will follow
                the "$ref" to the "tree" schema, examine its "children" subschema,
                and find the "$dynamicRef": to "#node" (note the "#" for URI fragment syntax)
                in its "items" subschema.  That reference resolves to
                "https://example.com/tree#node", which is a URI with a fragment
                created by "$dynamicAnchor".  Therefore we must examine the dynamic
                scope before following the reference.¶\nAt this point, the dynamic path is
                "#/$ref/properties/children/items/$dynamicRef", with a dynamic scope
                containing (from the outermost scope to the innermost):¶\n"https://example.com/strict-tree#"¶\n"https://example.com/tree#"¶\n"https://example.com/tree#/properties/children"¶\n"https://example.com/tree#/properties/children/items"¶\nSince we are looking for a plain name fragment, which can be
                defined anywhere within a schema resource, the JSON Pointer fragments
                are irrelevant to this check.  That means that we can remove those
                fragments and eliminate consecutive duplicates, producing:¶\n"https://example.com/strict-tree"¶\n"https://example.com/tree"¶\nIn this case, the outermost resource also has a "node" fragment
                defined by "$dynamicAnchor".  Therefore instead of resolving the
                "$dynamicRef" to "https://example.com/tree#node", we resolve it to
                "https://example.com/strict-tree#node".¶\nThis way, the recursion in the "tree" schema recurses to the root
                of "strict-tree", instead of only applying "strict-tree" to the
                instance root, but applying "tree" to instance children.¶\nThis example shows both "$dynamicAnchor"s in the same place
                in each schema, specifically the resource root schema.
                Since plain-name fragments are independent of the JSON structure,
                this would work just as well if one or both of the node schema objects
                were moved under "$defs".  It is the matching "$dynamicAnchor" values
                which tell us how to resolve the dynamic reference, not any sort of
                correlation in JSON structure.¶\nAppendix D. Working with vocabularies\nWorking with vocabularies\nD.1. Best practices for vocabulary and meta-schema authors\nBest practices for vocabulary and meta-schema authors\nVocabulary authors should
                    take care to avoid keyword name collisions if the vocabulary is intended
                    for broad use, and potentially combined with other vocabularies.  JSON
                    Schema does not provide any formal namespacing system, but also does
                    not constrain keyword names, allowing for any number of namespacing
                    approaches.¶\nVocabularies may build on each other, such as by defining the behavior
                    of their keywords with respect to the behavior of keywords from another
                    vocabulary, or by using a keyword from another vocabulary with
                    a restricted or expanded set of acceptable values.  Not all such
                    vocabulary re-use will result in a new vocabulary that is compatible
                    with the vocabulary on which it is built.  Vocabulary authors should
                    clearly document what level of compatibility, if any, is expected.¶\nMeta-schema authors should not use "$vocabulary" to combine multiple
                    vocabularies that define conflicting syntax or semantics for the same
                    keyword.  As semantic conflicts are not generally detectable through
                    schema validation, implementations are not expected to detect such
                    conflicts.  If conflicting vocabularies are declared, the resulting
                    behavior is undefined.¶\nVocabulary authors SHOULD provide a meta-schema that validates the
                    expected usage of the vocabulary's keywords on their own.  Such meta-schemas
                    SHOULD not forbid additional keywords, and MUST not forbid any
                    keywords from the Core vocabulary.¶\nIt is recommended that meta-schema authors reference each vocabulary's
                    meta-schema using the "allOf" (Section 10.2.1.1) keyword,
                    although other mechanisms for constructing the meta-schema may be
                    appropriate for certain use cases.¶\n"allOf" (Section 10.2.1.1)\nThe recursive nature of meta-schemas makes the "$dynamicAnchor"
                    and "$dynamicRef" keywords particularly useful for extending
                    existing meta-schemas, as can be seen in the JSON Hyper-Schema meta-schema
                    which extends the Validation meta-schema.¶\nMeta-schemas may impose additional constraints, including describing
                    keywords not present in any vocabulary, beyond what the meta-schemas
                    associated with the declared vocabularies describe.  This allows for
                    restricting usage to a subset of a vocabulary, and for validating
                    locally defined keywords not intended for re-use.¶\nHowever, meta-schemas should not contradict any vocabularies that
                    they declare, such as by requiring a different JSON type than
                    the vocabulary expects.  The resulting behavior is undefined.¶\nMeta-schemas intended for local use, with no need to test for
                    vocabulary support in arbitrary implementations, can safely omit
                    "$vocabulary" entirely.¶\nD.2. Example meta-schema with vocabulary declarations
        

                    This meta-schema explicitly declares both the Core and Applicator vocabularies,
                    together with an extension vocabulary, and combines their meta-schemas with
                    an "allOf".  The extension vocabulary's meta-schema, which describes only the
                    keywords in that vocabulary, is shown after the main example meta-schema.¶

                    The main example meta-schema also restricts the usage of the Unevaluated
                    vocabulary by forbidding the keywords prefixed with "unevaluated", which
                    are particularly complex to implement.  This does not change the semantics
                    or set of keywords defined by the other vocabularies. It just ensures
                    that schemas using this meta-schema that attempt to use the keywords
                    prefixed with "unevaluated" will fail validation against this meta-schema.¶

                    Finally, this meta-schema describes the syntax of a keyword, "localKeyword",
                    that is not part of any vocabulary.  Presumably, the implementors and users
                    of this meta-schema will understand the semantics of "localKeyword".
                    JSON Schema does not define any mechanism for expressing keyword semantics
                    outside of vocabularies, making them unsuitable for use except in a
                    specific environment in which they are understood.¶

                        This meta-schema combines several vocabularies for general use.¶


{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/general-use-example",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://example.com/vocab/example-vocab": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2020-12/meta/core"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/applicator"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/validation"},
    {"$ref": "https://example.com/meta/example-vocab"}
  ],
  "patternProperties": {
    "^unevaluated": false
  },
  "properties": {
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}

¶


                        This meta-schema describes only a single extension vocabulary.¶


{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/example-vocab",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://example.com/vocab/example-vocab": true,
  },
  "type": ["object", "boolean"],
  "properties": {
    "minDate": {
      "type": "string",
      "pattern": "\d\d\d\d-\d\d-\d\d",
      "format": "date",
    }
  }
}

¶


                    As shown above, even though each of the single-vocabulary meta-schemas
                    referenced in the general-use meta-schema's "allOf" declares its
                    corresponding vocabulary, this new meta-schema must re-declare them.¶

                    The standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.¶

                    While the general-use meta-schema can validate the syntax of "minDate",
                    it is the vocabulary that defines the logic behind the semantic meaning
                    of "minDate".  Without an understanding of the semantics (in this example,
                    that the instance value must be a date equal to or after the date
                    provided as the keyword's value in the schema), an implementation can
                    only validate the syntactic usage.  In this case, that means validating
                    that it is a date-formatted string (using "pattern" to ensure that it is
                    validated even when "format" functions purely as an annotation, as explained
                    in the Validation specification [json-schema-validation].¶\nD.2. Example meta-schema with vocabulary declarations\nExample meta-schema with vocabulary declarations\nThis meta-schema explicitly declares both the Core and Applicator vocabularies,
                    together with an extension vocabulary, and combines their meta-schemas with
                    an "allOf".  The extension vocabulary's meta-schema, which describes only the
                    keywords in that vocabulary, is shown after the main example meta-schema.¶\nThe main example meta-schema also restricts the usage of the Unevaluated
                    vocabulary by forbidding the keywords prefixed with "unevaluated", which
                    are particularly complex to implement.  This does not change the semantics
                    or set of keywords defined by the other vocabularies. It just ensures
                    that schemas using this meta-schema that attempt to use the keywords
                    prefixed with "unevaluated" will fail validation against this meta-schema.¶\nFinally, this meta-schema describes the syntax of a keyword, "localKeyword",
                    that is not part of any vocabulary.  Presumably, the implementors and users
                    of this meta-schema will understand the semantics of "localKeyword".
                    JSON Schema does not define any mechanism for expressing keyword semantics
                    outside of vocabularies, making them unsuitable for use except in a
                    specific environment in which they are understood.¶\nThis meta-schema combines several vocabularies for general use.¶\n{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/general-use-example",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://example.com/vocab/example-vocab": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2020-12/meta/core"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/applicator"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/validation"},
    {"$ref": "https://example.com/meta/example-vocab"}
  ],
  "patternProperties": {
    "^unevaluated": false
  },
  "properties": {
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}

¶\nThis meta-schema describes only a single extension vocabulary.¶\n{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/example-vocab",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://example.com/vocab/example-vocab": true,
  },
  "type": ["object", "boolean"],
  "properties": {
    "minDate": {
      "type": "string",
      "pattern": "\d\d\d\d-\d\d-\d\d",
      "format": "date",
    }
  }
}

¶\nAs shown above, even though each of the single-vocabulary meta-schemas
                    referenced in the general-use meta-schema's "allOf" declares its
                    corresponding vocabulary, this new meta-schema must re-declare them.¶\nThe standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.¶\nWhile the general-use meta-schema can validate the syntax of "minDate",
                    it is the vocabulary that defines the logic behind the semantic meaning
                    of "minDate".  Without an understanding of the semantics (in this example,
                    that the instance value must be a date equal to or after the date
                    provided as the keyword's value in the schema), an implementation can
                    only validate the syntactic usage.  In this case, that means validating
                    that it is a date-formatted string (using "pattern" to ensure that it is
                    validated even when "format" functions purely as an annotation, as explained
                    in the Validation specification [json-schema-validation].¶\nValidation specification [json-schema-validation]\nValidation specification\njson-schema-validation\nAppendix E. References and generative use cases\nReferences and generative use cases\nWhile the presence of references is expected to be transparent
                to validation results, generative use cases such as code generators
                and UI renderers often consider references to be semantically significant.¶\nTo make such use case-specific semantics explicit, the best practice
                is to create an annotation keyword for use in the same
                schema object alongside of a reference keyword such as "$ref".¶\nFor example, here is a hypothetical keyword for determining
                    whether a code generator should consider the reference
                    target to be a distinct class, and how those classes are related.
                    Note that this example is solely for illustrative purposes, and is
                    not intended to propose a functional code generation keyword.¶\n{
    "allOf": [
        {
            "classRelation": "is-a",
            "$ref": "classes/base.json"
        },
        {
            "$ref": "fields/common.json"
        }
    ],
    "properties": {
        "foo": {
            "classRelation": "has-a",
            "$ref": "classes/foo.json"
        },
        "date": {
            "$ref": "types/dateStruct.json",
        }
    }
}

¶\nHere, this schema represents some sort of object-oriented class.
                The first reference in the "allOf" is noted as the base class.
                The second is not assigned a class relationship, meaning that the
                code generator should combine the target's definition with this
                one as if no reference were involved.¶\nLooking at the properties, "foo" is flagged as object composition,
                while the "date" property is not.  It is simply a field with
                sub-fields, rather than an instance of a distinct class.¶\nThis style of usage requires the annotation to be in the same object
                as the reference, which must be recognizable as a reference.¶\nAppendix F. Acknowledgments\nThanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.¶\nThanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Evgeny Poberezkin,
                Brad Bowman,
                Gowry Sankar,
                Donald Pipowitch,
                Dave Finlay,
                Denis Laxalde,
                Phil Sturgeon,
                Shawn Silverman,
                and Karen Etheridge
                for their submissions and patches to the document.¶\nAppendix G. ChangeLog\nThis section to be removed before leaving Internet-Draft status.¶\nThis section to be removed before leaving Internet-Draft status.\nImprove and clarify the "type", "contains", "unevaluatedProperties", and "unevaluatedItems" keyword explanations¶\nClarify various aspects of "canonical URIs"¶\nComment on ambiguity around annotations and "additionalProperties"¶\nClarify Vocabularies need not be formally defined¶\nRemove references to remaining media-type parameters¶\nFix multiple examples¶\n"$schema" MAY change for embedded resources¶\nArray-value "items" functionality is now "prefixItems"¶\n"items" subsumes the old function of "additionalItems"¶\n"contains" annotation behavior, and "contains" and "unevaluatedItems" interactions now specified¶\nRename $recursive* to $dynamic*, with behavior modification¶\n$dynamicAnchor defines a fragment like $anchor¶\n$dynamic* (previously $recursive) no longer use runtime base URI determination¶\nDefine Compound Schema Documents (bundle) and processing¶\nReference ECMA-262, 11th edition for regular expression support¶\nRegular expression should support unicode¶\nRemove media type parameters¶\nSpecify Unknown keywords are collected as annotations¶\nMoved "unevaluatedItems" and "unevaluatedProperties" from core into their own vocabulary¶\nUpdate to RFC 8259 for JSON specification¶\nMoved "definitions" from the Validation specification here as "$defs"¶\nMoved applicator keywords from the Validation specification as their own vocabulary¶\nMoved the schema form of "dependencies" from the Validation specification as "dependentSchemas"¶\nFormalized annotation collection¶\nSpecified recommended output formats¶\nDefined keyword interactions in terms of annotation and assertion results¶\nAdded "unevaluatedProperties" and "unevaluatedItems"¶\nDefine "$ref" behavior in terms of the assertion, applicator, and annotation model¶\nAllow keywords adjacent to "$ref"¶\nNote undefined behavior for "$ref" targets involving unknown keywords¶\nAdd recursive referencing, primarily for meta-schema extension¶\nAdd the concept of formal vocabularies, and how they can be recognized through meta-schemas¶\nAdditional guidance on initial base URIs beyond network retrieval¶\nAllow "schema" media type parameter for "application/schema+json"¶\nBetter explanation of media type parameters and the HTTP Accept header¶\nUse "$id" to establish canonical and base absolute-URIs only, no fragments¶\nReplace plain-name-fragment-only form of "$id" with "$anchor"¶\nClarified that the behavior of JSON Pointers across "$id" boundary is unreliable¶\nThis draft is purely a clarification with no functional changes¶\nEmphasized annotations as a primary usage of JSON Schema¶\nClarified $id by use cases¶\nExhaustive schema identification examples¶\nReplaced "external referencing" with how and when an implementation might know of a schema from another document¶\nReplaced "internal referencing" with how an implementation should recognized schema identifiers during parsing¶\nDereferencing the former "internal" or "external" references is always the same process¶\nMinor formatting improvements¶\nMake the concept of a schema keyword vocabulary more clear¶\nNote that the concept of "integer" is from a vocabulary, not the data model¶\nClassify keywords as assertions or annotations and describe their general behavior¶\nExplain the boolean schemas in terms of generalized assertions¶\nReserve "$comment" for non-user-visible notes about the schema¶\nWording improvements around "$id" and fragments¶\nNote the challenges of extending meta-schemas with recursive references¶\nAdd "application/schema-instance+json" media type¶\nRecommend a "schema" link relation / parameter instead of "profile"¶\nAllowed for any schema to be a boolean¶\n"$schema" SHOULD NOT appear in subschemas, although that may change¶\nChanged "id" to "$id"; all core keywords prefixed with "$"¶\nClarify and formalize fragments for application/schema+json¶\nNote applicability to formats such as CBOR that can be represented in the JSON data model¶\nUpdated references to JSON¶\nUpdated references to HTTP¶\nUpdated references to JSON Pointer¶\nBehavior for "id" is now specified in terms of RFC3986¶\nAligned vocabulary usage for URIs with RFC3986¶\nRemoved reference to draft-pbryan-zyp-json-ref-03¶\nLimited use of "$ref" to wherever a schema is expected¶\nAdded definition of the "JSON Schema data model"¶\nAdded additional security considerations¶\nDefined use of subschema identifiers for "id"¶\nRewrote section on usage with HTTP¶\nRewrote section on usage with rel="describedBy" and rel="profile"¶\nFixed numerous invalid examples¶\nSalvaged from draft v3.¶\nSplit validation keywords into separate document.¶\nSplit hypermedia keywords into separate document.¶\nInitial post-split draft.¶\nMandate the use of JSON Reference, JSON Pointer.¶\nDefine the role of "id". Define URI resolution scope.¶\nAdd interoperability considerations.¶\nAuthors' Addresses
      

        Austin Wright (editor)

Email:
[email protected]



        Henry Andrews (editor)

Email:
[email protected]



        Ben Hutton (editor)
Postman

Email:
[email protected]


URI:
https://jsonschema.dev



        Greg Dennis

Email:
[email protected]


URI:
https://github.com/gregsdennis\nAustin Wright (editor)\nAustin Wright (editor)\nEmail:
[email protected]\nHenry Andrews (editor)\nHenry Andrews (editor)\nEmail:
[email protected]\nEmail:
[email protected]\nURI:
https://jsonschema.dev\nhttps://jsonschema.dev\nEmail:
[email protected]\nURI:
https://github.com/gregsdennis\nhttps://github.com/gregsdennis\n\n\n8. A Vocabulary for the Contents of String-Encoded Data
      

        
8.1. Foreword
        

                    Annotations defined in this section indicate that an instance contains
                    non-JSON data encoded in a JSON string.¶

                    These properties provide additional information required to interpret JSON data
                    as rich multimedia documents.  They describe the type of content, how it is encoded,
                    and/or how it may be validated.  They do not function as validation assertions;
                    a malformed string-encoded document MUST NOT cause the containing instance
                    to be considered invalid.¶

                    Meta-schemas that do not use "$vocabulary" SHOULD be considered to
                    require this vocabulary as if its URI were present with a value of true.¶

                    The current URI for this vocabulary, known as the Content vocabulary, is:
                    <https://json-schema.org/draft/2020-12/vocab/content>.¶

                    The current URI for the corresponding meta-schema is:
                    https://json-schema.org/draft/2020-12/meta/content.¶


        
8.2. Implementation Requirements
        

                    Due to security and performance concerns, as well as the open-ended nature of
                    possible content types, implementations MUST NOT automatically decode, parse,
                    and/or validate the string contents by default.  This additionally supports
                    the use case of embedded documents intended for processing by a different
                    consumer than that which processed the containing document.¶

                    All keywords in this section apply only to strings, and have no
                    effect on other data types.¶

                    Implementations MAY offer the ability to decode, parse, and/or validate
                    the string contents automatically.  However, it MUST NOT perform these
                    operations by default, and MUST provide the validation result of each
                    string-encoded document separately from the enclosing document.  This
                    process SHOULD be equivalent to fully evaluating the instance against
                    the original schema, followed by using the annotations to decode, parse,
                    and/or validate each string-encoded document.
                    
                        For now, the exact mechanism of performing and returning parsed
                        data and/or validation results from such an automatic decoding, parsing,
                        and validating feature is left unspecified.  Should such a feature
                        prove popular, it may be specified more thoroughly in a future draft.
          ¶

                    See also the Security Considerations (Section 10)
                    sections for possible vulnerabilities introduced by automatically
                    processing the instance string according to these keywords.¶


        
8.3. contentEncoding
        

                    If the instance value is a string, this property defines that the string
                    SHOULD be interpreted as encoded binary data and decoded using the encoding
                    named by this property.¶

                    Possible values indicating base 16, 32, and 64 encodings with several
                    variations are listed in RFC 4648 [RFC4648].  Additionally,
                    sections 6.7 and 6.8 of RFC 2045 [RFC2045] provide
                    encodings used in MIME. This keyword is derived from MIME's
                    Content-Transfer-Encoding header, which was designed to map binary data
                    into ASCII characters.  It is not related to HTTP's Content-Encoding header,
                    which is used to encode (e.g. compress or encrypt)
                    the content of HTTP request and responses.¶

                    As "base64" is defined in both RFCs, the definition
                    from RFC 4648 SHOULD be assumed unless the string is specifically intended
                    for use in a MIME context.  Note that all of these encodings result in
                    strings consisting only of 7-bit ASCII characters.  Therefore, this keyword
                    has no meaning for strings containing characters outside of that range.¶

                    If this keyword is absent, but "contentMediaType" is present, this
                    indicates that the encoding is the identity encoding, meaning that
                    no transformation was needed in order to represent the content in
                    a UTF-8 string.¶

                    The value of this property MUST be a string.¶


        
8.4. contentMediaType
        

                    If the instance is a string, this property indicates the media type
                    of the contents of the string.  If "contentEncoding" is present,
                    this property describes the decoded string.¶

                    The value of this property MUST be a string, which MUST be a media type,
                    as defined by RFC 2046 [RFC2046].¶


        
8.5. contentSchema
        

                    If the instance is a string, and if "contentMediaType" is present, this
                    property contains a schema which describes the structure of the string.¶

                    This keyword MAY be used with any media type that can be mapped into
                    JSON Schema's data model.¶

                    The value of this property MUST be a valid JSON schema. It SHOULD be ignored if
                    "contentMediaType" is not present.¶


        
8.6. Example
        

                        Here is an example schema, illustrating the use of "contentEncoding" and
                        "contentMediaType":¶


{
    "type": "string",
    "contentEncoding": "base64",
    "contentMediaType": "image/png"
}

¶


                        Instances described by this schema are expected to be strings,
                        and their values should be interpretable as base64-encoded PNG images.¶

                        Another example:¶


{
    "type": "string",
    "contentMediaType": "text/html"
}

¶


                        Instances described by this schema are expected to be strings containing HTML,
                        using whatever character set the JSON string was decoded into.
                        Per section 8.1 of
                        RFC 8259 [RFC8259], outside of an entirely closed
                        system, this MUST be UTF-8.¶

                        This example describes a JWT that is MACed using the HMAC SHA-256
                        algorithm, and requires the "iss" and "exp" fields in its claim set.¶


{
    "type": "string",
    "contentMediaType": "application/jwt",
    "contentSchema": {
        "type": "array",
        "minItems": 2,
        "prefixItems": [
            {
                "const": {
                    "typ": "JWT",
                    "alg": "HS256"
                }
            },
            {
                "type": "object",
                "required": ["iss", "exp"],
                "properties": {
                    "iss": {"type": "string"},
                    "exp": {"type": "integer"}
                }
            }
        ]
    }
}
¶


                        Note that "contentEncoding" does not appear.  While the "application/jwt"
                        media type makes use of base64url encoding, that is defined by the media
                        type, which determines how the JWT string is decoded into a list of two
                        JSON data structures: first the header, and then the payload.  Since the
                        JWT media type ensures that the JWT can be represented in a JSON string,
                        there is no need for further encoding or decoding.¶\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-Schema2020-12 Release NotesThe previous draft (2019-09) introduced a lot of new concepts including
$recursiveRef/$recursiveAnchor, unevaluatedProperties/unevaluatedItems,
vocabularies, and more. Since then, these new features have seen multiple
implementations and usage in real schemas. This draft is mostly dedicated to
changes related to applying the lessons we've learned about implementing and
using these new features in the wild.This document attempts to put information most useful to schema authors toward
the top and information for implementation authors toward the bottom.Changes to items and additionalItemsThe keywords used for defining arrays and tuples have been redesigned to help
lower the learning curve for JSON Schema. Since the items keyword was used for
both types, we would often see people mistakenly defining a tuple when they
meant to define an array and not understand why only the first item in the array
was validating.The items and additionalItems keywords have been replaced with prefixItems
and items where prefixItems has the same functionality as the
array-of-schemas for of the old items and the new items keyword has the same
functionality as the old additionalItems keyword.Although the meaning of items has changed, the syntax for defining arrays
remains the same. Only the syntax for defining tuples has changed. The idea is
that an array has items (items) and optionally has some positionally defined
items that come before the normal items (prefixItems).Here are some examples to illustrate the changes.Open tupleDraft 2019-09Draft 2020-12data{  "items": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ]}﻿data{  "prefixItems": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ]}﻿ Closed tupleDraft 2019-09Draft 2020-12data{  "items": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "additionalItems": false}﻿data{  "prefixItems": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "items": false}﻿ Tuple with constrained additional itemsDraft 2019-09Draft 2020-12data{  "items": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "additionalItems": { "$ref": "#/$defs/baz" }}﻿data{  "prefixItems": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "items": { "$ref": "#/$defs/baz" }}﻿$dynamicRef and $dynamicAnchorThe $recursiveRef and $recursiveAnchor keywords were replaced by the more
powerful $dynamicRef and $dynamicAnchor keywords. $recursiveRef and
$recursiveAnchor were introduced in the previous draft to solve the problem of
extending recursive schemas. As the "recursive" keywords got some use and we
understood them better, we discovered how we could generalize them to solve even
more types of problems. The name change reflects that these keywords are useful
for more than just extending recursive schemas.A $dynamicAnchor can be thought of like a normal $anchor except that it can
be referenced across schemas rather than just in the schema where it was
defined. You can think of the old $recursiveAnchor as working the same way
except that it only allowed you to create one anchor per schema, it had to be at
the root of the schema, and the anchor name is always empty.$dynamicRef works the same as the old $recursiveRef except that fragments
are no longer empty ("$dynamicRef": "#my-anchor" instead of "$recursiveRef":
"#") and non-fragment-only URIs are allowed. When a $dynamicRef contains a
non-fragment-only URI-Reference, the schema the URI-Reference resolves to is
used as the starting point for dynamic resolution.Here's how you would covert a schema using $recursiveRef to use $dynamicRef.Draft 2019-09Draft 2020-121// tree schema, extensible
2{
3"$schema": "https://json-schema.org/draft/2019-09/schema",
4"$id": "https://example.com/tree",
5"$recursiveAnchor": true,
6"type": "object",
7"properties": {
8"data": true,
9"children": {
10  "type": "array",
11  "items": { "$recursiveRef": "#" }
12}
13}
14}
15// strict-tree schema, guards against misspelled properties
16{
17"$schema": "https://json-schema.org/draft/2019-09/schema",
18"$id": "https://example.com/strict-tree",
19"$recursiveAnchor": true,
20"$ref": "tree",
21"unevaluatedProperties": false
22}
231// tree schema, extensible
2{
3"$schema": "https://json-schema.org/draft/2020-12/schema",
4"$id": "https://example.com/tree",
5"$dynamicAnchor": "node",
6"type": "object",
7"properties": {
8"data": true,
9"children": {
10  "type": "array",
11  "items": { "$dynamicRef": "#node"}
12}
13}
14}
15// strict-tree schema, guards against misspelled properties
16{
17"$schema": "https://json-schema.org/draft/2020-12/schema",
18"$id": "https://example.com/strict-tree",
19"$dynamicAnchor": "node",
20"$ref": "tree",
21"unevaluatedProperties": false
22}
23contains and unevaluatedItemsIn the previous draft, it wasn't specified how or if the contains keyword
affects the unevaluatedItems keyword. This draft specifies that any item in an
array that passes validation of the contains schema is considered "evaluated".This allows you to use contains to express some constraints more cleanly than
you could in previous drafts. This example show how you can express an array
that has some item matching one schema and everything else matching another
schema.Draft 2019-09Draft 2020-12data  {    "type": "array",    "contains": { "type": "string" },    "items": {      "anyOf": [        { "type": "string" },        { "type": "number" }      ]    }  }﻿data  {    "type": "array",    "contains": { "type": "string" },    "unevaluatedItems": { "type": "number" }  }﻿Unfortunately, this change means you may not be able to use contains in some
situations you did before. Consider this draft 2019-09 schema describing a tuple
of two strings where one of the two must be three or more characters long and
any additional items are not allowed. schema{  "$schema": "https://json-schema.org/draft/2019-09/schema",  "type": "array",  "items": [{ "type": "string" }, { "type": "string" }],  "contains": { "type": "string", "minLength": 3 },  "unevaluatedItems": false}﻿
Given this schema, the instance ["a", "b", "ccc"] will fail because "ccc" is
considered unevaluated and fails the unevaluatedItems keyword. Now let's
naively convert that example to a draft 2020-12 schema. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "array",  "prefixItems": [{ "type": "string" }, { "type": "string" }],  "contains": { "type": "string", "minLength": 3 },  "unevaluatedItems": false}﻿
Given this schema, the instance ["a", "b", "ccc"] will pass because "ccc" is
considered evaluated and doesn't not apply to the unevaluatedItems keyword. To
fix this problem we can use the same boolean algebra transformation we used to
use before we had the contains keyword. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "array",  "prefixItems": [{ "type": "string" }, { "type": "string" }],  "not": {    "items": {      "not": { "type": "string", "minLength": 3 }    }  },  "unevaluatedItems": false}﻿
Given this schema, the instance ["a", "b", "ccc"] will fail because "ccc" is
considered unevaluated and fails the unevaluatedItems keyword like it did in
previous drafts.Regular ExpressionsRegular expressions are now expected (but not strictly required) to support
unicode characters. Previously, this was unspecified and implementations may or
may not support this unicode in regular expressions.Media Type ChangesJSON Schema defines two media types, application/schema+json and
application/schema-instance+json. This draft drops support for the schema
media type parameter. It's caused a lot of confusion and disagreement. Since we
haven't seen any evidence of anyone actually using it, it was decided to remove
it for now.Embedded Schemas and BundlingIn Draft 2019-09, the meaning of $id in a sub-schema changed from indicating a
base URI change within the current schema to indicating an embedded schema
independent of the parent schema. A schema that contains one or more embedded
schemas is called a "Compound Schema Document". This draft introduces guidance
on how bundlers should embedded schemas to create Compound Schema Documents.If you reference an external schema, that schema can declare its own $schema
and that may be different than the $schema of the referencing schema.
Implementations need to be prepared to switch processing modes or throw an
error if they don't support the $schema of the referenced schema. Embedded
schemas work exactly the same way. They may declare a $schema that is not the
same as the parent schema and implementations need to be prepared to handle the
$schema change appropriately.A notable consequence of embedded schemas having a different $schema than its
parent is that implementations can't validate Compound Schema Documents directly
against the meta-schema. The Compound Schema Document needs to be decomposed and
each Schema Resource needs to be validated individually against the appropriate
meta-schema for that schema.This draft introduces official guidance on how to use embedded schemas to
bundle schemas into a Compound Schema Document. The approach is designed to not
have to modify schemas (other than adding to $defs) so that output results
remain as similar as possible whether you are validating the bundled schema or
following external references. Here's an example of a customer schema with
external references that we want to bundle. schema{  "$schema": "https://json-schema.org/draft/2020-12",  "$id": "https://example.com/schema/customer",﻿  "type": "object",  "properties": {    "name": { "type": "string" },    "phone": { "$ref": "/schema/common#/$defs/phone" },    "address": { "$ref": "/schema/address" }  }}﻿
data{  "$schema": "https://json-schema.org/draft/2020-12",  "$id": "https://example.com/schema/address",﻿  "type": "object",  "properties": {    "address": { "type": "string" },    "city": { "type": "string" },    "postalCode": { "$ref": "/schema/common#/$defs/usaPostalCode" },    "state": { "$ref": "/$defs/states" }  },﻿  "$defs": {    "states": {      "enum": [...]    }  }}﻿
data{  "$schema": "https://json-schema.org/draft/2019-09",  "$id": "https://example.com/schema/common",﻿  "$defs": {    "phone": {      "type": "string",      "pattern": "^[\+]?[(]?[0-9]{3}[)]?[- \.]?[0-9]{3}[- \.]?[0-9]{4,6}$"    },    "usaPostalCode": {      "type": "string",      "pattern": "^[0-9]{5}(?:-[0-9]{4})?$"    },    "unsignedInt": {      "type": "integer",      "minimum": 0    }  }}﻿
To bundle these schemas, we simply add each of the referenced schemas as
embedded schemas using $defs. Here's what the bundled schema would look like.data{  "$schema": "https://json-schema.org/draft/2020-12",  "$id": "https://example.com/schema/customer",﻿  "type": "object",  "properties": {    "name": { "type": "string" },    "phone": { "$ref": "/schema/common#/$defs/phone" },    "address": { "$ref": "/schema/address" }  },﻿  "$defs": {    "https://example.com/schema/address": {      "$id": "https://example.com/schema/address",﻿      "type": "object",      "properties": {        "address": { "type": "string" },        "city": { "type": "string" },        "postalCode": { "$ref": "/schema/common#/$defs/usaPostalCode" },        "state": { "$ref": "#/$defs/states" }      },﻿      "$defs": {        "states": {          "enum": [...]        }      }    },    "https://example.com/schema/common": {      "$schema": "https://json-schema.org/draft/2019-09",      "$id": "https://example.com/schema/common",﻿      "$defs": {        "phone": {          "type": "string",          "pattern": "^[\+]?[(]?[0-9]{3}[)]?[- \.]?[0-9]{3}[- \.]?[0-9]{4,6}$"        },        "usaPostalCode": {          "type": "string",          "pattern": "^[0-9]{5}(?:-[0-9]{4})?$"        },        "unsignedInt": {          "type": "integer",          "minimum": 0        }      }    }  }}﻿
Here are a few things you might notice from this example.No $refs were modified. Even local references are unchanged.https://example.com/schema/common#/
$defs/unsignedInt got pulled in with the
common schema even though it isn't used. It's allowed to trim out the extra
definitions, but not necessary.https://example.com/schema/address doesn't declare a $schema. Because it
uses the same $schema as https://example.com/schema/customer, it can skip
that declaration and use the $schema from the schema it's embedded in.https://example.com/schema/common uses a different $schema than the
document it's embedded in. That's allowed.Definitions from https://example.com/schema/common are used in both of the
other schemas and only needs to be included once. It isn't necessary for
bundlers to embed a schema inside another embedded schema.AnnotationsImplementations that collect annotations should now include annotations for
unknown keywords in the "verbose" output format. The annotation value for an
unknown keyword is the keyword's value.Vocabulary ChangesThe unevaluatedProperties and unevaluatedItems keywords have been moved from
the applicator vocabulary to their own designated vocabulary which is required
in the default meta-schema. In Draft 2019-09, these keywords were expected to
throw an error if not implemented. This was a special-case behavior of the
applicator vocabulary. Moving the "unevaluated" keywords into their own
vocabulary allows us to remove that special-case and also allowing for dialects
to be constructed that don't require these keywords.The format vocabulary was broken into two separate vocabularies. The
"format-annotation" vocabulary treats the format keyword as an annotation and
the "format-assertion" vocabulary treats the format keyword as an assertion.
The "format-annotation" vocabulary is used in the default meta-schema and is
required. In Draft 2019-09, format should be evaluated as an annotation by
default and implementations could provide configuration to change the behavior
to evaluate format as an assertion. The separate vocabularies allow for
removing the special configuration requirements and just use the vocabulary
system to express which behavior should be used.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-Schema2019-09 Release NotesFor the vast majority of schema authors, we hope that these changes are minimally disruptive.The most likely to be frustrating is that format is no longer treated as a validation assertion by default (although it is still possible for an application or user to configure a validator to treat it as one).  We decided this was acceptable because many schema authors are already extremely frustrated by its inconsistent behavior.For implementors, there is a lot more to consider, and further guidance on implementation topics will be forthcoming.Incompatible ChangesSemi-incompatible ChangesAnnotations, Errors, and OutputsKeyword Changes
  Core VocabularyApplicator VocabularyValidation VocabularyFormat VocabularyContent VocabularyMeta-Data VocabularyHyper-Schema VocabularyFor a basic list of changes to each document, see their change logs:CoreValidationHyper-SchemaIncompatible ChangesBy default, format is no longer an assertion.  This has been done because the inconsistent implementation of format as an assertion has been an endless source of surprising problems for schema authors.  The default behavior will now be predictable, if not ideal.  There are several ways to turn on assertion functionality, as explained below.  However, we recommend doing semantic validation in the application layer.Plain name fragments are no longer defined with $id, but instead with the new keyword $anchor (which has a different syntax).$id cannot contain a fragment anymore (except possibly an empty fragment, although that is discouraged).In cases where multiple URIs could be used for the same schema, some are now discouraged.  These are believed to have rarely been used, as the behavior involved was fairly confusing and not well explained until the updated version of draft-07 (draft-handrews-json-schema-01).  If this doesn't mean much to you, you are probably safe.Semi-incompatible ChangesThe old syntax for these keywords is not an error (and the default meta-schema still validates them), so implementations can therefore offer a compatibility mode.  However, migrating to the new keywords is straightforward and should be preferred.definitions is now $defsdependencies has been split into dependentSchemas and dependentRequiredAnnotations, Errors, and OutputsAnnotation keywords such as title, readOnly, and default have always been a part of JSON Schema, but without any guidance on how to make use of them.  This draft formalizes how implementations can make annotation information available to applications.Similarly, there has not previously been guidance on what constitutes useful error reporting when validation fails.To solve both of these problems, we now recommend that implementations support one or more of standardized output formats.Keyword ChangesAll keywords have now been organized into vocabularies, with the Core and Validation specifications containing multiple vocabularies.  In this process, some keywords have moved from Validation into Core.Core VocabularyCore Specification, Section 8 keyword  change  notes$anchor  new  Replaces the #plain-name form of $id, with a different syntax and approach$defs (renamed from definitions)  renamed  Note that the standard meta-schema still reserves definitions for backwards compatibility$id  changed  Only URI-references without fragments are allowed; see $anchor for a replacement for plain-name fragments; all other fragments in $id had undefined behavior previously$recursiveAnchor and $recursiveRef  new  Used for extending recursive schemas such as meta-schemas$ref  changed  Other keywords are now allowed alongside of it$vocabulary  new  Has effects only in meta-schemas, and is used to control what keywords an implementation must or can support in order to process a schema using that meta-schemaApplicator VocabularyCore Specification, Section 9These keywords were formerly found in the Validation Specification. keyword  change  notesdependentSchemas (split from dependencies)  split  This is the schema form of dependencies; note that the standard meta-schema still reserves dependencies for backwards compatibilityunevaluatedItems  new  Similar to additionalItems, but can "see" into subschemas and across referencesunevaluatedProperties  new  Similar to additionalProperties, but can "see" into subschemas and across referencesThe other applicator vocabulary keywords are items, additionalItems, properties, patternProperties, additionalProperties, anyOf, allOf, oneOf, not, if, then, else.Validation VocabularyValidation Specification, Section 6 keyword  change  notesdependentRequired (split from dependencies)  split  This is the string array form of dependencies; note that the standard meta-schema still reserves dependencies for backwards compatibilitymaxContains and minContains  new  Assertion for controlling how many times a subschema must be matched within an array
Format VocabularyValidation Specification, Section 7The format keywords has always been problematic due to its optional nature.  There has never been a way to ensure that the implementation processing your schema supports format at all, or if it does, to what degree it validates each type of format.  In theory, since each format references a standard specification, if a format is supported, it should behave consistently.  In practice, this is not the case.There are two ways for an application to validate formats: It can rely on a JSON Schema implementation to validate them (which may or may not have the expected results), or it can note where the format keyword has been used and perform its own validation based on that.  This second approach is supported by treating format as an annotation keyword and supporting the basic, detailed, or verbose output formats.To impose some predictability on this system, the behavior has changed in several ways, as illustrated below.  The key difference here is that format validation is now predictably off by default, but can be configured to be turned on.  In draft-07, it was on (but possibly unimplemented) by default and could be configured to be turned off.In the following charts, the "supported" column refers to whether and (for 2019-09) to what degree the implementation claims to support the format keyword.  The "configuration" column refers to whether some non-default behavior for format is configured somehow (in a configuration file, or through a command-line option, or whatever).Summary of draft-07 behavior supported    configuration  outcome no           n/a            not validated yes          default (on) inconsistently validated yes          off            not validatedObviously, each implementation will behave consistently from schema to schema, although some formats may be supported more thoroughly than others despite the wording in the specification.  However, complex formats are, in practice, supported to different degrees in each implementation.  If they are supported at all.Summary of 2019-09 behaviorThe goal with this draft is to make the default behavior predictable, with the inconsistent behavior as an opt-in feature.  This is not entirely satisfactory, but we feel that it is a good first step to reduce the number of complaints seen around surprising results.  This way, there should at least be fewer surprises."best effort" validation is a fairly weak requirement, which matches how things work in practice today.  Simple formats are probably fully valid, complex formats may be minimally validated or even not validated at all."full syntax" validation means that you can expect a reasonably thorough syntactic validation, probably corresponding to whatever commonly available libraries can do in the implementation language.  For formats such as IP addresses and dates, this is expected to be complete validation.  For more complex formats such as email addresses, support will probably still vary significantly.  It's unclear how many implementations have ever provided this level of support.An outcome of vocabulary error means that the implementation will refuse to process the schema as it cannot satisfy the vocabulary requirement. supported    configuration   vocabulary     outcome no           n/a             false          not validated no           n/a             true           vocabulary error best effort  default (off) false          not validated best effort  default (off) true           vocabulary error best effort  on              false          best effort validation best effort  on              true           vocabulary error full syntax  default (off) false          not validated full syntax  default (off) true           full syntax validation full syntax  on              false          full syntax validation full syntax  on              true           full syntax validationNote that, given that almost no draft-07 or earlier implementations have offered strict and complete validation of every single format, it seems unlikely that any implementations will support option 3 option in practice.Additionally, two new formats were added, and a specification reference was updated:format  change  notes "duration"  added  The duration format is from the ISO 8601 ABNF as given in Appendix A of RFC 3339 "hostname" and "idn-hostname"  updated  Use RFC 1123 instead of RFC 1034; this allows for a leading digit "uuid"  added  A string instance is valid against this attribute if it is a valid string representation of a UUID, according to RFC4122
Content VocabularyValidation Specification, Section 8These keywords are now specified purely as annotations, and never assertions.  Some guidance is provided around how an implementation can optionally offer further automatic processing of this information outside of the validation process. keyword  change  notes contentEncoding  updated  Encodings from RFC 4648 are now allowed, and take precedence over RFC 2045 when there is a difference contentSchema  added  Schema for use with the decoded content string; note that it is not automatically applied as not all content media types can be understood in advanceMeta-Data VocabularyValidation Specification, Section 9 keyword  change  notes deprecated  added  Used to indicate that a field is deprecated in some application-specific mannerHyper-Schema VocabularyHyper-Schema Specification, Sections 5 and 6 keyword  change  notes rel  changed  Can now be an array of values instead of just a stringNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft-07 Release NotesFor the Core and Validation specifications, draft-07 is a relatively
minor update.  In terms of validation keywords and outcomes, it is fully
backwards-compatible with draft-06.Some differences exist with keywords moved over from Hyper-Schema, and with
how instances and schemas are recommended to be linked together.  Finally,
the process of collecting annotation keyword values has been defined
more clearly than before.KeywordsFormatsClassification of KeywordsCollecting Annotation ValuesJSON Schema in Hypermedia Environments
  Linking Instances and SchemasInstance Media TypeKeywordsNo keywords changed behaviorNo keywords were removedSome keywords were moved from Hyper-Schema, and two of those were renamed keyword  change  notes"$comment"  added to Core  Intended for notes to schema maintainers, as opposed to "description" which is suitable for display to end users"if", "then", "else"  added to Validation  explicit conditional schema evaluation"readOnly"  moved from Hyper-Schema to Validation  not limited to hypermedia environments"writeOnly"  added to Validation  general write-only fields, including but not limited to passwords"contentMediaType"  moved from Hyper-Schema to Validation  formerly "media": {"type": "..."}"contentEncoding"   moved from Hyper-Schema to Validation  formerly "media": {"binaryEncoding": "..."}Note that the "content*" keywords do not require validation.FormatsNumerous formats were added, clarified, or restored from older drafts. format  change  notes"iri"  added  I18N equivalent of "uri""iri-reference"  added  I18N equivalent of "uri-reference""uri-template"  noted IRI support  There is no separate IRI Template standard"idn-email"  added  I18N equivalent of "email""idn-hostname"  added  I18N equivalent of "hostname""json-pointer"  clarified  Use for string form only, not URI fragment"relative-json-pointer"  added  Revived Relative JSON Pointer draft"regex"  restored from draft-03  ECMA 262 regular expressions"date"  restored from draft-03  RFC 3339 "full-date""time"  restored from draft-03  RFC 3339 "full-time"All other RFC 3339 date, time, and duration names are reserved for future
consideration.  If added as extension formats, they SHOULD be implemented
in a way that is compatible with their use in the RFC to ensure future
compatibility.Classification of KeywordsWhile it does not have a direct impact on the validation process, this set
of drafts classifies keywords by their behavior.  The names of these
classifications are used throughout the documents, so they are useful
to know:ApplicabilityAssertionsAnnotationsNote that definitions does not fit any of these categories, nor do the
dollar-prefixed Core keywords.Collecting Annotation ValuesAnnotation keywords (formerly
called metadata keywords
now provide guidance on
how to collect multiple values
that apply to the same location in the instance.  By default, all values
that are not found within
negated schemas are collected
as an unordered set.  The following exceptions are documented under the
approprite keywords:readOnly and writeOnly should be logically ORedexamples should be flattened into a single collected arrayJSON Schema in Hypermedia EnvironmentsThese changes are not relevant to many Validation use cases, and are more
of interest to Hyper-Schema users.  However, even without Hyper-Schema,
if you are accessing instance documents over HTTP or through other hypermedia
environments, you may find this section useful.Linking Instances and SchemasAfter discussions with the author of the "profile" specification, we concluded
that its use for JSON Schema was not correct.  The new guidance for
what relations to use
to link instances to schemas is: link relation  change  notes"describedBy"  no change  network-accessible URL"profile"  removed; use "schema"  opaque identifying URI"schema"  added  opaque identifying URI"schema", like "profile" in past drafts, can also be used as a
media type parameter.Instance Media TypeChanges in the section are more relevant to JSON Hyper-Schema than to
Validation, but as they are part of the core specification, they are
explained here.Media types determine their own parameters, as well as their own
URI fragment syntax(es).  application/json does not allow any parameters
or URI fragments.application/schema-instance+json
 is an optional media type for use with instances that supports "schema"
as a media type parameter, and allows for URI fragments using the JSON Pointer
syntax.Supporting "schema" as a media type parameter allows for
schema-based content negotiation in hypermedia environments.Supporting JSON Pointer URI fragments is primarily useful with JSON Hyper-Schema,
as many URIs involved in hyper-schema usage originate from or point to
locations within an instance document rather than the entire document.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDraft-06 Release NotesRelease notes for migrating from zyp-04 and fge-00 (draft-04) to wright-01 (draft-06).NOTE: draft-07 has been releasedNote that draft-07 core and validation are backwards-compatible with draft-06.
For more information, see that draft's migration notes.Q: What are the changes between draft-04 and draft-06?
  Backwards-incompatible changesAdditions and backwards-compatible changesFormats: "uri" vs "uri-reference"Q: What happened to draft-05?Q: What happened to all the discussions around re-using schemas with "additionalProperties"?Q: What are the changes between draft-04 and draft-06?Backwards-incompatible changes keyword  change  consequence"id"  replaced by "$id"  no longer easily confused with instance properties named "id""$id"  replaces "id"  behavior is identical, $ prefix matches the other two core keywords"$ref"  only allowed where a schema is expected  it is now possible to describe instance properties named "$ref""exclusiveMinimum" and "exclusiveMaximum"  changed from a boolean to a number to be consistent with the principle of keyword independence  wherever one of these would be true before, change the value to the corresponding "minimum" or "maximum" value and remove the "minimum"/"maximum" keyword"type"  definition of "integer"  in draft-04, "integer" is listed as a primitive type and defined as "a JSON number without a fraction or exponent part"; in draft-06, "integer" is not considered a primitive type and is only defined in the section for keyword "type" as "any number with a zero fractional part"; 1.0 is thus not a valid "integer" type in draft-04 and earlier, but is a valid "integer" type in draft-06 and later; note that both drafts say that integers SHOULD be encoded in JSON without fractional partsAdditions and backwards-compatible changes keyword  change  consequencebooleans as schemas  allowable anywhere, not just "additionalProperties" and "additionalItems"  true is equivalent to {}, false is equivalent to {"not": {}}, but the intent is more clear and implementations can optimize these cases more easily"propertyNames"  added  takes a schema which validates the names of all properties rather than their values"contains"  added  array keyword that passes validation if its schema validates at least one array item"const"  added  more readible form of a one-element "enum""required"  allows an empty array  an empty array indicates that no properties are required"dependencies"  allows an empty array for property dependencies  an empty array indicates that there are no dependencies for the given property"format": "uri-reference"  added  allows relative URI references per RFC 3986; see the section below about "uri" as a format"format": "uri-template"  added  indicates an RFC 6570 conforming URI Template value, as is used in JSON Hyper-Schema for "href""format": "json-pointer"  added  indicates a JSON Pointer value such as /foo/bar; do not use this for JSON Pointer URI fragments such as #/foo/bar: the proper format for those is "uri-reference""examples"  added  array of examples with no validation effect; the value of "default" is usable as an example without repeating it under this keywordFormats: "uri" vs "uri-reference"While not technically a change, the behavior of the "uri" format was not clearly explained and often implemented and used incorrectly (including in the draft-04 meta-schema)."uri" should only be used when an absolute URI (starting with a scheme) is required.When a relative path, fragment, or any other style of URI Reference (per RFC 3986) is allowable, use "uri-reference".Implementations offering a translation from draft-04 to draft-06 may want to offer an option to convert "uri" formats to "uri-reference", although any such option should be disabled by default for strict conformance.Q: What happened to draft-05?The draft-05 core and validation specifications were intended to be more clear and readable rewrites of draft-04, to give us a strong base for draft-06 changes.  Implementors should not implement or advertise support for "draft-05".Implementations that supported "draft-05" by implementing proposals from right after the publication of draft-04 should either remove that support or give it a different name to avoid confusion.Q: What happened to all the discussions around re-using schemas with "additionalProperties"?There are several competing proposals for making the re-use of schemas that set "additionalProperties" to something other than true.  Most people specifically care about the case where it is false, but the same behavior occurs with any non-true value.All of the proposals in this area will be the focus of draft-08.  While we made progress in eliminating some options during draft-07, the remaining divisions are deep enough to warrant making it the primary focus of a draft (draft-07's primary focus is Hyper-Schema).The difficulty is that if you attempt to do this:data{    "type": "object",    "allOf": [        { "$ref": "#/definitions/foo" },        { "$ref": "#/definitions/bar" }    ],    "definitions": {        "foo": {            "properties": {                "foo": { "type": "string" }            },            "additionalProperties": false        },        "bar": {            "properties": {                "bar": { "type": "number" }            },            "additionalProperties": false        }    }}﻿
Validation will always fail for any non-empty object instance.  "additionalProperties" only knows about immediately adjacent "properties" and "patternProperties", in order to ensure that each subschema means the same thing whether it is being used with another subschema or on its own.So in this example, if the instance has a "bar" property, it will fail the first subschema because "bar" is not "foo".  If it has a "foo" property, it will fail the second subschema because "foo" is not "bar".  And any other property will fail both schemas.A workaround is available with the new "propertyNames" keyword:data{    "type": "object",    "allOf": [        { "$ref": "#/definitions/foo" },        { "$ref": "#/definitions/bar" }    ],    "propertyNames": {        "anyOf": [            { "$ref": "#/definitions/fooNames" },            { "$ref": "#/definitions/barNames" }        ]    },    "definitions": {        "foo": {            "properties": {                "foo": { "type": "string" }            }        },        "fooNames": { "enum": ["foo"] },        "bar": {            "properties": {                "bar": { "type": "number" }            }        },        "barNames": { "enum": ["bar"] }    }}﻿
This will allow an object with either "foo" or "bar" or both, but will fail validation if any other property is present.  The "allOf" ensures that "foo" and "bar" will each be validated correctly if present, while the "anyOf" allows for properties with names in either allowed set, but forbids properties that are not listed in at least one set.It does require duplicating the names, and the awkward use of both an "allOf" and "anyOf", but it is less repetition than other options, and can be re-used fairly robustly even if the "foo" and "bar" schemas are in separate files managed by a different person or organization.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-Schema2019-09 Release NotesFor the vast majority of schema authors, we hope that these changes are minimally disruptive.The most likely to be frustrating is that format is no longer treated as a validation assertion by default (although it is still possible for an application or user to configure a validator to treat it as one).  We decided this was acceptable because many schema authors are already extremely frustrated by its inconsistent behavior.For implementors, there is a lot more to consider, and further guidance on implementation topics will be forthcoming.Incompatible ChangesSemi-incompatible ChangesAnnotations, Errors, and OutputsKeyword Changes
  Core VocabularyApplicator VocabularyValidation VocabularyFormat VocabularyContent VocabularyMeta-Data VocabularyHyper-Schema VocabularyFor a basic list of changes to each document, see their change logs:CoreValidationHyper-SchemaIncompatible ChangesBy default, format is no longer an assertion.  This has been done because the inconsistent implementation of format as an assertion has been an endless source of surprising problems for schema authors.  The default behavior will now be predictable, if not ideal.  There are several ways to turn on assertion functionality, as explained below.  However, we recommend doing semantic validation in the application layer.Plain name fragments are no longer defined with $id, but instead with the new keyword $anchor (which has a different syntax).$id cannot contain a fragment anymore (except possibly an empty fragment, although that is discouraged).In cases where multiple URIs could be used for the same schema, some are now discouraged.  These are believed to have rarely been used, as the behavior involved was fairly confusing and not well explained until the updated version of draft-07 (draft-handrews-json-schema-01).  If this doesn't mean much to you, you are probably safe.Semi-incompatible ChangesThe old syntax for these keywords is not an error (and the default meta-schema still validates them), so implementations can therefore offer a compatibility mode.  However, migrating to the new keywords is straightforward and should be preferred.definitions is now $defsdependencies has been split into dependentSchemas and dependentRequiredAnnotations, Errors, and OutputsAnnotation keywords such as title, readOnly, and default have always been a part of JSON Schema, but without any guidance on how to make use of them.  This draft formalizes how implementations can make annotation information available to applications.Similarly, there has not previously been guidance on what constitutes useful error reporting when validation fails.To solve both of these problems, we now recommend that implementations support one or more of standardized output formats.Keyword ChangesAll keywords have now been organized into vocabularies, with the Core and Validation specifications containing multiple vocabularies.  In this process, some keywords have moved from Validation into Core.Core VocabularyCore Specification, Section 8 keyword  change  notes$anchor  new  Replaces the #plain-name form of $id, with a different syntax and approach$defs (renamed from definitions)  renamed  Note that the standard meta-schema still reserves definitions for backwards compatibility$id  changed  Only URI-references without fragments are allowed; see $anchor for a replacement for plain-name fragments; all other fragments in $id had undefined behavior previously$recursiveAnchor and $recursiveRef  new  Used for extending recursive schemas such as meta-schemas$ref  changed  Other keywords are now allowed alongside of it$vocabulary  new  Has effects only in meta-schemas, and is used to control what keywords an implementation must or can support in order to process a schema using that meta-schemaApplicator VocabularyCore Specification, Section 9These keywords were formerly found in the Validation Specification. keyword  change  notesdependentSchemas (split from dependencies)  split  This is the schema form of dependencies; note that the standard meta-schema still reserves dependencies for backwards compatibilityunevaluatedItems  new  Similar to additionalItems, but can "see" into subschemas and across referencesunevaluatedProperties  new  Similar to additionalProperties, but can "see" into subschemas and across referencesThe other applicator vocabulary keywords are items, additionalItems, properties, patternProperties, additionalProperties, anyOf, allOf, oneOf, not, if, then, else.Validation VocabularyValidation Specification, Section 6 keyword  change  notesdependentRequired (split from dependencies)  split  This is the string array form of dependencies; note that the standard meta-schema still reserves dependencies for backwards compatibilitymaxContains and minContains  new  Assertion for controlling how many times a subschema must be matched within an array
Format VocabularyValidation Specification, Section 7The format keywords has always been problematic due to its optional nature.  There has never been a way to ensure that the implementation processing your schema supports format at all, or if it does, to what degree it validates each type of format.  In theory, since each format references a standard specification, if a format is supported, it should behave consistently.  In practice, this is not the case.There are two ways for an application to validate formats: It can rely on a JSON Schema implementation to validate them (which may or may not have the expected results), or it can note where the format keyword has been used and perform its own validation based on that.  This second approach is supported by treating format as an annotation keyword and supporting the basic, detailed, or verbose output formats.To impose some predictability on this system, the behavior has changed in several ways, as illustrated below.  The key difference here is that format validation is now predictably off by default, but can be configured to be turned on.  In draft-07, it was on (but possibly unimplemented) by default and could be configured to be turned off.In the following charts, the "supported" column refers to whether and (for 2019-09) to what degree the implementation claims to support the format keyword.  The "configuration" column refers to whether some non-default behavior for format is configured somehow (in a configuration file, or through a command-line option, or whatever).Summary of draft-07 behavior supported    configuration  outcome no           n/a            not validated yes          default (on) inconsistently validated yes          off            not validatedObviously, each implementation will behave consistently from schema to schema, although some formats may be supported more thoroughly than others despite the wording in the specification.  However, complex formats are, in practice, supported to different degrees in each implementation.  If they are supported at all.Summary of 2019-09 behaviorThe goal with this draft is to make the default behavior predictable, with the inconsistent behavior as an opt-in feature.  This is not entirely satisfactory, but we feel that it is a good first step to reduce the number of complaints seen around surprising results.  This way, there should at least be fewer surprises."best effort" validation is a fairly weak requirement, which matches how things work in practice today.  Simple formats are probably fully valid, complex formats may be minimally validated or even not validated at all."full syntax" validation means that you can expect a reasonably thorough syntactic validation, probably corresponding to whatever commonly available libraries can do in the implementation language.  For formats such as IP addresses and dates, this is expected to be complete validation.  For more complex formats such as email addresses, support will probably still vary significantly.  It's unclear how many implementations have ever provided this level of support.An outcome of vocabulary error means that the implementation will refuse to process the schema as it cannot satisfy the vocabulary requirement. supported    configuration   vocabulary     outcome no           n/a             false          not validated no           n/a             true           vocabulary error best effort  default (off) false          not validated best effort  default (off) true           vocabulary error best effort  on              false          best effort validation best effort  on              true           vocabulary error full syntax  default (off) false          not validated full syntax  default (off) true           full syntax validation full syntax  on              false          full syntax validation full syntax  on              true           full syntax validationNote that, given that almost no draft-07 or earlier implementations have offered strict and complete validation of every single format, it seems unlikely that any implementations will support option 3 option in practice.Additionally, two new formats were added, and a specification reference was updated:format  change  notes "duration"  added  The duration format is from the ISO 8601 ABNF as given in Appendix A of RFC 3339 "hostname" and "idn-hostname"  updated  Use RFC 1123 instead of RFC 1034; this allows for a leading digit "uuid"  added  A string instance is valid against this attribute if it is a valid string representation of a UUID, according to RFC4122
Content VocabularyValidation Specification, Section 8These keywords are now specified purely as annotations, and never assertions.  Some guidance is provided around how an implementation can optionally offer further automatic processing of this information outside of the validation process. keyword  change  notes contentEncoding  updated  Encodings from RFC 4648 are now allowed, and take precedence over RFC 2045 when there is a difference contentSchema  added  Schema for use with the decoded content string; note that it is not automatically applied as not all content media types can be understood in advanceMeta-Data VocabularyValidation Specification, Section 9 keyword  change  notes deprecated  added  Used to indicate that a field is deprecated in some application-specific mannerHyper-Schema VocabularyHyper-Schema Specification, Sections 5 and 6 keyword  change  notes rel  changed  Can now be an array of values instead of just a stringNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Hyper-Schema Draft-07 Release NotesJSON Hyper-Schema draft-07 completes the
reworking of Hyper-Schema that was begun in draft-06.Hyper-Schema is now solely focused on adding hyperlinks to JSON documents,
so keywords used for other purposes (readOnly and media) have been
moved to the Validation specification.The new draft has been completely rewritten
for clarity and accessibility, so it is best to simply approach it as a new
proposal.  We hope to add tutorial material at some point, but that is
outside of the scope of release notes.However, if you wish to migrate from an earlier draft, this page is a guide
to the key changes.  The additions, which are much more numerous,
should be learned directly from the new specification until we can provide
tutorials.Note that draft-handrews-json-schema-hyperschema-00 has been replaced
by draft-handrews-json-schema-hyperschema-01 in order to fix confusing
bugs.  The newer -01 draft is still considered to be draft-07.
It now references the draft-07 meta-schema with the correct URI, among
other typo fixes.  There are no funcitonal changes between -00 and -01.Migrating from draft-06Migrating from draft-05Migrating from draft-04
  GETPUTDELETEPOSTPATCHMigrating from draft-06No draft-06 features were changed, although two keywords were renamed
for clarity and consistency:mediaType -> targetMediaTypesubmissionEncType -> submissionMediaTypeAdditionally, hrefSchema was somewhat confusing, so a great deal
more effort has gone into explaining how it works, and how it fits
into the overall link resolution process.Migrating from draft-05See the draft-06 release notes
for information related to draft-05.Migrating from draft-04In the ideal draft-07 world, links and
operations
are not the same concept.  Using terminology borrowed from
OpenAPI's Operation Object, HTTP methods are operations, and each
link (as described by a single LDO) can support multiple operations.Therefore, unlike draft-04, draft-07 hyper-schemas
do not have separate links for each operation.  This makes the migration guidelines below approximate at best.For a more detailed explanation of how draft-04's method and targetSchema
were typically used to create single-operation links, and how that poses
a challenge for migrating to multi-operation links, see the
draft-06 release notes.
Those release notes also explain what happened to the link relations defined
in draft-04 and subsequently removed, and the changes in how the instance
base URI is determined.Beyond those changes, a minimal migration would be something along the
following lines, although the
intentional lack of explicit response descriptions
(except when the response happens to be a representation of the target resource)
means that some uses of draft-04 do not have direct analogues in draft-07.Any keyword not mentioned in a list below is unchanged for that link operation.GET"method": "GET" -> "targetHints": {"allow": ["GET"]}mediaType -> targetMediaTypeschema -> hrefSchema with parameters added to hrefencType -> drop if application/x-www-form-urlencoded, contact the mailing list otherwisePUTIf you have a PUT link where schema/encType differ from
targetSchema/mediaType, where targetSchema/mediaType
describe a non-representation response, then those fields do
not have a direct replacement."method": "PUT" -> "targetHints": {"allow": ["PUT"]}schema -> targetSchemaencType -> targetMediaTypeDELETEDELETE does not take a request payload, so schema and encType
should be unused.  If targetSchema and mediaType were being
used for a response other than the just-deleted resource's representation,
then they do not have a direct replacement."method": "DELETE" -> "targetHints": {"allow": ["DELETE"]}mediaType -> targetMediaType (if describing the representation)POSTIn most cases, the response of a POST is not a representation of the
target resource, but rather some sort of result or status of whatever
the POST attempted to do.  Therefore targetSchema and mediaType
should almost certainly be dropped.  Other than that:"method": "POST" -> "targetHints": {"allow": ["POST"]}schema -> submissionSchemaencType -> submissionMediaTypePATCHIt was never entirely clear how to model a proper PATCH (that uses
a patch media type rather than application/json in the request) in Hyper-Schema.
One option was to treat it identically to PUT except with the patch media type
in encType.  Assuming that approach (and the same taregetSchema/mediaType
caveats as for PUT):"method": "PATCH" -> "targetHints": {"allow": ["PATCH"]}schema -> targetSchema"encType": "..." -> "targetHints": {"accept-patch": "..."}Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Hyper-Schema Draft-06 Release NotesRelease notes for migrating from draft-luff-json-hyper-schema-00 (draft-04) to draft-wright-json-schema-hyperschema-01 (draft-06).NOTE: draft-07 has been releasedThe migration notes for draft-07 give a much more straightforward overview of migrating from draft-04 to draft-07 by skipping the complicated intermediate states of draft-05 and draft-06.  This page has been retained for historical interest, but it is not recommened for those who just want to get going with the latest draft.For implementors: We recommend just implementing draft-07, and not draft-06 or earlier.Q: What are the incompatible changes between draft-04 and draft-06?
  Changes from draft-04 to draft-05Changes from draft-05 to draft-06Proper use of "targetSchema"Q: Why were several major changes made to Hyper-Schema just before draft-06’s publication?Q: Why doesn’t the spec mention or behave like HTML anymore?
  Splitting "schema"Removing "method"Q: So how do I indicate which HTTP methods are supported on a link?Q: No, really. How do I explicitly indicate which HTTP methods are supported on a link?Q: If "targetSchema" is not the response, how do I describe responses?Q: What are the incompatible changes between draft-04 and draft-06?Between drafts 04 and 06 we undertook a major re-examining of Hyper-Schema, which has never been as widely adopted as JSON Schema Validation.While we knew that there were still major gaps in draft-06, we felt that it was a good set of changes for collecting feedback.  With draft-07 published, that draft or later should be used, and draft-06 becomes an historical curiosity.Changes from draft-04 to draft-05 keyword  change  consequence"base"  replaces looking up the nearest "self" link to determine the base URI for "href"  if you were relying on "self" links to change the base, set "base" explicitly"rel"  "full" relation removed  use "item""rel"  "instances" and "create" relations removed  use "collection""rel"  "root" relation removed  use a fragment in your "href" URI Template"fragmentResolution"  removed  media type determines how fragments are interpreted"pathStart"  removed  [no replacement]"method"  changed back to HTML form semantics of "get" and "post" rather than all HTTP methods  [changed again in draft-06 due to feedback that this was confusing]Changes from draft-05 to draft-06 keyword  change  consequence"method"  removed  for HTTP method proposals, see issues #73 and #296 (use either "method" or "allow" as an extension keyword if needed); indication of how to use "schema" and "encType" no longer necessary"schema"  removed  use "hrefSchema", "submissionSchema",  or "targetSchema" "encType"  removed  use "submissionEncType" for request bodies; no longer needed for URI query strings"hrefSchema"  added  replaces "method": "get", "schema": {...}, with additional functionality "submissionSchema"  added  replaces "method": "post", "schema": {...}"submissionEncType"  added  replaces "method": "post", "encType": "...""href"  preprocessing removed  to be replaced and expanded in future draftsProper use of "targetSchema"While "targetSchema" did not change its meaning in either recent draft, it has been widely misinterpreted.  So it may feel like a change to use it as specified.Due to draft-04 emphasizing individual HTTP methods as "method" values, many users interpreted "targetSchema" as a hint of the response to the method in "method".  This was never correct; all drafts define this keyword as describing the representation of the target resource, which appears as a response to HTTP GET, but may or may not appear in other responses.Draft-06 clarifies this usage and provides guidance on its use with different HTTP methods.  This includes using "targetSchema" as a request description for PUT and PATCH.  With draft-04, many users used "schema" to describe PUT and PATCH requests which is not needed.However, the "targetHints" proposal has been accepted into draft-07.  Among other things, it enables hinting at "Accept-Patch", which is needed to properly use "targetSchema" with HTTP PATCH.  There will be examples and detailed guidance in draft-07.Q: Why were several major changes made to Hyper-Schema just before draft-06's publication?A: During final review, it became apparent that there was no consensus on how to use the spec as written.  The late changes were necessary to publish a spec with unambiguous meaning, so that we could get feedback on its contents rather than differing interpretations.  Originally we attempted to simply clarify what was there, but then we realized there was no agreement on what was there in the first place.Q: Why doesn't the spec mention or behave like HTML anymore?A: We came to a consensus that the existing analogies caused more harm than good, for two reasons:The change between draft-03 and draft-04 to let "method" indicate any HTTP method instead of HTML's <form method="..."> "get" and "post" values broke the original analogy to HTML, and trying to change it back was not well-receivedOnly being able to use "schema" and "encType" for either the URI query string (but no other part of the URI) or the request body, but not having any way to work with both at once, was overly restrictive for API designSplitting "schema"Instead of having "schema" perform two different things depending on "method", we split it into two keywords, one for each use.  This allows using both simultaneously when needed, which is a use case not present in HTML forms."hrefSchema" replaces the "method": "get" use, but leverages URI Template variables so that client data-driven dynamic  URIs are no longer limited to the query string.  "encType" is no longer needed with this approach."submissionSchema" directly replaces the "method": "post" use, with "submissionEncType" replacing "encType".Removing "method"Draft-05 tried to restore the draft-03 behavior of "method", but feedback told us that users found the change very confusing.  With "schema" split, the draft-05 behavior of "method" was no longer needed.We could have switched by to draft-04's "method" behavior, but in addition to producing more confusion from all of the back and forth, the draft-04 approach to "method" was not consistent with the rest of the LDO design anyway.  Most notably, it caused problems with the usage of "targetSchema" as described above.Q: So how do I indicate which HTTP methods are supported on a link?A: Ideally, this is implicitly conveyed by your link relation type, which is the primary indicator of semantics across machine-oriented hypermedia in general.  RFC 5988 provides guidance on creating custom (a.k.a. "extension") link relations.Several URI schemes and namespaces, such as the UUID namespace in the urn: scheme, or the tag: scheme, are particularly suitable for creating unique identifiers.And of course, there are ways to detect this at runtime such as HTTP's "Allow" response header, or attempting a method and handling a 405 Method Not Allowed error accordingly.Q: No, really. How do I explicitly indicate which HTTP methods are supported on a link?A: The "targetHints" proposal is part of draft-07, so using it as an extension to draft-06 is an option, but we recommend simply using draft-07 at this point.Q: If "targetSchema" is not the response, how do I describe responses?A: You should have hyper-schemas for your various success and error responses, but connecting them to links is more of a documentation question than a usage question: each response will indicate its own schema, so you don't need to know it in advance at runtime.There has never been a Hyper-Schema keyword to explicitly associate responses with operations such as HTTP methods.  The use cases for this seem to be about generating API documentation, so this is most likely a candidate for a JSON Schema API Documentation vocabulary.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nCreate a new workspace\nCreate a new workspace\nProductPricingSupportDownload the Slack appSign inCreate a new workspace\nDownload the Slack app\nDownload the Slack app\nCreate a new workspace\nCreate a new workspace\nCreate a new workspace\nWe're very sorry, but your browser is not supported!Please upgrade to a supported browser, or try one of our apps.Desktop AppsMacSee system requirementsv4.44.59WindowsSee system requirementsv4.44.59LinuxSee system requirementsv4.43.51Mobile AppsiOSAndroidDon't see the platform you're looking for? Let us know.\nWe're very sorry, but your browser is not supported!Please upgrade to a supported browser, or try one of our apps.Desktop AppsMacSee system requirementsv4.44.59WindowsSee system requirementsv4.44.59LinuxSee system requirementsv4.43.51Mobile AppsiOSAndroidDon't see the platform you're looking for? Let us know.\nWe're very sorry, but your browser is not supported!Please upgrade to a supported browser, or try one of our apps.\nWe're very sorry, but your browser is not supported!\nPlease upgrade to a supported browser, or try one of our apps.\nMacSee system requirementsv4.44.59WindowsSee system requirementsv4.44.59LinuxSee system requirementsv4.43.51\nMacSee system requirementsv4.44.59\nSee system requirements\nSee system requirements\nWindowsSee system requirementsv4.44.59\nSee system requirements\nSee system requirements\nLinuxSee system requirementsv4.43.51\nSee system requirements\nSee system requirements\nDon't see the platform you're looking for? Let us know.\nUsing SlackProductEnterprisePricingSupportSlack GuidesSlack MarketplaceAPISlack JobsCustomersDevelopersEventsBlogLegalPrivacySecurityTerms of ServicePoliciesHandy LinksDownload desktop appDownload mobile appBrand GuidelinesSlack at WorkStatus\nUsing SlackProductEnterprisePricingSupportSlack GuidesSlack MarketplaceAPI\nSlack JobsCustomersDevelopersEventsBlog\nLegalPrivacySecurityTerms of ServicePolicies\nHandy LinksDownload desktop appDownload mobile appBrand GuidelinesSlack at WorkStatus\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHub195 Tools195ToolsLanguage.NETCC#C++ClojureCoffeeScriptCommon LispDartDelphiElixirElmErlangGoHaskellHelmJavaJavaScriptJuliaKotlinLua/LuaJITObjective-COpenAPIOrderlyPerlPHPPostgreSQLProtocol BuffersPythonRAMLRubyRustScalaSwiftTypeScriptXSDTooling TypeAnnotationsBenchmarksBundlerCode To SchemaData To SchemaDocumentationEditorEditor PluginsHyper SchemaLDO UtilityLinterLinter PluginsModel To SchemaSchema RepositorySchema To CodeSchema To DataSchema To TypesSchema To Web UIUtil Draft MigrationUtil Format ConversionUtil General ProcessingUtil Schema To SchemaUtil TestingValidatorEnvironmentCOM/ActiveXCommand LineEmbedded platformGithub ActionsiOSLinuxmacOSMicrosoft WindowstvOSvisionOSwatchOSWeb (Online)WindowsDialect2020-122019-097654License(MIT AND Apache-2.0)AFL-2.1 OR BSD-3-ClauseAGPL-3.0AGPL-3.0 and CommercialAGPL-3.0-onlyApache License 2.0Apache-2.0Artistic-2.0BSD-2-ClauseBSD-3-ClauseBSL-1.0CC0-1.0EPL-1.0GPL-1.0+ OR Artistic-1.0GPL-2.0GPL-3.0GPL-3.0-onlyISCLGPL 2.1 or laterLGPL-2.1LGPL-2.1-onlyLGPL-3.0MITMPL-2.0Ms-PLPostgreSQLProprietaryProprietary and FreewareShow obsoleteApply FiltersClear FiltersJSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.JSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on Slack\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, February 7, 2025 · 22 min readHow Oracle is Bridging the Gap Between JSON Schema and Relational DatabasesGo back to blogLoïc Lefèvreon this pageJSON Data Guide


Data Validation


















Performance Improvement

Relational Model Evolution
ConclusionAs modern multi-model databases increasingly support JSON, it's time to explore what role JSON schema will play. In this post, we'll dive into the newly developed "Database Vocabulary", a proposed extension to the official JSON schema specification, developed by Oracle (with inputs from the MySQL and PostgreSQL teams). This vocabulary addresses key database tasks, including validation, type coercion/casting, and metadata preservation, making it easier to manage JSON in databases effectively and bridging the gap with existing relational data. Regardless of whether you are a JSON developer or a relational model developer, you'll learn something reading this post!Oracle Database 23ai fully implements this new vocabulary, and we'll describe not only the concepts but we'll also see real-world examples of JSON schema validation in action and how to describe database objects in JSON schema.JSON Data GuideWith Oracle Database 12cR2 (2017), we've introduced the concept of a JSON data guide; that lets you discover information about the structure and content of existing JSON documents stored in JSON columns inside the database.Let's look at the following example which creates a table blog_posts with a column data of type JSON and inserts one JSON document:1create table blog_posts (
2  data json -- BINARY JSON
3);
4
5insert into blog_posts( data ) values (
6  json {
7    'title': 'New Blog Post',
8    'content': 'This is the content of the blog post...',
9    'publishedDate': '2023-08-25T15:00:00Z',
10    'author': {
11      'username': 'authoruser',
12      'email': '[email protected]'
13    },
14    'tags': ['Technology', 'Programming']
15  }
16);
17commit;
18
We can query the table and retrieve JSON values using the SQL dot notation to navigate the JSON document hierarchy. Attributes within the JSON document can simply be referenced by .<attribute name>:1select -- field names are case sensitive
2       p.data.title,
3       p.data.author.username.string() as username, 
4       p.data.tags[1].string() as "array_field[1]"
5  from blog_posts p;
6
The item method string() allows explicit casting of the JSON field value. Alongside string() are other casting methods like number(), date(), etc.However, nothing prevents us from inserting unexpected data!1insert into blog_posts( data ) values( '{ "garbageDocument":true }' );
2commit;
3
4select data from blog_posts;
5Results: DATA  {  "title": "New Blog Post",  "content": "This is the content of the blog post...",  "publishedDate":"2023-08-25T15:00:00Z",  "author": {    "username":"authoruser",    "email":"[email protected]"  },  "tags": [ "Technology", "Programming" ]}  {  "garbageDocument":true} This is where, JSON schemas can help, and the JSON_DATAGUIDE() function can generate one from a set of already existing JSON document(s):1select json_dataguide(
2         data, 
3         dbms_json.format_schema,
4         dbms_json.pretty
5       ) as json_schema
6  from blog_posts;
7Results:data{  "type": "object",  "o:length": 1,  "properties": {    "tags": {      "type": "array",      "o:length": 1,      "items": {        "type": "string",        "o:length": 16      }    },    "title": {      "type": "string",      "o:length": 16    },    "author": {      "type": "object",      "o:length": 1,      "properties": {        "email": {          "type": "string",          "o:length": 32        },        "username": {          "type": "string",          "o:length": 16        }      }    },    "content": {      "type": "string",      "o:length": 64    },    "publishedDate":  {      "type": "string",      "o:length": 32    },    "garbageDocument": {      "type": "boolean",      "o:length": 4    }  }}﻿
We can see that the garbageDocument field was properly detected and added to the set of accepted JSON fields for the JSON schema.Data ValidationThe most obvious use case for JSON schema is JSON data validation. The Oracle Database 23ai brings the new PL/SQL package DBMS_JSON_SCHEMA which can be used to validate JSON schemas and JSON data.The dbms_json_schema.is_schema_valid() function can tell us if a given JSON schema itself is valid:1-- Validate the generated JSON schema
2select dbms_json_schema.is_schema_valid( 
3    (
4      -- Generate JSON Data Guide/Schema from data column
5      select json_dataguide(
6               data,
7               dbms_json.format_schema,
8               dbms_json.pretty
9             ) as json_schema
10        from blog_posts
11    ) 
12) = 1 as is_schema_valid;
13
Another function dbms_json_schema.validate_report() validates a JSON document against a JSON schema and  generates a validation report, including validation errors, if there are any:1-- Validate current JSON data with a simple JSON schema
2select dbms_json_schema.validate_report( 
3           data,
4           json( '{
5                    "type": "object",
6                    "properties": { 
7                      "tags": {
8                        "type": "array",
9                        "items": {
10                          "type": "string"
11                        }
12                      }
13                    }
14                  }' )
15       ) as report
16from blog_posts;
17Results: REPORT                                                      {  "valid": true,  "errors": []}  {  "valid": true,  "errors": []} With the simplistic JSON schema, no validation errors are present. Let's use a more complex JSON schema (based on the Blog post example from the JSON schema website itself):1select dbms_json_schema.validate_report( 
2  data,
3  json('{
4    "$id": "https://example.com/blog-post.schema.json",
5    "$schema": "https://json-schema.org/draft/2020-12/schema",
6    "description": "A representation of a blog post",
7    "type": "object",
8    "required": ["title", "content", "author"],
9    "properties": {
10      "title": {
11        "type": "string"
12      },
13      "content": {
14        "type": "string"
15      },
16      "publishedDate": {
17        "type": "string",
18        "format": "date-time"
19      },
20      "author": {
21        "$ref": "https://example.com/user-profile.schema.json"
22      },
23      "tags": {
24        "type": "array",
25        "items": {
26          "type": "string"
27        }
28      }
29    },
30    "$def": {
31      "$id": "https://example.com/user-profile.schema.json",
32      "$schema": "https://json-schema.org/draft/2020-12/schema",
33      "description": "A representation of a user profile",
34      "type": "object",
35      "required": ["username", "email"],
36      "properties": {
37        "username": {
38          "type": "string"
39        },
40        "email": {
41          "type": "string",
42          "format": "email"
43        },
44        "fullName": {
45          "type": "string"
46        },
47        "age": {
48          "type": "integer",
49          "minimum": 0
50        },
51        "location": {
52          "type": "string"
53        },
54        "interests": {
55          "type": "array",
56          "items": {
57            "type": "string"
58          }
59        }
60      }
61    }
62  }')
63) as report
64from blog_posts;
65Results: REPORT                                                                                                                                                                                                                                                                                                                                                                                                                                      {   "valid": true,  "errors": []}  {  "valid": false,  "errors": [    {      "schemaPath": "$",      "instancePath": "$",      "code": "JZN-00501",      "error": "JSON schema validation failed"    }, {      "schemaPath": "$.required",      "instancePath": "$",      "code": "JZN-00515",      "error": "required properties not found: 'title', 'content', 'author'"    }  ]} Now we can see that the second JSON document shows several validation errors, namely the missing fields title, content and author.If you don't want or need to know the validation error details, you may simply use the dbms_json_schema.is_valid() function.Finally, you can leverage the dbms_json_schema.describe() function to generate JSON schemas from existing relational objects such as tables, views, and JSON Relational Duality Views (more on that later).1-- Get the JSON schema from a relational table!
2select dbms_json_schema.describe( 'BLOG_POSTS' ) as json_schema;
3Results: JSON_SCHEMA                                                                                                                                                                                   {  "title": "BLOG_POSTS",  "dbObject": "APIDAYS.BLOG_POSTS",  "type": "object",  "dbObjectType": "table",  "properties": {    "DATA": {}  }} Client-side validation using JSON SchemaNow that we are able to create and retrieve JSON schemas from the database, we may consider the database as a central repository for JSON schemas that can be used by clients (backends and frontends) to validate JSON data.Below, you can see a quick overview of a demo available in this GitHub repository:Using Oracle REST Data Services, we can indeed expose a JSON schema to a frontend via REST. Below, we are using the json-schema-form library to build an input form from a JSON schema where title, description, and check constraints are used to define input fields and associated validation rules. Let's drill down into this example:We'll start by creating a basic relational table that will store products:1-- drop table if exists products purge;
2
3create table products (
4  name     varchar2(100) not null primary key
5      constraint minimal_name_length check (length(name) >= 3),
6  price    number not null 
7      constraint strictly_positive_price check (price > 0),
8  quantity number not null 
9      constraint non_negative_quantity check (quantity >= 0)
10);
11
12insert into products (name, price, quantity)
13values ('Cake mould',     9.99, 15),
14       ('Wooden spatula', 4.99, 42);
15commit;
16
This table has 3 columns. Each column has a named check constraint ensuring inserted values are conform with business rules (strictly positive prices, etc.).If we retrieve the JSON schema corresponding to this relational table using dbms_json_schema.describe(), we'll also get these check constraints translated into the JSON schema format:1-- JSON Schema of PRODUCTS table
2-- Contains check constraints!
3select dbms_json_schema.describe( 'PRODUCTS' ) as json_schema;
4Results:data{  "title": "PRODUCTS",  "dbObject": "APIDAYS.PRODUCTS",  "type": "object",  "dbObjectType": "table",  "properties": {    "NAME": {      "type": "string",      "extendedType": "string",      "maxLength": 100,      "allOf": [        {          "minLength": 3        }      ]    },     "PRICE": {      "type": "number",      "extendedType": "number",      "allOf": [        {          "exclusiveMinimum": 0        }      ]    },    "QUANTITY": {      "type": "number",      "extendedType": "number",      "allOf": [        {          "minimum": 0        }      ]    }  },  "required": [    "NAME",    "PRICE",    "QUANTITY"    ],  "dbPrimaryKey": [    "NAME"  ]}﻿
One thing we remark is the absence of title and description attributes for our 3 columns but considering JSON schemas are also JSON documents, we may enrich the JSON schema with the missing values.Database Schema AnnotationsStarting with the Oracle Database 23ai, you can leverage Schema Annotations to annotate database objects (columns, tables, views, indexes, etc.).Consider the following schema annotations:1ALTER TABLE products MODIFY name ANNOTATIONS (
2  ADD OR REPLACE "title" 'Name',
3  ADD OR REPLACE "description" 'Product name (max length: 100)',
4  ADD OR REPLACE "minLength" '3'
5);
6
7ALTER TABLE products MODIFY price ANNOTATIONS (
8  ADD OR REPLACE "title" 'Price',
9  ADD OR REPLACE "description" 'Product price strictly positive',
10  ADD OR REPLACE "minimum" '0.01'
11);
12
13ALTER TABLE products MODIFY quantity ANNOTATIONS (
14  ADD OR REPLACE "title" 'Quantity',
15  ADD OR REPLACE "description" 'Quantity of products >= 0',
16  ADD OR REPLACE "minimum" '0'
17);
18
These schema annotations provide additional information for each relational columns. Note that the minimum and minLength ones are here to work around a current json-schema-form library limitation (hopefully, this open issue will be solved soon).These annotations are stored inside the database dictionary and can be retrieved via the user_annotations_usage dictionary view:1-- View annotations
2select column_name, annotation_name, annotation_value
3  from user_annotations_usage
4 where object_name='PRODUCTS'
5   and object_type='TABLE'
6order by 1, 2;
7Results:COLUMN_NAMEANNOTATION_NAMEANNOTATION_VALUENAMEdescriptionProduct name (max length: 100)NAMEminLength3NAMEtitleNamePRICEdescriptionProduct price strictly positivePRICEminimum0.01PRICEtitlePriceQUANTITYdescriptionQuantity of products >= 0QUANTITYminimum0QUANTITYtitleQuantityTo mix both, the table JSON schema with these column level annotations, we can use the following PL/SQL function:1-- Annotate JSON Schema with column level annotations
2-- p_table_name: the table name to work on
3create or replace function getAnnotatedJSONSchema( p_table_name in varchar2 )
4return json
5as
6  schema       clob;          -- the original JSON schema
7  l_schema     JSON_OBJECT_T; -- the JSON schema as DOM to modify
8  l_properties JSON_OBJECT_T; -- the "properties" JSON object entry of the JSON schema
9  l_keys       JSON_KEY_LIST; -- the list of JSON field names of "properties" JSON object
10  l_column     JSON_OBJECT_T; -- the JSON object to modify (for each column of the table)
11begin
12  -- get JSON schema of table
13  select json_serialize( dbms_json_schema.describe( p_table_name )
14                         returning clob ) into schema;
15  
16  -- create a DOM object
17  l_schema := JSON_OBJECT_T.parse( schema );
18  -- access the "properties" JSON schema field that lists all the table columns
19  l_properties := l_schema.get_Object('properties');
20  -- get all the field names of this "properties" DOM: the table columns
21  l_keys := l_properties.get_Keys();
22
23  -- loop over all the columns...
24  for i in 1..l_keys.count loop
25    l_column := l_properties.get_Object( l_keys(i) );
26
27    -- now retrieve from the database dictionary, all the annotations
28    -- associated with this table column
29    for c in (select ANNOTATION_NAME, ANNOTATION_VALUE 
30                from user_annotations_usage
31               where object_name=p_table_name 
32                 and object_type='TABLE' 
33                 and column_name=l_keys(i))
34    loop
35      -- add each annotation found as a new key/value pair to the JSON schema 
36      -- for that table column
37      l_column.put( c.ANNOTATION_NAME, c.ANNOTATION_VALUE );
38    end loop;
39  end loop;
40
41  -- returns the annotated JSON schema
42  return l_schema.to_json;
43end;
44/
45
Then one can use the function as below:1select getAnnotatedJSONSchema( 'PRODUCTS' );
2Results:data{  "title": "PRODUCTS",  "dbObject": "APIDAYS.PRODUCTS",  "type": "object",  "dbObjectType": "table",  "properties": {    "NAME": {      "type": "string",      "extendedType": "string",      "maxLength": 100,      "allOf": [        {          "minLength": 3        }      ],      "title": "Name",      "description": "Product name (max length: 100)",      "minLength": "3"    },    "PRICE": {      "type": "number",      "extendedType": "number",      "allOf": [        {          "exclusiveMinimum": 0        }      ],      "description": "Product price strictly positive",      "minimum": "0.01",      "title": "Price"    },    "QUANTITY": {      "type": "number",      "extendedType": "number",      "allOf": [        {          "minimum": 0        }      ],      "title": "Quantity",      "description": "Quantity of products >= 0",      "minimum": "0"    }  },   "required": [    "NAME",     "PRICE",    "QUANTITY"  ],  "dbPrimaryKey": [    "NAME"  ]}﻿
GET methodThe previous SQL query can then be used as the parameterized template for our REST end point for the GET method:1-- Run only once:
2BEGIN
3  ORDS.ENABLE_SCHEMA(
4    p_enabled             => TRUE,
5    -- database user/schema
6    p_schema              => 'APIDAYS',
7    p_url_mapping_type    => 'BASE_PATH',
8    p_url_mapping_pattern => 'apidays',
9    p_auto_rest_auth      => FALSE);
10    
11  ORDS.DEFINE_MODULE(
12    p_module_name    => 'apidays',
13    p_base_path      => '/schema_repository/',
14    p_items_per_page => 25,
15    p_status         => 'PUBLISHED',
16    p_comments       => NULL);
17
18  ORDS.DEFINE_TEMPLATE(
19    p_module_name    => 'apidays',
20    p_pattern        => 'products',
21    p_priority       => 0,
22    p_etag_type      => 'HASH',
23    p_etag_query     => NULL,
24    p_comments       => NULL);
25
26  ORDS.DEFINE_HANDLER(
27    p_module_name    => 'apidays',
28    p_pattern        => 'products',
29    p_method         => 'GET',
30    p_source_type    => 'json/item',
31    p_mimes_allowed  => NULL,
32    p_comments       => NULL,
33    p_source         => 
34'select getAnnotatedJSONSchema( ''PRODUCTS'' ) as schema');
35       
36COMMIT;
37
38END;
39/
40
In the GitHub repositoy, you'll find the src/ORDS.js module that demonstrates using this REST method:1import axios from 'axios';
2
3function ORDS() {}
4
5ORDS.prototype.getSchema = async function() {
6  return await axios.get(
7      'http://localhost/ords/apidays/schema_repository/products', 
8      {}
9  )
10  .then( res => res.data.schema )
11  .catch(err => err);
12}
13
14export default new ORDS();
15
With all this in place, our React frontend can now create the following form:Interestingly, whenever you change the schema annotation in the database, it is immediately reflected inside your browser once you refreshed it. You can try with:1ALTER TABLE products MODIFY name ANNOTATIONS (
2  REPLACE "title" 'Product name'
3);
4
JSON Relational Duality ViewOnce the new product has been validated inside the frontend, it is sent to the database for insertion into the relational table. To ease this process, we'll leverage one of the greatest 23ai new features: JSON Relational Duality View.This new type of view acts as a gateway between the JSON and relational worlds. Basically, one can insert JSON documents into a JSON relational duality view and the database will automatically map the proper JSON fields to the relational columns. From a retrieval perspective, whenever a JSON relational duality view is queried, a JSON  document will be constructed from the underlying relational model at runtime.Consider this very simple example (not even involving relationships between tables, nor flex fields, etc.):1-- GraphQL notation (SQL notation also exists)
2create or replace json relational duality view products_dv as
3products @insert {
4  _id: NAME
5  PRICE
6  QUANTITY
7};
8
Here we ask the view to accept INSERT SQL statements (via @insert) and remap the JSON _id attribute (mandatory JSON unique key) to the relational column NAME (note that JSON fields are case-sensitive). The other two attributes are automatically mapped because the JSON attributes and relational table column names are the same.You can find hereunder the JSON schema of this JSON relational duality view:1-- Get JSON Schema from JSON Relational Duality View
2select dbms_json_schema.describe( 'PRODUCTS_DV' );
3Results:data{  "title": "PRODUCTS_DV",  "dbObject": "APIDAYS.PRODUCTS_DV",  "dbObjectType": "dualityView",  "dbObjectProperties": [ "insert", "check" ],   "type": "object",   "properties": {    "_metadata": {      "etag": {        "type": "string",        "extendedType": "string",        "maxLength": 200      },      "asof": {        "type": "string",        "extendedType": "string",        "maxLength": 20      }    },    "_id": {      "type": "string",      "extendedType": "string",      "maxLength": 100,      "dbFieldProperties": [ "check" ]    },    "PRICE": {      "type": "number",      "extendedType": "number",      "dbFieldProperties": [ "check" ]    },    "QUANTITY": {      "type": "number",      "extendedType": "number",      "dbFieldProperties": [ "check" ]    }  },  "dbPrimaryKey": [    "_id"  ],  "required": [    "_id",    "PRICE",    "QUANTITY"  ],  "additionalProperties": false}﻿
So now we can run such an INSERT statement:1-- Insert JSON in a Relational table (Bridging the Gap...)
2-- by using the JSON Relational Duality View
3insert into PRODUCTS_DV(data) values( 
4  json_transform( '{
5                     "NAME": "Other nice product", 
6                     "PRICE": 5, 
7                     "QUANTITY": 10
8                  }', 
9                  RENAME '$.NAME' = '_id'
10  )
11);
12
13commit;
14
You will notice that we are using the JSON_TRANSFORM() function to rename the NAME JSON attribute to _id expected by the PRODUCTS_DV JSON relational duality view.1select * from products_dv;
2select * from products;
3
Running the 2 queries above respectively returns the data in JSON format: DATA                                                                                                                  {  "_id": "Cake mould",  "PRICE": 9.99,  "QUANTITY": 15,  "_metadata": { ... }}   {  "_id": "Wooden spatula",  "PRICE": 4.99,  "QUANTITY": 42,  "_metadata": { ... }}   {  "_id": "Other nice product",  "PRICE": 5,  "QUANTITY": 10,  "_metadata": { ... }} ...and relational format:NAMEPRICEQUANTITYCake mould9.9915Wooden spatula4.9942Other nice product510The _metadata object will contain additional information such as an etag that can be used for optimistic concurrency control.
POST methodWith the JSON relational duality view in place, we can now implement the REST POST method by adding another ORDS handler:1BEGIN
2  ORDS.DEFINE_HANDLER(
3    p_module_name    => 'apidays',
4    p_pattern        => 'products',
5    p_method         => 'POST',
6    p_source_type    => 'plsql/block',
7    p_mimes_allowed  => NULL,
8    p_comments       => NULL,
9    p_source         => 
10'begin
11  insert into PRODUCTS_DV( data ) values( json_transform(:body_text, RENAME ''$.NAME'' = ''_id'') );
12  commit;
13end;');
14       
15COMMIT;
16
17END;
18
19/
20
Precheck Check ConstraintsWith 23ai, a check constraint can now be marked as PRECHECK. Doing so tells the database that a relational check constraint has a corresponding JSON schema constraint that preserves the semantics of the constraint and hence the database doesn't need to verify the check again. An example of a constraint that has no corresponding JSON schema constraint could be a foreign key.Once a check constraint is marked as PRECHECK, you have the choice whether or not to disable the check constraint on the table as the retrieved JSON schema with dbms_json_schema.describe() will contain the check constraints as well.We do NOT advise to disable check constraints as it would allow inserting bad data into the relational tables directly. The remark about PRECHECK constraints is here to provide as much information as possible.
1-- Mark check constraints as PRECHECK
2alter table products modify constraint strictly_positive_price precheck;
3alter table products modify constraint non_negative_quantity precheck;
4
5-- Now disable the constraints at the database level
6-- They are checked in the clients
7--
8-- Warning: do that at your own risks!
9alter table products modify constraint strictly_positive_price disable;
10alter table products modify constraint non_negative_quantity disable;
11
12-- Check constraints still present inside the JSON Schema
13select dbms_json_schema.describe( 'PRODUCTS' );
14
15-- but following INSERT will work and insert bad data
16insert into products (name, price, quantity)
17values ('Bad product', 0, -1);
18
19commit;
20
21select * from products;
22
Data Use Case DomainsAnother way to validate JSON data is to associate a JSON schema with a JSON column. In 23ai, an extension of the ISO standard Domains is available: Data Use Case Domains.Consider the following very simple data use case domain that could be considered as a scalar JSON data type alias:1-- Introducing Data Use Case Domains
2create domain if not exists jsonb as json;
3
4create table test ( 
5  data jsonb -- JSON alias
6);
7
Domains also allow for centralizing JSON schema so that they can be reused across tables and columns. The example below demonstrates how to associate a JSON schema within a data use case domain:1-- drop table if exists posts purge;
2-- drop domain if exists BlogPost;
3create domain if not exists BlogPost as json
4validate '{
5  "$id": "https://example.com/blog-post.schema.json",
6  "$schema": "https://json-schema.org/draft/2020-12/schema",
7  "description": "A representation of a blog post",
8  "type": "object",
9  "required": ["title", "content", "author"],
10  "properties": {
11    "title": {
12      "type": "string"
13    },
14    "content": {
15      "type": "string"
16    },
17    "publishedDate": {
18      "type": "string",
19      "format": "date-time"
20    },
21    "author": {
22      "$ref": "https://example.com/user-profile.schema.json"
23    },
24    "tags": {
25      "type": "array",
26      "items": {
27        "type": "string"
28      }
29    }
30  },
31  "$def": {
32    "$id": "https://example.com/user-profile.schema.json",
33    "$schema": "https://json-schema.org/draft/2020-12/schema",
34    "description": "A representation of a user profile",
35    "type": "object",
36    "required": ["username", "email"],
37    "properties": {
38      "username": {
39        "type": "string"
40      },
41      "email": {
42        "type": "string",
43        "format": "email"
44      },
45      "fullName": {
46        "type": "string"
47      },
48      "age": {
49        "type": "integer",
50        "minimum": 0
51      },
52      "location": {
53        "type": "string"
54      },
55      "interests": {
56        "type": "array",
57        "items": {
58          "type": "string"
59        }
60      }
61    }
62  }
63}';
64
65-- Now use the Domain as a new column data type!
66create table posts ( content BlogPost );
67
68-- fails
69insert into posts values (json{ 'garbageDocument' : true });
70
71-- works
72insert into posts values (
73  json {
74    'title': 'Best brownies recipe ever!',
75    'content': 'Take chocolate...',
76    'publishedDate': '2024-12-05T13:00:00Z',
77    'author': {
78      'username': 'Bob',
79      'email': '[email protected]'
80    },
81    'tags': ['Cooking', 'Chocolate', 'Cocooning']
82  }
83);
84
85commit;
86
Now let's look closer at the publishedDate field:1select p.content.publishedDate 
2  from posts p;
3
4-- the binary encoded data type is 'string'
5select p.content.publishedDate.type() as type 
6  from posts p;
7Results:TYPEstringUsing the type() item method, we can see the date is in fact stored as a string.Performance ImprovementWith data use case domains, the Oracle Database 23ai can not only use JSON schema for JSON data validation but it can also improve performance by leveraging the  CAST functionality. Consider the following data use case domain example:1drop table if exists posts purge;
2
3drop domain if exists BlogPost;
4
5-- Recreate the Domain with CAST/Type coercion enabled
6create domain BlogPost as json
7validate CAST using '{
8  "$id": "https://example.com/blog-post.schema.json",
9  "$schema": "https://json-schema.org/draft/2020-12/schema",
10  "description": "A representation of a blog post",
11  "type": "object",
12  "required": ["title", "content", "author"],
13  "properties": {
14    "title": {
15      "type": "string"
16    },
17    "content": {
18      "type": "string"
19    },
20    "publishedDate": {
21      "extendedType": "timestamp",
22      "format": "date-time"
23    },
24    "author": {
25      "$ref": "https://example.com/user-profile.schema.json"
26    },
27    "tags": {
28      "type": "array",
29      "items": {
30        "type": "string"
31      }
32    }
33  },
34  "$def": {
35    "$id": "https://example.com/user-profile.schema.json",
36    "$schema": "https://json-schema.org/draft/2020-12/schema",
37    "description": "A representation of a user profile",
38    "type": "object",
39    "required": ["username", "email"],
40    "properties": {
41      "username": {
42        "type": "string"
43      },
44      "email": {
45        "type": "string",
46        "format": "email"
47      },
48      "fullName": {
49        "type": "string"
50      },
51      "age": {
52        "type": "integer",
53        "minimum": 0
54      },
55      "location": {
56        "type": "string"
57      },
58      "interests": {
59        "type": "array",
60        "items": {
61          "type": "string"
62        }
63      }
64    }
65  }
66}';
67
68create table posts ( content BlogPost );
69
By enabling the JSON schema for type CASTing, we can request the database to use the new extendedType  during the binary JSON encoding process. In the example above, this would mean that the encoded type would be a timestamp and no longer a string resulting in less parsing overhead compared to the previous version: from string to timestamp each time we retrieve the field for SQL processing (WHERE clause filtering, SELECT projection, etc.).Let's check this:1create table posts ( content BlogPost );
2
3-- We can retrieve the JSON schema associated to the column
4-- via the Data Use Case Domain
5select dbms_json_schema.describe( 'POSTS' );
6
7-- works
8insert into posts values (
9'{
10   "title": "Best brownies recipe ever!",
11   "content": "Take chocolate...",
12   "publishedDate": "2024-12-05T13:00:00Z",
13   "author": {
14     "username": "Bob",
15     "email": "[email protected]"
16   },
17   "tags": ["Cooking", "Chocolate", "Cocooning"]
18 }'
19);
20commit;
21
22-- Now let's look at the publishedDate field...
23select p.content.publishedDate from posts p;
24
25-- ...its binary encoded data type is 'timestamp'
26select p.content.publishedDate.type() from posts p;
27
28-- I can add 5 days to this date...
29select p.content.publishedDate.timestamp() + interval '5' day 
30from posts p;
31
We use the item method timestamp() in the last statement above because otherwise the SQL dot notation would return a SQL JSON (by default in 23ai) on which we cannot apply an interval operation. However, because the value is already stored as TIMESTAMP inside the binary JSON format, there will be no conversion from JSON to timestamp here.
Last but not least, by enabling type casting, native SQL data type checks are also performed ensuring 100% fidelity between stored binary values in the encoded JSON and SQL data types. As a result, we can store not just the standard JSON data types but also the SQL data types inside the encoded binary JSON such as NUMBER, DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, INTERVAL, RAW, VECTOR, etc.Relational Model EvolutionOur last use case that leverages JSON schema inside the Oracle Database is available since version 12cR2. Imagine, you are a data analyst and the only tool you have to build charts only allows you to see tables and columns. Each time a new data attribute is added, you know that it will take time before you see it appearing inside your BI tool because of the involved development processes.Now, imagine this is no more the case...Let's look at the following example:1create table orders ( j json );
2
3insert into orders(j) values (
4  json { 'firstName': 'Bob', 'address': 'Paris' }
5);
6commit;
7
8select j from orders;
9Results: J                                                                       {  "firstName": "Bob",  "address": "Paris"} We have an orders table with one column containing a JSON document. The JSON document itself  has 2 fields and 2 values. Now, we'll create a JSON Search index (that can perform Full-Text search). This index can optionally maintain a JSON Data Guide in real-time, meaning the JSON schema for the JSON documents stored inside the JSON column.With this ability comes another one: Change Triggers For Data Guide-Enabled Search Index which, based on the maintained JSON schema, can react to any newly added JSON attributes and dynamically expose these by adding the corresponding virtual columns.The example below demonstrates this behavior:1-- drop index s_idx force;
2
3-- Create a Full-Text Search index for JSON with Data Guide
4-- enabled and add_vc stored procedure enabled to change
5-- table structure: add virtual column for JSON fields,
6-- helpful for Analytics => you directly have the existing
7-- JSON fields listed as columns!
8create search index s_idx on orders(j) for json
9parameters('dataguide on change add_vc');
10
11select * from orders;
12Results: J                                                                 J$addressJ$firstName {  "firstName": "Bob",  "address": "Paris"} ParisBob1insert into orders(j) values (
2  json { 'firstName': 'Bob', 'address': 'Paris', 'vat': false }
3);
4commit;
5
6select * from orders;
7Results: J                                                                                    J$addressJ$firstNameJ$vat {  "firstName": "Bob",  "address": "Paris"}                    ParisBobnull {  "firstName": "Bob",  "address": "Paris",  "vat": false} ParisBobfalse1
2insert into orders(j) values (
3  json { 'firstName': 'Bob', 'address': 'Paris', 'vat': false, 'tableEvolve': true }
4);
5commit;
6
7select * from orders;
8Results: J                                                                                                                    J$addressJ$firstNameJ$vatJ$tableEvolve {  "firstName": "Bob",  "address": "Paris"}                                                ParisBobnullnull {  "firstName": "Bob",  "address": "Paris",  "vat": false}                            ParisBobfalsenull {  "firstName": "Bob",  "address": "Paris",  "vat": false,  "tableEvolve": true} ParisBobfalsetrueThe trigger executes asynchronously, hence not delaying DML response times, however, because of it being asynchronous, it may take a second before you will see the new virtual column.
ConclusionWe have shown lots of features inside the Oracle Database 23ai which provide powerful capabilities to have JSON data coexist with relational data, and JSON schema clearly strengthens this even more. But this is only the beginning and as you discover more and more features that work the same way regardless of the data model, or that allow going back and forth from one model to another, you'll understand the true value of a converged database which has one goal: removing barriers, simplifying architecture and making developers more productive!Lean more:Oracle Database 23ai DBMS_JSON_SCHEMA PL/SQL packageOracle Database 23ai JSON Developer GuideGetting started with Oracle Database 23aiOracle Database 23ai JSON Feature HighlightsOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSponsorsJSON Schema uses OpenCollective and GitHub Sponsors to gather money. This money is used to cover project expenses in a transparent way (See the OpenCollective documentation), and your donation will help to sustain and grow the Project.While donations can be made to both OpenCollective and GitHub Sponsors, the JSON Schema funds are fully managed in OpenCollective, therefore the donations received in GitHub Sponsors will be transferred to OpenCollective.Please go to our OpenCollective page or GitHub Sponsors page to become a backer or a sponsor.Benefits of being an individual backerIndividual backers donate $5 per month to the project, and get the following benefits:Visibility on the GitHub main project page in the "sponsors" section.Benefits of being a community sponsorCommunity sponsors is a special tier for companies under 20 employees. Community sponsors donate $20 per month to the project, and get the following benefits:Visibility on the GitHub main project page in the "sponsors" section."Thank you" tweet from @jsonschema."Thank you" post in Linkedin from @jsonschema.A dedicated slack channel in our organization.Benefits of being a bronze sponsorBronze sponsors donate $100 per month to the project, and get the following benefits:Visibility on the front page of https://json-schema.org in the "sponsors" section (about 110,000 views/month on November, 2023).Visibility on the GitHub main project page in the "sponsors" section."Thank you" tweet from @jsonschema."Thank you" post in Linkedin from @jsonschema.Benefits of being a silver sponsorThere is a limit to 10 silver sponsors.Silver sponsors donate $500 per month to the project, and get the following benefits:Same benefits as bronze sponsors.A mention on the Newsletter.Possibility of getting expert advice from the team.Get a Swag Kit.Benefits of being a gold sponsorThere is a limit to 3 gold sponsors.Gold sponsors donate $1,000 per month to the project, and get the following benefits:Same benefits as silver sponsors.Company logo in the footer of the Newsletter.Company logo on all https://json-schema.org page footers.What will the project do with the money?As you can read in the OpenCollective documentation, the way your money will be used will be public and totally transparent.Money will first be used to cover direct project costs:Infrastructure and hostingNew feature developmentAny administrative or legal costsThen, money will be used for:MerchandisingMentoring and Contributing programsAcceptance policyWe don't accept sponsorship from the following types of companies: Adult websites, affiliate and review websites, fake news services, fake social media engagement services, casinos and gambling, insurance & financial products (credit), pharmacy products (weight loss, anti-aging), and essay writing services.Please, contact us if you have further questions.References:JHipster - SponsorsMUI Code - Sponsors and BackersGo BackRoadmapUp NextUse CasesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema referenceMaster the full power of JSON Schema with our reference documentation.From basic data types to advanced techniques like conditional validation and schema composition, you will learn everything about JSON Schema keywords through clear explanations and examples. By learning best practices for building clear, scalable, and easy-to-maintain schemas, you will ensure that your JSON data is both robust and flexible.KeywordsBrowse our comprehensive index of JSON Schema keywords, each linking to detailed documentation.Read MoreType-specific KeywordsBecome profficient at using the type keyword to validate your data.Read MoreDialect and vocabulary declarationLearn how to declare the JSON Schema dialect and vocabulary your schema uses, ensuring compatibility and proper validation.Read MoreEnumerated and Constant ValuesEnsure data consistency and accuracy, by defining value sets and fixed values for your JSON properties.Read MoreAnnotations and commentsEnhance your JSON Schemas with annotations and comments. Learn how to add descriptions, defaults, examples, and more to improve readability and maintainability.Read MoreConditional schema validationControl validation based on property presence and values using conditional subschemas.Read MoreSchema compositionLearn how to combine JSON Schemas using modular and boolean techniques to create flexible and maintainable data models.Read MoreString-encoding non-JSON dataDescribe and handle non-JSON data within JSON strings using media type and encoding information.Read MoreLearn JSON SchemaImprove your JSON Schema skills with this reference, crafted by our TSC members, offering practical examples, best practices, and common pitfalls.Read MoreGo BackUnderstanding common interfacesUp NextJSON Schema keywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, January 30, 2025 · 11 min readHow RxDB embraces JSON Schema to build its NoSQL DatabaseGo back to blogDaniel Meyeron this pageHow RxDB embraces JSON Schema to build its NoSQL Database
How RxDB uses JSON Schema
Restrictions
Inferring Document Types with TypeScript
Different JSON Schema ValidatorsPerformance Comparison of Validators

Should JSON Schema Validation Be Used in Production?
LearningsFollow UpHow RxDB embraces JSON Schema to build its NoSQL DatabaseRxDB is a NoSQL database designed primarily for client-side JavaScript applications, focusing on the offline-first approach, multi-tab operations, and data replication. It seamlessly integrates with modern web and mobile app frameworks, supports various storage backends, and provides a plugin-based architecture to handle encryption, compression, type generation, and more.One of RxDB's standout architectural choices is its reliance on JSON Schema to define data models for documents in collections. Instead of inventing a custom schema language, RxDB adopts a standard that is already well-established in the broader JavaScript community. By doing so, RxDB solves several major hurdles that often arise when developers are introduced to new databases:Familiarity: Most JavaScript developers have already encountered JSON Schema, either via OpenAPI or other tooling. Thus, they can quickly understand and adopt RxDB's schemas without investing time in learning a new schema language.Tooling ecosystem: JSON Schema boasts a robust set of libraries, validators, and code generators. RxDB leverages these rather than maintaining its own schema validation library, giving teams the freedom to pick what works best for them.Long-term maintainability: Because JSON Schema is recognized as a standard, future updates and ecosystem support are more reliable than a custom, one-off solution.By building on JSON Schema, RxDB has a foundation that makes schema design, data validation, and typing straightforward, making it easier for developers to build robust, safe applications in production.
How RxDB uses JSON SchemaWhile RxDB adopts the JSON Schema Core and Validation specifications, it also extends it to introduce RxDB-specific functionality. Like in other NoSQL databases, you can manually define which fields to encrypt, which ones to index, and how to interpret specific fields for queries. RxDB enables these configurations as custom JSON Schema keywords:primaryKey: Specifies which field in the document serves as the primary key.indexes: Defines which fields (or combination of fields) RxDB indexes. You can have single-field indexes or compound indexes.version: Indicates the version of the schema. Whenever you change your schema, you must increment this version so RxDB can handle migrations or other adjustments. This is important because data migration on a client-side database can be tricky when you have many clients out there that update your app at different points in time.encryption: Specifies which fields should be stored in an encrypted form. This is useful for sensitive data that you do not want to store in plaintext on the client's device.keyCompression: Can be set to true to enable the key-compression plugin.RxDB supports a compression plugin that uses a "compression table." This is essentially a lookup table derived from your JSON Schema which assigns shorter keys or transforms fields so that the stored data becomes more compact. By analyzing the schema, the plugin understands which fields appear repeatedly and can replace them with shorter tokens. Remarkably, RxDB can still query the data in its compressed form. This leads to performance improvements, especially in environments where local storage space is limited.Below is a sample RxDB schema that demonstrates how standard JSON Schema vocabularies combine with RxDB's custom extensions:1const mySchema = {
2    primaryKey: 'id',
3    type: 'object',
4    properties: {
5        id: {
6            type: 'string',
7            maxLength: 100
8        },
9        name: {
10            type: 'string'
11        },
12        birthdate: {
13            type: 'string',
14            format: 'date'
15        },
16        secret: {
17            type: 'string'
18        }
19    },
20    additionalProperties: false,
21    required: ['name', 'birthdate', 'id'],
22    // RxDB specific fields:
23    primaryKey: 'id',
24    version: 0,
25    keyCompression: true,
26    indexes: [
27        'name', // single-field index
28        ['name', 'birthdate'] // compound index
29    ],
30    encrypted: ['secret']
31}
32
RestrictionsAlthough RxDB aims to remain fully spec compliant with JSON Schema, it does impose some extra restrictions:The schema requires top-level field names to match the regex ^[a-zA-Z][a-zA-Z0-9_]*[a-zA-Z0-9]$. This rule ensures that property names are valid JavaScript identifiers.At the top level of the schema, additionalProperties must be set to false. This prevents silently introducing new fields that could potentially clash with built-in RxDocument methods (like .toJSON()). By making you list out each property, RxDB ensures you can't unknowingly overwrite or conflict with standard methods.RxDB does not allow $ref to other files or external schema fragments or $dynamicRef. The goal is to keep schema loading fast and self-contained. If a schema needs to be composed of multiple parts, you must combine them at build time or otherwise ensure they are merged before passing them to RxDB at runtime. This approach also prevents any network calls or asynchronous fetches that could slow down your application's startup.
Inferring Document Types with TypeScriptJSON Schema is not just for validation and structural guarantees, it can also help generate or infer TypeScript types. In many projects, developers rely on tools like json-schema-to-typescript to produce .d.ts files or interface definitions from schema files at build time. However, that requires a separate build step, which slows down your workflow.To improve developer experience, RxDB offers a built-in way to infer the document's TypeScript type from the schema during runtime. This is helpful because you get immediate feedback in your IDE: As soon as you update the schema, TypeScript picks up the changes. You'll see type errors in your code if you attempt to use fields that are no longer valid or if you forget to include newly required fields.Below is an example on how to infer the TypeScript type of a document from its JSON-schema:1import {
2    toTypedRxJsonSchema,
3    ExtractDocumentTypeFromTypedRxJsonSchema,
4    RxJsonSchema,
5    RxCollection
6} from 'rxdb';
7
8const heroSchemaLiteral = {
9    title: 'hero schema',
10    description: 'describes a human being',
11    version: 0,
12    keyCompression: true,
13    primaryKey: 'passportId',
14    type: 'object',
15    properties: {
16        passportId: {
17            type: 'string',
18            maxLength: 100
19        },
20        /* ...other fields... */
21    },
22    required: ['name', 'birthdate', 'passportId'],
23    indexes: ['name', 'birthdate']
24} as const;
25
26// Convert the literal object to a typed schema
27const schemaTyped = toTypedRxJsonSchema(heroSchemaLiteral);
28
29// Extract the document type from the typed schema
30type HeroDocType = ExtractDocumentTypeFromTypedRxJsonSchema<typeof schemaTyped>;
31
32// Create a typed RxJsonSchema
33const heroSchema: RxJsonSchema<HeroDocType> = heroSchemaLiteral;
34
35// Example usage: create a typed collection
36const myCollection: RxCollection<HeroDocType> = db.heroes;
37
Different JSON Schema ValidatorsIn order to validate whether a given document complies with the schema, RxDB uses pluggable validators. Historically, RxDB supports/supported:ajvz-schemais-my-json-valid (now deprecated in RxDB because it incorrectly handles large and decimal numbers)No single validator is perfect; each has its trade-offs in performance, build size, and correctness edge cases. Some libraries rely on eval() or new Function, which can break in strict Content-Security-Policy (CSP) environments. Others have issues with large integers. RxDB encourages you to pick a validator that matches your app's needs and environment constraints.Note that RxDB itself does not define a specific JSON Schema dialect. Instead, the range of supported dialects is determined by the JSON Schema validation plugin in use.One important consideration is that each validator has a unique format for its error messages. If your application inspects validation errors and makes decisions (e.g., showing descriptive warnings to the user), be aware that switching validators later can require extensive code changes. In theory this is solved by the JSON Schema specification by the use of the Standard Output format, but this is not implemented in the listed schema validators.Performance Comparison of ValidatorsPerformance is a critical factor in deciding whether to validate documents at runtime, especially in production environments. The following tables illustrate a basic comparison of initialization time (time-to-first-insert) and bulk insertion speed for different validators on two RxDB storagesThe RxDB team ran performance benchmarks using two storage options on an Ubuntu 24.04 machine with Chrome version 131.0.6778.85. The testing machine has 32 core 13th Gen Intel(R) Core(TM) i9-13900HX CPU.Dexie Storage (based on IndexedDB in the browser): Dexie Storage  Time to First insert  Insert 3000 documents  no validator              68 ms                         213 ms  ajv                       67 ms                         216 ms  z-schema                  71 ms                         230 ms On Dexie Storage, the difference in time-to-first-insert is negligible, and inserting thousands of documents also shows only a modest increase in latency when using a validator. The overall overhead for 3000 inserts remains fairly small (a difference of tens of milliseconds).
Memory Storage: stores everything in memory for extremely fast reads and writes, with no persistence by default. Often used with the RxDB memory-mapped plugin that processes data in memory an later persists to disc in background: Memory Storage  Time to First insert  Insert 3000 documents  no validator              1.15 ms                        0.8 ms  ajv                       3.05 ms                        2.7 ms  z-schema                   0.9 ms                         18 ms For the Memory Storage, you see a wider variance. Although z-schema has a faster startup (time-to-first-insert) than ajv, it becomes much slower at continuous inserts (18 ms vs. 2.7 ms). This discrepancy might not matter if you rarely insert documents, but it can become significant if you have high-volume write operations.Including a validator library also increases your JavaScript bundle size. Here's how it breaks down (minified + gzip): Build Size (minified+gzip)  Build Size (dexie)  Build Size (memory)  no validator                         73103 B                    39976 B  ajv                                  106135 B                   72773 B  z-schema                             125186 B                   91882 B Including a validator can substantially increase your final bundle size. For large single-page applications, an extra 30-50 KB or more of JavaScript could influence startup times, especially for users on slow networks.
Should JSON Schema Validation Be Used in Production?Many teams limit JSON Schema validation to development builds to avoid performance overhead in production. However, if your application deals with highly sensitive or mission-critical data, keeping validation enabled ensures data integrity and can prevent costly errors, despite the added CPU and bundle-size costs. Ultimately, the choice depends on your performance targets and  the risk of invalid data.Running the Validation in a WebWorkerIf you must keep validation enabled in production but you have to ensure that your UI does not lack during validation, you might consider the RxDB WebWorker plugin. This plugin runs the RxDB storage & validation in a separate Web Worker, offloading the main UI thread. While it won't reduce the absolute time spent on validation, it can help maintain a smooth UI by preventing blocking operations on the main thread.
LearningsOver time, RxDB has evolved its usage of JSON Schema, learning from real production experiences and feedback from the community. Here are some key takeaways:Avoid inlined required fields: In older JSON Schema dialects such as Draft 3, it was acceptable to define "required": true directly inside the property definition. However, more recent dialects expect required to be declared as an array at the parent object level. If you're using a validator based on newer specs, place your required fields in the parent-level array. If you intentionally stick to Draft 3, inlined required is still valid, but it may cause confusion if you switch to a newer validator or tool later on.Keep Custom Fields at the Top Level: Originally, RxDB allowed custom definitions (index, encrypted, etc.) to appear deeply nested. This caused performance hits because the library had to traverse large schema objects to find them. By placing these fields at the top level, RxDB can parse and apply them much faster, improving startup times.Error messages are not standardized: Each validator produces a different structure for error messages. If your app logic inspects these errors, you risk partial or complete rewrites if you ever switch validators. Decide early on which validator meets your needs and plan on sticking with it long-term. This might be solved in the future when all validators support the standard output formatting.Follow UpUsing JSON Schema in RxDB has greatly simplified data definitions, tooling integration, and type inference. Although some restrictions and performance considerations come into play, the overall developer experience is significantly improved by using a well-known standard rather than reinventing the wheel.For more information on RxDB, including further details on schema extensions and advanced plugins, check out the official RxDB documentation.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, January 17, 2025 · 6 min readCelebrating JSON Schema’s Google Summer of Code 2024 JourneyGo back to blogOnyedikachi Hope Amaechi-Okorieon this pageA Unique Start: Setting the Stage for SuccessTransformative Projects and Talent ContributorsMentorship: A Two-Way Learning ProcessWatch the JourneyLooking ForwardReady to contribute?Last year, JSON Schema proudly participated in Google Summer of Code (GSoC) 2024, a global program designed to bring fresh talent into open-source communities. Through this initiative, we tackled some of our most exciting projects yet, creating opportunities for contributors to make meaningful impacts while gaining valuable experience.We’re thrilled to share the highlights of this journey and the incredible work our contributors and mentors achieved together.A Unique Start: Setting the Stage for SuccessFor JSON Schema, GSoC 2024 wasn’t just about welcoming contributors but about setting a high standard. Before selection, applicants underwent a qualification test, allowing us to assess technical skills and alignment with project goals. This ensured each participant had the tools and mindset to thrive.Here’s what stood out in our journey:8 projects completed across diverse aspects of JSON Schema.A record number of applicants, with a community brimming with enthusiasm.Returning mentors and contributors, bringing experience and new perspectives.Transformative Projects and Talent Contributors1. Bowtie-Trend: Long-Term Reporting With BowtieContributor: Adwait GodboleMentors: Julian Berman, Agnivesh ChaubeyIdea on GitHubThe project aims to enhance Bowtie, a meta-validator for the JSON Schema specification that coordinates the execution of validator implementations and reports their results. While Bowtie already generates compliance reports accessible here, this project introduces a mechanism to track compliance metrics over time. The goal is to enable graphing and querying of how test results evolve as implementations fix bugs or new tests are added. Key outcomes include a new bowtie trend command to aggregate results into trend reports and a dedicated webpage displaying graphs of failed tests over time, providing deeper insights into long-term compliance trends.2. Bowtie-Perf: A Performance Tester for JSON Schema ImplementationsContributor: Dhruv SinghMentors: Julian Berman, Agnivesh ChaubeyIdea on GithubThe project enhances Bowtie, a meta-validator of the JSON Schema specification. Bowtie provides universal access to JSON Schema implementations, enabling users to validate instances and identify bugs or gaps in functionality. Currently, Bowtie supports validating instances against schemas and comparing implementations based on correctness. This project expands its capabilities by developing a performance tester integrated within Bowtie. This addition provides a critical dimension for performance optimization and enables more comprehensive comparisons across JSON Schema implementations.3. Setting up the CI/CD Pipeline for the JSON Schema WebsiteContributor: Alok GuptaMentor: Benjamin GranadosIdea on GithubThe Improved CI/CD Workflow for the website project with GitHub Actions project focuses on enhancing the existing CI/CD pipelines by adding essential features like linting, formatting, unit testing, UI testing, broken link checks, and build processes. The project involves streamlining workflows for pull requests, pushes, and issues, with special emphasis on first-time contributors. Key deliverables include creating and optimizing workflows such as PR workflows, push workflows, issue workflows, stale issue and PR reminders, unauthorized file detection, and CodeQL for security analysis. Additionally, the project aims to provide clear documentation on workflow roles and guidelines for updates, ensuring smoother community operation integration and more efficient code management.4. Building a New Version of the JSON Schema Tooling PageContributor: DVMentor: Benjamin GranadosIdea on GithubThe JSON Schema Tooling Page plays a vital role in helping developers explore the ecosystem of JSON Schema tools and implementations. However, its current design presents usability challenges that hinder adoption. This project aims to rebuild the tooling page using a data-driven approach while adhering to the updated UI/UX standards of the JSON Schema website. By improving accessibility, simplifying navigation, and enhancing clarity, the revamped tooling page will make JSON Schema implementations more discoverable and user-friendly, ultimately reducing friction and encouraging broader adoption within the developer community.5. JSON Schema Language Server ContributionsContributor: Diya SolankiMentor: Jason DesrosiersIdea on GithubThe project focuses on enhancing the Language Server Protocol (LSP) for JSON Schema, enabling improved support for various editors and IDEs. Unlike the existing VSCode integration, which lacks support for recent JSON Schema versions and struggles with performance for large schemas, this project aims to expand functionality. Key improvements include inline diagnostics for invalid schemas, semantic highlighting for JSON Schema and deprecated keywords, support for multiple drafts (04/06/07/2019-09/2020-12), and enhanced configuration management. The project also focuses on adding code completion for $schema, making JSON Schema development more efficient and accessible across platforms.6. Define Upgrade/Downgrade Language-Agnostic Declarative Transformation Rules for all JSON Schema DialectsContributor: Suprith KGMentor: Juan Cruz ViottiIdea on GithubThe project addresses the challenges of maintaining software compatibility across different schema versions. It focuses on creating declarative, language-agnostic rules to streamline the process of upgrading or downgrading JSON Schemas. This is crucial for users working with high-level languages like Python, managing large documents, or navigating diverse network communication setups such as HTTP, WebSocket, microservices, or IoT. By simplifying schema transformations and introducing standardized procedures, this project aims to save time, ensure reliability, and improve JSON Schema’s versatility across various implementations and use cases.7. Source Generation Analyzer Powered by Corvus.JsonSchema (.NET)Contributor: Pranay JoshiMentors: Matthew Adams (Endjin), Greg DennisIdea on GithubThe project focuses on creating a source generator that integrates seamlessly with Corvus.JsonSchema. This tool will automatically generate code from JSON Schema files within a .NET project at compile time, streamlining the development process. The ultimate goal is to foster collaboration and consistency across software development teams using diverse technology stacks by establishing JSON Schema as a unified source of truth for data modeling. This ensures that generated code adheres to a standardized data structure, improving efficiency and alignment within organizations.8. A Tour of JSON SchemaContributor: Zeel RajodiyaMentors: Bence Eros, Benjamin GranadosIdea on GithubThe Tour of JSON Schema project is an interactive learning platform designed to help beginners quickly grasp JSON Schema concepts and best practices. Through step-by-step lessons and hands-on exercises, users can learn by doing, using a simple interface and built-in code editor. The platform provides practical examples, real-time validation of JSON Schema, and immediate feedback, making the learning process engaging and effective. By following structured lessons, users will gain the confidence to create and work with JSON Schemas independently.Mentorship: A Two-Way Learning ProcessThe success of GSoC 2024 for JSON Schema wouldn’t have been possible without our dedicated mentors. They not only guided contributors but also gained fresh perspectives from working closely with emerging talent.Watch the JourneyWant to hear more about the contributors’ stories? Watch our YouTube presentation where contributors reflect on their challenges, successes, and learning moments.Looking ForwardGSoC 2024 has left an indelible mark on JSON Schema. From automation to tooling, each project has strengthened our ecosystem and laid a foundation for continued innovation.
We are excited about the future and invite developers from around the world to join us in shaping it.Ready to contribute?Explore our GitHub repository, get involved in discussions, and be a part of the JSON Schema community!Background photo by Jess Bailey 
on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, January 13, 2025 · 8 min readMoving Toward a Stable SpecGo back to blogGreg Dennison this pagePublication ProcessCompatibility with Draft 2020-12Many of you may have noticed a lot of changes happening around the JSON Schema community.  This website has had a facelift, we've started appearing at developer conferences, and we even participated in Google's Summer of Code & Summer of Docs programs.  But many of you may be asking, "What's happening with the spec?"In this post I'll be providing an update on specification development and our new publication process.Publication ProcessIn a previous post, we announced that we were no longer publishing our specifications through the IETF.  At the time, the intent was to join the OpenJS Foundation, however for multiple reasons, the onboarding process was not able to be completed.  As such, currently we are independent.  In the future, we may again seek to join a foundation (we may even try OpenJS again), but for now, independence seems to be the best place for us.When we last published a specification, we used the IETF's Internet-Draft Publication Process.  This meant that our documents were required to retain the "draft" moniker, even though we considered them fully fledged and ready for use in production systems.  Publishing independently, we're no longer bound by this requirement, however it does mean that we can no longer rely on the IETF document publishing infrastructure.  We have to build our own.The foundation of our publication process is built on several ideals, and I'll cover the major ones in the next few sections.  By focusing on these pillars, we can ensure a safe and easy upgrade path for our users as the specification continues to evolve.Minimize Backward-Incompatible Changes Between ReleasesOne of the primary complaints we received about releasing a new specification over the last few iterations, particularly between Drafts 2019-09 and 2020-12, is the lack of consideration for backward compatibility.Just to highlight a few of the breaking changes introduced with the latest version:$recursiveRef / $recursiveAnchor became $dynamicRef / $dynamicAnchorArray-form items became prefixItemsadditionalItems was removed; use schema-form items nowThese changes meant that a schema written for Draft 2019-09 could validate completely differently when processed under Draft 2020-12 rules.  This creates a very poor upgrade experience.In defending our decision to include these breaking changes, we hid behind our own advice to schema authors to include the $schema keyword, which identifies the dialect (specification version), instead of designing a pit of success that allowed them to continue their current behavior in a system that "just works".Moving forward, upgrade compatibility is our #1 concern when developing a new release.That doesn't mean that a breaking change will never happen, but we will make every effort to ensure that it doesn't.Maximize Forward CompatibilityWe need to protect ourselves from potential future changes that would harm or prevent backward compatibility.Ironically, this means introducing a breaking change.  (I had posted about this a couple of years ago, and the reception wasn't awesome, which led to a follow-up post.)In short, to preserve future compatibility, we need to ensure that schemas can't contain extra properties which may one day be proposed as legitimate keywords.  This means that extra data in schemas can no longer be acceptable.  To accommodate our users' need to include meta-data and other values in their schemas, the specification will define a convention or namespace for property names that are to be ignored, and we guarantee that no future proposed keyword may follow this convention in order to keep the namespace protected.As it stands today, the convention is that your property name should start with x-.  If you like, you can read about alternative ideas and how we decided on this approach in the ADR.Formally Define a Feature Proposal ProcessIn the past, new features would just be added to the specification and released with the next version.  We held it as acceptable that a feature may not be fully finished when we released the specification.  We expected to receive feedback, and the feature would be updated in the next version.However, this approach puts a large burden on tooling maintainers who want to support multiple versions of the specification, which is basically all of them.  They'd have to support many different behaviors, sometimes for the same keyword.The perfect example of this is Draft 2019-09's $recursiveRef & $recursiveAnchor.  The idea was solid and had a lot going for it.  In 2019 when we were working on it, we developed the concept as best we could, but we needed actual user feedback, so we added it to the specification, knowing that it wasn't quite complete.  Prior to releasing the specification, a few of us who had implementations also added it as an optional feature to let our users try it out.  But after the specification was released, we found that many users were confused as to how it should work, and we identified several ways that we could make it better.  Those improvements became $dynamicRef & $dynamicAnchor in Draft 2020-12.  Even though the "recursive" keywords weren't part of the latest specification, many implementations wanted to support Draft 2020-12 while continuing to support Draft 2019-09.  Furthermore, schemas which contained the "recursive" keywords couldn't be processed under the Draft 2020-12 rules, which takes us back to the backward compatibiility problem.We need a feature proposal process that encourages tool support while also allowing continued feature development.By introducing a feature proposal process, all tooling maintainers can add support as they elect to do so.  And because these proposals aren't considered a hard requirement of the specification, we can continue to iterate on them (including breaking changes).  Finally, by actively encouraging tooling support, we can obtain the real-world feedback that we need to ensure that the feature is the best it can be before we officially integrate it into the specification.Compatibility with Draft 2020-12To close this out, and with all of the above in mind, I want to cover what the upcoming release will entail as it stands now.First, the incompatibilities:As mentioned before, we won't be supporting arbitrary properties anymore.  Any extra data you wish to include will need to use the x- property name convention.The $dynamicRef / $dynamicAnchor referencing system will be completely disjoint from the $ref / $id / $anchor system.  In Draft 2020-12, $dynamicRef could sometimes fall back to a normal $ref behavior.  This has been very confusing, so we've just isolated the two referencing systems.  This is technically a breaking change, but we're pretty certain no one ever used $dynamicRef expecting it to work like $ref.format will validate by default.  There was a lot of discussion on this topic, but the deciding factor was that users generally expect it to validate, and we wanted to meet that expectation.Vocabularies are being demoted to a feature proposal.  This was one of those ideas that wasn't completely finished when it was added to the spec in Draft 2019-09.  It's likely that this feature will change substantially before being merged back into the specification.  As a proposal, the feature can still be supported as development continues, but it's not a hard requirement.Additionally, but not breaking:The recommended output format introduced in Draft 2019-09 has been extracted to its own specification.  The two driving factors for this decision were that different output formats could be more beneficial to different consumers and having the output versioned separately from the specification would more easily allow them to evolve independently.Many keyword interaction behaviors were defined by the annotations that were produced at various levels of evaluation.  This led to some confusion and unnecessary requirements, so we've loosened the language around this to allow tooling to figure out how they want to implement the behavior rather than prescribing a particular approach.General clean-up and clarifications to more accurately define behavior.Beyond that, we still have a lot to do, but not nearly as much as we had this time last year, and we still have to figure out the actual publication piece, i.e. how we want it on the website.  We have the IETF-published documents mirrored here, and the new ones will likely go up next to those.  It's just another thing we need to do.  You can track our list of items on the GitHub project board.It's been four years since we published a new version, but we're getting really close, and I'm very excited.  Stay tuned!Cover image is of Mt. Taranaki in New Zealand, by Sophie Turner on Unsplash.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, December 19, 2024 · 5 min readJSON Schema conference: A milestone event at Apidays Paris 2024Go back to blogValeria Hernandez@valeriahhdezon this pageIntroductionThe first JSON Schema conferenceCollaboration with organizationsIntroductionApidays Paris, the flagship event of the apidays family, returned this year with a focus on "The Future API Stack for Mass Innovation." This annual gathering of API enthusiasts, developers, and industry leaders brought together experts to discuss the latest trends and best practices in API design, API development, and API management.This year's agenda highlighted the increasing role of AI in API development, exploring how AI can be used to automate tasks, improve API design, and enhance API performance.
Continuing our successful partnership with AsyncAPI and OpenAPI, this year's event marked a significant milestone with the inaugural JSON Schema conference track. This dedicated track, sponsored by Octue, delved deep into the world of JSON Schema, exploring its role in API design, validation, and documentation.The first JSON Schema conferenceThe inaugural JSON Schema conference track at apidays Paris 2024 was a resounding success. As part of the larger conference theme "The Future API Stack for Mass Innovation," the track showcased JSON Schema's crucial role in modern API development and data contract design.Community members at the standards booth shared with AsyncAPI, OpenAPI, and GraphQL. From left to right: Benjamin Granados (community manager), Thomas Clark (Octue CEO), Andreas Eberhart (JSON Schema ambassador), Juan Cruz Viotti (TSC member), and Ben Hutton (TSC member).Ten comprehensive presentations spanned the spectrum of JSON Schema applications, from foundational concepts to cutting-edge implementations. The list of talks included:JSON Schema for data design and contract, client and code generation by Tom Collins (DVLA, UK Gov)IEC standards: Toward digital standards with JSON Schema by Thomas Clark (Octue CEO, conference sponsor)Introducing Strands - a JSON Schema repository by Thomas ClarkJSON Schema: powering FINOS architecture as code by James Gough (Morgan Stanley)Generic and extensible web of things manager using JSON Schema and AI by Andreas Eberhart (Dashjoin, JSON Schema ambassador)High-performance JSON Schema validation in .NET by Matthew Adams (Endjin, TSC member)JSON schema and relational databases: bridging the gap by Loic Lefèvre (Oracle)Applying software engineering practices to JSON Schemas by Juan Cruz Viotti (Sourcemeta CEO, TSC member)The state of JSON schema by Benjamin Granados (Celonis, TSC member)Unlocking dynamic frontend development through JSON Schema by Neha Singla (Apple)Three major themes recurred throughout the track: data design and standardization, tooling infrastructure, and modern application integration. Particularly notable was the emphasis on JSON Schema's role in AI integration and automated API development, aligning perfectly with the broader conference focus on AI's increasing importance in the API landscape.Octue's sponsorship significantly bolstered the track's success, demonstrating their commitment to the JSON Schema community. This support enabled a diverse range of speakers to share their expertise and experiences.Audience engagement exceeded expectations. Attendees from various industries and organizations - such as fintech, renewable energy, IT, and government - participated in robust Q&A sessions after each presentation. The discussions revealed both the growing adoption of JSON Schema across different sectors and the community's hunger for more knowledge about its practical applications.A room full of people listening to Loïc Lefèvre’s engaging presentation on utilizing JSON schemas to manage relational databases.Looking ahead, this first dedicated track has laid a strong foundation for future JSON Schema events. The feedback highlighted the need to further showcase JSON Schema's versatility across different use cases, and plans are underway to expand and enhance next year's track. This successful launch not only validates JSON Schema's importance in modern API development but also signals the beginning of a new chapter in the community's growth and evolution.Collaboration with organizationsThe success of the JSON Schema track at apidays Paris 2024 highlighted the vital role of community collaboration in our growth. It also demonstrated how organizations collaborating with JSON Schema gain more than just visibility - they become part of a broader movement toward standardized, high-quality API development.Here's how your organization can benefit:Standardization & interoperability: Ensure seamless data exchange and API integration.Improved data quality: Minimize errors with robust data validation.Enhanced API design: Streamline development with clear and concise schemas.Increased productivity: Automate tasks and boost efficiency with JSON Schema tools.Here’s how you can become part of the initiative:Be an ambassador: Share your JSON Schema expertise and champion its adoption.Become a sponsor: Gain visibility and support the standard's growth.Contribute to the project: Help us shape the future of JSON Schema development.Join our Slack workspace: Connect with the vibrant JSON Schema community.Together, we can build a more robust and interoperable API ecosystem.A final thank you to Octue for sponsoring the conference, apidays Paris for hosting it, the organizers for their dedication and hard work, and the attendees for your valuable input and insightful questions. On behalf of JSON Schema, we look forward to seeing you again next year!Acknowledgments: The author would like to thank Onyedikachi Hope, Ben Hutton, and Benjamin Granados for their valuable feedback, which enhanced the quality of this article.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubTuesday, September 3, 2024 · 2 min readUpdate from the Google Season of Docs 2024 ProjectGo back to blogBlessing Ene AnyebeValeria HernandezDhairya Amrish MajmudarBenjamin Granadoson this pageThe JSON Schema documentation projectThe GSoD project accomplishmentsThe road aheadConclusionThe JSON Schema documentation projectThe main goal of JSON Schema's documentation project is to create a scalable documentation architecture that is clear, consistent, and comprehensive. To achieve this through Google Season of Docs (GSoD), we focused on:Restructuring the specification docs: The specification docs need a structure that helps all personas understand how JSON Schema has evolved across different releases and the features introduced in each version.Revamping the information architecture: The documentation needs a new information architecture that better aligns with the documentation developer journey and organizes content based on the diataxis framework. The new information architecture's goal is to improve the onboarding experience and content findability.The GSoD project accomplishmentsSince May, the team (Valeria Hernandez, Blessing Ene Anyebe, Dhairya Amrish Majmudar, and Benjamin Granados) has been working hard to achieve these goals. On the part of documentation, we have completed the following:Conducted a thorough content auditMapped out the developer experience journeyImplemented the keywords pageRestructured the specification docsThe team has also introduced changes to the website, like a table of contents and a Next-Previous component that aim to improve content scannability and navigation.The road aheadSo, what's pending? We're currently working on the JSON Hyper-Schema and Migration pages, which are part of the specification docs.We're also documenting guidelines for docs contributions and text formatting, documenting missing keywords (see issues 951, 952, and 961), and writing step-by-step guides (see issues 180, 950, and 954).ConclusionOur documentation efforts are expanding daily, and your contributions can improve them. There are several ways you can help, including:Breaking down large documents to improve the overall structure of the documentation websiteCreating missing documentation for the Troubleshooting and Scaling stages of the developer journeyContributing to the Migration pageOur docs meeting is held bi-weekly every Tuesday at 3:00 PM (UTC). You're welcome to join the #gsod24 channel in the JSON Schema Slack workspace and send us a message with your email address so we can add you to the meeting.We appreciate your interest in the JSON Schema documentation project and look forward to your contributions and their benefits to the wider developer community.The JSON Schema's Google Season of Docs Team.Photo by Duy Pham on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, June 20, 2024 · 8 min readJSON Schema Ambassadors Are Here!Go back to blogBen Huttonon this pageAmbassadors program?The time is right - we are growingHow we benefit, from todayA portrait of an AmbassadorRecognising our Ambassadors from the communityHow to apply todayYou (yes, you!) can help support and expand Ambassadors and other programsAmbassadors program?You may have noticed our new Ambassadors Program! If not, don't worry—we're here to explain what it is and how you can get involved.I'm personally very excited to see this program come to life. Recognizing our community champions in a meaningful and sustainable way has always been a goal. The Ambassadors Program is our first step in publicly supporting our most experienced and helpful members.We have many community members who frequently help others, provide feedback, answer questions, and debug schemas and code. They also assist newcomers in avoiding basic misconceptions. JSON Schema wouldn't be where it is today without this support.The time is right - we are growingFor the past few years, a small team has worked full time on JSON Schema, focusing on ongoing projects. Now, we have the capacity to launch new initiatives, including this Ambassadors Program. We want to better recognize and support those who are giving back to our community.We are better placed today than we ever have been to support and empower our existing ambassadors, and build a program which recognizes and supports them to further their efforts. It's always encouraging to see others as excited about JSON Schema as you are."The new website, and assorted outreach programmes have started to connect the huge JSON Schema user base, and we've really started to see the benefit in terms of the number of people actively participating." - Matthew Adams - Founder at Endjin - Candidate Ambassador.
How we benefit, from todayWhen thinking about our programs, two aspects we should consider are how they will impact the project overall, and the community. These are not the only aspects, but ones I want to touch on in this context.As a ProjectHaving ambassadors not only recognizes individual contributions but also benefits JSON Schema. It will increase visibility and encourage positive community engagement.Despite JSON Schema's presence, many still see it as part of another standard. By promoting JSON Schema through various channels, we enhance its recognition and usage. This increased visibility can attract more sponsorships, funding further programs like the Ambassadors Program and fostering a better ecosystem. It's a positive cycle; once we start, momentum will help us grow.As the project thrives, so too does our community. The Ambassadors Program brings several benefits specifically for our community."The community is very friendly, welcoming, and extremely smart. I already learnt a LOT by participating in it. I want the JSON Schema ecosystem to grow, as it will likely power my business as a result. The Ambassadors Program is a great opportunity to recognise key contributors and encourage them to continue being involved." - Juan Cruz Viotti - Founder and CTO at Intelligence.AI - Candidate Ambassador
As the CommunityThe project and the community both benefit from the Ambassadors Program. Ambassadors will contribute valuable content, enhancing learning and engagement. To keep their ambassador status each year, ambassadors will be expected to make a number of contributions that benefit the community, such as articles, videos, podcasts, or even talking or running a workshop at a conference.Given the prominence of the ambassadors, we will, collectively, check any and all published work they produce, making sure it's accurate. If you work with code, you've probably seen your fair share of poorly documented projects, and you know the impact that can have. High-quality, up-to-date content makes it easier for both newcomers and veterans to learn and stay current.Further, we don't require or even expect that all the content ambassadors produce will go onto the project's website. No. There's actually improved reach by ambassadors using their existing channels to reach their community, hopefully expanding the JSON Schema community in addition to educating other spaces.A portrait of an AmbassadorWe've long planned the Ambassadors Program and have identified initial candidates. (You can nominate yourself or others!) Here are the qualities we seek in ambassadors.Firstly, an ambassador has to be with the community. This means in the slack server, on Github, and occasionally on calls or other places representing or being a recognised expert or source of knowledge for JSON Schema.Critically, we expect ambassadors to be aligned with the JSON Schema project's mission and values, be respectful of our code of conduct, and continue to be active in the community.Recognising our Ambassadors from the communityWe easily identified several community members to invite into the Ambassadors Program. The TSC and the Community Team spend a LOT of time in our community spaces, so even if we don't always reply or comment, we do notice those who are active and helpful.When I first started the JSON Schema Slack server, the numbers were very few. Gradually, it grew. The core team answered most of the questions. I recall the feeling when I came back in the morning to find other people had answered questions from the community while I'd been asleep. I've previously recognised that saying "thank you" can be a big win, but I also know that we can do several magnitudes better.We already have several members of our community who have become ambassadors for JSON Schema, just without any sort of formal recognition. Recognising, supporting, and further enabling these individuals, and new ambassadors, is going to have a positive impact, and I can't wait to see what it unlocks for JSON Schema in the future.There's a swag kit for all accepted into the Ambassadors Program, and I can't wait to meet the individuals excited and proud to be wearing the exclusive swag at events and conferences in the future. We see you, ambassadors!How to apply todayOK, OK. If you've read all the above, maybe you haven't yet made it to the Ambassador Program documentation file in our community repo. That would be your next stop if you're thinking about applying to become an ambassador.We will be looking for existing contributions from individuals who have already been in our community for a while. If you're brand new to JSON Schema, becoming an ambassador is probably not something immediately in your reach, and that's OK. If you have some experience with JSON Schema, go write about it, apply to talk at events and conferences, or make videos. Be part of our community, answer questions. Then your application is much more likely to be accepted.As I mentioned, we have a number of people in mind already, and I'd love to introduce a few of them to you today. If you're in our community spaces, you've probably seen them around."As a small team ourselves at Endjin, we live by the mantra 'helping small teams achieve big things'. I believe we can have a disproportionate positive impact by working on JSON Schema as it is so widely adopted, across so many different disciplines and industry verticals." - Matthew Adams"JSON is the world's most popular data format, and it's impossible to not work with it in some way or another. Once you want to embrace JSON, JSON Schema is the most powerful and expressive schema language for it, elegantly enabling a wide variety of use cases." - Juan Cruz ViottiYou (yes, you!) can help support and expand Ambassadors and other programsIf this program sounds great and you want to support it, you can! Being part of our community is a great first step. Our Slack server may sometimes get busy, but you could mute it and only get notified of announcements, if you wanted. We actively use and monitor GitHub Discussions, so if Slack isn't your thing or you have one too many already, that's going to be a space for you. We're also more active on LinkedIn over this past year, and it seems to be increasing in popularity with professionals; We love to hear how JSON Schema is used in industry.Sharing content from the JSON Schema project and community promotes growth and enhances your professional credibility. With ambassadors contributing more content, they may even seek ideas from you!We are sending out swag at our expense, and we have a little money saved in our Open Collective budgeted and set aside for doing so. However, we would love to be able to support ambassadors to cover the expenses involved in getting to the larger conferences, including our own in the future. If your organization supports open source projects, please consider financial donations, especially if you use JSON Schema in production. We also support GitHub Sponsors.If that's easy, great, but we do appreciate it's not always attainable. What might be more possible is to get your organization added to our Adopters list. You can read all about that in our community repository.I'm thrilled to see our Ambassadors Program get off the ground, and I'm positive it will have a really impactful effect on the project, the community, and the ambassadors that take part. Join us, get involved, and let's see what we can achieve together!Photo by Ian Schneider on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, February 15, 2024 · 15 min readUnderstanding JSON Schema Lexical and Dynamic ScopesGo back to blogJuan Cruz Viottion this page
Schema ResourcesSchemas as Directed GraphsLexical ScopeDynamic Scope
Summary
Most of the keywords defined
by the JSON Schema organization can be either evaluated on their own, or by
only considering the values of their adjacent keywords. For example, the type
keyword is independent of any other keywords, while the additionalProperties
keyword depends on the properties and patternProperties keywords defined in
the same schema object.If you want to learn more about keyword dependencies, check out the Static
Analysis of JSON Schema article by Greg
Dennis.
However, there is a small set of keywords whose evaluation depend on the
scope they are in. These keywords are $ref, $dynamicRef,
unevaluatedItems, and unevaluatedProperties. Additionally, there is also a
set of keywords that affect the scope they are declared in. These keywords
are $id, $schema, $anchor, and $dynamicAnchor.JSON Schema defines two types of scopes for the purpose of URI resolution: the
lexical scope and the dynamic scope. Understanding how these scopes work is
essential for mastering some of the most advanced (and often confusing!)
features of JSON Schema, such as dynamic referencing.Schema ResourcesBefore we jump into lexical and dynamic scopes, lets review some JSON Schema
fundamentals.The $id keyword defines the URI of a
schema. While this keyword is
typically set at the top level, any
subschema may declare it to
distinguish itself with a different URI. For example, the following schema
defines 4 identifiers, some relative and some absolute:In JSON Schema
parlance,
we say that the $id keyword introduces a new schema resource, and that the
top level schema resource is referred to as the root schema resource.Consider the following example. This schema consists of 3 schema resources,
each highlighted using a different color: the root schema resource (red), the
schema resource at /properties/foo (blue), and the schema resource at
/properties/bar (green). Note that the subschema at /properties/baz is part
of the root schema resource, as it does not introduce a new identifier:Note that children schema resources are not considered part of the parent
schema resource. For example, in the previous figure, https://example.com/foo
or https://example.com/bar are separate schema resources and not part of
the root schema resource, despite their structural relationship.Schemas as Directed GraphsJSON Schema is a recursive data structure. In the context of schema resources,
this means that a schema resource may introduce nested schema resources (like
we saw on the previous section) and use referencing keywords (like $ref) to
point to external schema resources, creating a directed graph of schema
resources.Consider the following example. In the top left, a root schema resource named
https://example.com/origin that declares a nested schema resource named
https://example.com/nested (at /properties/bar) and references an external
schema resource named https://example.com/destination (from
/properties/foo/$ref). In the bottom left, a root schema resource named
https://example.com/destination that references a nested schema resource
called https://example.com/nested-string (from /items/$ref). On the right,
a directed graph representation of the relationship between these schema
resources:As you will see, thinking of a schema as a directed graph of schema resources
greatly helps in understanding both lexical and dynamic scopes.Lexical ScopeUnder the graph analogy from the previous section, the lexical scope of a
schema consists of the node being evaluated. In other words, the lexical scope
of a schema consists of the entire schema resource to which it belongs.Consider the following sequence of examples. On the left, a JSON Schema with a
single nested schema resource. On the right, the corresponding directed graph
representations for the root schema resource called
https://example.com/person and the nested schema resource called
https://example.com/surname. At each step of the evaluation process, we gray
out the parts of the schema and of the directed graph that are not part of the
lexical scope.The evaluation process starts with the top level schema. The lexical scope at
that point is the root schema resource, and the nested schema resource is out
of scope.Then, we enter the properties applicator, and if the instance defines a
firstName property, we get into the subschema at /properties/firstName.
This subschema is part of the root schema resource (as it does not declare its
own identifier), so the lexical scope remains the same as the previous step.Finally, if the instance defines a lastName property, we follow the
properties applicator into the subschema at /properties/lastName. This
subschema defines a new schema resource, so the lexical scope at this point is
the nested schema resource, and the root schema resource is out of scope.Note that by definition, the lexical scope of any subschema can be statically
determined without taking
instances into account, just
as we did here.Lexical Scope and AnchorsAs another practical example, consider the $anchor keyword that defines a
location-independent
identifier
for a schema. This keyword not only affects the schema object it is defined in,
but also its lexical scope. This is why declaring the same anchor identifier
more than once in the same schema resource is an error (a clash in the lexical
scope), while it is possible to declare the same anchor identifier on different
schema resources (as the lexical scopes are different):Following ReferencesWhen the evaluation process encounters a reference keyword, it abandons the
lexical scope of the reference schema and enters the lexical scope of the
destination schema.If the reference points to a subschema within the same schema resource, the
lexical scope remains the same. Coming back to the graph analogy, each node
represents a schema resource, so the evaluation process remains at the same
node. However, if the reference points to a subschema on a different schema
resource, the schema resource of the destination becomes the new lexical scope.
In the graph analogy, the evaluation process follows an arrow to another
node.Within Schema ResourcesIn the following example, the reference at /items/$ref points to
/$defs/person-name. The destination schema is part of the same schema
resource (the root schema resource), so the lexical scope remains the same:Across Schema ResourcesNow consider the following sequence of examples. On the left, a JSON Schema
called https://example.com/point-in-time with a nested schema resource (at
/$defs/timestamp) and a reference to an external schema called
https://example.com/epoch (from /anyOf/1/$ref). On the right, the
corresponding directed graph representations of the root schema resource, the
nested schema resource, and the external schema resource. Like before, at each
step of the evaluation process, we gray out the parts of the schema and of the
directed graph that are not part of the lexical scope.The evaluation process starts with the top level schema. The lexical scope at
that point is the root schema resource, and both the nested schema resource and
the external schema resource are out of scope:Then, we enter the first branch of the anyOf logic applicator and follow the
reference at /anyOf/0/$ref (highlighted in red) into /$defs/timestamp. This
subschema has its own identifier, so the lexical scope becomes the nested
schema resource and both the root schema resource and the external schema
resource go out of scope:Finally, we go back to the root schema resource, enter the second branch of the
anyOf logic applicator, and follow the remote reference at /anyOf/1/$ref
(highlighted in red) into https://example.com/epoch. This external schema is
by definition a separate schema resource. Therefore, it becomes the new lexical
scope. This time, both the root schema resource and its nested schema resource
are out of scope:Dynamic ScopeTo recap, the lexical scope of a schema consists of its enclosing schema
resource. In comparison, the dynamic scope of a schema consists of the stack of
schema resources evaluated so far. Coming back to our analogy of a schema as a
graph, the dynamic scope corresponds to the ordered sequence of nodes that were
visited by the evaluation process.Consider the following sequence of examples. In the top left, a root schema
resource named https://example.com/person that declares two nested schema
resources: https://example.com/name (at /properties/name) and
https://example.com/age (at /properties/age). In the bottom left, an
example instance that successfully validates against the schema. Note that the
instance does not declare the age optional property. On the right, a directed
graph representation of the relationship between these schema resources.
Similar to how we did before, we gray out the parts of the schema and of the
directed graph that are not part of the dynamic scope.The evaluation process starts with the top level schema. The dynamic scope at
that point is the root schema resource, and the nested schema resources are out
of scope. So far the lexical and dynamic scope align:Because the instance defines a name property, we enter the properties
applicator into the subschema at /properties/name. This subschema introduces
a new schema resource. Therefore, the dynamic scope now consists of both the
root schema resource and the nested schema resource called
https://example.com/name, in order:In comparison to the lexical scope, the dynamic scope of a schema cannot always
be statically determined, as the evaluation path often depends on the instance.
For example, for schemas that make use of logic applicator keywords such as
if or oneOf, the ordered sequence of schema resources in scope may vary
depending on the characteristics of the instance.Following ReferencesSo far, we've learned that for the lexical scope, following a reference consists of
abandoning the lexical scope of the origin schema and entering the lexical
scope of the destination schema. In comparison, for the dynamic scope,
following a reference to another schema resource involves retaining the
current dynamic scope and pushing the destination schema resource to the top
of the stack.Within Schema ResourcesJust like with the lexical scope, if a reference points to a subschema within
the same schema resource, the dynamic scope remains the same. In other words,
if the destination schema resource is the same as the schema resource at the
top of the stack, the dynamic scope is not modified. Therefore, until the
evaluation process encounters a reference to another schema resource (either
local or remote), the lexical scope and the dynamic scope align:Across Schema ResourcesLeaving the simple case behind, lets consider an example consisting of local
and remote references across schema resources. In the top left, an example
instance and a root schema resource named https://example.com that declares
two nested schema resources: https://example.com/name (at /properties/name)
and https://example.com/person (at /$defs/person) where the former
references the latter (from /properties/name/$ref). Furthermore,
https://example.com/person references an anchored schema called item (from
/$defs/person/$ref) that is part of an external schema resource called
https://example.com/people shown in the bottom left. On the right, a directed
graph representation of the relationship between these schema resources and the
dynamic scope.Like the other examples so far, the evaluation process starts with the top
level schema. The dynamic scope at that point is the root schema resource, and
all other schema resources are out of scope:Because the instance defines a name property, we enter the properties
applicator into the subschema at /properties/name. This subschema introduces
a new schema resource. Therefore, the dynamic scope now consists of
https://example.com (the root schema resource) followed by
https://example.com/name (the nested schema resource at /properties/name):The https://example.com/name schema resource references the other nested
schema resource: https://example.com/person. After following this reference,
the dynamic scope now consists of https://example.com (the root schema
resource), followed by https://example.com/name (the nested schema resource
at /properties/name), followed by https://example.com/person (the nested
schema resource at /$defs/person):Now comes an interesting case. We are currently evaluating the nested schema
resource called https://example.com/person. This schema resource points to
the remote schema called https://example.com/people (the people part of the
people#item URI reference), but does not land at its root.  Instead, it lands
at the subschema in /items (where the item anchor from the people#item
URI reference is located). This subschema is part of the root schema resource,
so the dynamic scope now consists of https://example.com (the root schema
resource), followed by https://example.com/name (the nested schema resource
at /properties/name), followed by https://example.com/person (the nested
schema resource at /$defs/person), followed by https://example.com/people:The Dynamic Scope as a StackAt the beginning of this section, we said that the dynamic scope of a schema
consists of the stack of schema resources evaluated so far. However, our
examples so far only considered pushing schema resources to the top the of
stack.In traditional programming languages, program execution typically involves
procedures calling other procedures, creating what is referred to in Computer
Science as a call stack.
Eventually, a procedure will not call any other procedures. When such leaf
procedures finish executing, the call stack will
unwind (a pop operation)
and control will return to the caller frame.If you are having trouble understanding the previous paragraph, you might
enjoy watching Call Stacks - CS50
Shorts by Harvard University.
The JSON Schema dynamic scope works in the same way. At some point, a schema
resource will not reference any other schema resource. Then, the dynamic scope
will unwind, popping the last schema resource from the stack.Consider the following sequence of examples. In the top left, a root schema
resource named https://example.com/integer that makes use of the if,
then, and else logic applicators to check whether a positive integer is
even or odd and produce a corresponding title annotation. Note that each
subschema is a separate schema resource: https://example.com/check (at
/if), https://example.com/even (at /then), and https://example.com/odd
(at /else). In the bottom left, the even integer instance
42.
On the right, a directed graph representation of the relationship between these
schema resources and the dynamic scope.As usual, the evaluation process starts with the top level schema. The dynamic
scope at that point is the root schema resource, and all other schema resources
are out of scope:Next, we enter the if applicator that checks whether the integer instance is
even or odd. This subschema declares a new schema resource called
https://example.com/check, which is pushed onto the stack. Therefore the
dynamic scope consists of https://example.com/integer followed by
https://example.com/check:The https://example.com/check nested schema resource does not reference any
other schema resource. When the evaluation process completes and determines
that the instance is an even integer, the stack unwinds, the
https://example.com/check schema resource is popped, and the evaluation
process returns to the root schema resource. Therefore the dynamic scope is
back to just https://example.com/integer:Because the if subschema successfully validated the instance, we enter the
then applicator. This subschema declares a new schema resource called
https://example.com/even, which is pushed onto the stack. Therefore the
dynamic scope consists of https://example.com/integer followed by
https://example.com/even:Like before, the https://example.com/even nested schema resource does not
reference any other schema resource. Therefore, the evaluation process returns
once more to the root schema resource, the dynamic scope is back to just
https://example.com/integer, and the evaluation process completes:SummaryUnderstanding how static and dynamic scopes work is essential for gaining a
deeper understanding of JSON Schema. The most important points to remember are
summarized in the following table: Comparison Point                      Lexical Scope  Dynamic Scope  Definition                        Consists of the schema resource being evaluated  Consists of the stack of schema resources evaluated so far  Determining the scope             Can be statically determined without taking instances into account  Cannot always be statically determined. It may vary depending on the instance  Following references              Consists of abandoning the lexical scope of the origin schema and entering the lexical scope of the destination schema  Consists of pushing the destination schema resource to the top of the dynamic scope stack In a future post, we will build on top of the concepts introduced in this
article to demystify how dynamic referencing ($dynamicRef and
$dynamicAnchor) works.If you enjoyed this content and want to put your JSON Schema skills into
practice in the data industry, check out my O'Reilly book: Unifying Business,
Data, and Code: Designing Data Products using JSON
Schema.
You can also connect with me on
LinkedIn.
Image by Christina Morillo from Pexels.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubTuesday, February 6, 2024 · 4 min readTransforming the technical recruiting industry with JSON SchemaGo back to blogBenjamin Granados@benjagmYeray Darias@ydariason this pageChallengeSolutionImpactKey Impact ResultsManfred - The Company 
Manfred is a Spanish based technical recruiting platform allowing developers to manage their careers while keeping absolute control over their data. Manfred has been built by developers for developers, leading a paradigm shift in the technical recruiting industry. This case study showcases how Manfred harnessed the power of JSON Schema to redefine transparency, empower developers, and foster interoperability within the tech recruitment ecosystem.ChallengeManfred started their journey with the ambitious mission of revolutionizing the recruitment landscape by prioritizing total transparency and open data. Traditional recruiting platforms offered limited accessibility to personal data, often providing static, non-actionable PDFs. To establish a unique value proposition, Manfred sought a solution that would empower developers to own their data in a universally understood format—JSON."While other recruiting platforms rely on capturing your data and then giving it back using inefficient formats like PDF, our approach was completely different. Your data is yours and in JSON, the most used format in the industry." - David Bonilla - Founder
SolutionRecognizing the need for a dynamic and developer-friendly approach, Manfred turned to JSON Schema as the cornerstone of their platform by creating the MAC, a standard open source format to define and share resumes. By offering developers their data in JSON format and providing the JSON Schema (the MAC) as the map to use it, Manfred transformed the way professionals interacted with their own information. This innovative approach not only differentiated Manfred from competitors but also provided actionable, structured data, fostering a new level of transparency in the recruitment process."After trying different formats, we realized that by using JSON jointly with JSON Schema we would have the flexibility to be able to do anything." - David Bonilla - Founder
ImpactThe adoption of JSON Schema had a profound impact on Manfred's operations, contributing to transparency, flexibility, and scalability. Unlike conventional platforms that provide static, non-machine-readable data, Manfred empowered developers to utilize their own data effectively. JSON Schema enabled:Transparency and Accessibility: Manfred's commitment to open data and JSON Schema allowed developers to access, understand, and navigate their professional data seamlessly. This transparency became a cornerstone of trust between Manfred and its user community.Community Engagement: Manfred's usage of JSON Schema resonated with the developer community, strengthening its position as a developer-centric platform.Competitive Advantage: The unique value proposition of providing actionable data in JSON format set Manfred apart in a competitive industry. Developers could now harness the power of their own data, making informed decisions about their careers.Flexibility and Scalability: JSON Schema provided the necessary flexibility to adapt to evolving business needs and accommodate the rapid growth of Manfred's user base.Key Impact ResultsThe adoption of JSON Schema enabled third parties to integrate with Manfred easier and faster. Validation and documentation became trivial, for Manfred and their partners.“Using JSON Schema proved to be a key decision to provide the platform with the flexibility and scalability to support the Company's growth.” - David Bonilla - Founder
Manfred - The CompanyIn their own words:“Manfred is a recruiting company. Well, to be fair, it's a company that was born to change recruiting, helping the community with more structured, transparent processes and a focus on people.We help people achieve their professional goals by connecting individuals and companies that share objectives, values, and interests. We search, interview, advise, and present tech profiles to companies. But our mission goes beyond that: we seek to assist them throughout their career journey. We are there, regardless of the stage you're in—whether you're actively looking for a job or not, whether you need advice or are unsure about how to refocus.Our priority has always been people. We aim to give back to all the developers what they have not given to us. We belong to a very open and collaborative community, but it has a problem: talent acquisition and talent management. 
We don't move boxes, we don't move resources. We move help people.”Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, February 5, 2024 · 5 min readTransformando la industria de la contratación técnica con JSON SchemaGo back to blogBenjamin Granados@benjagmYeray Darias@ydariason this pageRetoSolutionImpactoResultados claveSobre ManfredManfred es una plataforma de gestión de talento tecnológico con sede en España que permite a sus usuarios gestionar sus carreras profesionales manteniendo un control absoluto sobre sus datos. Manfred ha sido creada por desarrolladores para desarrolladores, liderando un cambio de paradigma en la industria de contratación técnica. Este case study muestra cómo Manfred utilizó JSON Schema para potenciar la transparencia, empoderar a los desarrolladores y fomentar la interoperabilidad dentro del ecosistema de reclutamiento tecnológico.RetoManfred inició su andadura con la ambiciosa misión de revolucionar el panorama de reclutamiento y para ello decidió apostar por la transparencia total y una estrategia Open Data. Las plataformas de reclutamiento tradicionales se han caracterizado por ofrecer un acceso limitado a los datos personales, a menudo proporcionando archivos poco accionables como PDFs. Manfred apostó por ofrecer una propuesta de valor única ofreciendo una solución que empoderara a los desarrolladores para poseer sus datos en el formato de intercambio universal: JSON."Mientras que otras plataformas de recruiting se basan en la captura de tus datos para luego entregarlos en formatos poco interoperables como PDF, nuestra propuesta fue completamente diferente. Tus datos son tuyos y en JSON, el estándar de facto." - David Bonilla - Founder
SolutionReconociendo la necesidad de un enfoque developer-friendly, Manfred apostó por JSON Schema como la piedra angular de su plataforma al crear el MAC, un formato estándar y open source para definir y compartir currículums. Al ofrecer a los desarrolladores sus datos en formato JSON ofreciendo además el JSON Schema (el MAC) como el mapa para usarlo, Manfred transformó la forma en que los profesionales interactuaban con su propia información. Este enfoque innovador no sólo permitió a Manfred diferenciarse de sus competidores, sino que también propició un nuevo nivel de transparencia en los procesos de contratación al ofrecer un enfoque basado en datos estructurados y accionables con enormes capacidades de interoperabilidad."Tras probar diferentes formatos, descubrimos que usando JSON junto a JSON Schema tendríamos la flexibilidad de poder hacer prácticamente cualquier cosa." - David Bonilla - Founder
ImpactoLa adopción de JSON Schema tuvo un impacto profundo en la estrategia de Manfred, contribuyendo a la transparencia, flexibilidad y escalabilidad de la plataforma. A diferencia de las plataformas convencionales que proporcionan datos estáticos y poco accionables, Manfred empoderó a los desarrolladores para utilizar sus propios datos de manera efectiva. La adopción de JSON Schema afectó muy positivamente en distintas áreas:Transparencia y Accesibilidad: El compromiso de Manfred con los datos abiertos sumado al uso de JSON Schema permitió a los desarrolladores acceder, comprender y navegar sus datos profesionales de una manera fácil e intuitiva. Esta transparencia se convirtió en un factor clave de la confianza entre Manfred y la comunidad.Comunidad: El uso de JSON Schema por parte de Manfred fue percibido positivamente por la comunidad de desarrolladores, fortaleciendo su posición como una plataforma que pone a los desarrolladores en el centro.Ventaja competitiva: La propuesta de valor única de proporcionar datos accionables en formato JSON diferenció a Manfred en una industria muy competitiva. Los desarrolladores ahora podían aprovechar el poder de sus propios datos, tomando mejores decisiones sobre sus carreras.Flexibilidad y Escalabilidad: JSON Schema proporcionó la flexibilidad necesaria para adaptarse a las necesidades de una industria cambiante y facilitando un crecimiento más rápido de la base de usuarios.Resultados claveLa adopción de JSON Schema permitió que partners y 3rd parties se integraran con la plataforma de manera más fácil y rápida. La validación e intercambio de información entre Manfred y sus partners se convirtió en un proceso trivial.“Usar JSON Schema demostró ser una decisión clave para que la plataforma fuera lo suficientemente flexible y escalable como para soportar al crecimiento de la Empresa.” - David Bonilla - Founder
Sobre ManfredEn sus propias palabras:“Manfred es una empresa de reclutamiento. Bueno, para ser justos, es una empresa que nació para cambiar el reclutamiento, ayudando a la comunidad con procesos más estructurados y transparentes y un enfoque basado en las personas.Ayudamos a las personas a alcanzar sus metas profesionales conectando individuos y empresas que comparten objetivos, valores e intereses. Buscamos, entrevistamos, asesoramos y presentamos perfiles tecnológicos a empresas. Pero nuestra misión va más allá: buscamos ayudarlos a lo largo de su trayectoria profesional. Estamos allí, independientemente de la etapa en la que te encuentres, ya sea que estés buscando activamente un trabajo o no, ya sea que necesites consejos o no estés seguro de cómo reorientar tu carrera.Nuestra prioridad siempre han sido las personas. Nuestro objetivo es devolver a todos los desarrolladores lo que no nos han dado. Formamos parte de una comunidad abierta y colaborativa, pero tiene un problema: la adquisición y gestión de talento.No movemos cajas, no movemos recursos. MovemosAyudamos a las personas.”Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, December 18, 2023 · 4 min readAPI Days Paris 2023 - RecapGo back to blogBenjamin Granados@benjagmon this pageAbout API Days ParisConnecting with JSON Schema and API practitionersMeaningful conversations with organizationsLearning from the AsyncAPI and the OpenAPI conference tracksWe hope to see you next year!Last month, we had the privilege of partnering with AsyncAPI and OpenAPI with the first API Specs and Standards booth at the API Days Paris Conference. This resulted in a fantastic experience where attendees could easily connect with experts in one booth. We had the opportunity to learn from the experience of OpenAPI and AsyncAPI conference tracks.This is our first time having a booth at a conference, but we are sure it won't be the last. We returned energized for the great conversations, inspired by the great work of the other standards, excited with the great content, and impressed by the great work done by the API Days Team.About API Days ParisApidays is the leading business and technology conference series in APIs, and the programmable economy and Paris edition is the biggest event of the series.The Conference ThemeIn today's intricate digital landscape, APIs have emerged as powerful conduits for innovation, bridging the gaps and unlocking new realms of possibility. This year, API Days Paris revolves around four strong pillars: "Software, Sovereignty, Society, and Sustainability."Software: Software & APIs are the pulsing heart of the digital revolution, from the frameworks that power global platforms to the microservices optimizing niche solutions, Serveless, Kubernetes, Kafka, and many other technologies.Sovereignty: How should sovereignty be defined in the age of the cloud, decentralization, and ubiquitous connectivity, all while empowering individuals and organizations to chart their distinct digital paths?Society: Let's understand the societal implications of rapid technological advances to ensure that we leave no member of society behind, fostering an equitable and harmonious future.Sustainability: Let's explore the sustainable development, deployment, and management of software solutions to grasp the importance of eco-friendly digital infrastructures, ethical AI, and the long-term impact of our digital choices.Connecting with JSON Schema and API practitionersIt has been great having the chance to connect with JSON Schema practitioners in person. We received lots of feedback, we discussed about challenges and use cases and we created great connections with amazing people.Meaningful conversations with organizationsIt has been great having the chance to connect with JSON Schema practitioners in person. We received lots of feedback, discussed challenges and use cases, and created great connections with amazing people.At JSON Schema, we are looking to connect with stakeholders from Organizations invested in JSON Schema and its ecosystem, and this event was perfect for it. We want Organizations to be more directly part of our community and be involved in driving our roadmap.
We have an ambitious mission, but we need help. We are looking for sponsors!. We recently updated our sponsorship packages, increasing the benefits for every sponsorship package, but this is not only about getting funds; we'd love to explore other types of collaborations like "people-resource".If you are reading this, your Organization is using JSON Schema, and you like to get involved, let's talk!Learning from the AsyncAPI and the OpenAPI conference tracksAt JSON Schema, we have been discussing organizing a JSON Schema conference, but doing it alone will require a lot of resources and some years to get its own status. Instead, we returned inspired by great OpenAPI and AsyncAPI tracks, which we think is our path forward! We'd love to host our own track in the future!We hope to see you next year!We'd like to thank AsyncAPI, OpenAPI, and most importantly, the API Days Team for their generosity in having us in the Conference, and we hope to repeat this in the future!In the meantime, you can connect with us in our Slack workspace, the best place to ask questions, learn, get help, or discuss all things JSON Schema.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, November 8, 2023 · 7 min readInterpreting JSON Schema OutputGo back to blogGreg Dennison this pageNo Problem




More Complexity



Output Includes Why
A Note About Format

Wrap-upI've received a lot of questions (and purported bugs) and had quite a few discussions over the past few years regarding JSON Schema output, and by far the most common is, "Why does my passing validation contain errors?"Let's dig in.The last time we talked about output, it was to announce changes from the 2019-09/2020-12 version.  I'm going to use the new formats because it's easier to read and more compact.No ProblemBefore we get into where the output may be confusing, let's have a review of a happy path, where eitherall of the child nodes are valid, so the overall validation is valid, orone or more of the child nodes is invalid, so the overall validation is invalid.These cases are pretty easy to understand, so it serves as a good place to start. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.org/blog/interpreting-output/example1",  "type": "object",  "properties": {    "foo": { "type": "boolean" },    "bar": { "type": "integer" }  },  "required": [ "foo" ]}﻿
This is a pretty basic schema, where this is a passing instance:data{ "foo": true, "bar": 1 }﻿
with the output:data{  "valid": true,  "evaluationPath": "",  "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#",  "instanceLocation": "",  "annotations": {    "properties": [      "foo",      "bar"    ]  },  "details": [    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#/properties/foo",      "instanceLocation": "/foo"    },    {      "valid": true,      "evaluationPath": "/properties/bar",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#/properties/bar",      "instanceLocation": "/bar"    }  ]}﻿
All of the subschema output nodes in /details are valid, and the root is valid, and everyone's happy.Similarly, this is a failing instance (because bar is a string):data{ "foo": true, "bar": "value" }﻿
with the output:data{  "valid": false,  "evaluationPath": "",  "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#",  "instanceLocation": "",  "details": [    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#/properties/foo",      "instanceLocation": "/foo"    },    {      "valid": false,      "evaluationPath": "/properties/bar",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#/properties/bar",      "instanceLocation": "/bar",      "errors": {        "type": "Value is \"string\" but should be \"integer\""      }    }  ]}﻿
The subschema output at /details/1 is invalid, and the root is invalid, and while we may be a bit less happy because it failed, we at least understand why.So is that always the case?  Can a subschema that passes validation have failed subschemas?  Absolutely!More ComplexityThere are limitless ways that we can create a schema and an instance that pass it while outputting a failed node.  Pretty much all of them have to do with keywords that present multiple options (anyOf or oneOf) or conditionals (if, then, and else).  These cases, specifically, have subschemas that are designed to fail while still producing a successful validation outcome.For this post, I'm going to focus on the conditional schema below, but the same ideas pertain to schemas that contain "multiple option" keywords. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.org/blog/interpreting-output/example2",  "type": "object",  "properties": {    "foo": { "type": "boolean" }  },  "required": ["foo"],  "if": {    "properties": {      "foo": { "const": true }    }  },  "then": { "required": ["bar"] },  "else": { "required": ["baz"] }}﻿
This schema says that if foo is true, we also need a bar property, otherwise we need a baz property.  Thus, both of the following are valid:data{ "foo": true, "bar": 1 }﻿
data{ "foo": false, "baz": 1 }﻿
When we look at the validation output for the first instance, we get output that resembles the happy path from the previous section: all of the output nodes have valid: true, and everything makes sense.However, looking at the validation output for the second instance (below), we notice that the output node for the /if subschema has valid: false.  But the overall validation passed.data{  "valid": true,  "evaluationPath": "",  "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#",  "instanceLocation": "",  "annotations": {    "properties": [      "foo"    ]  },  "details": [    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/properties/foo",      "instanceLocation": "/foo"    },    {      "valid": false,      "evaluationPath": "/if",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/if",      "instanceLocation": "",      "details": [        {          "valid": false,          "evaluationPath": "/if/properties/foo",          "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/if/properties/foo",          "instanceLocation": "/foo",          "errors": {            "const": "Expected \"true\""          }        }      ]    },    {      "valid": true,      "evaluationPath": "/else",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/else",      "instanceLocation": ""    }  ]}﻿
How can this be?Output Includes WhyOften more important than the simple result that an instance passed validation is why it passed validation, especially if it's not the expected outcome.  In order to support this, it's necessary to include all relevant output nodes.If we exclude the failed output nodes from the result,data{  "valid": true,  "evaluationPath": "",  "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#",  "instanceLocation": "",  "annotations": {    "properties": [      "foo"    ]  },  "details": [    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/properties/foo",      "instanceLocation": "/foo"    },    {      "valid": true,      "evaluationPath": "/else",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/else",      "instanceLocation": ""    }  ]}﻿
we see that the /else subschema was evaluated, from which we can infer that the /if subschema MUST have failed.  However, we have no information as to why it failed because that subschema's output was omitted.  But looking back at the full output, it's clear that the /if subschema failed because it expected foo to be true.For this reason, the output must retain the nodes for all evaluated subschemas.It's also important to note that the specification states that the if keyword doesn't directly affect the overall validation result.A Note About FormatBefore we finish up, there is one other aspect of reading output that can be important: format.  All of the above examples use the Hierarchical format (formerly Verbose).  However, depending on your needs and preferences, you may want to use the List format (formerly Basic).Here's the output from the simple schema in List format:data{  "valid": false,  "details": [    {      "valid": false,      "evaluationPath": "",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#",      "instanceLocation": ""    },    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#/properties/foo",      "instanceLocation": "/foo"    },    {      "valid": false,      "evaluationPath": "/properties/bar",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example1#/properties/bar",      "instanceLocation": "/bar",      "errors": {        "type": "Value is \"string\" but should be \"integer\""      }    }  ]}﻿
This is easy to read and process because all of the output nodes are on a single level.  To find errors, you just need to scan the nodes in /details for any that contain errors.Here's the output from the conditional schema in List format:data{  "valid": true,  "details": [    {      "valid": true,      "evaluationPath": "",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#",      "instanceLocation": "",      "annotations": {        "properties": [          "foo"        ]      }    },    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/properties/foo",      "instanceLocation": "/foo"    },    {      "valid": false,      "evaluationPath": "/if",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/if",      "instanceLocation": ""    },    {      "valid": true,      "evaluationPath": "/else",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/else",      "instanceLocation": ""    },    {      "valid": false,      "evaluationPath": "/if/properties/foo",      "schemaLocation": "https://json-schema.org/blog/interpreting-output/example2#/if/properties/foo",      "instanceLocation": "/foo",      "errors": {        "const": "Expected \"true\""      }    }  ]}﻿
Here, it becomes obvious that we can't just scan for errors because we have to consider where those errors are coming from.  The error in the last output node only pertains to the /if subschema, which (as mentioned before) doesn't affect the validation result.Wrap-upJSON Schema output gives you all of the information that you need in order to know what the validation result is and how an evaluator came to that result.  Knowing how to read it, though, takes understanding of why all the pieces are there.If you have any questions, feel free to ask on our Slack workspace (link in the footer) or open a discussion.All output was generated using my online evaluator https://json-everything.net/json-schema.Cover image by Tim Gouw on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubTuesday, November 7, 2023 · 2 min readIntroducing the JSON Schema AdoptersGo back to blogBenjamin Granados@benjagmon this pageWhat is the Adopters list?We need you!Ready to join?Join the JSON Schema CommunityData consistency and interoperability are critical for success in today's interconnected reality. While JSON is undoubtedly the most popular format for exchanging data, JSON Schema is essential for ensuring data consistency, validity, and interoperability at scale. Despite the widespread adoption of JSON Schema, there has yet to be a comprehensive list of adopters where individuals and organizations can seek inspiration and real-world use cases. This is why we are thrilled to announce the launch of the Adopters list.What is the Adopters list?The Adopters list is a directory that features organizations that have successfully implemented JSON Schema. It's your go-to place to discover how industry leaders use JSON Schema.When you explore the Adopters list, you'll uncover how organizations use JSON Schema in Production. It's a valuable resource for inspiration and learning. Whether you are seeking insights to enhance your projects or to remain informed about the latest trends in the JSON Schema Ecosystem, the Adopters list provides a window into the best practices within the community.We need you!Adding your organization to the JSON Schema Adopters list demonstrates your commitment to supporting the JSON Schema Ecosystem and encouraging others to do the same. Additionally, adding your organization to this list provides valuable feedback to the JSON Schema team, helping them to improve the project's adoption and impact.By joining the list, you play an active role in the growth and sustainability of the JSON Schema Ecosystem.
It's a small contribution to the project with a big impact to encourage and grow JSON Schema adoption.This is the Open Source way: Learn from others and give back to the community! ❤️Ready to join?You can add your Company using this Adopter form or following these simple steps.Join the JSON Schema CommunityIf your organization uses JSON Schema, please consider contributing in other ways. You can report issues, suggest improvements, improve our documentation, become a sponsor, or even make code contributions.Join us and shape the future of JSON Schema!Photo by Patrick Tomasso on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, October 2, 2023 · 3 min readAnnouncing our new websiteGo back to blogBenjamin Granadoson this pageWe are so pleased to announce the launch of our new website!A little bit of historyA new storyWho made this possible?What is next?We are so pleased to announce the launch of our new website!We are excited to announce the launch of our newly designed JSON Schema website!We have created a modern design with improved site navigation and new information architecture to help you find exactly what you are looking for and better explain the benefits of JSON Schema and its incredible ecosystem.A little bit of historyThe JSON Schema story started in 2007 when Chris Zyp proposed JSON Schema as a schema language to validate JSON documents. Today, JSON Schema is one of the most used standards in the industry. During all this time, there have been different leading groups, specification releases, site versions, and, most importantly, hundreds of contributions by the JSON Schema Community. However, we have been receiving feedback about different ways to improve and refresh the site experience, and this is why the Community has been working so hard to release a new version of the website to help JSON Schema continue this amazing growth!The JSON Schema website back in 2016A new storyOur new landing page is a modern, single destination with all the resources necessary for the different types of personas visiting the website: JSON Schema users, JSON Schema tooling implementers, and other organizations.The information architecture will make it easier for everyone to find the resources they need and make it easier for the Community to maintain and evolve our docs as the project grows.Who made this possible?This has been a long journey led by the Community. We want to start by acknowledging all the people who contributed to the previous website versions because this wouldn't have been possible without them. THANKS!We'd like to recognize and thank everybody who worked on the new site release: Johannes Linowski, Paul Waller, Akanksha Kushwaha, Roni Lookwood and Melinda Gutermuth. Thanks for making this happen!What is next?This journey has just started, but now we still have much work to do, and we are actively looking for contributors!The short term focus of our future work is:Continue refining our docs. See this issue for more details.Build the JSON Schema landscape. See this issue to know more.Are you interested in getting involved?
Please join our Slack workspace and visit the #website channel.Cover photo by Ricardo Rocha on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, September 15, 2023 · 12 min read50+ million requests in 7 days on json-schema.orgGo back to blogBen Huttonon this pageWhat are we sharing here?Someone's accessing Hyper Schema?OK, so who's still accessing ?Who is accessing draft-04?Latest three JSON Schema versions?ASN, OSI, what?CountrySourceWhat does this all mean?I grant you, 7 days isn't an ideal length of time to do an analysis over, but this is what we have for now. Previously, we had basic website analytics, but that only tells a fraction of the story. We run the website on GitHub pages with Cloudflare in front, which provides 7 days of analytics, critically, including direct access traffic.The JSON Schema website hosts the official meta-schemas. If you're not sure what that means, meta-schemas are JSON Schemas for JSON Schema. Why is this interesting? Well, we host all historical versions of the meta-schema, not just the most recent. And while we don't expect code to be making requests on a regular basis to download the meta-schemas, the number of requests strongly suggests that they do.Why now? In addition to providing meta-schemas at versioned URLs, the web site has, and continues to, provide the latest meta-schema at /schema. We currently advise people not to be accessing this! We put in a delayed redirect with a message warning people to avoid it, but realistically, we expect most access will be via code and not in a browser. (This means things are likely broken. More on that later.)Maybe now we can remove hosting that URL? For reasons out of the scope of this article, using it really isn't a great idea, and will probably produce results you don't expect. As mentioned, web analytics won't tell us what's happening outside of a browser, so we needed something else… We were already using Cloudflare, so decided to submit for the open source free pro tier plan… while we wait, the cost isn't huge, so I decided we should look at the data now.The data in this article is a seven-day snapshot taken at 2023-07-21.
(At the end of the article, I'll share an image from this snapshot, and one from 2023-07-31 for comparison.)Caveat 1: Clients should not be making requests to meta-schemas as part of their production code. It may be appropriate as part of a CI/CD system, but this is also unlikely. Instead, clients should store a local cached copy. Any noticeable number of requests strongly suggests little or no caching.Caveat 2: The traffic analytics data is based on a sample of the total traffic. Each stat uses a different percentage. Anywhere from 0.16%, to 16.67%. I guess there's a lot of numbers to crunch and logs to keep to do a true analysis. You can ask for logs to be piped to a third party… but you need the enterprise plan. Regardless, the insights are still pretty interesting.Caveat 3: The "top" of each category of data is limited to 15 items in the UI. I think we could use their API to access additional data, but that's something I couldn't figure out in 5 minutes, so let's use what we have today.Oh yes, and we are limited to the last SEVEN days worth of data.What are we sharing here?It's best if we start with some splashy numbers, then go into what is exactly being accessed and why that's interesting, and finally just some interesting discoveries.The big numbers51.92 million requests211.47GB of data transfer1.05 million page views1.01 million visitsAll the meta-schemas!About 51 million of those requests are made from something that doesn't declare a browser, client, or bot name. We see Chrome and Firefox take the top spots, and lower down we see CURL and various indexing bots.In terms of what paths are accessed, and therefore what meta-schemas, I found the results interesting and insightful.The top result, at 11.82 million, is /draft-07/schema. This suggests that draft-07 JSON Schema is the most popular passed to misbehaving implementations. (Most well behaved implementations won't go download the meta-schemas, because they already have it! This includes the most popular implementations!)Web traffic snapshot 2023-07-21."Draft-04 doesn't appear till number 4 in the list. Ranks number 2 and 3 are taken by Draft 2019-09, but not as we might expect… the files there, links and hyper-schema are for Hyper Schema, as opposed to the primary validation use case of JSON Schema.Someone's accessing Hyper Schema?Remember, we previously published JSON Hyper Schema in addition to our core offering. Hyper Schema is a hypermedia specification. Specifically, in relation to APIs, Hypermedia as the engine of application state (HATEOAS). (For those interested, further reading: Richardson Maturity Model). We decided to pause JSON Hyper Schema, as we didn't have the resources to champion progressing the specification, around the same time as wrapping up draft 2020-12. (We can ascribe the difference between hyper-schema and links to the sample used. It's reasonable to assume both were accessed sequentially.)Where are these requests for Hyper Schema meta-schemas coming from? While the physical location is uninteresting, we can look at the user agent provided. The top two, which covers 7.5 million requests, doesn't really help… python-requests. At most, we can see that version 2.27 and 2.28 are roughly in equal use. After that, we jump down to 635k requests, from something identifying as neptune-client. Curiosity piqued!They call it an "Experiment tracking tool and model registry". This is to do with Machine Learning (ML) Ops (MLOps), built for data scientists and ML engineers. I know very little about ML, so I asked my colleague to share his take on the Neptune.ai service, who knows vastly more about this space…"Piece of software that, when you tweak something about a machine learning model, let's you run some calculations that tell you how your changes affect how good the model is" - Julian BermanWell, that's dumbed down enough for me! Thanks Julian!I guess we should reach out to them to find out about their use case for Hyper Schema!OK, so who's still accessing /schema?Accessing the latest meta-schema published using this unversioned URI is not advised. We started making people aware of this about four years ago, and you'll see a message with your redirection if using a browser.The vast majority of requests to this have no referring source, so that's not very helpful. Turning to user agent, we see the vast majority of requests have a user agent of "". sigh. Yup! blank! This is poor form, and I had a suspicion about what might be causing this.When you look at the adjacent data, seeing over half of the remaining top 15 user agents, it's pretty clear that most of these requests are coming from IDEs and code editors. We see InteliJ IDEA, WebStorm, and multiple versions of each. But, what we don't see is VSCode.Sure enough, VSCode, as far as we can tell, doesn't provide a user agent. At least, when making requests related to JSON Schema. While we love VSCode and the baked-in support for JSON Schema, there are a number of things we wish were a little better, and this is one of them.Visual Studio provides a user agent (and we'll get to that analysis later), but given Visual Studio Code does not, we can't differentiate between requests it is making, and any others which aren't providing a user agent. (We generally see a user agent is given.)It's important to note here that, due to the limitations of hosting the site on GitHub, the redirect used for /schema is an HTML based header redirect as opposed to using a HTTP 302 status code like you might expect. This means that realistically, it's unlikely any code making these requests is actually getting what they want. (The redirection technique is almost exclusivly followed by browsers, and not developer tools, such as CURL, as it is non-standard). Sure enough, if we try this in Visual Studio Code, we see an "Unable to parse content" error. It expects JSON in the response, but the website does not oblige.Who is accessing draft-04?The total number of requests to the draft-04 meta-schema is 7.21 million in the last 7 days.The physical locations showed one surprise, with Peru taking the lead over the UK and Russia. Next the USA with 5.73 million of those 7.21 million requests.This time, the user agent data is much more useful. We don't see the empty agent string till slot number 10, accounting for only 78k requests. At the top we see Java! I'm making an educated guess here, and saying this is related to the Java implementation by Francis Galiegue. They were one of the early core team members of JSON Schema, and created a Java implementation, which hasn't upgraded support since draft-04.From this, we can speculate that many Java services in production using JSON Schema, on AWS, don't have a reason to move away from obsolete implementations of JSON Schema. Maybe they are using a more modern version of JSON Schema itself, and the implementation is handling them incorrectly… but without testing, I'm just making educated guesses at this point.With Java taking the lions share, 4.11 million, we come next to Mojolicious (a Perl framework), followed by Visual Studio, with 526k. Now that's much more interesting. I also note here, that Visual Studio provides a much more helpful user agent string. Look:Visual Studio/17.6 (JSON Editor; ASP.NET and Web Tools/17.6.326.62524)If we account for multiple versions of Visual Studio, we are easily going over 1 million here. They take 8 of the top 15 spots. We already have some lines of communication open with people working on Visual Studio. The same cannot be said for Visual Studio Code. I'm hopeful we can correct that at some point.Latest three JSON Schema versions?Let's look at accessing paths with draft-07, 2019-09, and 2020-12.For draft-07, the path /draft-07/schema was accessed 11.66 million times. The next largest, at 1.8k, is the release notes… as in a HTML file on the website (oh, look, there's a website there too!).For 2019-09, we see 20.87 million requests. Why the jump? Both links and hyper-schema received over 8 million requests each. As mentioned previously, it's really hard to attribute those requests, but let's see what happens when we exclude them. Now we see 4.05 million… not bad! Although, we have to consider, with 2019-09 we broke up the meta-schema into multiple files, specifically the individual vocabularies. We see just above 500k requests for each of the vocabularies, with slightly more for the general purposes meta-schema, and core.The user agents for 2019-09, with hyper-schema URLs filtered out, are predominantly Java.What do we expect to see for 2020-12 then? I was curious too.We see 7.42 million, and none of those are related to Hyper Schema.Of that, 1.53 million to .../meta/core, and in the next place, the validation vocabulary meta-schema, with only 577.84k. If this is accurate, it's a little concerning. We would expect /draft/2020-12/schema to be the top path accessed, but it doesn't appear till position 8, with 472.46k.The traffic pattern is very spikey, with a repeating time based pattern. It's probably some cron job running. If we exclude the top IP address, we lose all the spikes, strongly suggesting this bursting traffic is coming from some Amazon controlled AWS servers.We'll reach out to AWS and see if we can get any more specific details. It's likely not a DoS attack, but it's a signal of something going wrong.ASN, OSI, what?The top two ASN sources are Amazon controlled, totalling just over 39 million requests.For those of you who aren't network engineers, ASN is an Autonomous System Number, used for routing of packets over the internet, making sure they take the likely fastest route. If you cast your mind back to when you learnt about the OSI model (yeah, I don't remember much of that either), AKA the Open Systems Interconnection model, these ASNs are used as part of the transport layer.Point is, we can tell without needing to look up IP address owners, that almost 80% of our traffic is coming from AWS!CountryGiven how much traffic is coming from AWS, it's not a surprise that about 43 million of those requests are coming from the US and Ireland. After those, Finland, India, and Netherlands make up the 1 mil club. Following on, Germany and Russia, and then several countries from Asia, all above 200k.SourceA staggering 51.12 million of those 51.92 million requests, are not declaring a reference. The following top three are json-schema.org, Google, and then, very interestingly, localhost!Weirdly, 1.54k requests declare a referrer of some defunct Uber settlement, just above Duck Duck Go.What does this all mean?Access of meta-schemas is unlikely to correlate with usage percentages, but it is at least an indicator of use to an extent.
Looking at this data has meant we are reaching out to AWS to see if we can get any details.
It has prompted us to reach out to IDE makers, although doing so was already on our list.
We have extended our known platform users. It's nice when people use a proper agent string.Given we only have access to a 7 day history, there's not much we can tell over a longer time.
While traditional analytics are useful, and we do use them, they can't tell us about accessing JSON files directly.While some of these numbers are interesting to see, I'm yet to be convinced that they provide much utility today.Here's the side by side traffic for paths from 2023-07-21 and 2023-07-31.Web traffic snapshot 2023-07-21.Web traffic snapshot 2023-07-31.Got any thoughts, comments, feedback on this article? Got any ideas why we are seeing this data? Have some ideas for futher research or analysis? Please, let's discuss this further: https://github.com/orgs/json-schema-org/discussions/480Photo by Isaac Smith on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, September 13, 2023 · 7 min readModelling Inheritance with JSON SchemaGo back to blogGreg Dennison this pageOur Models

Representing Our Models Using Constraints



Adding a Recursive Reference

Supporting Only Known Derivations


An Unexpected BenefitSo is Inheritance in JSON Schema Possible?
Probably the most common question that we get is, "How do I model an inheritance hierarchy in JSON Schema?"  And most commonly, our answer to that question is, "You don't."JSON Schema just isn't designed for that.  It's a subtractive system, where more constraints means fewer matches, and data modelling tends to be additive, where more definition means more matches.  The systems are inherently incompatible.However, if we accept a few concessions, we might just be able to work something out.Our ModelsTo get started, we're going to attempt to model some computer peripherals.  In a strongly typed language, we may model this using a Peripheral base class that defines a number of properties (and typically functions) that are common to all peripherals.  Then, each device would be a subclass of this base class.For our purposes, we're just going to define the name property on the base class.  That is, every peripheral needs to have a name.I'm going to use TypeScript for the code samples, but the concepts will apply to other languages as well.1abstract class Peripheral {
2  name: string;
3  // ...
4}
5
Now we can define other peripherals, Mouse and Keyboard, by inheriting from this base class.1class Mouse extends Peripheral {
2  buttonCount: number;
3  wheelCount: number;
4  trackingType: "ball" | "optical";
5  // ...
6}
7
8class Keyboard extends Peripheral {
9  keyCount: number;
10  mediaButtons: boolean;
11  // ...
12}
13
This will suffice to get us started.Representing Our Models Using ConstraintsIn JSON Schema, ideally, we'd want to have schemas for each of these.  For peripheral, we might try something like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:peripheral",  "type": "object",  "properties": {    "name": true  },  "required": [ "name" ],  "additionalProperties": false}﻿
I'm using a schema: URI for the schema identifiers since these schemas aren't accessible anywhere.  It's a recommendation that we're considering for the upcoming version of JSON Schema.  Let us know if you like this approach.But that additionalProperties keyword causes problems.  Specifically, "inherited" schemas (like what we're going to build for Mouse) can't define additional properties, which is something it definitely needs to do.  That just won't work at all, and the solution is simply to omit it. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:peripheral",  "type": "object",  "properties": {    "name": true  },  "required": [ "name" ]}﻿
But now, any JSON object with a name property is validated as a peripheral.  While not quite right, we can live with it.  This gives us our first concession:Schemas that model base classes cannot verify that an instance represents a derivation of that class.
Modelling the derivations is pretty straightforward: we model what the derivation defines and add a $ref back to the base schema.data{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:mouse",  "$ref": "schema:peripheral",  "type": "object",  "properties": {    "buttonCount": { "type": "integer" },    "wheelCount": { "type": "integer" },    "trackingType": { "enum": [ "ball", "optical" ] }  },  "required": [ "buttons", "wheels", "tracking" ],  "unevaluatedProperties": false}﻿{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:keyboard",  "$ref": "schema:peripheral",  "properties": {    "keys": { "type": "integer" },    "mediaButtons": { "type": "boolean" }  },  "required": [ "keys", "mediaButtons" ],  "unevaluatedProperties": false}﻿
For the derived schemas, we can use unevaluatedProperties because these don't have any schemas which derive from them.  If the inheritance hierarchy is bigger and these classes serve as bases for others, we'd have to leave the unevaluatedProperties off, just like we did for schema:peripheral.  Checking for extra properties can only be done for the leaves of the inheritance tree.Additionally, we use unevaluatedProperties instead of additionalProperties because we need it to be able to "see inside" of the $ref to identify that name was evaluated as part of the base schema.  With additionalProperties, name would be rejected.That seems pretty simple, and we only had to make a single (and rather easy) concession.Adding a Recursive ReferenceWhat if one of our peripherals could itself have other peripherals attached?  Say, a USB hub.1class UsbHub extends Peripheral {
2  connectedDevices: Peripheral[];
3  // ...
4}
5
Let's try to model that in a schema: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:usbhub",  "$ref": "schema:peripheral",  "properties": {    "connectedDevices": {      "type": "array",      "items": { "$ref": "schema:peripheral" }    }  },  "required": [ "connectedDevices" ],  "unevaluatedProperties": false}﻿
This works, but remember that first concession we made?  This schema would allow items that are anything with a string name property.  But that doesn't align with the TypeScript models.  The TypeScript model says that connectedDevices can only hold types that are derived from Peripheral.While this may be sufficient for some, in my opinion it doesn't work.  I want to ensure that the items in the connectedDevices array are only known peripheral types.  To do this, we need another schema.Supporting Only Known DerivationsProblem: we want a schema that identifies that some JSON represents one of our known device types.Solution: define the schema using a oneOf that references all of the known device type schemas. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:known-peripherals",  "oneOf": [    { "$ref": "schema:mouse" },    { "$ref": "schema:keyboard" },    { "$ref": "schema:usbhub" }  ]}﻿
This schema is pretty basic.  It just says, "If the JSON matches one of these devices, then it's a known peripheral."We can now reference this in schema:usbhub. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "schema:usbhub",  "$ref": "schema:peripheral",  "properties": {    "connectedDevices": {      "type": "array",      "items": { "$ref": "schema:known-peripherals" }    }  },  "required": [ "connectedDevices" ],  "unevaluatedProperties": false}﻿
Now the USB hub and its connected devices can be validated properly.The catch is that because I can't dynamically add items to the oneOf, I can only support devices I know about at dev time.  For most cases, this isn't a problem.  However, if I plan on publishing this in a package to be used by others, it wouldn't support devices that they create.  (I do have a workaround for this, but it's not a good one, so I won't be sharing it here.)  This gives us our second concession:If we need references to the base class, we can only support derivations we know about ahead of time.
An Unexpected BenefitTo determine whether some JSON is a Mouse or a Keyboard or a UsbHub, one might hold all three of those schemas and validate each one of them in turn to determine which one was received.  But our solution to the referencing problem actually gives us a better option.We know that schema:known-peripherals can validate any known peripheral (because we designed it to do that), but if we use a more verbose output format, it can actually tell us which kind of peripheral we got.First, we identify which oneOf subschema passed validation by looking through its child output nodes for a valid: true.  We know that's going to be a $ref schema (because it's a oneOf that contains only $ref schemas), which means that the child output node of that $ref schema will represent the output of the peripheral schema, which contains the peripheral schema's $id URI.So in a single validation pass, we get whether it's a supported peripheral of any kind, and we can discern what kind it is.  Two birds, one stone.So is Inheritance in JSON Schema Possible?No.And yes, if we're okay that:Schemas that model base classes cannot verify that an instance represents a derivation of that class.
If we need references to the base class, we can only support derivations we know about ahead of time.
I think these will be acceptable for most people, but I'm also sure that someone will inevitably run into a scenario where this approach won't work.This is the best I've seen so far at modelling inheritance, and I'm fairly certain that JSON Schema can't get it 100% right without some new functionality.If you have some other ideas about how to support polymorphism, or if you think polymorphism is overrated and JSON Schema doesn't need to support it, please join the conversation in our IDL Vocabulary repository.Cover image by Gerd Altmann on PixabayOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSaturday, September 9, 2023 · 5 min readHow JSON Schema Was an Obvious Choice at GitHubGo back to blogJulian Bermanon this pageChallengeSolutionImpactGitHub - The CompanyChallengeGitHub stands as a ubiquitous and invaluable tool for software developers and those in related fields, enabling efficient code management, seamless collaboration, automation, project management and more.
More than 100 million users rely on the platform, many of them making use of it daily for building and sharing open source software.There is a staggering amount of functionality packed into GitHub, assisting across all parts of the development lifecycle, and supporting this ever-growing list of functionality is an undoubtedly powerful and complex underlying platform developed within GitHub, as well as extensive documentation covering features new and old.Documentation at GitHub is housed at docs.github.com, itself a massive undertaking, covering pages upon pages of functionality within the platform.
Historically, this documentation was split into two statically generated sites (help.github.com and developer.github.com), but in 2020 these static sites were combined in a new dynamic application hosted at docs.github.com.
The full story of the rebirth of GitHub's documentation is told best on the GitHub blog here and here, but an important outcome of this change was a move towards data-driven documentation, and in particular a big investment in the use of JSON both to drive content as well as for intercommunication within the application's platform itself.More specifically, some page content is assembled fully automatically from JSON data files and some JSON is manually authored by content writers.
Within the platform, the application's entire queryable in-memory context is retrievable as JSON."Not being able to validate our JSON data against a JSON schema would result in bugs in production like missing data on automated documentation pages or unavailable pages", explain Rachael Sewell and Robert Sese, software engineers who work on GitHub's Docs Engineering team.Without proper schemas for their JSON data, there was no way to verify whether code changes introduced new bugs, or to ensure that data consumed from external sources was in the format needed for automated documentation pages.Hubbers (GitHub staff) working to empower developers.SolutionThe team began to introduce JSON Schemas to validate all of the JSON data files, context data and API request bodies consumed or produced as part of the application.
Each time a change to the data model is made, the schemas are updated accordingly, and in any circumstance the schemas are used to validate that the application functions correctly with each change.This occurs in three main ways:While the application runs in production, each API call has its request body validated via a corresponding JSON Schema before passing the event off to a data warehouseWhen retrieving external data in automation pipelines, whenever data is transformed from a source format into JSON, the generated data is validated against a JSON Schema to ensure it has been correctly transformed.
If validation succeeds, the generated data is checked into a git repository to be used in production.
Otherwise, the failure is raised for investigation.When running continuous integration each time a change is made to the application, various additional schemas ensure:that YAML frontmatter properties are correctly included in Markdown files which are used to generate pages within the applicationthat YAML or JSON data files which contain page content and which have been hand authored by content writers are correctly formedthat the context object created at runtime which contains the entirety of the site content along with a site tree for the application is itself correctly formed"Choosing JSON schema to allow JSON schema validation was a natural and obvious choice that our team made. It has been a fundamental part of our application since we moved from having a static site to a dynamic application about 3 years ago." - Rachael Sewell & Robert Sese, Docs Engineers at GitHubImpactIntroducing JSON Schema into the platform produced meaningful impact in productivity, in discoverability, as well as in reliability."JSON schema makes it so much easier to see the shape of a data and its property types. I can quickly open the file on disk and understand what the data structure looks like. This saves the whole team time when extending a feature that relies on data backed by a schema." - Rachael Sewell & Robert Sese, Docs Engineers at GitHubThe GitHub team moves quickly, with the documentation team releasing to production 20 times per day or more, and relying heavily on continuous integration checking each and every commit to ensure changes work as intended.
Failures in continuous integration alert the team before the change is shipped out to production, with JSON Schema validation an integral piece of ensuring all of the various pieces of JSON data needed for the application are properly formed.GitHub Offices.GitHub - The CompanyGitHub is the world's largest developer platform, helping developers and organizations around the world to build, scale and deliver secure software.It is based in San Francisco, CA, though its hiring and work culture is remote-first.Particular to the subject at hand, within GitHub is an internal organization called Education, Community, and Open Source Software, which houses the Docs team responsible for the documentation application.
This Docs team consists of content writers, content designers, docs product managers, and docs designers and docs engineers.Thank you to Rachael Sewell and Robert Sese, Software Engineers at GitHub's Docs Engineering team who maintain the wonderful docs.github.com, as well as to the entire team at GitHub, for sharing their experiences and allowing us to further share them with you.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, August 2, 2023 · 8 min readStatic Analysis of JSON SchemaGo back to blogGreg Dennison this pageWhat are constraints?
Keywords that have dependencies

Unknown instance locationsStatic referencesDynamic referencesSummaryWhen I first implemented JSON Schema, I took an approach that was probably typical for a C# developer: a blend of object-oriented and procedural programming.  However, over the past year or so, I've had an idea that I just haven't been able to escape.A schema defines constraints on values in well-known locations inside the instance.  What if I could capture those constraints somehow and model a schema that way?  Then I would only have to do that work once, and when I finally received an instance, I would only have to evaluate each individual constraint.I tried this several times.  Four, I think.  Each time, I got closer to getting it working, but I would always hit a roadblock that whatever design I had come up with just couldn't overcome.But over the past couple weeks, I got it!  (And the performance boost was substantial!)In this post, I'd like to share some of the more abstract JSON Schema analysis things that I've learned during this process.  This one's for the implementers!What are constraints?Constraints are the building blocks of JSON Schema.  They're individual requirements that apply to specific locations within JSON data.In this schemadata{  "type": "object",  "properties": {    "foo": { "type": "string" },    "bar": { "type": "number" }  }}﻿
we have three constraints:The root instance must be an object.If there is a foo property, its value must be a string.If there is a bar property, its value must be a number.Each constraint identifies:where in the schema we are, the "schema location"how we got there, the "evaluation path"the instance locationa specific requirement by one keywordNote that none of this actually requires an instance, and we should be able to precalculate a lot of this.This seems pretty easy to set up.  We can model each of these constraints, and when we get an instance, we test each constraint.  If they all pass, then the validation passes.Simple, right?  That's what I thought, too.  It gets complicated in multiple ways pretty quickly.Please note that I don't present these as problems that need to be overcome when implementing JSON Schema; they're simply mechanics that exist.Keywords that have dependenciesThe vast majority of keywords operate completely independently.  These are keywords like type and properties, as we saw above, as well as maximum, minItems, title, format, and a bunch of others.But there are a few keywords that depend on (or interact with) others in order to operate.  These are: Keyword  Dependencies  additionalProperties  propertiespatternProperties  contains  minContainsmaxContains  thenelse  if  items  prefixItems  unevaluatedItems*  prefixItemsitemsunevaluatedItems  unevaluatedProperties*  propertiespatternPropertiesadditionalPropertiesunevaluatedProperties * While most keywords can only find their dependencies among their siblings, the unevaluated* keywords also take dependencies on keywords inside subschemas of their siblings (that apply to the same instance location).The if/then/else keywords are a good example of keyword interaction.The procedural approach would use branching logic like1if ( ... )
2then {
3  ...
4} else {
5  ...
6}
7
We evaluate if, and the result of that determines whether we evaluate then or else.But if we think of these as constraints, then these three present a rather peculiar boolean logic:1valid = (if && then) || (!if && else)
2
Note how this differs from the notion that all individual constraints passing implies validation passing.  In this case, if if passes, then it doesn't matter whether else passes because it's just skipped; conversely, if if fails, then is skipped.While the interaction for if/then/else is pretty straightforward to precalculate, doing so for some other keywords, like additionalProperties, doesn't work.  For that, you have an additional complication.Unknown instance locationsAt the top, we defined a constraint as a requirement applied to a specific location.  However some keywords apply their subschemas more generally.  These keywords include: Keyword  Instance locations  patternProperties  any property that matches one of its regular expression keys  additionalPropertiesunevaluatedPropertiesunevaluatedItems  any object property not evaluated by one of its dependencies  contains  any item in an array  itemsunevaluatedItems  any array item not evaluated by one of its dependencies For all of these, you need the instance to determine what locations are available.  Only then can you complete the constraints.The strategy here is to build a "constraint template."  The idea is a constraint that has a requirement and some mechanism to determine where that requirement needs to be applied once the available locations are known.  So while we can't build a completed constraint, we can still get a little of the work out of the way.Static referencesStatic references, i.e. $ref, can be resolved ahead of time without an instance.  They always point to the same location within the same document, regardless of the instance.  Easy mode.  Sometimes.What if we have a recursive schema, like a schema that validates a linked list or a binary tree?  In these cases, the recursion stops when the instance no longer has any data that needs validating, i.e. when you read the end of the list or a leaf on the node.  To handle this, we can take the same "constraint template" approach as in the previous section.The template solution actually works for a lot of cases.  The real trick is figuring out when you need to use it.Dynamic referencesDynamic references, on the other hand, generally boil down to one thing: dynamic scope.  Dynamic scope is the ordered set of resource IDs (generally set by $id) that evaluation enters and leaves.  (Think of a stack, pushing when entering a resource, and popping when leaving.)  The dynamic scope is influenced by two things:where the evaluation startedinstance dataRoot schema dynamicsLast year I wrote a post describing how to use $dynamicRef to model generic types in languages.  The idea went like this:Start by defining a generic schema, using a $dynamicRef to a $dynamicAnchor to identify an undefined "type" parameter.Define multiple secondary schemas that reference the generic one and use their own $dynamicAnchor to define the "type" parameter: one for each type.Using this approach, if you start evaluation from the generic schema, evaluation will fail because the "type" isn't defined.  However, starting evaluation from a secondary schema redirects the $dynamicRef resolution to the one defined in the secondary schema.  This different resolution can allow an instance to pass validation.This is a great example of a dynamic reference that can be resolved without an instance present.  You only need the starting point of the evaluation.  Specifically, you need to know where the dynamic scope starts in order to identify the reference target.Data-driven dynamicsAnother way the dynamic scope can change is through some kind of conditional logic.  This test from the JSON Schema Test Suite is a good example.  It uses the same ideas from from the generics post, but instead of having separate schemas, everything is bundled up into one.For this case, depending on the value of the kindOfList instance property, the items in the array are expected to either be numbers or strings.  Mechanically, this is determined by a set of if/then/else keywords that directs evaluation into either of the numberList or stringList definitions, both of which define $dynamicAnchor: itemType and reference into the genericList definition which contains $dynamicRef: #itemType.When $dynamicRef is eventually hit, the evaluation had to either go through numberList or stringList.  This identifies which $dynamicAnchor is resolved.In this case, you can't fully define the constraint until you have the instance because, while you may know the instance location, you don't know the requirements that need to apply.I wasn't able to find a good strategy to isolate any kind of pre-work for this, and as a result, I still have to calculate all of this at evaluation time.SummaryThese were the primary gotchas that I found when trying to change my approach to schema evaluation.  JSON Schema static analysis has proven to be a pretty interesting area of study for me, and I hope that I've piqued your interest as well.If you'd like to find out more about how I ended up implementing all of this, I've got a summary on blog.json-everything.net.  It's a bit more functional now than procedural, but still very object-oriented.There's probably a lot more to explore here, too.  If you think of something, feel free to come find me in Slack.Cover image by Google DeepMind on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, July 17, 2023 · 6 min readHow Postman uses JSON SchemaGo back to blogJuan Cruz Viottion this page
JSON Schema in the Postman organizationJSON Schema in the Postman API PlatformPostman and JSON SchemaOriginally published at blog.postman.com.
Disclaimer: A number of members of the JSON Schema organization are employed by Postman, but this post is not sponsored content.
The Postman API Platform offers a rich set of solutions for every step of the API lifecycle. Through the years, we have witnessed from the front row how JSON Schema entered the scene to become the industry standard for describing and annotating JSON documents. While many alternatives came and went, JSON Schema unquestionably proved to be the robust and extensible foundation behind the API specification movement. According to Postman's 2022 State of the API Report, an impressive 72% of respondents chose JSON Schema as their preferred API specification.With JSON Schema being so ingrained in how APIs are developed today, it is hard to find a place in the Postman organization or the Postman API Platform where JSON Schema is not involved in some way or another. And with the modern (and increasing) importance of API-first development, the use of API specifications plays a critical role in designing and sharing APIs. JSON Schema is currently the backbone of the most popular API specification technologies in the world, including OpenAPI, AsyncAPI, and RAML.JSON Schema in the Postman organizationHow Postman uses JSON Schema to build its own APIsPostman operates a complex distributed system consisting of many dozens of microservices powering the cloud tools that make the Postman API Platform. These microservices make use of JSON Schema to model their interfaces through standalone JSON Schema definitions or OpenAPI and AsyncAPI specifications. Many of these microservices also use JSON Schema under the hood to validate internal data structures and configuration files, and to perform end-to-end testing by either asserting on expected responses or auto-generating input data from JSON Schema definitions. Being a Node.js company, Postman have started efforts to analyze how they can rely on TypeScript annotations to automatically generate OpenAPI and AsyncAPI definitions from our codebases.Given the importance of API specifications for managing Postman's distributed systems, in 2021 a comprehensive internal research project was conducted to understand the diverse set of JSON Schema definitions introduced by microservices run within the internal Postman platform. The corresponding JSON Schema definitions were analyzed based on characteristics such as reusability, degree of similarity, uniqueness ratio, and type of content. To promote reusability and discoverability, Postman is exploring the idea of a new microservice that acts as a central JSON Schema catalog API.For analysis purposes, Postman periodically extracts data from every SQL-based database powering the Postman API Platform. To accommodate for schema changes in our services, Postman automatically converts SQL table definitions into JSON Schema definitions, and rows into JSON documents, before aggregating them into Postman's internal data warehouse. Some initial experiments have been conducted to explore generating SQL table definitions out of JSON Schema documents, making the latter the source of truth.Use cases of JSON Schema beyond APIsThe use of JSON Schema within the Postman organization is not restricted to its backend services. For example, the popular Postman Collection JSON-based data format is formally defined using JSON Schema. Postman's Newman command-line Collection Runner makes use of JSON Schema to validate the expected output of custom reporters. Postman's in-house cross-platform desktop framework makes use of JSON Schema to validate and annotate profile definitions that declare the various variants of the desktop application (Stable, Canary, etc). Postman also maintains internal C4 diagrams of the Postman architecture defined using JSON and validated using JSON Schema.In early 2022, Postman released support for gRPC and Protocol Buffers. Internally, Postman is able to transform Protocol Buffers schema definitions into JSON Schema definitions and back again. The JSON Schema definitions corresponding to the Protocol Buffers schemas are used to provide type-hinting and auto-completion in the gRPC payload composer editor, to validate user input and to generate random data that matches a Protocol Buffers schema for testing purposes. This approach allows Postman to implement the aforementioned features on top of a single unified schema language: JSON Schema.JSON Schema in the Postman API PlatformJSON Schema is not only used internally to develop the various components of the Postman API Platform - many of the features offered by Postman directly involve the use of JSON Schema.JSON Schema in the context of Postman CollectionsThe Postman app can be used to convert a growing number of API specification formats into Postman Collections. As noted earlier in this post, the most popular API specification formats such as OpenAPI, Swagger, and RAML rely on JSON Schema. In many cases, the API specification conversion logic requires generating random JSON documents that match a JSON Schema definition.When defining a Postman Collection, users may define JavaScript-based test and pre-request scripts that are executed automatically when running the corresponding collection. The JavaScript engine embedded within Postman to run these scripts integrates with the popular AJV JSON Schema validator. With it, Postman users write scripts that employ JSON Schema validation using a wide range of JSON Schema specification versions.JSON Schema in the context of OpenAPIThe Postman app provides a rich OpenAPI editor with advanced JSON Schema capabilities. The editor is able to show autocompletion and syntax warnings, and it also highlights potential areas of improvements with regards to readability and security for JSON Schema and OpenAPI endpoint definitions. An OpenAPI definition is then used to generate rich documentation of the available endpoints and their respective JSON Schema definitions, and to optionally generate matching server code written in Go, Java, Python, and Node.js.An API defined using Postman is more than its API definition. It has surrounding elements such as documentation, tests, mock servers, and monitors. When writing an OpenAPI specification, Postman will cross-check the integrity of each of these elements against the JSON Schema definitions included in the API specification.The Postman API NetworkA key component of the Postman API Platform is the Postman API Network, the world's largest registry of public APIs. This global public registry includes a vast amount of APIs and their corresponding JSON Schema definitions typically maintained by their respective original authors. Some notable examples are the Slack Web API, the Docker HUB API, and the Twilio API. The Postman API Network is therefore one of the largest datasets of production-grade JSON Schema definitions.Postman and JSON SchemaWith JSON Schema being a crucial component of the Postman API Platform and the API ecosystem, Postman is honored to be supporting the JSON Schema organization as part of the OpenJS foundation by bringing aboard some of its passionate core contributors - Ben Hutton, Greg Dennis, Jason Desrosiers, and Julian Berman - as Postmanauts. We can't know everything about what the future might hold, but Postman is certain that the future of APIs involves JSON Schema.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, May 8, 2023 · 9 min readHow 6 River Systems saves time and boosts collaboration with JSON SchemaGo back to blogMelinda GutermuthBen Huttonon this page
ChallengesSolutionImpact
6 River Systems' Journey
With the help of AI and collaborative robots, 6 River Systems has become an industry leader in fulfillment operations. Companies in the United States, Canada, and Europe use their comprehensive solutions to optimize their shipping workflows and fulfill millions of units every week. Since they were founded in 2015, 6 River Systems has grown rapidly and experienced a handful of common hurdles that come with scaling a business. During this journey, they found that JSON Schema was able to help them through some of these challenges.
ChallengesLike many organizations that experience rapid growth, 6 River Systems has faced a series of organizational, technical, and evolutionary challenges as they've scaled. When 6 River Systems' number of warehouse clients increased by a factor of 10, the company itself had to grow as well. The operations, engineering, and analytics teams at 6 River Systems expanded significantly, and as a result, they realized they needed a better way to stay aligned and communicate expectations, contracts, and understandings—not only with one another, but also with the fulfillment system.6 River Systems uses a large amount of robotics and hardware, and many of those technologies don't always work well together. They struggled to integrate best-in-class data processing, storage, and analytics tools into their existing systems. For example, the robots in their facility use the Robot Operating System (ROS) framework, which stores messages, commands, and system status information. While tools like ROSbag make it easier to collect and analyze robot data, they aren't compatible with modern data stack tools like Elasticsearch and BigQuery. Additionally, the most widely used version of ROS depends on Python 2.7, which is deprecated.One inevitable byproduct of rapid growth is technical debt. 6 River Systems found early success, enough for Shopify to acquire them in 2019. Some of the solutions they implemented were short-sighted, and they knew that their next phase of growth would require them to focus on projects and practices that were sustainable in the long term.Automation robot "Chuck"SolutionBy expanding their use of JSON Schema, 6 River Systems was able to solve a number of organizational and technical problems. In fact, JSON Schema has become the nucleus for automation across the organization, which has helped them achieve more consistency and higher-quality results.To address their communication challenges, 6 River Systems' analysts started to directly collaborate with product engineers to draft new schemas. Using JSON Schema, the analysts can write a production-ready specification that the engineers understand immediately.6 River Systems has found JSON Schema to be extremely helpful for generating typed SDKs. When an analyst and an engineer finish iterating on a schema, they use the schema to generate TypeScript interfaces for use by robots and throughout the application. The strongly typed nature at the data generation point makes development much smoother and eliminates bugs before they reach production, which makes all the difference.6 River Systems also uses their schemas to automatically update destination databases, identify and isolate non-conforming data, and provide insight into the data that flows through the pipelines.Here's a look at some of the technical solutions they've implemented:Every time a new schema is released, a series of database reconciliation steps run to make sure everything is in sync. Database tables are created or migrated automatically, and schemas are pushed to registries.Data processing systems use JSON Schemas to continuously validate data. Any data that doesn't adhere to the schema specification is redirected to an "invalid events" table (also known as "dead-lettering"), and an alert is triggered. They track the volume of invalid events and notify stakeholders as needed.They use JSON Schemas to build event-level namespaces that are incorporated into all of their metrics and monitoring systems. They can identify the exact instrumentation and version of what's running through the pipes, and any issues are immediately visible on a graph.Tools for data discovery, such as data catalogs, are seeded with JSON Schemas, so the tools no longer have to manually scrape metadata.They're starting to use JSON Schemas to help automate the generation of sources in dbt, a popular warehouse analytics platform. As a result, an analytics engineer or data analyst no longer has to help write a new JSON Schema and then write the same thing all over again in YAML.ImpactAs a result of using JSON Schema, 6 River Systems has seen benefits across the organization. They've found that JSON Schema saves time across all layers of their tech stack. Some would say that structuring data at the point of generation slows things down, and there's some truth to that sentiment. But 6 River Systems has found that isn't the case when the team has TypeScript interfaces to point out incorrect data types and missing attributes in an IDE.JSON Schema is a tool that both a data analyst and a product engineer can understand. This enables two people who work with very different languages, such as TypeScript and SQL, to communicate directly with one another—a benefit that "cannot be understated," says Jacob Thomas, Data Platform team lead at 6 River Systems.JSON Schema has enabled 6 River Systems to implement automation across the stack. They've implemented TypeScript interfaces for instrumentation SDKs, used it to generate tables for data warehouses, and put it to use in streaming environments to generate Kafka topics and dbt sources. In a large fulfillment center, it's very difficult to track down data problems after code has been released, so using JSON Schema to validate code before it goes out saves time and brings peace of mind.As a company scales, having individuals chase things down through complicated infrastructure is not sustainable. Using JSON Schema as the shared language across the organization has improved the quality and visibility of data at all levels, which enables sustainable practices.Operator Command Center - "The Bridge"Key Impact ResultsThe biggest advantage 6 River Systems has seen from using JSON Schema is the time they have saved. For such a small team managing such a large amount of work, every minute counts! They want to automate everything that can be automated."We have processed hundreds of millions of events—each and every one of them is 'known good'. It's a model that works, and it works very well."6 River Systems discovered that by using JSON Schema, they could:Deploy known-good instrumentation to thousands of robots in the field.Enable effective collaboration between product engineers who think in TypeScript and JavaScript, data engineers who think in Python, and analysts who think in SQL.Validate every payload that reaches their data collection infrastructure.Proactively seed data discovery mechanisms and catalogs, as opposed to having the tools manually scrape metadata.As a result of using JSON Schema, they've been able to implement tools like Quicktype and TypeBox on the producer side and JSON Schema-based validators on the client side. With some logic to connect the two, their data warehouses stay up-to-date.
6 River Systems' Journey6 River Systems was founded in Waltham, Massachusetts, in 2015 and became a subsidiary of Shopify in 2019. Like many companies that grow quickly, 6 River Systems discovered that they needed to make some changes in order to sustain their early success. Let's take a look at how 6 River Systems went through the process of identifying the challenges they were facing and the different solutions they considered.
Identifying Pain PointsWhen 6 River Systems was starting out, they dealt with a lot of semi-structured data sent without context. There was no way of knowing what the data meant, how to structure it, or what was acceptable and what wasn't. They formed a team to analyze this data, but as the volume of data increased, scaling the team became unsustainable. On top of that, instrumentation would often change and sometimes be removed entirely, making it even harder to contextualize the data and causing customer-facing dashboards to break.All this was happening as new customers continued to come on board. Costs were increasing across the organization, and 6 River Systems knew that they needed to expand as fast as possible using sustainable, long-term solutions—all without blocking current development."We identified very quickly that we needed a solution for expressing expectations, contracts, and understanding—an IDL for both systems and humans within various teams."Finding a SolutionIn their search for solutions to maintain explicit contracts with their data, here are some of the options they considered:Protobuf: While Protobuf works very well, it's less common than JSON. Analysts tend not to know it, while JSON is something they work with every day. Because 6 River Systems' engineering and analytics teams work so closely together, they needed a solution that was equally understandable to both.Apache Avro: There's a lot to like about Avro, but it's heavily tied to the Kafka ecosystem, which 6 River Systems doesn't use.JSON Schema: Rather than completely rewriting the stack with new technology, using JSON Schema was an incremental solution that was easy to understand. JSON was already widely used by front-end engineers, it integrates well with the Node.js and TypeScript ecosystem, and it can be "bolted onto" existing code with little to no changes.Validating the SolutionUsing JSON and JSON Schema turned out to be the best solution at all levels of the stack. Instead of starting from scratch, they could use JSON Schema to enhance upstream processes while automating downstream ones. They were able to make each schema more strict than before and enforce more constraints around the data."The 'aha!' moment was when teams no longer needed to talk to us to push new instrumentation. The product team and analysts could talk to each other, and good data would show up in BigQuery."While 6 River Systems had previously used JSON Schema in a number of areas across the company, they now use it to power UI components, workflow and configuration management systems, and incoming and outgoing integrations to warehouse management systems. By implementing JSON Schema consistently across the organization, they are confident in their ability to keep growing and scaling while always maintaining the high-quality solutions they are known for.Thank you to Jacob Thomas and 6 River Systems for enabling us to share this case study with you.Images used with permission.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSaturday, May 6, 2023 · 8 min readUsing JSON Schema at Remote to scale forms and data validationsGo back to blogBen Huttonon this pageChallengeSolutionImpactKey Impact ResultsRemote - The Company
Further BenefitsChallengeForms. Legal forms, employment forms, salary forms, all the forms! Hiring from many different countries creates many different requirements, and Remote has to handle them all. Continually evolving laws and regulations in one country is enough to keep up with, let alone close to 100 countries!"Imagine wanting to hire someone in Argentina, Germany, and Nigeria. Those are all incredibly different countries with different laws and requirements, and we have to handle all of them." - Sandrina Pereira, Staff Frontend Engineer at Remote.com.One of the onboarding forms for Netherlands, among more than 500 unique forms to all the countries.When Remote first started,  the company only covered a handful of countries with a few specific forms per country. Scaling to hundreds of country forms with complex requirements is impressive. Did you even realize that the working hours and weekend days are different across countries and employment types? In some countries, the weekend is Friday and Saturday. And there are many other types of schedules besides the traditional 9 to 5. Getting that wrong for someone's salary payment could have huge implications.Managing and maintaining hardcoded forms in full HTML format (or even frontend components), wasn't going to be viable for the scaling Remote wanted."Our hardcoded solution was blocking us from scaling our business. Duplicated code, inconsistent server/client validations, huge JavaScript bundles…" explains Sandrina.Remote needed a way to configure forms on the server side to be used by the Remote API, including centralized validations that could be shared between the server and the client.SolutionJSON Schema was designed specifically for JSON data validation, but that hasn't stopped emergent use cases. While there are several form generation libraries that take JSON Schema as their input, Remote wanted to have total control, and needed the freedom to evolve the solution as required."All of that is now being solved with JSON Schemas," continued Sandrina. They worked on JSON Schema for forms and validation initially in their Development Foundations team, and later as part of the company's "Onboarding" vertical. Their onboarding process, which requires a lot of data, has to be the best experience possible to avoid incompletion, without compromising data safety or accuracy.Remote decided to create their own form generation tool, allowing them to layer on additional custom keywords in JSON Schema related to the presentation of form fields as needed. "After deep research with proof of concepts, taking into account the critical nature of forms in our core product, we decided to take a leap of faith… " The first version of this library has very recently been open-sourced, so you can try it today! Go check @remoteoss/json-schema-form!Diagram of how JSON Schema integrates with the server and client.Data doesn't just come via forms though, but also through APIs, which usually includes third parties. "We started this journey as part of the Remote API, a horizontal tool by itself. Gradually it will affect every area of Remote. Ultimately our vision is to have every form that talks to our API powered by a 'headless form' on top of JSON Schemas," Sandrina explains. Getting data boundaries right can be hard, but it pays to do the work. Having the validation on the server reusing it on the client, not only simplifies the development, but also reduces attack surface in terms of security.As with adding any new technology to your stack, you must critically evaluate if it will be viable long term, and how flexible it will be for any changes in your existing stack. Sandrina and her colleagues did their research…"Although JSON Schema is not an "official standard", seeing big players adopting and contributing to its maturity is a big point of trust for us. JSON Schema is in active development by its strong community, with a high adoption rate by many companies, including mature libraries in many languages, as the ones we use: JavaScript and Elixir.""When looking for a way to describe and validate JSON objects, there was no other solid alternative. JSON Schema was adopted with confidence." - Sandrina Pereira, Staff Frontend Engineer at Remote.com.ImpactUsing JSON Schema as the SSoT (Single Source of Truth) unlocked a lot of potential. "JSON Schemas were the first step to solving data validation and form generation problems across all levels at Remote," explains Sandrina.Once you start with JSON Schema, it's not uncommon to discover multiple uses. Remote creates JSON Schemas on the server and uses them to validate API payloads, run periodic validation reports (based on legal requirements), and auto-complete in code. Additionally, the client consumes these schemas to generate visual representations such as forms and tables.Armed with the SSoT, Remote sees reduced time to create and maintain forms, but also a measurable reduction in support tickets related to inconsistent data and incorrect validation. Most importantly for Remote, they also reduced the time to onboard new international employees and contractors. While other improvements were made at the same time as integrating JSON Schema, they were confident JSON Schema was pivotal.Key Impact ResultsAdapt and evolve at a large scale, providing services quicker, and onboarding from weeks to days. Here's a list of the biggest results so far:Shared validations between the server and clientReduced JS bundles and code duplication, replaced by API requestsReduced number of tickets reporting inconsistent validations.Conclude tickets much quickerCreate and maintain forms more easilyOpened the doors to allow the Internal Operations team to build the forms themselves"JSON Schemas are the connector to keep our data accurate on a large scale, speeding up many of our provided services to our customers. In some cases, the time taken to implement the forms for a new country was reduced from weeks to just a couple of days."Remote - The CompanyRemote makes it easy to onboard and pay your international employees and contractors. Remote is a global, fully distributed company in the Human Resources industry, with no physical offices. "Our employees are free to work from their chosen locations around the world!"Sandrina Pereira: "I'm a Staff Frontend Engineer working in the Onboarding vertical, and we are the ones who have the biggest and more dynamic forms that carry all the data needed to hire new people." Without question, a critical position to enable the value proposition Remote offers.With many companies having had to provide a means to work remotely where possible, why limit the talent pool to one geographical location?Remote wants to empower employees too: "Talent is everywhere, but opportunities aren't. Remote makes it possible for employers to hire anybody from anywhere, to present access to opportunities for anyone, to ultimately make better lives for themselves." These are not just words for Remote.In 2021, Remote launched their Refugee program, enabling employers to invest in a cost effective way, while also helping refugees rebuild their lives. Remote has also set up dedicated resources for displaced Ukrainians.Remote raised a $300 million Round C in 2022, at a validation of over $3 billion.
Further Benefits"JSON Schemas is bringing us data consistency (annotation) and data security (server validations)." - Sandrina Pereira, Staff Frontend Engineer at Remote.com.Having migrated some core parts of the business, Remote followed to create an interface allowing Operations teams to edit forms themselves, stored as JSON Schema to benefit from validation. Static JSON Schema files have served them well, but ultimately they needed to be able to react faster to change.Backoffice tool to build the Country Forms, powered by JSON Schema.Knowledge sharing has also benefited from JSON Schema, with Remote revamping their Knowledge Base. Country specific data such as supported VISA options and onboarding timelines, can be encoded into a data structure, which in turn can be validated both on the server and client side.Initially unsure how far JSON Schema could go, and despite Remote pushing the barrier of what JSON Schema can do, it has proven to have an important impact on Remote's ability to scale."JSON Schema has proven its value as part of our core tooling ecosystem to validate data and generate its visual representations, such as forms and tables, which are a fundamental piece to take our services to a large-scale without compromising accuracy, speed, and most importantly, customer happiness!" We are glad you've found value in JSON Schema Sandrina! Long may it continue.Thank you to Sandrina Pereira, Staff Frontend Engineer, and Remote.com, for allowing and enabling us to share this case study with you. Sandrina would also like to acknowledge and thank her colleagues who kicked-off this journey more than a year ago: André Albuquerque, António Capelo, António Silva, Livia Barbosa, and João Almeida.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, February 23, 2023 · 5 min readThe Last Breaking ChangeGo back to blogGreg Dennison this pageWhat are unknown keywords?
Why can't we still support this?What is being done to soften the blow?Will there be any other breaking changes in the next release?Sum upAs we continue to move toward a stable specification, we have been analyzing the various components, behaviors, and features of JSON Schema to determine what can be included, what may need modification, and what (if anything) needs to be removed or replaced.  The primary question that we had was whether there were any planned changes that would cause problems for users with existing schemas, i.e. breaking changes.To answer that, we needed user input.  So we posted across the internet in order to encourage users to participate in a particular conversation on GitHub around how we treat any supposed breaking changes for the upcoming release.  The response was very much, "If you can help it, please don't break things."  But many people also said they would be less bothered if there was a defined migration path and tooling to help.We also performed an internal survey of feature stability, involving all of the JSON Schema core team members.  We're pleased to report that the vast majority of Draft 2020-12 can be kept completely as-is.  There are a few keywords and behaviors that could use some tweaking, but mostly in ways that we feel are generally compatible with the current release.Another common sentiment among both users and team members was that JSON Schema already has a history (and reputation) of including breaking changes when releasing new versions of the specification, meaning that a schema that validates properly with one version may not validate properly with the next.  This perception is one that we need to address.  To do that, we need to orient ourselves and the specification so that we can promise schemas written to one version will validate consistently with every subsequent version.Unfortunately, in order to make that promise, there is one behavior that we absolutely must change in a breaking way: support for unknown keywords.What are unknown keywords?A keyword is "known" if it is defined by a vocabulary listed in the schema's meta-schema (identified by the value in $schema).  By recognizing this vocabulary and continuing to process the schema, an implementation declares that it understands how to process all of the keywords that vocabulary defines.  Any keyword which is not defined by a vocabulary listed in the schema's meta-schema is considered "unknown."All of the currently published versions of JSON Schema instruct implementations to (at a minimum) ignore keywords that are not recognized.  With the introduction of annotations in Draft 2019-09, implementations were given the option to collect the values of unknown keywords and report them to the user in the output.  This behavior was widely supported by the community because it meant that they could annotate and document their schemas without having to worry that their validations would be impacted.  For a schema like schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "object",  "properties": {    "firstName": {      "type": "string",      "database-field-id": 1234    }  }}﻿
a validator would either ignore database-field-id or include it and its value as an annotation in the output.  One can see how this feature would be extremely helpful.  However, this feature also blocks our ability to promise future compatibility.Why can't we still support this?Suppose a user wrote the example schema above while using a validator written to conform to the 2023 version of the specification.  A couple years later, they want to upgrade the validator now that supports the 2025 specification.  However in that 2025 specification, we added database-field-id as a keyword, and its value is expected to be a string.  Suddenly the user's schema is no longer valid.  We've broken a user by adding a new keyword.In order to prevent this scenario, we are forced to forbid keywords that are not declared by a listed vocabulary.  We recognize that this will break a lot of people up front.  However we feel that a promise of future-compatible specifications should take precedence over the immediate pain of having to change your schemas yet again (and potentially again perpetually into the future).What is being done to soften the blow?We have an open discussion on this very topic, and we invite you to weigh in.Current proposals include things from simple prefixes on unknown keywords as a convention to indicate custom annotations to more complex solutions like inlined and ad-hoc vocabularies bundled into the schema that can define annotation-only keywords, like title and readOnly.  These options are effectively ways for the schema author to say, "I know these keywords aren't declared by any vocabulary, but I'd really like them in my schema.  Please disregard them."Will there be any other breaking changes in the next release?Hopefully not.  We believe that removing support for unknown keywords will be the only change of any real negative impact, but that doesn't preclude the possibility of other changes that break things in less critical ways.We recognize that making breaking changes like this is hard on developers, both users and implementors, and so we're doing our best to measure the changes that are needed and seek alternatives to breaks where possible.  We don't see this as an opportunity to go wild with changes.In any case, we will be open and transparent about any changes that we make, breaking and otherwise.Sum upIt looks like we have to break some schemas with the next version.  However by doing so, we are able to promise that we won't in the future.We have to break it in order to fix it.Cover photo by Ken Suarez on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, February 22, 2023 · 7 min readCustom Annotations Will ContinueGo back to blogGreg Dennison this pageWhat's the solution?Why a prefix and not some other solution?How did we arrive at  as the prefix of choice?Too long; Read anywayLast time, I wrote about how we had to remove support for unknown keywords.  I ended that post with a note saying that we were still searching for a way that we can support non-functional custom keywords, that is, simple annotations.In this post, I'd like to review the solution and how we came to it, as well as a brief overview of some of the other solutions we dreamed up and were offered.  Buckle up, 'cause it's gonna be a mild ride!What's the solution?The tl;dr of it is that going forward, JSON Schema will treat any keyword that starts with x- as an annotation.This solution was chosen for several reasons.Ad-hoc keywords necessarily cannot have any functionality tied to them.  That is, they're only ever annotations; their values are just returned to the user or application without any processing by the schema.Having ad-hoc annotations follow a convention makes them very easy to identify.A prefix is a good convention to follow.Reserving this prefix for ad-hoc annotations means that there can be no collision with keywords defined by vocabularies, now or in the future (preserving our compatibility promise).Developers are generally familiar with the x- prefix as it's already commonly used in other arenas, such as HTTP headers, to denote custom data intended for recipients that understand it.The one hesitancy we had for using x- was that its origins denoted experimental behavior.  However, it seems that in practice, this prefix used quite liberally for any custom data.  Since we're making custom data our expressed purpose, it seems like a good fit.Why a prefix and not some other solution?After releasing the previous blog post and publicizing it as far across the internet as we could, we received feedback that custom keywords were used quite extensively and not supporting them would break users more severely than we wanted.  While we had already planned on still supporting annotative custom keywords, we didn't know what that would look like.  So, I started a discussion with some of the loose ideas that the team already had.There's a lot in that discussion and quite a few ideas, but I'll just go through some highlights here.  If you're interested in the details, feel free to read the discussion.Alternative #1 - Defining the prefix in a new keywordThis option actually builds on the one we selected by defining a new Core keyword (one that starts with $) that would contain the prefix used for that schema.  It's a fascinating concept that would allow schema authors to use the prefix they wanted.It was pointed out, however, that in order for a schema to be validated by the meta-schema, the meta-schema would need to be able to read this new keyword to get the prefix so that it could ignore the keywords that started with it.  This requires a whole lot of new mechanisms that we don't currently have in JSON Schema, so it's not very practical at this time.We also noted that we couldn't figure out what the scope of this keyword would be.  Would it be only the schema resource (indicated by $id) where the keyword was used?  Would it be the whole document?  What if we $ref to another schema resource or document that doesn't define a prefix?  There's a balance somewhere between inferring intent and requiring too much repetition.Alternative #2 - Listing the custom keywords to ignore in a new keywordThis option defines a new Core keyword such as $ignored that would hold an array of the names of keywords to ignore.  This would allow schema authors to explicitly define the keywords they wanted to use.Like alternative #1, this has the problem that JSON Schema doesn't currently have the mechanisms to perform the kind of meta-schema validation that would be required, as well as the same scoping issues.  It's also possible that a schema author could ignore a keyword that would later be added to the spec or some vocabulary, meaning that it shouldn't be ignored, resulting in surprisingly wrong validations and violates our compatibility requirements.Alternative #3 - Inlined vocabularies that define keywordsThis option allows for a vocabulary to be defined and described within a meta-schema's $vocabulary keyword.  This is like alternative #2, except that the ad-hoc keywords are defined by a vocabulary so the normal JSON Schema process that enforces "no unknown keywords" wouldn't pick them up; they would be known.We decided against this because it requires a lot of further development of vocabularies, a concept which is still under development anyway.  This solution would also skew that development toward solving this problem, which may not be the right direction for the vocabulary concept.Alternative #4 - A new keyword to contain all custom annotationsThis option creates a new Core keyword such as $extra that simply houses all of the custom keywords that a schema author may want to use.Undesirably, this creates a layer of separation between the annotations and the data they're trying to annotate.  But more importantly, a keyword can only create a single annotation (as it's defined now), and so a keyword like $extra would lump all of the annotations into a single large object rather than being more targeted like individual keywords would be.Alternative #5 - Support unknown keywords behind an optionFinally, this option just requires implementations to provide a configuration option to allow unknown keywords, defaulting to "disallow."  While allowing unknown keywords breaks our compatibility promises, a user explicitly setting this option is effectively acknowledging that risk.This felt like a step backwards.  It just didn't feel like it aligned with the spirit of supportability we want for this project.How did we arrive at x- as the prefix of choice?In the previous post, I linked to the discussion and invited everyone to support their preferred ideas or propose new ones.  We saw a lot more interaction than we have in the past, and that was great!Additionally, we posted about the discussion on social media and we even found several posts (e.g. on reddit) that others made linking back to the blog post or the discussion (or both) and discussing on that platform.Once we had determined that the prefix option looked like the favorite, Benjamin Granados, our Community Manager, created a survey that listed options for what that prefix could be.  It included the proposals we had in the discussion so far, x- and a handful of easily typeable symbols, as well as a "make your own" option.We had 53 respondents, which may not seem like much, but it's more than we've ever had.  The results clearly showed that x- (with 17 votes) was the preferred prefix.  Tying for second were the "at" symbol @ and the asterisk * with 12 votes each.Too long; Read anywayMoving forward, prefix your custom annotation keywords with x-.Another nice thing about this solution is that you don't have to wait for the next version of JSON Schema to come out.  You can start updating your schemas today.  x- keywords are compatible with all versions of JSON Schema that are currently published; they'll still just be collected as annotations.  And when the next version comes out, you'll already have migrated!Cover photo by Mick Haupt on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubTuesday, January 10, 2023 · 2 min readHello 2023, Hello JSON Schema CommunityGo back to blogBenjamin Granados@benjagmon this pageWho is this guy?But who is this guy for real?Like to know more about me?Let's do this!
Since Ben Hutton joined Postman to work full-time on JSON Schema the past year, other top contributors like Jason Desrosiers, Julian Berman, and Greg Dennis have joined, and now all are full-time supporting JSON Schema. So today, I am excited to announce that I am joining as Developer Advocate with a focus on serving the Community, nurturing relationships with other organizations, launching programs to support and grow the Community, and increasing awareness through content, public speaking, and discussions in X, Linkedin, Stackoverflow or Reddit.Who is this guy?My whole career, APIs have been at the core of everything. In the first part of my career, I focused on the engineering aspect of building APIs, playing all the possible team roles. Later, I focused on API Design and Governance, leading API Programs, and most recently, my focus has been Developer Experience and Developer Relations because this human aspect is the most critical for a technology or product to be successful.Having said that, I see myself as a mix of 1/3 Software Engineering 1/3 API Strategy 1/3 Developer Relations, but I am constantly learning and testing new things, and today I am investing in Product Strategy/Growth. With this diverse background, I hope to be a good complement to the current JSON Schema Team.But who is this guy for real?I am a father of two who loves to spend time with my family and friends. I love mountaineering and team sports, and I think nothing is impossible if you truly believe it. I love this sentence by Nelson Mandela "It always seems impossible until it's done".Like to know more about me?If you like to know more about me, check out this intro post I wrote when I joined Twilio.Let's do this!2023 will be a fantastic year for JSON Schema, and I am excited to be part of this journey with all of you! I can't wait to start connecting with you in the upcoming working meetings, in Slack, and Github.* Email: [email protected]Twitter: @benjagmLinkedin: benjagranadosGithub: benjagm
Cover photo by Jai Cano on Instagram.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, November 16, 2022 · 12 min readIntroducing: BowtieGo back to blogJulian Berman@JulianWasTakenon this page
What It IsWhy It Might Be InterestingHow Do I Run It?

How Does It Work?How to HelpConclusionThis is the first in what will hopefully be an intermittent series on Bowtie.
I speak here without speaking on behalf of the JSON Schema organization in any official capacity -- Bowtie isn't a tool we The JSON Schema Team are "blessing" in some way today, though I have personal hopes it becomes a sort of official tool, and have developed it intending it to be owned by "the community" in whatever sense that means.
For the moment, I speak only on behalf of myself as its author :)The JSON Schema schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "string",  "maxLength": 3}﻿
validates strings of length at most 3.
This behavior is what the specification says should happen.
Does every implementation of the specification, across the wide spectrum of programming languages, properly follow the specification?
What about for other more complicated schema / instance pairs?
This is the key question Bowtie tries to address -- how can we compare behavioral differences between JSON Schema implementations and between the specification, in the hopes that we make it easier to fix implementation issues and clarify any unclear portions of the specification?What It IsBowtie is what I'm calling a "meta-validator", by which I mean a program which can execute other JSON Schema validation implementations and collect results from them.There's prior art in doing this sort of thing.
The JSONPath Comparison project does this extremely well for JSONPath, and Nicolas Seriot's "Parsing JSON is a Minefield" is a fantastic example for JSON itself.
Bowtie attempts to bring these ideas to JSON Schema.From the existing list of JSON Schema implementations, Bowtie already supports 12 implementations across 9 programming languages, allowing anyone to run any of these implementations and see what they have to say about schemas and instances.It ships with a command line program but perhaps more excitingly, ongoing automated runs of this CLI have been set up, such that Bowtie emits a report across all of its supported implementations.To produce this report, Bowtie runs the official JSON Schema Test Suite, which is our existing set of tests meant to exercise compliance with the JSON Schema specifications.
Many implementations already use the suite within their own continuous integration, but this is the first time both users of JSON Schema as well as implementers can see results of running the suite in a single place, across many implementations.
The test suite already has great coverage of our specifications (specifically the validation portions of them).
The suite certainly isn't perfect, but Bowtie's results therefore cover the validation specification really well.Why It Might Be InterestingThe most noticeable thing Bowtie enables is an easy way to compare how close an implementation follows the specification.
This gives transparency to users of implementations, and also to the community about areas which might be hard to implement, or are commonly misimplemented.
Our hope is that this leads to improvement and energy to help fix issues, and overall to a stronger community!Even beyond the test suite, Bowtie is capable of providing a uniform interface to the implementations it supports, meaning you can quickly access results from each one without needing to learn the language-specific API each implementation offers.
If you have a schema and instance and want to run it across many implementations, or a single implementation which you're not already familiar with or don't have set up, Bowtie can help.How Do I Run It?If you're just interested in its output (i.e. reports on runs of the test suite), you can currently find them at the following links, corresponding to each version of the specification:draft2020-12draft2019-09draft7draft6draft4draft3The medium-term goal is to combine these onto one unified report (at which point the links may change, though hopefully we'll put a redirect in place).If you want to go beyond the test suite reports, you can run Bowtie locally as well, on whatever input you'd like.
Bowtie is written in Python and published on PyPI.
If you have no existing preferred setup for installing Python applications, install pipx using the platform-specific instructions for your OS, then run:1$ pipx install bowtie-json-schema
2
which should give you a working Bowtie, which you can check via:1$ bowtie --help
2
The usage instructions are in Bowtie's documentation, but more documentation is definitely needed, so do ping myself (Julian) if there are things you can't figure out, it will motivate documenting them.How Does It Work?I won't go into full details of Bowtie's implementation in this post, but at a high level, Bowtie is a command-line program written in Python which orchestrates spinning up and down OCI containers ("Docker containers" in a loose sense).
The containers it runs are "test harnesses" -- little bridge programs which take an implementation of JSON Schema, written in any programming language, and then allow incoming requests from Bowtie to call into the library under test.
Adding support for an implementation essentially means implementing a test harness in this fashion (which is generally simple to do), and once the harness is present, the implementation will light up in Bowtie's reports, and any user of Bowtie will be able to execute the implementation via Bowtie's uniform CLI.How to HelpThere are two areas you (a user of JSON Schema, author of an implementation, or community member) can help with:Improving ImplementationsThe first and most obvious is by helping to take any issues uncovered by Bowtie back to implementations (after confirming them), and then helping implementations fix them.Find your favorite JSON Schema implementations and the tests it fails.
Are there existing open issues on the implementation's bug tracker about the failures?
If they aren't previously known, an issue ticket (with minimal reproducer) is likely going to be welcome by the implementer, so you may want to file one.
If they are known, you can file a pull request in Bowtie which contains information about the downstream issue, which Bowtie can make use of in reports (by showing that the test is explicitly skipped).
Here's an example pull request showing how to do so.Look out for Bowtie-generated badges in the near future which you can use to show off your spec-compliance (nothing could be cooler, eh?).Improving BowtieThe second is by helping to improve Bowtie itself, which I already have a long list of ideas for, which can only grow as more people start to use it.To repeat part of the above, I myself have implemented support for many implementations.
If you maintain or use one, look at the harness I wrote -- it's possible I misused your implementation (though so far thankfully hasn't happened).I'll also mention that I've been experimenting with doing work on Bowtie on livestreams here -- without too much self-promotion, feel free to stop by and say hello, or even to flip through previous streams where I fight with various Bowtie-adjacent things, it may give you some pointers on how to work on it.Below is some specific guidance around areas in need of help:This is current as of the publication of this post, but my hopes are that it swiftly becomes out of date. If it seems to be, feel free to reach out!Give Me Something Easy to Get My Feet WetThere's a list of good first issues on Bowtie's issue tracker which I've attempted to curate.
They cover various portions of Bowtie's codebase (the Python bits, the frontend bits, and its surrounding infrastructure).
The label doesn't indicate that the issue is necessarily "small" to fix, though many are.
But it does indicate the relevant functionality or fix is "straightforward" or likely well-scoped.
If you don't see activity on one, feel free to leave a comment if you begin to work on it.I Want to Learn About a New Implementation or Programming LanguageThis is possibly the most "fun" thing to work on, or at least I quite enjoyed doing it.
Pick an implementation Bowtie doesn't already support from the list of implementations and follow the tutorial for writing a harness which will guide you through what Bowtie expects from a harness.
If there are gaps in the tutorial, do raise them or ping me!
But this can be a nice way to play with a simple program in a language you haven't used before, as well as a way to learn a JSON Schema implementation which may have made different choices than one you're already familiar with.The Report is Ugly, I'm a Frontend Developer or UI Designer Who Can HelpThis is probably the most beneficial area you can help in.
I myself am not a frontend developer, in case that wasn't obvious.
What I put together (with Bootstrap) is essentially the bare minimum of what's needed to show off results Bowtie emits.
If you have more experience or headspace to think about how to effectively report test results, or compare implementations, please help!
All of Bowtie's "frontend code" today lives in one place, a Jinja2 template which gets formatted into a static single page site.
Beyond generally "make it prettier, more responsive, or more usable", here are a few specific issues to look at:Add client-side filtering and sortingShow combined errors+failures counts, or more generally improve the summary from a "table of counts" into a more graphically pleasing representation of what happened in a runDisplay schemas & instances more prettily, or more generally, design a good widget or component for representing test cases, their schemas, instances, and (sub)testsShow average compliance numbers, or more generally, what summary statistics across implementations should we show, and how should we show them?I Develop Other Tooling in the JSON Schema EcosystemGreat!
I have hopes Bowtie may hook in well with other upstream or downstream tooling.
As a concrete example, given that Bowtie provides uniform interfaces to downstream implementations, an "obvious" complimentary tool might be to fuzz-test across all implementations, looking for cases they disagree, or blow up, or more generally produce behavior non-compliant with the specification which isn't already covered by an explicit test in the suite.
Doing this likely simply means hooking such a tool up to Bowtie and letting it rip.
See this issue though it doesn't contain much beyond the above in the way of detail.Other tools may also have nice interactive properties when combined with Bowtie, so if you have other ideas, reach out, or try it!I Want to Contribute TestsThis is definitely also helpful.
If they're tests of the specification itself, check whether they're already present in the official suite, and if not, do submit them there.
If they're not tests that the official suite covers today, e.g. because they cover pathological cases like causing implementations to "blow up" rather than produce a result, they are now "fair game" to add (somewhere, TBD where), because Bowtie can "gently" run implementations and catch these sorts of errors.
Bowtie also allows for a wider range of $ref-related testing, because its protocol specifically instruments harnesses with a sort of "registry" of schemas that the implementation is expected to be able to reference.
This issue is the relevant one, but ideas are welcome here on kinds of tests we can now add.I Found a Bug, or Have an Idea for Bowtie ItselfIf it's with an implementation, you likely should take it to the implementation's issue tracker.
Please be polite, as there's still a small but non-zero chance that issues are caused by Bowtie itself.
And even if there isn't, please do be kind to maintainers, many (including myself!) are already aware of issues Bowtie is flagging and may really want to fix them but have things which make doing so difficult.
Help out implementations if you can!If it's with Bowtie itself, or is a new idea related to Bowtie, definitely file an issue, start a discussion, or start a thread on the JSON Schema Slack.I Want to Do Something Random and CoolThere are some funky ideas in this bin, even already.
I would love to figure out whether we can make use of Bowtie to benchmark implementations uniformly, rather than just test them.
Being able to jump into a language-specific REPL is also a kind of out-there idea but one which might be fun to play with.
There likely are many others!Setting Up Bowtie Was Hard But I Figured It Out / I Want to Help With CI, "Infrastructure" or TriagingThese are all under-appreciated areas you can help with, so please do reach out if you're interested in anything here.
Even something like making Bowtie easier to install for those who don't use Python is a nice help!
(Right now, builds produce a shiv, but not a cross-platform one.)ConclusionThanks for taking the time to hear a bit about Bowtie.
Special thanks also must be given to Postman who employs me full-time to be able to do work like this on behalf of the community.
Without Postman, this work would never have happened!
I hope there's a lot more to come.
Please do share feedback, it's very welcome, and if you do want to get involved, that'd be very much appreciated!Cover photo generated via Stable Diffusion.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubTuesday, November 1, 2022 · 6 min readHow the W3C Web of Things brings JSON Schema to the Internet of ThingsGo back to blogJuan Cruz Viotti@jviottidcon this pageChallengeSolutionImpactKey Impact ResultsW3C Web of ThingsGetting StartedChallengeThe Internet of Things (IoT) is the network of physical "smart" objects that
exchange data with other devices over the Internet. While communication and
interoperability are by definition the crux of the Internet of Things, the
emergence of custom or proprietary solutions results in devices that cannot
talk to each other due to differences in data interchange mechanisms.To integrate these disparate devices, developers must work with a growing set
of protocols, serialization formats and API specifications. This results in
repetitive, non-scalable and error-prone work that is difficult to automate.While technologies like OpenAPI and AsyncAPI largely solve this problem in the
context of Web APIs, they fall short for describing networks of non-HTTP and
multi-protocol devices, and do not consider different modes of interaction
based on their meaning in the physical world.SolutionTo solve these problems, the W3C Web of Things works on providing standardized
building blocks that make use of JSON Schema.JSON Schema is used for validating descriptions of network-facing capabilities
of physical entities called Thing Descriptions, and to
model and describe data sent by Internet of Things consumers and producers in a
multi-protocol manner.The W3C Web of Things specifications are on board with JSON Schema since Draft
4, and even the first draft versions already catered to data models of Internet
of Things devices.  "Currently, we are on JSON Schema Draft 7 and expect to
move to JSON Schema
2020-12
or a newer one when starting our new charter in February 2023," said Ege
Korkan, Research Scientist at Siemens and W3C Specifications editor."We observe JSON Schema becoming more and more stable over the years and
Postman's support to the community gives us even more confidence on it,"
continued Ege Korkan.JSON Schema is delivering exciting features, and more importantly these
features are becoming more and more consistent across implementations.  For
example, Ege Korkan added, "JSON Schema vocabularies are very promising and we
plan to explore them further in conjunction with Semantic Web technologies."ImpactThe W3C Web of Things relies on JSON-LD for linking vocabularies and ontologies
that already exist on the web, such as [SAREF][#saref], [Units of
Measure][#units-of-measure] and [Schema.org][#schema-org]. Being based on the
JSON data model, JSON Schema fits well with JSON-LD when integrating both
technologies as part of a single specification.Adopting JSON Schema means that the W3C Web of Things does not need to invest
effort on inventing another schema language. As a consequence of the popularity
of JSON Schema, existing tooling can be often reused instead of implementing
custom parsers, validators, code generators and UI generators for all the
programming languages that the community might be interested in.JSON Schema has proven to be a foundational block for creating higher-level
tooling that is specific to the W3C Web of Things. As a notable example, the
community has developed a tool called
testbench that makes use of JSON Schema
definitions inside Thing Descriptions to generate matching payloads for the
purpose of stress and penetration testing.Given the growing popularity of using JSON Schema to generate web-based forms,
W3C Web of Things specifications can be used to automatically generate
dashboards and user interfaces to interact with the objects modeled by Thing
Descriptions.Key Impact ResultsThe ultimate metric of success for a standard like the W3C Web of Things is
adoption, and community adoption is not something you can just "engineer".  Ege
Korkan commented, "since we adopt JSON Schema, developers who are familiar
with it have a smaller learning curve when learning the W3C Web of Things
standard.""During my PhD times, my MSc engineering students had to become familiar with
the W3C Web of Things. These students typically took 1 week to go through my
tutorial. If they knew JSON Schema,
that 1 week would become 2 days", said Ege Korkan.W3C Web of ThingsThe World Wide Web Consortium (W3C) is the standardization organization behind
most of the standards used in the Web. The W3C Web of Things Working and
Interest Groups work on the standardization of Web of Things at W3C.The Web of Things groups aim to create an interoperability layer so that
different Internet of Things platforms, protocols and standards can operate
together.The work started as a discussion in the Web of Things Community Group in
2013-2014.  It proceeded to become an Interest Group in 2015 that
collected the use cases and defined the standards to be worked on. Since 2016,
the working group is working on different standards on the Web of Things with
the first publications of the Thing Description and Architecture
recommendations in 2019 and more that will be published by the end of this
year.At the time of this writing, the Working Group consists of 96 participants
representing 36 organizations and the Interest Group consists of 131
participants representing 48 organizations.Getting StartedThe W3C Web of Things Working Group invites you to leverage your existing JSON
Schema knowledge to play with the Internet of Things through the use of the W3C
Web of Things specifications and tools. You might already have a smart device
next to you, just that it does not come with a Thing Description!If you write your own Thing Description, you can programatically interact with
your device by using the Node.js Web of Things
implementation, or play with it
through the
Node-RED
integration.To learn more, head over to the
documentation, watch the introductory
videos, have a look at the many examples
provided as part of the Thing Description specification
and try them out on the Thing Description
Playground app.Thank you to Ege Korkan, Web of Things Researcher at Siemens AG, Munich, the
W3C Web of Things Working and Interest Groups and Coralie Mercier from the W3C
Marketing and Communications Team for allowing and enabling us to share this
case study with you.Cover image: Hello WoT © 2022 by desertmonitor OÜ is licensed under CC BY-ND 4.0Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, October 21, 2022 · 6 min readTowards a stable JSON SchemaGo back to blogJason Desrosiers@jasondesrosierson this pageWhy is it a "draft"?The real problemOur solutionStandards considerationsThe bottom lineAbout this time last year, I hosted a discussion at the API Specification
Conference about the future of JSON Schema. The most popular topic of discussion
was, when JSON Schema is going to be "done". Of course we've heard that question
a lot. The question stems from the "draft" label we put on your releases. The
term "draft" has led to quite a bit of confusion for our community over the
years, so let's take a moment to understand where it comes from.Why is it a "draft"?JSON Schema has been loosely following the IETF standards track RFC process.
That means our releases are in the form of an Internet Draft (I-D). That's why
we refer to them as drafts. However, because of JSON Schema's wide use in
production systems, it's not really possible to treat the spec like a typical
I-D. Therefore, our use of the term "draft" is a bit of legacy artifact from
when the IETF process made more sense for JSON Schema.This is has been a problem because when people hear "draft", they hear
"unfinished" or "not production ready". That's not the way we treat our
releases. Every release is expected and encouraged to be used in production.
It's no different than OpenAPI releasing a new version. No one asks when OpenAPI
is going to be "done". JSON Schema is just perceived differently because we call
our releases "drafts".The real problemBut this isn't just a branding problem. When people ask when JSON Schema is
going to be out of "draft", what they really mean is, when is JSON Schema going
to be "stable". They want to be able to write a schema and be sure that it will
continue to work the same way no matter how JSON Schema evolves in the future.
They want to be able to update their dependencies and not have to update their
schemas that were working just fine.This effects library maintainers as well. Needing to support multiple versions
of JSON Schema with no backward or forward compatibility guarantees gets
cumbersome and has led many maintainers to
drop support for
older releases. When this happens, it can leave users with a choice to have to
update all of their existing schemas that weren't broken or pin to a
no-longer-supported version of the JSON Schema library they are using.Our solutionThose are the problems we're aiming to solve in the next release. Instead of
continuing to release a new immutable and incompatible version of JSON Schema
with each release, our next release will be a long-lived version that is stable,
but evolving. In this case, "stable" means that there will be strict backward
and forward compatibility requirements that must be followed for any change. It
will be much like JavaScript in that as it evolves you can always be sure that
your existing schemas will continue to work with any JSON Schema library you're
using, but you take a risk using newer features because not all libraries will
have implemented those features yet.That vision of a stable yet continuously evolving spec doesn't fit well with the
IETF process. There are paths we considered, but nothing was proposed that we
thought would allow us to continue to evolve the standard and get out of "draft"
any time soon. Therefore, the first step to achieving our vision is to decouple
our main spec development from the IETF process.
This split allows us to pursue a new model for the main spec development that is
more conducive to our vision.Whether or not you're a fan of the direction the JavaScript language has
evolved, it seems clear that they've come up with an
effective process for allowing
for continuous evolution without sacrificing interoperability and longevity.
That's why we've chosen to base our new process on the process that is used to
evolve the JavaScript language. In our next release, most of the keywords and
features you use today will be declared stable and they will never change in a
backward incompatible way again. Features and keywords we aren't comfortable
making stable yet will become part of a new staged release process that we are
working on defining now. The goal of the staged release process is to ensure
that the feature gets sufficient implementation, testing, and real world vetting
for us to be confident in declaring it stable. The process should not only make
us more confident, but also allow us to achieve that confidence much more
quickly.Standards considerationsStarting with the next release, the JSON Schema specification will be
self-published on our website.One of the concerns about self-publishing is about other standards being able to
reference the JSON Schema specification. We have received
feedback
from people involved in standards development that our approach would be
acceptable for them to reference our specification in their standards based on
our membership with the OpenJS Foundation. We don't know if all standards
bodies will come to the same conclusion, but this feedback gives us confidence
that it isn't going to be a significant problem.Although the main specification will be self published, we are continuing to
work through the IETF process where it makes sense. For example, we are in the
process of registering our media types such as application/schema+json through
the HTTPAPIs WG. We are also looking into standardizing reusable components such
as Relative JSON Pointer through IETF.The bottom lineDetails about the new process will be shared in a separate post when they are
finalized, but here are some outcomes users can expect.If you use only stable features, you are guaranteed interoperability between
JSON Schema libraries and you will never need to update your schemas just for
the sake of keeping up with new releases.You can safely use new features before they are stable, as long as the
libraries consuming your schemas support the feature.Compatibility/Interoperability guarantees will only apply to the next release
and beyond. You will need to update your schemas to the stable version, but
you won't have to continue to update them as JSON Schema evolves.Custom dialects and vocabularies will continue to be central concepts for
customizing and extending JSON Schema.Implementers won't need to maintain distinct code to support past stable
releases. A library that supports the 2025 release will automatically support
the 2023 and 2024 releases. The past stable releases will no longer need to be
maintained as distinct versions. However, implementations that continue to
support the "draft" releases would still need to maintain those as distinct
versions from the current stable release.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, August 31, 2022 · 6 min readUsing Dynamic References to Support Generic TypesGo back to blogGreg Dennison this pageGeneric Types
Representing Generics with  and 




Conclusion
One of the most common questions we get is how to represent a concept from a strongly typed programming language in JSON Schema.  Class hierarchies, polymorphisms, generics, etc.  These ideas define strongly typed languages, and influence our data models.The topic in this post can apply to any programming paradigm where you have a defined data model and support for something like generic types.  This will likely be the first in a disjoint series on the relation between data modelling in programming languages and JSON Schema.Today, I want to cover the idea of generics or templates or some other label you may have heard.  To start, let's cover what I mean by "generic types."  This isn't intended as a lesson on them; I just want to ensure that we're all on the same page.Generic TypesBy "generic types" I mean the feature in many programming languages to create a type that requires the additional information of one or more secondary types to be complete.  In object-oriented programming, generics can also apply to services as well as data models, but since we use JSON Schema to describe data models, we can be fairly certain that the generic types we care about for this use case are wrappers and containers.In .Net (C#), these are denoted by angle brackets at the end of the type name, so List<T> or Dictionary<TKey, TValue> where T, TKey, and TValue represent the secondary types.  (These examples are both container types, but you can also do this with envelope types like Cloud Events (e.g. CloudEvent<T>).)In C++, these types are called "templates" and are denoted by the keyword template with the additional type information afterward, also in angle brackets:1template <class T>
2class List { ... }
3
4template <class TKey, class TValue>
5class Dictionary { ... }
6
Typescript also has this concept and mostly follows the C# syntax.These types are then completed by defining the required secondary type(s).  This is typically done by replacing the type placeholder (e.g. T) with the secondary type, so List<T> or Dictionary<string, int> for the C# examples.  One of the interesting consequences is that a generic type cannot be instantiated on its own: it needs the secondary type so that the compiler or script engine (or whatever runs the code) can know various things about the type, like memory footprint.So, the question, then, is how to represent a partially defined type in JSON Schema.Representing Generics with $dynamicRef and $dynamicAnchorThe dynamic keywords, collectively $dynamic*, enable references that generally can't be resolved until evaluation time, unlike $ref, which can be resolved statically with just the schema.  Typically this is most evident when the schema also defines conditionals (if/then/else) which can change the resolution based on the JSON instance being evaluated.However to support generics, we want to use this dynamic behavior a bit differently.  The strategy we'll use is a two-step process.For the generic type itself, we're going to write a schema with a reference that initially resolves to a subschema that always fails validation.For each derivation, we write a subschema that
 references the generic type schema from #1defines a new subschema for the same reference that describes the secondary typeTo see this in action, let's write schemas for the List<T> from above.  Then we'll write two more that will use it to help us define List<string> and List<int>.The Generic Schema: List<T>We start simply with a list of things. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.example/list-of-t",  "type": "array"}﻿
Now we define the items.  This is where $dynamic* does some work for us. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.blog/list-of-t",  "$defs": {    "content": {      "$dynamicAnchor": "T",      "not": true    }  },  "type": "array",  "items": { "$dynamicRef": "#T" }}﻿
NOTE I used T here to match up with the C# List<T> to better illustrate what's happening.  You can name it whatever you want.If we validate an instance against only this schema, "$dynamicRef": "#T" resolves to the subschema with "$dynamicAnchor": "T" that we included at /$defs/content.  In this case, $dynamicRef and $dynamicAnchor work just like $ref and $anchor.The "not": true means that all instances will fail validation.  Typically, to ensure all instances fail validation, we'd use the false schema, but in this case, we need to include a dynamic anchor, so a simple false doesn't work.  I think "not": true is probably the cleanest alternative, but you can also use something like "allOf": [ false ] if that makes more sense to you.NOTE An empty array will still pass validation for this schema, but any array that has items will fail.You can also use multiple dynamic anchors to support types like Dictionary<TKey, TValue> that need multiple secondary types. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.blog/list-of-t",  "$defs": {    "key": {      "$dynamicAnchor": "TKey",      "not": true    },    "value": {      "$dynamicAnchor": "TValue",      "not": true    }  },  "type": "array",  "items": {    "type": "object",    "properties": {      "key": { "$dynamicRef": "#TKey" },      "value": { "$dynamicRef": "#TValue" }    }  }}﻿
And that's it for the generic type.  The magic comes when we define the content.Defining ContentsAs mentioned before, we need a schema that references list-of-t and also provides a definition for T.  Let's write one for List<string>. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.blog/list-of-string",  "$defs": {    "string-items": {      "$dynamicAnchor": "T",      "type": "string"    }  },  "$ref": "list-of-t"}﻿
Here's how this works:When evaluation begins, it creates a "dynamic scope" which starts with the root schema (list-of-string) and remains throughout evaluation.This root schema defines a "$dynamicAnchor": "T".Evaluation then $refs into the generic schema, list-of-t.  This is a new lexical scope, but the dynamic scope remains unchanged.The generic schema also declares "$dynamicAnchor": "T", but that dynamic anchor is already defined, so the new declaration is ignored.When evaluation hits "$dynamicRef": "#T", it uses the first one from the beginning of the dynamic scope.If we wanted int items instead of strings, we just create a new schema where the subschema with $dynamicAnchor defines an integer. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://json-schema.blog/list-of-int",  "$defs": {    "int-items": {      "$dynamicAnchor": "T",      "type": "integer"    }  },  "$ref": "list-of-t"}﻿
ConclusionBy using $dynamicRef and $dynamicAnchor, you don't need to write full schemas for classes which share structure but vary in a content type.  Instead, you can write a partial, reusable schema for the structure, which makes the fully-defined schemas significantly smaller and easier to maintain.ASIDE With Draft 2020-12, including $dynamicAnchor in the generic schema is required for $dynamicRef to work.  In future versions, this requirement will be removed as it isn't strictly needed: any resolution attempt will simply fail.  (This requirement is a holdover from its Draft 2019-09 predecessor $recursive*.)  However for the particular application of modelling generic types, I'd still keep it in because it serves as an analog for not being able to instantiate a generic type, like List<T>.  The net outcome is the same (validation failure), but I think including it more explicitly describes the intent.
Cover photo by Nick Fewings on Unsplash with some edits by me. 😁Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSaturday, July 23, 2022 · 11 min readFixing JSON Schema OutputGo back to blogGreg Dennison this pageAdding requirements to the specTasting my own medicineTime for an update
Status quo

There's gotta be a better way



How this affects errors




Wrap-upI have a problem: when I read GitHub issues, they occasionally resonate with me, and I obsess about them until they're resolved.  That may not sound like a problem to some, but when that resolution causes JSON Schema implementation developers to ask fundamental design questions for three years... yeah, that's a problem.And that's precisely what happened coming out of draft 2019-09.  For this version of the specification we released the very first official output format.  It was actually multiple formats that were supposed to cater to multiple needs.While most people wanted to know what the errors were, some just wanted a pass/fail result, so we created the flag format.Among those who wanted some more detail about what actually failed, some preferred a flat list, while others figured a hierarchy that matched the schema would work better.  So we created basic for the list people.Finally of those that wanted a hierarchy, some wanted a condensed version (which became detailed), and others wanted the fully-realized hierarchy (verbose).ASIDE Some people wanted a hierarchy that mimicked the instance data, but we couldn't figure out how to make that work in a realistic way, so we just kinda swept it under the rug and moved on.Adding requirements to the specAt the time, I hadn't contributed anything major to the spec, but I'd been pretty involved in making direction-type decisions, so I thought I'd take a crack at authorship.  That's not to say that I hadn't contributed any text to the spec; just not anything as significant as an entire section.So I spent a couple weeks writing up the new requirements for output based on the lengthy github issues that results from weeks (months?) of discussion.Man, I thought I had everything!  I defined the properties, the overall structure, validation examples, and I wrote it all in that wonderful spec-ese that we all love.I even implemented it in my library, Manatee.Json, before the spec was released just to make sure that it worked.But I missed something: annotations.  I mean, I considered them, and provided requirements for them.  But I didn't provide an example of the results from a passing instance that generated annotations.  I guess technically I did, but it was buried, nested way down inside the verbose example, which happened to be so big that I decided it needed to be in its own file, separate from the specification document.  (Yeah, like anyone was gonna read that.)The highlight of the following years would be the numerous questions I would receive from fellow implementors regarding confusion about the output, mainly around how annotations should be represented.  And my general response to these questions wasn't great either:  "They're just like errors."  I thought it was a trivial exercise.Fortunately, we listed the output as a whole as a "SHOULD" requirement, so implementations weren't required to do it.  The idea behind this was that we were in the early stages of defining it and we didn't want to put too much of a burden on implementations knowing that we were likely going to tweak it in future releases.Tasting my own medicineIt wasn't until I decided to deprecate Manatee.Json to build JsonSchema.Net that I realized why everyone was asking questions.  Having to reimplement the output opened my eyes.Wow.  I left out a lot!Knowing what I originally intended helped me quite a bit, but I can't imagine what it must have been like trying to implement what I wrote while not also having written it.So, I started taking notes.Time for an updateDraft 2020-12 has been published for over a year, and I've decided something needs to be done about the output.  I created this mess, and I feel it's my responsibility to clean it up.  (Now it's actually my job to clean it up! 😁)  I organized all of my notes and dumped out a massive opening discussion comment on improvements that I think could be made to the formats.The first thing that everyone agreed on was isolating purpose for and renaming some of the output unit properties.  These properties served a distinct purpose, but naming things is hard, so of course the names for these could be better.  After some back-n-forth, proposed alternatives, and refinements, this got a quick-n-easy PR that's already been merged, so that's one thing done.keywordLocation ➡️ evaluationPathabsoluteSchemaLocation (mostly optional) ➡️ schemaLocation (required)errors/annotations ➡️ detailsYou can read the discussion for the rest of the proposed changes, but I want to focus on one in particular.  At some point in the discussion, I had an epiphany:Why is the output designed to capture errors and annotations from individual keywords instead of from subschemas when it's the subschemas that ultimately collect errors and annotations and provide the final result?
Status quoTo understand what I mean by this, let's take a look at the existing output.  We'll start with a simple example, and for brevity we'll only cover the basic, or list, form. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "example-schema",  "type": "object",  "title": "foo object schema",  "properties": {    "foo": {      "title": "foo's title",      "description": "foo's description",      "type": "string",      "pattern": "^foo ",      "minLength": 10,    }  },  "required": [ "foo" ],  "additionalProperties": false}﻿// instance (passing){  "foo": "foo isn't a real word"}﻿
As you can see, this schema defines that a JSON value must be an object with a single string-valued property, foo, and the instance meets these requirements.  Additionally, the schema defines several annotations.The 2019-09 / 2020-12 specs would require the following output for this evaluation:data{  "valid": true,  "keywordLocation": "",  "instanceLocation": "",  "annotations": [    {      "valid": true,      "keywordLocation": "/title",      "instanceLocation": "",      "annotation": "foo object schema"    },    {      "valid": true,      "keywordLocation": "/properties",      "instanceLocation": "",      "annotation": [        "foo"      ]    },    {      "valid": true,      "keywordLocation": "/properties/foo/title",      "instanceLocation": "/foo",      "annotation": "foo's title"    },    {      "valid": true,      "keywordLocation": "/properties/foo/description",      "instanceLocation": "/foo",      "annotation": "foo's description"    }  ]}﻿
So what's bad about this?Annotations are being rendered as full nodes.  This results in a lot of unnecessary or duplicate information.  This is actually more apparent in the hierarchical formats where everything is grouped by location making the repeated location properties redundant.All nodes carry the valid property, which makes it difficult to tell what is the result of an annotation vs the result of a validation.The top-level node has a plural annotations property with an array of nodes, whereas the inner nodes each have a singular annotation property with the annotation value.  This is just confusing.This is just a simple example.  You can see how this can become considerably larger as the size and complexity of the schema grows.There's gotta be a better wayThere is: reporting output by subschema rather than keyword.In the above example, this means that we'd get two nodes:  one for the root schema, and one for the foo property subschema.  (Also note the aforementioned property name changes.)data{  "valid": true,  "evaluationPath": "",  "instanceLocation": "",  "details": [    {      "valid": true,      "evaluationPath": "/properties/foo",      "instanceLocation": "/foo"    }  ]}﻿
That does look a lot simpler.  But what about annotations?  Well, we can group them in a new property.  And, since we know that any keyword is only going to produce a single annotation value, we can utilize an object to report those annotations by using the keyword as the property names.data{  "valid": true,  "evaluationPath": "",  "instanceLocation": "",  "annotations": {    "title": "foo object schema",    "properties": [      "foo"    ]  },  "details": [    {      "valid": true,      "evaluationPath": "/properties/foo",      "instanceLocation": "/foo",      "annotations": {        "title": "foo's title",        "description": "foo's description"      }    }  ]}﻿
Alternatively for the basic format, which is supposed to be a list, the result for the root schema could be moved inside the root output node as shown below.  This is the proposed idea, anyway.  Let us know in a comment on the PR which way you prefer.  I'll be using this format for the rest of the post because it's what is currently proposed.data{  "valid": true,  "details": [    {      "valid": true,      "evaluationPath": "",      "instanceLocation": "",      "annotations": {        "title": "foo object schema",        "properties": [          "foo"        ]      }    },    {      "valid": true,      "evaluationPath": "/properties/foo",      "instanceLocation": "/foo",      "annotations": {        "title": "foo's title",        "description": "foo's description"      }    }  ]}﻿
The last thing is that the absolute URI of the subschema is now required, so let's add that in.NOTE All of these examples (both old and new) are generated by my implementation, which uses a default base URI of https://json-everything/base.  I've implemented this new output on an experimental branch, and you can view the impact of those changes on my library suite here.data{  "valid": true,  "details": [    {      "valid": true,      "evaluationPath": "",      "schemaLocation": "https://json-everything/example-schema#",      "instanceLocation": "",      "annotations": {        "title": "foo object schema",        "properties": [          "foo"        ]      }    },    {      "valid": true,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-everything/example-schema#/properties/foo",      "instanceLocation": "/foo",      "annotations": {        "title": "foo's title",        "description": "foo's description"      }    }  ]}﻿
And that's it!  All of the information we had before in a much more concise package.  Moreover, all of the related annotations are grouped together, which increases readability.How this affects errorsI wanted to start off with annotations because that's what I missed in the previous iteration.  Now, let's take a look at how a couple of failing instances would be reported.  There is an interesting nuance that isn't immediately apparent, and I had to do some double- and triple-checking to ensure that it was right.Our first failing instancedata{  "baz": 42}﻿
This will fail becausefoo is required but missingbaz isn't allowedThe current error output has the same problems as the current annotations output:data{  "valid": false,  "keywordLocation": "#",  "instanceLocation": "#",  "errors": [    {      "valid": false,      "keywordLocation": "#/required",      "instanceLocation": "#",      "error": "Required properties [\"foo\"] were not present"    },    {      "valid": false,      "keywordLocation": "#/additionalProperties",      "instanceLocation": "#/baz",      "error": "All values fail against the false schema"    }  ]}﻿
Note how even though all of the errors actually result from the root schema, they are reported from child locations.  This just seems wrong.Let's look at the new output:data{  "valid": false,  "details": [    {      "valid": false,      "evaluationPath": "",      "schemaLocation": "https://json-everything/example-schema#",      "instanceLocation": "",      "errors": {        "required": "Required properties [\"foo\"] were not present"      }    },    {      "valid": false,      "evaluationPath": "/additionalProperties",      "schemaLocation": "https://json-everything/example-schema#/additionalProperties",      "instanceLocation": "/baz",      "errors": {        "": "All values fail against the false schema"      }    }  ]}﻿
Again, we see the errors exist as a single errors property, which is reported at the subschema level.Also, that nuance I mentioned appears: that false under additionalProperties is reported as a separate subschema (because it technically is a subschema), and the error is reported as an empty-string keyword.  Looking at the evaluation path, though, it still appears that we're reporting at the keyword level.  That's the nuance:  we're actually reporting at the subschema level; it's just that the subschema happens to be located at a keyword.  Let's take a look at another failing instance to see this better.data{  "foo": "baz"}﻿
data{  "valid": false,  "details": [    {      "valid": false,      "evaluationPath": "/properties/foo",      "schemaLocation": "https://json-everything/example-schema#/properties/foo",      "instanceLocation": "/foo",      "errors": {        "pattern": "The string value was not a match for the indicated regular expression",        "minLength": "Value is not longer than or equal to 10 characters"      }    }  ]}﻿
Here, you can see that the evaluation path shows that we are at the subschema located at /properties/foo.  Compare this to the previous example, where we were evaluating the subschema false at the location /additionalProperties, and you can see the similarity.Wrap-upSo that's one way that I would like to update the output and the reasoning behind it.  If you have any thoughts on this, please do let us know in a comment either in the discussion or on the PR.Again, if you'd like to see what the impact of making this change in my implementation was, please have a look at this PR.  All of these changes were driven by updating the output, but I think most of them are specific to my architecture, and some of them could be made to the library even without implementing the new output.  The short summary, though, is the net -343 lines of code!Cover photo by Daria Nepriakhina on Unsplash 😁Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, July 15, 2022 · 5 min readThe Architectural Scope of JSON SchemaGo back to blogGreg Dennison this pageWhat is JSON Schema?Making JSON Schema usefulA nuanceWhy any of this mattersThe scope of the specificationRecently, I've had a few conversations that got me thinking about JSON Schema's place architecturally.  Today I'd like to share some of those thoughts.What is JSON Schema?JSON Schema is a specification that defines a mechanism to describe a JSON value and can be used to validate and annotate the value.  This mechanism is organized into a number of keywords, each of which provides a defined behavior.A single set of keywords comprises a "schema."This system takes an input of a schema, which itself is representable as a JSON value, and a JSON value (which we call the "instance") to which the rules in the schema will be applied.  For the purposes of this post, we'll call the application of these rules "evaluation."  (i.e. A schema "evaluates" an instance.)The output of an evaluation is an aggregation of the individual errors and/or annotations of each of the rules.However, in general, a system of behaviors is somewhat abstract, and so it's not practically useful.  What we need is a realization of this system in code.  What we need is an implementation.Making JSON Schema usefulBefore we can make JSON Schema useful, we need to ask who it should be useful for.  To answer that we need to know why JSON Schema exists in the first place.Well, we visited that in the previous section: a schema evaluates an instance to ensure that the instance complies with all of the rules represented by the schema.  If the instance does comply with the rules in the schema, then we say it is "valid" against that schema.The reasons to ensure we have valid JSON data could be numerous: checking data before deserializing into programmatic models, checking form inputs before submission, etc.  These are the needs of applications.So applications are the consumers of JSON Schema.But what about annotations?  Well, annotations are specifically intended for applications so that they can provide additional behavior.  So, yeah, applications are still the consumers here.But an application can't consume a specification without that specification being realized into code.  That's where implementations come in.An implementation of JSON Schema is an embodiment of the specification that is directly consumable by an application.A nuanceSomething I've seen a lot of lately, and I think the source of some of the confusion that has arisen in my discussions, is that an application may be merely an executable wrapper around an implementation.  This tends to give the appearance that the application itself is the implementation, in which case the application would be subject to the requirements of the specification.  But I don't see it that way.  Even in these cases, there exists a distinction between the application and the implementation, even if that distinction is, in practice, really blurry.NOTE It's important to recognize that this distinction is actually blurry.  This is currently an open point of discussion, and nothing has been officially defined in this area.Applications tend to have three basic components:  an interface (UX or API), some business logic, and data persistence.  All applications have an interface.  However, the business logic and data persistence components are optional to the degree that you can have one or the other or both.  (An application with only a UX is generally not very useful.)An application may only provide an interface over data persistence (e.g. a Postgres web service), meaning that there's no need for any business logic.  Conversely, another application may provide a computational service (e.g. image processing) where there's no need to persist data.For the recent conversations I've had, this second scenario seems to be the case: an application is created that just evaluates instances against schemas.  But this doesn't mean that the application and implementation are the same thing.Within these applications the implementation, which for these applications is the business logic, is still a separate component from the interface.  And it's important to recognize that JSON Schema as a specification can only cover the implementation part.Why any of this mattersIt all comes back to what I touched on this in the opening section: JSON Schema needs to define inputs and outputs.  This comprises a minimal API that implementations and applications can use to communicate with each other.When the line between implementation and application is blurred, it's natural to think that the specification is imposing requirements on how the application communicates with its users.  But that's not the case.It is impossible for JSON Schema to know the needs of an application's users, and so it's impractical for the specification to attempt to define input and output requirements to which applications must adhere.Users of different applications have different needs.  Even when you consider two applications that essentially just provide a UX for implementations, say a web app and a CLI, the UX needs of their users are vastly different, despite the two applications doing basically the same thing.The scope of the specificationAs a result of everything discussed above, it follows that the specification's input and output requirements are only applicable when there is a clear communication seam between an application and a JSON Schema implementation.The specification recognizes that programming languages and frameworks likely will not be dealing with textual JSON, but rather they will use data models defined within the limitations of that language.  As such, it defines input and output in terms of abstract JSON data and JSON Schema models so that implementations are free to use what they have at their disposal.Specifically, these requirements only pertain to standalone implementations that are provided as general-use representations of the JSON Schema specification to be consumed by unknown parties.Applications which have integrated implementations or application/implementation pairs which have specialized contracts need not adhere to these requirements because these arrangements are out of scope of the specification.Cover photo by me 😁Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSunday, July 3, 2022 · 5 min readJoining PostmanGo back to blogJason Desrosiers@jasondesrosierson this pageBackgroundGoalsPersonalIn the last couple of weeks, you may have seen that Postman has been investing
heavily in JSON Schema's future by hiring some of its top contributors giving
them the opportunity to work full time on improving the JSON Schema
specification and tooling ecosystem. I'm happy to announce that I'm the next
addition to that team.JSON Schema has always been a small group of volunteers working in their free
time with no financial support for their work. Thanks to Postman, we now have a
team of four that has the financial support and creative freedom to focus on the
projects and goals we never had time for in the past. I'm excited to see what
this team can achieve in the next couple years.When Postman hired Ben Hutton last year to work full time on JSON Schema, there
was some concern within our community that Postman might try to own or influence
the evolution of JSON Schema in someway the way we often see with certain big
companies having undue influence on web standards today. Fortunately, this
hasn't been the case with Postman and none of us who have joined in the past
month would have joined if it were. Postman is just making it possible for us to
put more time and effort into doing what we've been doing for years.BackgroundI discovered JSON Schema around 2013 when draft-04 was new. I was designing APIs
and I was doing a deep dive on REST and hypermedia. I discovered JSON
Hyper-Schema and it's unique approach to hypermedia allowed me to introduce
hypermedia to APIs in an unobtrusive way and express relationships that weren't
possible with other approaches. But, the biggest win was that using a JSON
Hyper-Schema implementation called Jsonary along with some basic hand rolled
tooling, I could design APIs in a interactive way. I could try out workflows by
clicking links and filling out forms before we invested in building anything
out. It was API first design before it had a name.Around 2015-ish, I started contributing to specification discussions and
supporting the community through StackOverflow where I'm the all time top
answerer of JSON Schema questions. For a while I was too busy with other
obligations necessary for paying bills to be as involved as much as I wanted to
be. But, a couple years ago I managed to transition to doing consulting part
time with the goal of doing work to pay the bills when necessary and spending as
much time as I could afford on things that bring me joy like working on JSON
Schema.During that time I decided to work on a JSON Hyper-Schema implementation. I was
hoping to make use of an existing validation library and build a JSON
Hyper-Schema client on top of it, but nothing existed that was capable of that.
I ended up writing my own validation implementation which became one of the
first 2019-09 implementations. The goal of this implementation was to be a set
of tools to create JSON Schema related libraries. The validation implementation
was just a proof of concept of something you can create with these tools.
Eventually, I'll get back to actually implementing that JSON Hyper-Schema
client.GoalsNow that I can focus full time on JSON Schema, I have many goals. The following
are my top three objectives at the moment, but who knows how the winds will
change and priorities will shift over time.My first priority is to get the application/schema+json media type registered
with IANA. It's been used for years in many applications and it's about time it
was officially recognized and defined. This is a unique challenge because of how
much JSON Schema has evolved over the years and will evolve in the years to
come. Whatever we end up with needs to be inclusive of past and future JSON
Schema.Another goal is to complete the updates to the Understanding JSON Schema
documentation. Because the JSON Schema community was unfunded and limited to
contributing in our free time, things like documentation usually didn't get the
attention it deserved. Last year I began an effort to update the documentation
to cover the most recent two (!) drafts that had gone undocumented. I got most
of the way through it, but there are a few things like dynamic references
and the vocabulary system that I didn't get to before I had to take a consulting
gig and make some money.As I said before, I'm a huge fan of JSON Hyper-Schema. Due to not having
sufficient resources and lack of adoption, we've paused work on the JSON
Hyper-Schema specification. Now that I'm able to work on JSON Schema full time,
I want to bring JSON Hyper-Schema (or something like it) back. This is a big job
that above all needs tooling developed so people can see how powerful it can be.PersonalSince this is something of an introduction post, I guess I should include some
personal trivia as well. I live in San Luis Obispo, California. When I'm not at
a keyboard you'll probably find me hiking and/or camping deep in the mountains,
rock climbing, or coaching gymnastics. The cover image for this post is me doing
a handstand at the summit of Mt Baldy in Southern California.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, June 23, 2022 · 7 min readAnd Then There Were ThreeGo back to blogGreg Dennison this pageBeing InvolvedBeing an ImplementorBeing an EmployeeHi, everybody!I'm Greg Dennis.  I'm the author of json-everything, which aims to be an all-encompassing tool suite for JSON needs in .Net, including JSON Path, JSON Patch, and (of course) JSON Schema, amongst others.  I'm also responsible for driving and authoring the output requirements in the JSON Schema specification.Piggybacking on Julian's news, I'm also joining Postman to work on JSON Schema full time as a Specification & Tooling Architect!  This means that I will be working on updating the specification as well as helping define and implement validation and other JSON-Schema-adjacent tooling.  I also expect to be highly involved in the community by supporting other tooling implementors.Being InvolvedJSON Schema has always been a passion project for me.  I didn't really see it at work*, and I never had a problem for which JSON Schema was the solution.  Nevertheless, I recognized its potential that it could be the solution other people needed, and I wanted to contribute by giving them an easy adoption path.* I have primarily worked in the .Net world, where there are a lot of other data validation tools, most of which are built into the framework and centered around deserialization.  However, with the popularity of JSON Schema growing (especially around code generation), we could find a proper place for it in .Net soon.I first became involved with JSON Schema in 2015 when I was looking for JSON-related functionality to implement in my library, Manatee.Json.  I liked the ability to validate JSON data, and I especially liked that the validation requirements themselves could be represented in JSON.At that time, Draft 4 had been available for a couple years, and the project was just starting to be picked up again after having been nearly abandoned.  Although I didn't know it then, I kind of just stumbled upon the project at the right time.  I started reading through some of the open issues, commenting on a few, and I joined the Slack workspace.It soon became apparent that I wasn't going away, and I was invited to contribute as a core member of the team.  I spent my spare time discussing changes and new features, while trying to balance how helpful or easy to use a particular feature would be to JSON Schema users (primarily schema authors) against how hard that feature would be to implement.Since then, I have contributed to countless discussions, commented on alterations to the specification, and even made a few authorship contributions of my own, including the aforementioned section on output formatting.I've learned a lot from my involvement with JSON Schema.Most significantly, having a focus on interoperability has opened my eyes to the needs of programming languages and frameworks that I haven't used.  Working primarily in C-based languages, I had never considered that different programming languages could actually do different things.  Previous to my experience here, I had thought different languages all provided the same set of functionality, the only difference being that some made certain tasks easier.I've also learned that JSON Schema is used for a lot more than just validation: hyperschema, code generation, and form generation are primary examples.  The diversity of application really makes JSON Schema a great concept.Being an ImplementorI've had two libraries (so far) that implement JSON Schema.Manatee.Json was the first, and it was half a learning platform for me to develop my coding skills and half intended to actually be useful to people.  It wasn't fast by any stretch of the imagination (I later found out that it was just my home-brew parsing that was slow), but it was accurate to the specification, and it had done moderately well in the nuget.org download stats.  At the time of this writing, it continues to be downloaded 300 times per day and has reached 1 million downloads despite it being deprecated for two years.The second library, JsonSchema.Net, released in 2020, aims to be a more practical production-use library.  I created it as a JSON Schema companion to .Net's new built-in System.Text.Json parser/serializer, which was released in 2019.  In the two years that it's been available, it has amassed almost 450K downloads at about 670 per day.JsonSchema.Net also has several "expansion pack" libraries that provide additional functionality, such as schema generation from .Net code, data generation from a schema, and two vocabularies that I wrote to address a couple open GitHub issues on the specification repository: external data access and identifying item uniqueness within arrays by specified keys.I always keep an eye out for other extended uses for JSON Schema (and JSON in general) to add to the suite, and now I have more time to do it!Being an EmployeeLast year, when Ben announced he was joining Postman to work on JSON Schema full time, I had reservations about the direction of the project.  Was Postman looking to own the project?  What would that mean for its future or for our ability (as volunteer contributors) to enact changes?Ben's response was incredible and perfect:  he championed JSON Schema joining the OpenJS Foundation, cementing its independence.  And that he did it while being a Postman employee was reassurance that Postman was in it for the betterment of the open source community.Then business carried on as usual.  We were all working hard toward the release of an editorial, non-functional patch release for 2020-12 (now released!), and Ben found that he needed some more dedicated help.  So in Slack DMs, he asked me if I would be interested in joining up.  Even though I was just getting settled in at a new company, I couldn't let this opportunity pass me by.  Getting paid to work on a passion project is the dream!And now, I'm extremely excited to announce that I'm joining Postman Open Technologies as a Specification & Tooling Architect.  I will have three focuses: work on the JSON Schema specification, support for its implementors, and development support of adjacent uses.To start with the specification, the output format will continue to be a primary focus for me.  Earlier this year, I opened a discussion on potential improvements.  I think that we're in a good place, and I need to start creating PRs that move the current language in the specification to the new design.I'm not sure yet what implementor support will look like, but based on our implementations page, it seems that many of them haven't updated to supporting 2020-12 yet.  Outreach is probably the best place to start here.  We need to find out the status of each of these projects.  Are they still maintained?  Do they intend to stay up-to-date with the specification?  Do they need help?  Answering these questions will be the first step.And finally adjacent tooling.  I'm really excited about this part because it will highlight for me how JSON Schema is being used in the real world, thereby validating (ha!) its usefulness.I'm really excited about the opportunity that Postman has given me to work full time on a project that I love and its adjacency, and I foresee a bright future for this project and the community that continues to support and build it.Thank you to everyone I've met on this journey, used my libraries, asked questions, contributed code, or just offered opinions!  I love being a part of this community!Cover photo by me 😁Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, June 16, 2022 · 7 min readHello World, Hello PostmanGo back to blogJulian Berman@JulianWasTakenon this pageAt the StartThe Test SuiteA Bit More Reflection & ThanksWhat's NextHi! I'm Julian Berman.If you're a user of JSON Schema, you may know me as the author of a popular Python implementation of JSON Schema. If you're an implementer of the JSON Schema specification, you may instead know me as the primary maintainer of the cross-language JSON Schema test suite.I'd love to share some good news with the JSON Schema community.In short: I've joined Postman's Open Technology team to work on JSON Schema full-time. In doing so I'm joining a growing existing group of folks from the ecosystem, including amongst them Ben Hutton, JSON Schema's specification lead. This brings the number of people working on JSON Schema full-time up to 2 (and counting!).What does this mean? Primarily, on my part, more mindspace dedicated to JSON Schema, and hopefully thereby some long-needed improvements to the test suite, to my implementation, to new implementations, and beyond. We hope to grow the community even further, and to connect more strongly with it.Before talking more about that, I'd love to take you through my journey to get here. It's been a fun one.At the StartMy connection to JSON Schema started in 2011, more than 10 years ago. I was working on a now long-forgotten web project which needed a validation layer, and stumbled across JSON Schema as something I might use to fill the need. As is not uncommon in the programming world, the side project became the main project, and the web application is now long-forgotten. I don't even think I remember what it was meant to do.My first public commit of the Python jsonschema project was in December of that year.At the time, I decided to write a Python implementation not because one didn't already exist – on the contrary, at the time in 2011, there already were one or two out there. My implementation was instead almost born out of coincidence. I was growing as a developer at the time, and starting to form opinions about what I thought good code looked like (occasionally overly strong ones). When I found some specification inconsistencies in the pre-existing implementations, it gave me an itch to write something I could "own" and learn from as a maintainer.It wasn't long before my implementation was used by other projects, and those other projects were reaching out with issues, requests, thanks or feedback.
Hearing others appreciated my work was definitely good motivation to continue to invest effort into it.The Test SuiteNot long after writing my little Python library, I started what would become the official, language-agnostic test suite for implementers of JSON Schema. For awhile I churned away on the suite, hoping it would make it easier for others to do what I'd done – to write a spec-conformant implementation of JSON Schema.At the time, the implementations I found were each replicating their own incomplete, internal test suites. It seemed eminently beneficial to centralize the effort, giving someone authoring a library a way of running a "known" set of tests which would tell them whether their libraries were working as expected and specified.The test suite was originally not "official" by any means. I worked on it from my own account with no real connections to the work happening on the specification itself. Graciously however, a member of the specification team at the time reached out and proactively asked me to bring it within the JSON Schema organization, while continuing to maintain it. While I wasn't surprised in the interest in such a thing, I certainly was proud of having produced something useful.I've never been the one to drive new functionality in JSON Schema. My role instead has been more of an interpreter, taking what has been written and using the test suite to shine a light on corner cases. From early on, I was firm that the test suite wasn't a vehicle for enacting change to the specification, it was simply a representation of what the specifications already prescribed. Doing so was critical for its success (success both of the suite and the specification itself). Specifications are never perfect, and still today the JSON Schema specification continues to be improved and iterated on; nonetheless the test suite has given implementers a shared understanding of what the specification says (allowing discussions for how to improve it to carry on elsewhere).A Bit More Reflection & ThanksI owe a decent amount of debt to JSON Schema as a whole. It's been with me for a very long time in my programming career thus far, and I've learned a lot through needing to maintain bits and pieces of its orbit. Maintaining a widely used library is not easy at all at times, and JSON Schema gave me a way to exercise these muscles. At times, it has moved up or down on my (long) list of interests, but never completely off it. For over 10 years I've had it somewhere in my conscious.It's led me to serendipitous encounters sitting halfway around the world with developers who unknown to both of us had just dealt with an outage I'd caused to their internal systems by doing a release (n.b. pin your dependencies folks!). Luckily we both could crack a smile at the coincidence by that point.I've enjoyed waking up to unexpected emails from respectable open source projects' maintainers telling me they use it, or thanking me for it when we bump into each other. I've come across important looking documents with government seals on them giving guidance on how to use the library I wrote initially as an afterthought, and couldn't help but be amused.What's NextAnd so, proudly, it's time for JSON Schema to play a bigger part in my day-to-day. I join Postman with an expected bit of tentativeness – joining a for-profit company, one of course worries about any undue influences on direction of an open source project. I can say happily that Postman have been nothing but gracious supporters so far – of JSON Schema, of open source more broadly, and certainly of myself. The tentativeness I start with I expect to disappear quite quickly and be replaced with gratitude. There are many many knowledgeable people to both learn from and interact with here, something I think will prove to be invaluable.As for work on JSON Schema, there are many things I've wanted to do these past few years, particularly with the test suite, that there was just never enough time to dedicate to. Hardening the suite has even more potential to help expand JSON Schema's usage than we've tapped so far. There are things about maintainership which embarrass me somewhat, as any project occasionally does to its maintainers. The glacial pull request queue is definitely up there on that list; if you're a contributor, you have my deep apologies if a pull request of yours has sat stagnant. It will be one of the things I definitely aim to fix quickly. There are of course many things I am quite proud of as well, and hope to continue doing.Through the years I've occasionally spoken about JSON Schema at conferences or meetups, or occasionally poked my head beyond the borders of my implementation or the test suite. I intend to do more of both, and be better at it all.And more broadly than myself, we have even bigger dreams. Stay tuned for more details there, both here on the blog as well as on the issue trackers and discussion boards throughout the organization.Please help! Your feedback, as a user, as an implementer of the specification, or as an observer, are all likely invaluable to making sure JSON Schema moves forward. Please do reach out – to Ben, to myself, to other wonderful folks who form JSON Schema's contributors, and/or via the JSON Schema Slack. I know we'd all love to hear feedback, things you'd like to see, constructive complaints, or general thoughts on how we can grow the community.In particular, if you're an open source maintainer who depends on my library, or on the test suite, please introduce yourself if we don't already know each other! I'd love to hear about what either can do better for you.Thanks for the ride so far!Cover photo by Jim Kalligas on Unsplash.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, May 18, 2022 · 14 min readAstonishing Serializations & Schemas of HyperboreaGo back to blogYanick Champoux@yenzieon this page
Preparing the groundJSON is the worst
Setting up the validation train



Starting on the schema



Adding stats and definitions



One sample doesn't serious testing make



More schemas!






Referencing other parts of the schema
Custom keywords

More of the same





Originally published at techblog.babyl.ca.
For the last two years I am part of a band of intrepid
adventurers joining forces every Thursday night via the teleporting magic of Discords, semi-arguably doing our best
not to die horrible deaths in the raucously unforgiving world
of Astonishing Swordsmen and Sorcerers of Hyperborea,
a pulpy cousin of Dungeons & Dragons. The game is orchestrated
by evil dungeon mastermind Gizmo Mathboy, and it's a massive amount
of fun.But the world of Hyperborea is not only besieged by monsters. Oh no. It is also
a realm filled with rules, and statistics, and all manners of fate-defining
dice rolls. And of the nexus capturing a lot of those arcane laws is --
unsurprising to all savvy to the genre -- the character sheet.Being good little nerds, we usually do a good job of keeping the character
sheets up-to-date. But we're all fallible creatures; mistakes creep in. Which
made me think... surely there are ways to automate some validations on those
character sheets. In fact, we already keep our sheets as YAML
documents. JSON Schemas can totally be used to define document
schemas... surely it could twisted a little bit more to accommodate the exotic
logic of a game?The answer is that, of course, everything can be twisted provided the spell is dark
enough. This blog entry and its associated project repository, while not
an exhaustive solution (yet), is intended to the goodies that JSON
Schema could bring to the table, as well as the tools of the ecosystem.So... Interested, fellow adventurers? Then gird those loins, sheath those blades,
and follow me: into the JSON Schema jungle we go!Preparing the groundFirst, let's introduce the core tools I'll be using for this project.For all
things JSON Schema, we'll be using ajv (and ajv-cli for cli
interactions). It's a fast, robust implementation of the JSON Schema
specs with a lot of bonus features, and to ice the cake it provides an easy
mechanism to add custom validation keywords, something we'll abuse before
long.And since we'll do a lot of command-line stuff, I'll bring in Task,
a YAML-based task runner -- basically Makefile with the insane
whitespace-based syntax replaced by, uh, a different insane
whitespace-based syntax I'm comfortable with.Incidentally, the final form of all the code I'm going to discuss
in this article is in this repo.JSON is the worstOkay, that's overly mean. JSON is a great serialization format, but it's
a soulless drag to edit manually. But that's not much of a problem, as JSON Schema
is kind of a misnomer: both the target documents and the schemas themselves
are ultimately just plain old data structure -- JSON just happens to be
the typical serialization for it. Well, typical be damned, we'll go with
YAML as our source. And for convenience for the other pieces to come,
we'll convert those YAML documents to JSON via [transerialize][].1# in Taskfile.yml
2tasks:
3    schemas: fd -e yml -p ./schemas-yaml -x task schema SCHEMA='{}'
4
5    schema:
6        vars:
7            DEST:
8                sh: echo {{.SCHEMA}} | perl -pe's/ya?ml/json/g'
9        sources: ["{{.SCHEMA}}"]
10        generates: ["{{.DEST}}"]
11        cmds: transerialize {{.SCHEMA}} {{.DEST}}
12
Oh yeah, task is unfortunately janky where loops
are concerned, so I'm using fd and re-entries to
deal with all the individual schema conversions.Setting up the validation trainBefore we go hog-wild on the schema itself, we need
to figure out how we'll invoke things. And to do that, let's
seed our schema and sample document in the most boring, minimalistic
manner possible.1# file: schemas-yaml/character.yml
2$id: https://hyperboria.babyl.ca/character.json
3title: Hyperboria character sheet
4type: object
5
1# file: samples/verg.yml
2
3# Verg is my character, and always ready to face danger,
4# so it makes sense that he'd be volunteering there
5name: Verg-La
6
We have a schema, we have a document, and the straightforward way to
validate it is to do the following.1⥼ ajv validate -s schemas-yaml/character.yml -d samples/verg.yml
2samples/verg.yml valid
3
Sweet. Now we just need to formalize it a little bit in Taskfile and
we're ready to roll.1# file: Taskfile.yml
2# in the tasks
3validate:
4    silent: true
5    cmds:
6        - |
7            ajv validate  \\
8                --all-errors \\
9                --errors=json \\
10                --verbose \\
11                -s schemas-yaml/character.yml \\
12                -d {{.CLI_ARGS}}
13
Starting on the schemaTo warm ourselves up, let's begin with some easy fields.
A character has obviously a name and a player.1# file: schemas-yaml/character.json
2$id: https://hyperboria.babyl.ca/character.json
3title: Hyperboria character sheet
4type: object
5additionalProperties: false
6required:
7    - name
8    - player
9properties:
10    name: &string
11        type: string
12    player: *string
13
Nothing special there, except for the YAML anchor and alias, because I'm a
lazy bugger.1⥼ task validate -- samples/verg.yml
2samples/verg.yml invalid
3[
4    ...
5    "message": "must have required property 'player'",
6    ...
7]
8
Woo! Validation is screaming at us! The output is abbreged here because
I configured it to be extra-verbose in the taskfile. But the gist is clear:
we're supposed to have a player name and we don't. So let's add it.1# file: samples/verg.yml
2name: Verg-La
3player: Yanick
4
And with the player name added, all is well again.1⥼ task validate -- samples/verg.yml
2samples/verg.yml valid
3
Adding stats and definitionsNext thing, core statistics! All statistics are following the same
rules (numbers between 1 and 20). Copying and pasting the
schema for all stats would be uncouth. Using anchors as in the previous
section is an option, but in this case it's better to use the
a schema definition, to make things a little more formal.1# file: schemas-yaml/character.yml
2# only showing deltas
3required:
4    # ...
5    - statistics
6properties:
7    # ...
8    statistics:
9        type: object
10        allRequired: true
11        properties:
12            strength: &stat
13                $ref: "#/$defs/statistic"
14            dexterity: *stat
15            constitution: *stat
16            intelligence: *stat
17            wisdom: *stat
18            charisma: *stat
19$defs:
20    statistic:
21        type: number
22        minimum: 1
23        maximum: 20
24
Note that the allRequired is a custom keyword made available by
ajv-keywords, and to use it we have to amend our call to
ajv validate in the the taskfile:1# file: Taskfile.yml
2validate:
3    silent: true
4    cmds:
5        - |
6            ajv validate \\
7                --all-errors \\
8                --errors=json \\
9                --verbose \\
10                -c ajv-keywords \\
11                -s schemas-yaml/character.yml \\
12                -d {{.CLI_ARGS}}
13
To conform to the schema, we add the stats to our sample character too:1# file: samples/verg.yml
2statistics:
3    strength: 11
4    dexterity: 13
5    constitution: 10
6    intelligence: 18
7    wisdom: 15
8    charisma: 11
9
And we check and, yup, our sheet is still valid.1⥼ task validate -- samples/verg.yml
2samples/verg.yml valid
3
One sample doesn't serious testing makeSo far, we've used Verg as our test subject. We tweak the schema,
run it against the sheet, tweak the sheet, rince, lather, repeat. But as
the schema is getting more complex, we probably want to add a real test
suite to our little project.One way would be to use ajv test, which has the appeal that no additional
code is required.1⥼ ajv test -c ajv-keywords \\
2    -s schemas-yaml/character.yml \\
3    -d samples/verg.yml \\
4    --valid
5samples/verg.yml passed test
6# bad-verg.yml is like verg.yml, but missing the player name
7⥼ ajv test -c ajv-keywords \\
8    -s schemas-yaml/character.yml \\
9    -d samples/bad-verg.yml \\
10    --invalid
11samples/bad-verg.yml passed test
12
But what it has in simplicity, it lacks in modularity. Those
schemas are going to get a little more involved, and targeting
pieces of them would be good. So instead we'll go with good old unit test,
via [vitest][].For example, let's test statistics.1// file: src/statistics.test.js
2import { test, expect } from "vitest";
3
4import Ajv from "ajv";
5
6import characterSchema from "../schemas-json/character.json";
7
8const ajv = new Ajv();
9// we just care about the statistic schema here, so that's what
10// we take
11const validate = ajv.compile(characterSchema.$defs.statistic);
12
13test("good statistic", () => {
14    expect(validate(12)).toBeTruthy();
15    expect(validate.errors).toBeNull();
16});
17
18test("bad statistic", () => {
19    expect(validate(21)).toBeFalsy();
20    expect(validate.errors[0]).toMatchObject({
21        message: "must be <= 20",
22    });
23});
24
We add a test task to our taskfile:1# file: Taskfile.yml
2test:
3    deps: [schemas]
4    cmds:
5        - vitest run
6
And just like that, we have tests.1⥼ task test
2task: [schemas] fd -e yml -p ./schemas-yaml -x task schema SCHEMA='{}'
3task: [schema] transerialize schemas-yaml/test.yml schemas-json/test.json
4task: [schema] transerialize schemas-yaml/character.yml schemas-json/character.json
5task: [test] vitest run
6
7 RUN  v0.10.0 /home/yanick/work/javascript/hyperboria-character-sheet
8
9 √ src/statistics.test.js (2)
10
11Test Files  1 passed (1)
12     Tests  2 passed (2)
13      Time  1.41s (in thread 5ms, 28114.49%)
14
More schemas!Next step: the character class. While we could just slam an enum
in the main schema and call it done, it's a list that might be re-used
somewhere else, so it might pay off to define it in its own schema, and
refer to it in the character sheet schema.Addititional challenge! In Hyperborea you can have a generic class, or a
class and sub-class. Which can be schematized explicitly, like this:1oneOf:
2    - enum: [ magician, figher ]
3    - type: object
4      properties:
5        generic: { const: fighter }
6        subclass: { enum: [ barbarian, warlock, ... ] }
7    ...
8
But that's a lot of repetitive typing. Instead, it'd be nice to
have the source be more compact, if a little less JSON Schemy. Say, something
like this:1$id: https://hyperboria.babyl.ca/classes.json
2title: Classes of characters for Hyperborea
3$defs:
4    fighter:
5        - barbarian
6        - berserker
7        - cataphract
8        - hunstman
9        - paladin
10        - ranger
11        - warlock
12    magician: [cryomancer, illusionist, necromancer, pyromancer, witch]
13
And then have a little script massage the data as we turn the YAML into
JSON. Fortunately (what a lucky break!), transerialize does allow
for a transformation script to be wedged in the process. So we can change
our taskfile schema task to be:1schema:
2    vars:
3        TRANSFORM:
4            sh: |
5                echo {{.SCHEMA}} | \\
6                    perl -lnE's/yml$/pl/; s/^/.\//; say if -f $_'
7        DEST:
8            sh: echo {{.SCHEMA}} | perl -pe's/ya?ml/json/g'
9    cmds:
10        - transerialize {{.SCHEMA}} {{.TRANSFORM}} {{.DEST}}
11
And then we slip in a transform script that looks like this:1# file: schemas-yaml/classes.pl
2sub {
3    my $schema = $_->{oneOf} = [];
4
5    push @$schema, { enum => [ keys $_->{'$defs'}->%* ] };
6
7    for my $generic ( keys $_->{'$defs'}->%* ) {
8        push @$schema, {
9            type => 'object',
10            properties => {
11                generic => { const => $generic },
12                subclass => { enum => $_->{'$defs'}{$generic} }
13            }
14        }
15    }
16
17    return $_;
18}
19
With that, the output schema is inflated to what we want. We're having our concise cake eating the big fluffy one too. Nice!So what is left is to link the schemas together. We refer
to the classes schema from the character schema:1# file: schemas-yaml/character.yml
2required:
3    # ...
4    - class
5properties:
6    # ...
7    class: { $ref: "/classes.json" }
8
We also need to tell ajv of the existence of that new schema:1validate:
2    silent: true
3    cmds:
4        - |
5            ajv validate \\
6                --all-errors \\
7                --errors=json \\
8                --verbose \\
9                -c ajv-keywords \\
10                -r schemas-json/classes.json \\
11                -s schemas-json/character.json \\
12                -d {{.CLI_ARGS}}
13
Finally, we add Verg's class to his sheet:1# file: samples/verg.yml
2class:
3  generic: magician
4  subclass: cryomancer
5
And just like that, Verg (and our character schema) is all classy and stuff.Referencing other parts of the schemaSo far we can set up our character sheet schema to ensure that we
have the fields that we want, with the types and values that we want.
But something else we want to do is to validate the relations
between properties.For example, characters have a health statistic. Each time the character
levels up, the player rolls a dice and increases the health accordingly.
As you image, forgetting to get that bonus can prove to be a lethal mistake,
so it'd be nice to ensure that never happens.We'll do it through the magic of JSON Pointers and avj's $data, like so:1# file: schemas-yaml/character.yml
2level: { type: number, minimum: 1 }
3health:
4    type: object
5    required: [ max ]
6    properties:
7        max: { type: number }
8        current: { type: number }
9        log:
10            type: array
11            description: history of health rolls
12            items: { type: number }
13            minItems: { $data: /level }
14            maxItems: { $data: /level }
15
Basically (and once we add a --data flag to ajv to tell it to enable
that feature), any mention of { $data: '/path/to/another/value/in/the/schema' } will be replaced by the value for which that JSON pointer resolves to
in the document being validated. That's something that is not part of JSON
Schema proper, but it's a mightily useful way to interconnect the schema
and the document being validated.Word of caution, though: I say 'any mention of $data', but that's
overselling it. There are a few cases where $data fields won't be resolved.
If you are to use that feature, make sure to reserve a few minutes to read
the AJV docs about it. Trust me, it'll save you a few "what the everlasting heck?" moments.Custom keywordsIn the previous section, we checked that the number of rolls for health is
equal to the level of the character. That's already something. But
the logical next step is to ensure that the sum of those rolls are
equal to the max health points we have. We'd need something like:1# file: schemas-yaml/character.yml
2health:
3    type: object
4    properties:
5        max:
6            type: number
7            sumOf: { list: { $data: 1/log } }
8        log:
9            type: array
10            items: { type: number }
11
That's where custom keywords enter the picture. AJV allows us to
augment the JSON Schema vocabulary with new keywords.There is a few ways to define that custom keyword. The one I opted for
is defining it as a JavaScript function (here made a little more
complex because we're dealing internally with JSON pointers):1// file: src/sumOf.cjs
2
3const _ = require("lodash");
4const ptr = require("json-pointer");
5
6function resolvePointer(data, rootPath, relativePath) {
7    if (relativePath[0] === "/") return ptr.get(data, relativePath);
8
9    const m = relativePath.match(/^(\d+)(.*)/);
10    relativePath = m[2];
11    for (let i = 0; i < parseInt(m[1]); i++) {
12        rootPath = rootPath.replace(/\/[^\/]+$/, "");
13    }
14
15    return ptr.get(data, rootPath + relativePath);
16}
17
18module.exports = (ajv) =>
19    ajv.addKeyword({
20        keyword: "sumOf",
21        $data: true,
22        errors: true,
23        validate: function validate(
24            { list, map },
25            total,
26            _parent,
27            { rootData, instancePath }
28        ) {
29            if (list.$data)
30                list = resolvePointer(rootData, instancePath, list.$data);
31
32            if (map) data = _.map(data, map);
33
34            if (_.sum(list) === total) return true;
35
36            validate.errors = [
37                {
38                    keyword: "sumOf",
39                    message: "should add up to sum total",
40                    params: {
41                        list,
42                    },
43                },
44            ];
45
46            return false;
47        },
48    });
49
As usual we have to tell ajv to include that new bit of code via
-c ./src/sumOf.cjs. But beside that, congrats, we have a new keyword!More of the sameBy now we have most of the tools we want, all that is left to do is to
turn the crank.Experience points? Much of the same logic as for the health points:1# file: schemas-yaml/character.yml
2experience:
3    type: object
4    properties:
5        total:
6            type: number
7            sumOf:
8                list: { $data: '1/log' }
9                map: amount
10        log:
11            type: array
12        items:
13            type: object
14            properties:
15                date: *string
16                amount: *number
17                notes: *string
18
19
The other basic attributes are trivial:1# file: schemas-yaml/character.yml
2gender: *string
3age: *number
4height: *string
5appearance: *string
6alignment: *string
7
Fields based on lists? Been there, done that:1# file: schemas-yaml/character.yml
2  race: { $ref: /races.json }
3  languages:
4    type: array
5    minItems: 1
6    items:
7      $ref: /languages.json
8
Spells are only for magicians? Not a problem.1# file: schemas-yaml/character.yml
2type: object
3properties:
4    # ...
5    spells:
6      type: array
7      items: { $ref: /spells.json }
8      maxSpells:
9        class: { $data: /class }
10        level: { $data: /level }
11
With the new keyword maxSpells:1// file: src/maxSpells.cjs
2
3const _ = require("lodash");
4const resolvePointer = require('./resolvePointer.cjs');
5
6module.exports = (ajv) =>
7    ajv.addKeyword({
8        keyword: "maxSpells",
9        validate: function validate(
10            schema,
11            data,
12            _parent,
13            { rootData, instancePath }
14        ) {
15            if (schema.class.$data) {
16                schema.class = resolvePointer(
17                    rootData, instancePath, schema.class.$data
18                );
19            }
20
21            if( schema.class !== 'magician'
22                && schema.class?.generic !== 'magician'
23                && data.length ) {
24                validate.errors = [
25                    {
26                        message: "non-magician can't have spells",
27                    },
28                ];
29                return false;
30            }
31
32            return true;
33        },
34        $data: true,
35        errors: true,
36    });
37
Gears? Pfah! Sure.1# file: schemas-yaml/character.yml
2properties:
3    # ...
4    gear: { $ref: '#/$defs/gear' }
5$defs:
6  gear:
7    type: array
8    items:
9      oneOf:
10        - *string
11        - type: object
12          properties:
13            desc:
14              type: string
15              description: description of the equipment
16            qty:
17              type: number
18              description: |
19                quantity of the item in the
20                character's possession
21          required: [ desc ]
22          additionalProperties: false
23          examples:
24            - { desc: 'lamp oil', qty: 2 }
25
By now you get the point. A lot of constraints can be expressed via vanilla JSON Schema keywords. For the weirder things, new keywords can be added. And
for anything that is onerous to type of, we have to remember that underneath
it's all JSON, and we know darn well how to munge that.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, May 16, 2022 · 7 min readGet started with JSON Schema in Node.jsGo back to blogSimon Plenderleith@simonplendon this page
A powerful validation duo

Creating a schema and validating data






Schema generation

Try it yourselfWrapping upOriginally published at simonplend.com.
The first step in putting together request validation for your Node.js application is finding a way to create flexible validation rules. When you try to pick a validation library to use, it's often more difficult than you expect. They're all different from each other, and it's not clear what benefits one has over another.Perhaps you've tried to build your own custom validation before, but it starts to feel messy and difficult to maintain. You want to put some reliable validation in place and move on to building exciting new features in your application. Why is adding in validation such a headache?!In this article, we're going to learn how the JSON Schema specification can help us create flexible validation rules. We'll write a schema which describes the format we expect data to be in, then we'll write some JavaScript that uses the Ajv validator library to validate our data against it.Let's get started!A powerful validation duoThe JSON Schema specification defines a JSON-based format for describing the structure of JSON data. This includes validation keywords, such as type, required and properties. These keywords allow us to create a definition of the format we expect data to be in. This is a "schema". It can be as simple as: schema{ "type": "string" }﻿
To validate data against a schema, we need to use a validator library which implements the JSON Schema specification. The Ajv (Another JSON Schema Validator) library is the most popular JSON Schema validator for client and server side JavaScript, downloaded over 50 million times every week from npm.Let's get hands-on and see what validating data with JSON Schema and Ajv looks like.For a more detailed introduction to JSON Schema, check out the blog post JSON Schema in 5 minutes.
Creating a schema and validating dataFirst, we need to run the command npm install ajv to install the Ajv library.Then we can jump straight into defining a JSON schema. It describes the structure and types we expect:1const iceCreamSchema = {
2  type: "object",
3  properties: {
4    flavour: { type: "string" },
5    price: { type: "number" },
6    stock: { type: "number" },
7  },
8  required: ["flavour", "price", "stock"],
9};
10
Now we'll define the data which we want to validate:1const iceCreamData = {
2  flavour: "Pistachio",
3  price: 1.99,
4  stock: null,
5};
6
Then we'll import the Ajv library and create a new Ajv instance:1import Ajv from "ajv";
2
3const ajv = new Ajv();
4
And use it to validate the data against our schema:1const isDataValid = ajv.validate(iceCreamSchema, iceCreamData);
2
Lastly, we'll add some code to handle the validation results:1if (isDataValid) {
2  console.log("The ice cream data is valid! 🍨");
3} else {
4  console.error("The ice cream data is invalid:", ajv.errors);
5}
6
When we put this code together and run it, we get the following output:1The ice cream data is invalid: [
2  {
3    instancePath: '/stock',
4    schemaPath: '#/properties/stock/type',
5    keyword: 'type',
6    params: { type: 'number' },
7    message: 'must be number'
8  }
9]
10
Pretty slick, huh?Alright, we've created a schema which describes the structure and types we expect, validated data against it, and handled any validation errors. So far so good!A note from the editor: In the latest major release of AJV, a "strict mode" was introduced, enabled by default, which sometimes throws an exception when a valid JSON Schema is used. If you run into problems with strict mode related errors, check out the documentation for details on how to disable it, or even specific rules. We feel this may be better as linter functionality, however it does help prevent accidental errors in schema authorship. - Ben Hutton
As one final step, we'll look at how we can potentially improve the way we create our JSON schema.Schema generationJSON schemas are an expressive way of defining validation rules, but writing schemas "by hand" can sometimes get a bit much. There's a handy library called fluent-json-schema which can help us generate our JSON schemas. Let's give it a try.Note that while using a tool to define validaiton rules to be converted into a JSON Schema gives you control, other methods of generating JSON Schema, for example from your instance data, often leaves you with a partially complete or sometimes incorrect JSON Schema. Other approaches might be better called "scaffolding" rather than "generating", as you'll have the basics, but still have work to do before it's complete and useable.First we need to install the library by running the command npm install fluent-json-schema. Then we can import it and use it to generate our schema:1import S from "fluent-json-schema";
2
3const iceCreamSchema = S.object()
4  .prop("flavour", S.string().required())
5  .prop("price", S.number().required())
6  .prop("stock", S.number().required())
7  // This method call returns the generated schema as an object.
8  .valueOf();
9
If we console.log the iceCreamSchema object, we can see the JSON schema we've generated: schema{  "$schema": "http://json-schema.org/draft-07/schema#",  "type": "object",  "properties": {    "flavour": { "type": "string" },    "price": { "type": "number" },    "stock": { "type": "number" }  },  "required": ["flavour", "price", "stock"]}﻿
You'll notice this generated schema is almost identical to the iceCreamSchema we previously wrote "by hand". We can replace our handcrafted schema with this generated schema and the validation will behave in the same way as it did before.If we're writing our applications in TypeScript, the TypeBox library is a great alternative to fluent-json-schema.Schema generation is down to your personal preference: some folks like to write raw JSON schemas "by hand", whereas others prefer to use a library which helps generate them. Try out both and pick whichever approach works best for you.Try it yourselfBrowse the code on GitHubRun the code in your browser with StackBlitz (works in Chrome, Edge or Brave browsers)Take on the validation coding challenge! 🏆Wrapping upWe can use Ajv as a standalone library or we can integrate it with the framework we're using to build our Node.js application. Some Node.js frameworks even provide JSON Schema based validation with Ajv built in.When we combine JSON Schema and Ajv, we have a flexible solution for implementing validation in our Node.js applications:Learn once, use everywhere. The JSON Schema specification is cross-platform, and there are validation libraries available for every popular programming language. We're not locked into a library, framework or language. Once we've learnt the fundamentals of JSON Schema, we can use it everywhere.Portability. Because JSON Schema is cross-platform, even if we decide to rewrite our applications in another framework or language, we can take our schemas with us.Speed. Under the hood, Ajv compiles our JSON schemas into JavaScript code. This improves the performance of repeated validation of data against a schema. For example, schemas can be compiled by Ajv when our Node.js application starts. HTTP request data which the application receives can then be validated against the pre-compiled schemas.Active and supportive community. There's an active community of folks on Slack who are happy to help out (the JSON Schema website has a link you can use to join).Further readingIf you'd like to learn more about JSON Schema, you might find these links helpful:How to handle request validation in your Express API. If you're using the Express Node.js framework, I wrote this guide to help you integrate the Ajv library into your applications.Fastify framework validation documentation. The Fastify Node.js framework integrates the Ajv library, making it straightforward to add validation with JSON Schema.Understanding JSON Schema. A free online book which will teach you the fundamentals of JSON Schema. Also available in PDF format for offline reading.JSON Schema Cheat Sheet. I created this cheat sheet PDF as a handy reference for JSON Schema validation keywords. Use it to give you a helping hand any time you're writing schemas.Photo by Manik Rathee on Unsplash.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, May 9, 2022 · 5 min readHow Tyler Technologies reduced its client feedback loop with JSON SchemaGo back to blogBen Hutton@relequestualon this pageChallengeSolutionImpactKey Impact ResultsTyler TechnologiesBenefits in developmentChallengeWith multiple government clients, Tyler Technologies faces the continual challenge of meeting stringent differing requirements defined in law. Building custom rules for each client was very time-consuming, and Tyler Technologies were seeking to create a multi-tenancy application solution that could be customised for each client without needing custom code.Tyler's multi-tenant application solution needed an easy way to define custom data and validation rules, giving power to the client, rather than having to make heavy investment in custom development work."This way we can spend our time providing business value and innovating the application instead of handling all the custom work manually." - Andres Moreno, Lead Software Engineer at Tyler Technologies.SolutionJSON Schema allowed Tyler Technologies to create and maintain different model definitions for each client in a simple and understandable format.JSON Schema was chosen as a viable solution for defining data structures. Tyler found wide adoption of the standard across the industry, partial familiarity from using OpenAPI, and broadness of open-source tools providing rich functionality."With JSON Schema, Formly, and AJV we were able to get the functionality we needed to render and validate fields dynamically for each tenant without requiring a developer to do it!" - Andres MorenoFormly allows for the dynamic generation of forms from JSON Schema, enabling each client to have unique forms based on their unique definitions. AJV allowed for the validation of data from those same forms on the server-side."We are focused on API-First development, so we needed a way to allow validation on the server-side for when our API was used directly rather than through the generated forms," Andres continued.Further, AJV has options to take advantage of annotations such as the default keyword, filling in missing attributes, and optionally filtering out data not defined in the schema. These options allowed Tyler Technologies to provide additional value to customers, catering to broader requirements.ImpactThe effort required to develop and deliver custom work for customer-specific requirements was reduced. Existing schemas can now be easily updated using APIs, without the need to wait for a full deployment cycle.A new custom field would need to be fully identified and get approval, sent to the development team, verified by QA, and finally deployed to the production environment. "This process can span multiple days or even weeks," explains Andres.Rather than a full development cycle and release process, updating a JSON Schema takes just a few minutes by those that know JSON Schema, dramatically reducing the time to resolution of bugs related to custom data structures.Key Impact Results"Showing added value to clients in minutes, rather than days or weeks.
""From what used to be a multi-day/week process, to being able to get something in front of the client within minutes," says Andres.Tyler TechnologiesTyler Technologies is a leading provider of end-to-end information management solutions and services for local governments. In recent years they've been playing a key role in the digital transformation of the public sector."We empower the public sector to create smarter, safer, and stronger communities. Our team is providing the most innovative solutions to the processes each of our customers have without reinventing the wheel; We choose to assemble instead of building everything ourselves."Custom development work for each client is a big investment, and a more cost-effective and performant approach was required.Benefits in development"We are very confident that JSON Schema has solved the challenges that we had faced as we started these projects" - Andres MorenoInitially using Formly's proprietary configuration format to dynamically generate forms, Tyler needed validation of the resulting data on the server-side. Creating different configurations for the client-side and server-side, which needed to match, wasn't going to give Tyler the scalability they needed.While investigating, they discovered that Formly also supported configuration using JSON Schema. The same JSON Schema could be used for validation on the client and server sides. With minimal research and prototyping, it became clear using JSON Schema was going to be useful.After demonstrating how JSON Schema could be easily used to build an extensible application, other teams at Tyler saw the appeal of using a single configuration to both dynamically generate forms and perform validation on the submitted data.JSON Schema is now a core concern when developing existing and new applications."We are very confident that JSON Schema has solved the challenges that we had faced as we started these projects. We can say with certainty that we are going to continue using JSON Schema as the core of the application for any future applications that are built using the cloud infrastructure that we have put in place," explains Andres.Thank you to Andres Moreno, Lead Software Engineer, and Tyler Technologies, for allowing and enabling us to share this case study with you.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, March 21, 2022 · 16 min readIt all starts with applicability - JSON Schema Fundamentals part 1Go back to blogBen Huttonon this pageApplicator keywordsStarting with everythingSubschema application - Validating Objects and ArraysValidating Objects







Validating Arrays
Apply but modify - Boolean logic with subschemas



Putting everything together - Avoiding oneOf pitfalls


Now you tryIn summaryPostambleUseful links and further reading"Validation begins by applying the root Schema to the complete instance document. Applicator keywords apply subschemas to the instance location." - Borrowed from JSON Schema in 5 minutes.The primary use case for JSON Schema is validation. Therefore it's imperative to understand precisely how the validation process happens. Let's take a little time to properly grasp the fundamental JSON Schema concept of Applicability.Applicator keywordsJSON Schema consists of many keywords. These keywords can be broken down into categories, one of which is "applicator". In the physical sense, an "applicator" is a thing you use to introduce one substance to another. For example, a cloth might be used to introduce polish to a nice wooden table. The cloth is the applicator. The polish is applied to the table via the cloth.Applicator keywords in JSON Schema are similar to the cloth, but they are applying Schemas to locations in the instance data (or just, "instance locations").Starting with everythingThe validation process for JSON Schema begins with applying the whole JSON Schema to the whole instance. The result of this application (Schema to instance) should result in a boolean assertion, which is the validation result.A JSON Schema may be a Boolean or an Object. In the introductory article mentioned above, we noted how a Boolean Schema of true or false resulted in the same assertion result (true and false respectivly) regardless of the instance data. We also noted how the equivalent Object Schemas were { } and { "not": { } } respectively. (The not keyword inverts the assertion result.)Vocabulary checkAn "assertion" is a statement of fact. This is used in reference to the result of testing in Computing. The test might be called "X is 1". If the test passes, the assertion is true!When we talk about the whole Schema in terms of application, we usually refer to it as the "root Schema". This is because the other Schemas which are applied to specific instance locations are different, and we call them "subschemas". Differentiating between the root Schema and subschemas allows us to communicate with clarity which JSON Schema we're talking about, and when to use the Schema as part of the validation process.The following examples assume to be using JSON Schema 2020-12. Where there are things you should know about previous versions (or drafts) of JSON Schema, it will be highlighted.Subschema application - Validating Objects and ArraysIf your JSON instance is an Object or an Array, you'll likely want to validate the values of the Object or the items in the Array. In this introduction, you'll be using the properties and items keywords, and subschemas.Validating ObjectsLet's jump into an example. Here's our instance data.data{  "id": 1234,  "name": "Bob",  "email": "[email protected]",  "isEmailConfirmed": true}﻿
To create the basics of our Schema, we duplicate the structure and place it under the properties keyword, change the values to empty objects, then define the type.data{  "properties": {    "id": { "type": "number" },    "name": { "type": "string" },    "email": { "type": "string" },    "isEmailConfirmed": { "type": "boolean" }  }}﻿
The value of properties must be an Object, and the values of that Object must be Schemas. These Schemas are subschemas.OK, let's check our Schema does all we need it to. What happens when our instance is missing, for example, the email field? Validation still passes. This is because subschemas in properties are applied to the instance values ONLY when the keys match.data{  "id": 1234,  "name": "Bob",  "email": "[email protected]",  "isEmailConfirmed": "true"}// isEmailConfirmed should be a Boolean, not a string.﻿﻿// Will cause validation error.﻿
We need to make sure we define the appropriate constraint if we want any keys to be required in our object. We can do this by adding the required keyword to our Schema.data{  "properties": {    "id": { "type": "number" },    "name": { "type": "string" },    "email": { "type": "string" },    "isEmailConfirmed": { "type": "boolean" }  },  "required": ["id", "name", "email"]}﻿
We can now be confident that if our required fields are missing, validation will fail. But what if someone makes an error with optional fields?data{  "id": 1234,  "name": "Bob",  "email": "[email protected]",  "isEmaleConfirmed": "true"}// Typo for key "isEmaleConfirmed".﻿﻿// Validates because of applicability.﻿
Our field isEmailConfirmed has a STRING value rather than a Boolean, but validation is still passing. If you look closely, you can see the key is spelt incorrectly "isEmaleConfirmed". Who knows why, but here we are.Luckily, picking this up with our Schema is simple. The additionalProperties keyword allows you to prevent properties (or keys) from being used in an object beyond those defined in properties.data{  "properties": {    "id": { "type": "number" },    "name": { "type": "string" },    "email": { "type": "string" },    "isEmailConfirmed": { "type": "boolean" }  },  "required": ["id", "name", "email"],  "additionalProperties": false}﻿
The value of additionalProperties is not just a Boolean, but a Schema. This subschema value is applied to all values of the instance object that are not defined in the properties object in our example. You could use additionalProperties to allow additional properties, but constrain their values to be a String.There is a little simplification here to help us understand the concept we're looking to learn. If you want to dig a little deeper, check out our learning resources on additionalProperties.Finally, what if we expect an Object, but are given an Array or another non-object type?data[  {    "id": 1234,    "name": "Bob",    "email": "[email protected]",    "isEmaleConfirmed": "true"  }]﻿﻿// An array is not an object...﻿
You may find it surprising that this would pass validation! But WHY!?The three keywords we've explored so far, properties, required, and additionalProperties only define constraints on Objects, and are ignored when encountering other types. If we want to make sure the type is as we expect (an Object), we need to specify this constraint too!data{  "type": ["object"],  "properties": {    "id": { "type": "number" },    "name": { "type": "string" },    "email": { "type": "string" },    "isEmailConfirmed": { "type": "boolean" }  },  "required": ["id", "name", "email"],  "additionalProperties": false}﻿
In summary, for the soundest validation, we must express all the constraints we require. Given the properties keyword only applies its Schema values when keys match, and only when the current instance location is an Object, we need to make sure other constraints are in place to capture those other possible situations.Note, type takes an Array of types. It may be that your instance is allowed to be an Object or an Array, and constraints for both can be defined within the same Schema Object.Validating ArraysIn this introduction, we're only going to be covering how things work for JSON Schema 2020-12. If you're using a previous version, including "draft-7" or prior, you will likely benefit from digging a little deeper into the learning resources for Array validation.Let's step back to our previous example data, where we were provided with an Array as opposed to an Object. Let's say our data is now only allowed to be an Array.To validate every item in the array, we need to use the items keyword. The items keyword takes a Schema for its value. The Schema is applied to all of the items in the array.data{  "items": {    "type": ["object"],    "properties": {      "id": { "type": "number" },      "name": { "type": "string" },      "email": { "type": "string" },      "isEmailConfirmed": { "type": "boolean" }    },    "required": ["id", "name", "email"],    "additionalProperties": false  }}﻿
As with the applicability rules of properties, the value Schema of items is only applicable if the instance location being validated is an array. If we want to make sure it's an array, we need to specify the constraint by adding "type": ["array"] to our Schema.There are other keywords that are applicable to arrays, but If I continue to explain all of them in detail, this article might start to turn into a reference book! Moving on...Apply but modify - Boolean logic with subschemasJSON Schema applicator keywords can do more than just apply a subschema and take the resulting Boolean assertion. Applicator keywords can conditionally apply subschemas, and combine or modify any resulting assertions using boolean logic.Let's look at our most basic applicator keywords: allOf, anyOf, and oneOf.Each of these keywords takes an array of schemas as their value. All of the schemas in the array are applied to the instance.We'll take each in turn and explore how they are different.After applying each schema item from an allOf array, the validation (assertion) results are combined with a logical AND. As the keyword implies, all of the schemas in the array must result in a true assertion. If any one of the schemas asserts false (fails validation), the allOf keyword also asserts false.This sounds simple, but let's look at some examples.data{  "allOf": [true, true, true]}﻿
data{  "allOf": [true, false, true]}﻿
Remember: A Boolean is a valid schema that always produces the assertion result of its value, regardless of the instance data.Our first "allOf" example shows the array having three subschemas, which are all true. The results are combined using the boolean logic AND operator. The resulting assertion from the allOf keyword is true.Our second "allOf" example shows the second item in the array is a false Boolean Schema. The resulting assertion from the allOf keyword is false.The true and false Boolean Schemas in this example could be any subschemas that pass or fail validation. Using Boolean Schemas allows us to easier demonstrate the use of boolean logic for these applicator keywords.Let's take the two examples again, but use anyOf rather than allOf.data{  "anyOf": [true, true, true]}﻿
data{  "anyOf": [true, false, true]}﻿
The assertion results of each Schema are combined using the boolean logic OR operator. If ANY of the resulting assertions are true, anyOf returns a true assertion. If ALL of the resulting assertions are false, anyOf returns a false assertion.Regardless of if this feels intuitive or not, let's look at how these two keywords behave in the form of a truth table. It's going to get a little mathsy, but not much, I promise! (This may seem like overkill or a deep dive, but it's fundamental. Stay with me.)Truth Table for "allOf"Truth Table for "anyOf"Truth tables are sometimes helpful in understanding boolean logic, for example looking at equivalencies, such as !(A AND B) is the same as !A OR !B.Our two truth tables above represent our allOf and anyOf keyword's boolean logic. A, B, and C represent the three subschemas from our earlier example and all possible combinations of their assertion results. T and F represent true and false assertions.(Remember, the values are subschemas, but we used Boolean Schemas to make the assertion result obvious).The chevrons are fancy maths things where the up chevron represents "AND" and the down chevron represents "OR". The right-hand column represents the overall assertion result based on the boolean logic in the header.We can visually see how these two keywords combine the boolean assertion results of their subschemas.allOf - If "all of" the assertions are true, then the combined assertion is true, otherwise false.anyOf - If "any of" the assertions are true, then the combined assertion is true, otherwise false.But what about oneOf? The boolean logic used for that keyword is an exclusive OR... sort of. "XOR" for short is often used with electronics but doesn't translate exactly to "one and only one can be true", which is the intent with oneOf in JSON Schema.Here is our truth table for two inputs (If the array value of oneOf only contained two subschema values).Truth Table for XORLooks fine, right? But what if we add another "input", making it an odd number.Truth Table for XOR with three inputsIt looks MOSTLY correct, but notice, if all the assertions are true, the resulting assertion is also `true'! That's not what we want, but that is the mathematically correct result. So, we have to extend the logic definition to include "... AND NOT(A && B && C)". Our resulting truth table looks like this.Truth Table for "oneOf" - (a xor b xor c) & ! (a && b && c)Much better! But why should you care?Well, now we have the vehicle to understand a pretty common problem, and all the new (or revised) knowledge from above to solve it.Putting everything together - Avoiding oneOf pitfallsLet's go back to our array of people data, modify it, and say it represents an array of teachers and students.data[  {    "name": "Bob",    "email": "[email protected]",    "isStudent": true,    "year": 1  },  {    "name": "Alice",    "email": "[email protected]",    "isTeacher": true,    "class": "CS101"  }]﻿
To start, let's do the same as we did when creating our first schema. Copy the instance, nest under properties. We also need to nest those Object Schemas under oneOf, the same as how we see allof being used. And nest all that under items to apply schema to every item in the array... Yeah, let's just take a look...data{  "items": {    "oneOf": [      {        "properties": {          "name": { "type": "string" },          "email": { "type": "string" },          "isStudent": { "type": "boolean" },          "year": { "type": "number" }        }      },      {        "properties": {          "name": { "type": "string" },          "email": { "type": "string" },          "isTeacher": { "type": "boolean" },          "class": { "type": "number" }        }      }    ]  }}﻿
Now let's see what happens when we try to validate our instance with our new Schema...1should match exactly one schema in oneOf.
2oneOf at "#/items/oneOf"
3Instance location: "/0"
4
Yikes! That's not what we want!But why isn't it working? Why isn't the instance passing validation?What do we know?The validator is "failing fast". This means it's stopping after the first error.The instance location being evaluated is the first item in the array.The error tells us that the first item in the array doesn't match exactly one of the subschemas found in our oneOf. This means it validates successfully for BOTH.The first item in our instance array is identifying as a student, so should only pass for the first subschema in oneOf. So why is it valid when applying the second subschema?Let's recap. The properties keyword applies its schemas (which are the values) based on matching keys in the instance Object. The implication we explored earlier is that just having a key in the properties object doesn't make it required in the instance.When you apply the second subschema in oneOf to the instance, there are no constraints that cause it to fail validation, so it passes validation. If all subschemas consider the instance location to be valid, oneOf fails validation, because it's not "one and only one", as in "true exclusive OR`.Now you tryWe can use the same approach as before to make sure our subschemas have sufficient constraints. Give it a try, and see if you can manage to make the validation work as expected.The link is pre-loaded with your starting Schema and instance. Let me know if you get stuck via Slack or X.In summarySchemas will almost always have some subschemas.Identifying where subschemas are and how they are applied to the different instance locations, unlocks the ability to assess and evaluate problematic schemas.You can take almost any subschema as a schema by itself, and test the validation process. (This might not always be possible when the subschema has references.)Applicator keywords can not only relay the assertion results from subschemas but combine and modify them in different ways, usually using Boolean logic, to provide their own assertion.PostambleI've really enjoyed being able to share the first of our fundamentals series with you, and I hope you find it valuable enough to come back for the next article in the series.You can find all of the example instances and schemas in the JSON Schema Fundamentals repo.All feedback is welcome. If you have questions or comments, you can find me on the JSON Schema Slack or reach out to me on X@relequestual.Useful links and further reading"Logical connective" (Those fancy mathsy symbols for boolean logic, with Venn diagrams!)WolframAlphaTo visualise truth tables, copy the formular in the images in this article, or try your own. Can also be used for many other "computational Intelligence" related things.JSON Schema in 5 minutes articleJSON Schema in 1 minute videoUp to date getting started guideWeekly Office Hours (Tuesday, 15:00 UTC)Open Community Slack ServerCommunity GitHub DiscussionsList of implementationsHuman-friendly documentation for understanding JSON SchemaJSON Schema live playground (ajv) for draft-07 with shareable linksJSON Schema live playground (hyperjump validator) for all drafts (from draft-04)Links to RFC specification documentsPhoto by Heidi Fin on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, February 11, 2022 · 8 min readJSON Schema joins the OpenJS Foundation and 2022 updatesGo back to blogBen Huttonon this pageJoining the OpenJS Foundation
OpenJS Foundation announcement
JSON Schema is hiring! (at Postman)
Regular calls
Community, Slack, and GitHub Discussions
JSON Schema Blog
JSON Schema on YouTube
Open Objectives
In Summary
Joining Postman to work full time on JSON Schema has been a great move for me personally, and I feel for the JSON Schema project. Working full time on JSON Schema has been something I never expected, but I'm grateful and honoured to be able to do.It's been almost a year, and one of the first meetings I organized was to chat with the OpenJS Foundation to learn more and discuss the potential for JSON Schema to join the foundation. That's why it gives me great pleasure to announce that JSON Schema has joined the OpenJS Foundation!I'll give a few other small updates, but joining the OpenJS Foundation is our headline.Joining the OpenJS FoundationThe application to join could have been put in a year ago, but that wouldn't have been in line with the way we operate, and we wanted to do it right. JSON Schema works as a loose collective of individuals looking to form general consensus, and act accordingly.There had long been a question over where JSON Schema would call home in terms of belonging to an organization. Would we formally join the IETF or the W3C, or maybe even some other open source / open standards organization? While myself and others had done some investigating and had a few calls, we were still unsure. We had made a few connections and could pick up threads again if required.However, with the prospect of working on JSON Schema full time, I decided we should re-engage with the OpenJS Foundation. I wanted to provide confidence to the core team and community that JSON Schema would remain neutrally owned, and have an assurance of continuation should myself or others vanish from the space.You can read my full proposal and report in a JSON Schema Community GitHub Discussion: https://github.com/json-schema-org/community/discussions/28I primed the application, which was then reviewed and revised by the team and community. You can read the full application in our Community GitHub Repository: https://github.com/json-schema-org/community/blob/main/docs/openjsf/application.md
OpenJS Foundation announcementHere's the majority of the OpenJS Foundation announcement regarding JSON Schema joining the foundation. You can read the full announcement here: https://openjsf.org/blog/2022/01/31/json-schema-joins-openjs-foundation/JSON Schema is the newest technical project hosted under the OpenJS Foundation!JSON Schema is a vocabulary that allows you to annotate and validate JSON documents. It defines how a JSON should be structured, making it easy to ensure that a JSON is formatted correctly, and it is useful for automated testing and validating. In addition, JSON Schema provides clear human- and machine-readable documentation."We are thrilled to welcome JSON Schema into the OpenJS Foundation. Building a community requires dedicated people and great technology, which JSON Schema already has. It also requires a reliable structure for open governance and legal support that allows worldwide communities to grow. As the vendor-neutral home to almost 40 open source projects, JSON Schema already fits in well with our ecosystem of projects," said Robin Ginn, OpenJS Foundation executive director. "We look forward to providing resources and support to JSON Schema to help their community to grow.""JSON Schema's supportive community has in part enabled us to get this far. This has been critical to its success. JSON Schema is primarily a validation tool, plus it's gaining additional uses such as generating forms, generating databases, or generating other UIs. We want to make sure the community and technology can continue to grow, possibly in unforeseen directions," said Ben Hutton, JSON Schema specification lead at Postman. "By joining the OpenJS Foundation, we gain the community structure and support - with a strong focus on open governance - to continue to build and enlarge the community. We remain committed to being an interoperability focused standard, and want to provide assurance that JSON Schema will remain open and owned by the community that needs it.""The OpenJS Foundation continues to grow, and JSON Schema is a great addition. It is a key foundational technology, and by joining the OpenJS Foundation, it now has a strong home for further growth," said Todd Moore, OpenJS Foundation Board Chairperson and Chief Developer Advocate IBM. "We are looking forward to working with and supporting JSON Schema.""The OpenJS Foundation is continuing to support key technologies that JavaScript communities rely upon. JSON Schema is an important addition," said Joe Sepi, Open Source Program Director at IBM, and chairperson of the OpenJS Foundation Cross Project Council." JSON Schema is a great example of how interconnected JavaScript technologies can be. Providing a structure for sharing data is critical.""The Cross Project Council carefully considers the projects that join our neutral home at the OpenJS Foundation. We are pleased to have JSON Schema onboard so we can support the project's growth, and the maintainers can contribute their expertise to the broader JavaScript ecosystem through OpenJS," said Eemeli Aro, Staff Software Engineer at Mozilla, and OpenJS Cross Project Council (CPC) member.JSON Schema will be designated "At-Large," which includes many different types of projects but is most often used for stable projects with minimal needs. They are now officially in the incubation process where projects complete their on-boarding to join the foundation.
JSON Schema is hiring! (at Postman)On joining Postman, one thing we discussed is the potential to bring on more people to work on JSON Schema full time. While JSON Schema currently does not provide or maintain any software as such, that could change.In the immediate future, we're looking to hire for Software Engineer and for Technical Community Manager / Developer Relations roles.Feel free to reach out to me directly via X or Slack should you have any questions.
Regular callsJSON Schema now holds two regular calls. We hold weekly Office Hours and twice monthly Open Community Working Meetings.Office Hours are 15:00 UTC every Tuesday. The objective is to provide a space for people to ask questions or just chat about JSON Schema in real time with video.Open Community Working meetings are every 1st and 3rd Friday of the month. We have split the time across multiple zones, but we will be consolidating the time to 12:00 PT for both calls moving forward due to low attendance.We still want more people to join us on these calls. If you want to have a voice in the future of JSON Schema, please join!Links to both regular calls can be found on our home page: https://json-schema.org
Community, Slack, and GitHub DiscussionsWe started using GitHub Discussions as a place for our community outside of Slack. The free tier of Slack limits history, and the valuable answers and discussions are lost. While they can be deep-linked, people still have to be registered with the JSON Schema slack to read the content, and it's not search engine indexed.After joining the OpenJS Foundation, I reached out to Slack again to see if they would bless us with a free Pro account. This time, they agreed! Enjoy access to the full history of our Slack server!As we expand the ways in which we interact with our community, it feels fitting to enable the community to discuss how they would like to see things develop, and have an open space to see and read proposals. Our Community repo is that space: https://github.com/json-schema-org/community
JSON Schema BlogJSON Schema now has a blog! https://json-schema.org/blogWe wanted a space to provide best practice examples, thought pieces, case studies, and updates. You may even be reading this article on the blog itself!Currently there are only a handful of articles, but several more case studies are in the works.The blog has an RSS feed, so if you're still using an RSS reader you can catch every new update.There were long time plans to rebuild the website as a whole, but our need for a blog escalated after some discussion around referencing on X. Our first article was a joint post between myself and Mike Ralphson on the new JSON Schema bundling process.We've published one case study in two languages, English and Japanese.If you're interested in writing a guest post or collaborating on a case study, please reach out.
JSON Schema on YouTubeIn addition to our written case studies, we wanted to provide some easy watching chat style case studies. This series is called JSON Schema in Production.We needed a YouTube channel to host the videos, which you can now subscribe to - We need 100 subscribers to claim a custom URL, so any sharing is appreciated.
Open ObjectivesWith updates to GitHub Projects, I figured I'd see if they could be useful for tracking JSON Schema work in a more public way. Ultimately, I've ended up using task lists in issues, which seems to be working just fine for now. (Projects are still in beta.)Postman uses the Objective, Key Results (ORK) approach to defining work. I created OKRs for JSON Schema.Here is a Project view for 2022 Q1 OKRs grouped by objective.Here's the Issue which lists all the Key Results as individual tasks.
In SummaryIf you've read this far, you must be interested in what we're doing at JSON Schema and our plans for the future.The most effective way to keep up to date is to join our Slack server. We're also using X, which is our primary way to reach out to our community when we have questions.There are lots more things we want to bring you, including essential tooling to enable a modern JSON Schema ecosystem.
Photo by Abraham Barrera on Unsplash.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubFriday, January 21, 2022 · 9 min readJSON Schema in 5 minutesGo back to blogBen Hutton@relequestualon this pageJSON What?JSON SchemaA JSON Schema (document)Introduction to constraints



The Object SchemaAssertions





Applicators



RecapNext steps / Further ReadingIf you have never heard of JSON Schema till now, then you are in the right place to learn more.
If you are confident in using JSON Schema, this article still holds some value for you, and you'll likely still learn something new.By the end of this article, you will:Understand what JSON Schema isKnow what JSON Schema can doUnderstand some key terminology for talking about JSON SchemaKnow some of the basics of how JSON Schema worksOutshine even those with years of JSON Schema experience (hopefully)Although this is a technical introduction, we won't cover writing any code today. But we will link you to a list of implementations in almost any programming language.JSON What?Primarily, JSON Schema is used to validate data.
The sorts of data JSON Schema can validate is data encoded in JSON.JSON stands for JavaScript Object Notation and is a subset of Javascript.
JSON is both human and machine-readable, making it a popular format choice for data interchange.JSON Schema is both the name given to the project and the artefact (A JSON Schema) that defines the required validation. The validation rules are expressed by defining constraints against the JSON data.The JSON data you are validating is called a "JSON instance".JSON SchemaJSON Schema the project is located on GitHub under the organization name "json-schema-org". It is comprised of several git repositories used to track changes and enable collaboration on the specification and supporting resources.The JSON Schema specification is made up of technical specification documents currently published canonically through the Internet Engineering Task Force (IETF) as a series of "personal drafts". A "personal draft" is the category given to documents published on the IETF which are from an IETF working group.A JSON Schema document is written in JSON itself. Being written in JSON means that it can be read by almost every programming language, making it an interoperable validation solution. It can also be written using other formats which translate to JSON, or using code that can serialize to JSON.A JSON Schema (document)We mentioned JSON Schema is itself JSON. It used to be that JSON had to be an Object or an Array at the root level, but today, it can also be any of the allowed values.A JSON Schema may be an Object or a Boolean. The Boolean form results in the same value as the validation assertion result. The Object form allows for keywords and values to express constraints for validation.JSON Schema is constraints based, meaning that anything not defined (or constrained) is allowed and considered valid.It may seem odd to allow Boolean values for a Schema, but we will explore why that's useful later. For now, let's look at our very first example Schemas.Introduction to constraintsdata{}﻿An empty Object
datatrue﻿A "true" Boolean value
datafalse﻿A "false" Boolean value
data{ "not": { } }﻿Not, empty Object
Let's take each Schema in turn and explain the validation result.The empty Object Schema expresses no constraints. Any instance data will always be considered valid.
The "true" Boolean Schema will always assert that the instance data is valid.As you may have guessed, the inverse is true for the remaining two Schemas. The "false" Boolean Schema will always assert false, and the "Not, empty Object" Schema will have the same result.The not keyword takes a JSON Schema as its value. These "schema values" are called subschemas. The subschema is applied to the instance data, and the resulting assertion is inverted. As we now know, the empty Object schema results in a "true" assertion, so the inverse is "false".The Object SchemaThe keys in an Object Schema are the JSON Schema keywords. These keywords have four classes: Identifiers, Applicators, Assertions, and Annotations. Some keywords don't fit into these classes, as they have unique functions.The $schema keyword has a unique function. The value of this keyword is a URI that identifies the JSON Schema Dialect to use when processing the schema.You can think of a JSON Schema Dialect as a set of keywords with a defined meaning. In most cases, the different dialects you will deal with are merely different versions (or "drafts") of JSON Schema.It is best practice to define the JSON Schema Dialect in use using the $schema keyword. In doing so, implementations should throw an error if they find a version of JSON Schema that they do not support.If your Schema does not define the Dialect of JSON Schema it is using, implementations may pick any dialect. This may result in false positives when used with an implementation that does not support that version.In this introduction, we will use the 2020-12 version of JSON Schema, however, most of what you will learn applies to almost all of the versions used in production today.The 2020-12 JSON Schema Dialect URI is https://json-schema.org/draft/2020-12/schema.AssertionsRemembering that JSON Schema provides constraints based validation, JSON Schema defines keywords that, when applied to the instance, provide an assertion result (pass or fail).The "const" keywordThe simplest assertion keyword is const. The value can be any valid JSON. To pass validation data must be the same as the value of const. Here's an example: schema{ "const": 1234 }﻿
data1234﻿compliant to schemavalid - It is exactly the same
data"foobar"﻿not compliant to schemainvalid - It is not the same
The "type" keywordAnother assertion keyword is type. Its value is an array of strings that are the allowed types. The types are the six primitive types defined by JSON, plus "integer". Let's look at an example. schema{ "type": ["object", "boolean", "null"] }﻿
data{ "ok": "yes" }﻿compliant to schemavalid - An Object is allowed.datatrue﻿compliant to schemavalid - A Boolean is allowed.datanull﻿compliant to schemavalid - Null is allowed.
data123﻿not compliant to schemainvalid - A Number is not allowed.data"foobar"﻿not compliant to schemainvalid - A string is not allowed.
These two assertion keywords are applicable to ANY type of data in JSON, but some assertion keywords are only applicable to specific types. If a keyword is NOT applicable to the instance data, it is ignored and performs no validation.The "required" keywordrequired is an assertion keyword that is only applicable for Objects. Let's explore the implications of this with some examples.{ "required": ["name"] } - Our JSON Schema
{ "name": "Bob" } - valid - "name" is in the Object.
{ "fullName": "Bob" } - invalid - "name" is missing from the Object.
"Bob" - valid - The required keyword only applies to an Object.
true - valid - Same as above.This may be surprising, but it allows for the composition of constraints that only logically otherwise make sense given a specific type of data.You should combine using type with other keywords in the same Schema to avoid type expectation mismatch.ApplicatorsValidation begins by applying the root Schema to the complete instance document. Applicator keywords apply subschemas to the instance location.The "properties" keywordThe most commonly used applicator keyword is properties, which has an object value, where the values are subschemas. Let's see it in action. schema{  "properties": {    "name": {      "type": ["string"]    }  }}﻿Our JSON Schema
data{  "name": "Alice"}﻿compliant to schemainstance has name, which is a string
data{  "fullName": "Alice"}﻿compliant to schemainstance object has no `name` property
data[ "name", 123 ]﻿compliant to schemainstance is not an object, therefore `properties` isn't applicable
The subschemas are only applied to the instance location where the key matches a key in the instance locations object.If you want to make sure the instance data is an Object, use the type keyword.If you want to make sure that the Object has the "name" property, use the required keyword.RecapThe most common reason a JSON Schema appears to not be working is the lack of the fully required constraints.JSON Schema is "constraints based", and keywords may only be applicable to the correct data types.
Using multiple keywords to tighten constraints allows you to make sure type-specific keyword mismatch is handled by a different keyword.Identifying subschemas, and knowing that Schemas can always be Boolean values allows you to confirm assumptions about correct applicability. Subschemas can always be tested on their own if required.Next steps / Further ReadingI hope you've found this very brief introduction to the fundamentals of JSON Schema beneficial in how you read, reason, and develop JSON Schemas.My recommendation for writing JSON Schemas today is to use VSCode. When a file is in JSON language mode, and a $schema value is added to a root object, VSCode provides auto-complete and IntelliSense  (Although this is limited to draft-07).Here are some places you may find helpful moving forward:Up to date getting started guideWeekly Office Hours (Tuesday, 15:00 UTC)Open Community Slack ServerCommunity GitHub DiscussionsList of implementationsHuman-friendly documentation for understanding JSON SchemaJSON Schema live playground (ajv) for draft-07 with shareable linksJSON Schema live playground (hyperjump validator) for all drafts (from draft-04)Links to RFC specification documentsPhoto by Saad Salim on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubMonday, January 17, 2022 · 11 min readクックパッド株式会社におけるJSON Schemaの活用事例Go back to blogBen Hutton@relequestualon this page挑戦解決策結果
主な成果クックパッド株式会社について
開発でのメリット挑戦クックパッドマートとは、クックパッド株式会社が力を入れて取り組んでいる新規事業のひとつです。生鮮食品を中心として扱っているECプラットフォームで、街の食材専門店や地域の生産者が、販売者としてクックパッドマートに参加しています。コンビニエンスストア・ドラッグストア・駅・マンションなどの様々な場所に、ユーザーの受け取り場所として専用の冷蔵庫が設置されています。ユーザーはアプリから注文を行い、冷蔵庫から生鮮食品を受け取ることができます。クックパッドマートでは、販売者が商品の登録や日々の出荷作業などを行うための機能を提供する販売者向け管理画面を開発しています。「商品の種類や状態によって異なる種類のデータを入力する必要がありますが、全項目が羅列されるフォームから適切な項目の入力を都度行うことはとても難しい状態でした。」とクックパッドマートの開発に携わっているエンジニアの塩出さんは語ります。商品の種類や状態に応じて、適切なフォームが出し分けされる仕組みが求められていました。また、フロントエンド側でフォームの出し分け制御がされるだけでは、不正なデータの登録を完全に防ぐことはできません。社内の運用メンバーが商品の販売開始前に審査を行っていましたが、商品審査の負担やミスを避けるために、バックエンド側でバリデーションされた上で商品が登録されることが望ましい状態でした。解決策開発チームでは、独自のコードを使用して複雑なフォームを生成することも検討しましたが、フロントエンドとバックエンドでのバリデーションの一貫性について懸念していました。そこで、共通の定義を作成するために、JSON Schemaが仕組みとして選択されました。「複雑なフォームをバリデーションできる仕組みとしてJSON Schemaを導入することにしました。」と塩出さんは言います。結果JSON Schemaにより、商品登録時の正確性や体験が改善され、商品審査にかかる運用の負担が大幅に軽減されました。また、JSON Schemaを利用することで、要件の変更に対して柔軟に対応することができるようになりました。「今後新しい要件が増えても、JSON Schemaの定義を更新するだけで解決し、フロントエンド側のフォームの出し分け制御ロジック・バックエンド側のバリデーションを容易に追加・更新することが可能な状態になりました。」と塩出さんは言います。
主な成果"品質保証に関する入力不備が10％から0％に
"主な成果として「以前は、新規登録商品の約10％で品質保証の項目の入力不備がありましたが、JSON Schemaの導入により、品質保証の項目の入力不備はほぼゼロになりました。」と塩出さんは言います。クックパッド株式会社についてクックパッドは、クックパッド株式会社がグローバルに展開している料理レシピ投稿・検索サービスです。世界の76か国で毎月平均1億人のユーザー数を誇り、34の言語をサポートし、日本では550万件以上のレシピが共有されている国内最大のレシピサービスです。クックパッドマートの冷蔵庫クックパッド株式会社のオフィステクノロジー企業であるクックパッド株式会社は、「毎日の料理を楽しみにする」というミッション実現に向けて様々な事業に取り組んでいます。料理は、人・地域社会・地球での生活に幸せと健康をもたらす大事なものであると考えています。クックパッドマートでは、新鮮で高品質の食材を手軽に入手できるようにすることで、料理をより良い体験にすることができると考えています。「おいしいものを新鮮なうちに」は、クックパッドマートの指針のひとつであり、ユーザーと生産者をより直接的に結び付けることを目指しています。新鮮な食材、おすすめを紹介する特集やレシピなど、ユーザーへ魅力的な提案をしています。代表的な商品のひとつには「キシっとした弾力ある食感とジュっと滴るミルク感は、フレッシュなモッツァレラならではの醍醐味です。」と記載されています。クックパッドマートは現在限られた地域でのみサービス展開されていますが、ユーザーが新鮮な食材を入手できるようにする仕組みだけでなく、事業規模の拡大に向けて、商品のひとつひとつの審査・承認にかかる運用コストの削減も重要です。
開発でのメリット「バックエンドとフロントエンドのアプリケーションに同じロジックを使用する必要がありました。最初は独自のJSONフォーマットの作成を考えましたが、多数のif文を自分たちで作成する必要が出てくるため、避けたいと思っていました。」""「JSON Schemaのおかげで、バックエンド側でのバリデーションとフロントエンド側のフォーム生成をとても簡単に実装することができました。とても素晴らしい体験でした！」と塩出さん。JSON Schemaを使用した結果、バリデーションおよびフォームの実装にかかる時間が半分以下で済んだ、と見積もっています
"開発者はDRY「Don't repeat yourself」という言葉をよく耳にします。「JSON Schemaの定義の構築のみに集中できました。その後は、JSON Schemaをサポートするライブラリによって、ほぼ全てが自動生成されました。最高の瞬間でしたね！」と塩出さんは語ります。ロジックの重複を減らすことで、フロントエンドとバックエンドの間で実装の不一致が起こりにくくなります。AIは多数のif文と比較されることがよくありますが、経験豊富なアプリケーション開発者は複雑さを軽減し、リスクを軽減しようとすることが多いです。多くの条件付きブロックを削除して複雑さを軽減することでコードレビューが簡単になり、継続的なメンテナンスタスクにもプラスの影響を与えました。「多くのエンジニアはif文を必要最小限に減らしたいのではないでしょうか。」と塩出さんは言います。私たちが目にする多くのJSON Schemaはとてもシンプルなものですが、ドキュメントを読む人に多大なる力を与えます。「JSON Schemaの構文の種類には本当に驚きました。型や文字列長などの単純な制約だけでなく、oneOfやIf-Then-Elseなどの複雑なものもありました。」と塩出さんは続けます。JSON Schemaはかなり前からありますが、条件付きのバリデーションはまだ新しいものです。あるデータ構造の制約を定義するために、複数のアプローチが存在することを理解できるようになると、JSON Schemaはより強力なものになります。「JSON Schemaの豊富な表現力を見つけたとき、JSON Schemaを自信を持って使うことができました。すごく良かったです！」塩出さん、本当にその通りです！JSON Schemaの活用事例の紹介に協力してくださった、エンジニアの塩出さんおよびクックパッド株式会社に深く感謝いたします。注：
本事例紹介の一部は、https://techlife.cookpad.com/entry/mart-json-schema にあるクックパッド株式会社による開発者ブログから許可を得て引用しています。Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubThursday, December 9, 2021 · 6 min readJSON Schema deduplicated complex logic and validation at CookpadGo back to blogBen Hutton@relequestualon this pageChallengeSolutionImpactKey Impact ResultsAbout Cookpad Inc.Benefits in developmentChallengeCookpad Mart is one of the new businesses that Cookpad Inc. is focusing on. It is an e-commerce platform that mainly deals with fresh food, and retailers in the city and local producers participate in Cookpad Mart as sellers. Dedicated refrigerators are installed as pick-up locations for users in various places such as convenience stores, drug stores, train stations, and condominiums. Users can place orders from the app and receive fresh food from the refrigerator.Cookpad Mart was developing a management screen for sellers that provided functions for sellers to register products and perform daily shipping operations."It is necessary to enter different types of data depending on the type and state of the product, but which information should be manually entered from the form in which all items are listed? It is very difficult to judge each time," says Kenshi Shiode, Engineer, Cookpad Mart Team. There was a need for a mechanism to sort out appropriate forms according to the type and condition of the product.In addition, it is not possible to completely prevent the registration of invalid data simply by controlling the distribution of forms on the front-end.
Although in-house operation members perform product screening before the product starts selling, it is desirable that the product is registered after being validated on the back-end side in order to avoid the burden of product screening and mistakes.SolutionThe team considered using custom code to generate complicated forms, but were concerned about consistent validation in the browser and on the server side. In looking to create a common Schema, JSON Schema was chosen as the mechanism. "We decided to introduce JSON Schema as a mechanism that can separate and validate complicated forms," says Kenshi.ImpactJSON Schema has improved the accuracy and experience when registering products, and has greatly reduced the operational burden of product screening.Using JSON Schema has reduced the burden of changing requirements. "Even if new requirements increase in the future, it can be solved by simply updating the JSON Schema definition, and validation of the form distribution control logic on the front-end side and validation on the back-end side can be easily performed," says Kenshi.Key Impact Results"From 10% of submissions being deficient, to zero.
""Previously, about 10% of newly registered products had incomplete input of quality assurance items, but with the introduction of JSON Schema, there are no deficiencies in the quality assurance items," says Kenshi.About Cookpad Inc.Cookpad is a global recipe sharing platform, boasting an average of 100 million people every month across the world, spanning 76 countries, supporting 34 languages, and boasting more than 5.5 million shared recipes. It is the largest recipe sharing service in Japan.Cookpad Mart FridgesCookpad OfficesAs a tech company, they work to "make everyday cooking fun". They believe that cooking is the key to a happier and healthier life for people, communities and the planet. Providing easier access to fresh quality ingredients enables better cooking, which is where Cookpad Mart has an impact."Delicious things while they are delicious" is one of the primary thoughts of Cookpad Mart, looking to connect customers more directly with producers. Fresh ingredients, recommendations, and recipes, make for an appealing proposition. "The crispy and elastic texture and the dripping milky texture are the real pleasures of fresh mozzarella," reads one example product.High quality ingredients that come from small producers tend to be difficult to find in the general market, making the most sensible approach to be mostly self-service listing. While Cookpad Mart operates in a limited area for now, the ability to scale and reduce manual review and approval is important, in addition to enabling customers to get the freshest ingredients.Benefits in development"We thought that we should use the same logic for backend and frontend applications. At first we thought about creating our own custom JSON Structure, but we had to write many if statements, and I do not want to imagine!"""JSON Schema helps us to implement backend validation and frontend form generation easily. It was quite an excellent experience!" explains Kenshi, estimating that time spent building validation has been cut in half as a result of using JSON Schema.
"One mantra developers often hear is DRY: 'don't repeat yourself'. "We could focus ONLY on JSON Schema definitions and everything has been automatically generated and applied," says Kenshi, "That was an excellent moment." Reducing duplication of logic reduces the likelihood of a mismatch in expectations between the client and server side.While AI is often compared to many if statements, experienced application developers usually seek to reduce complexity and therefore risk. Reducing complexity by removing many conditional blocks has made code reviews easier, and even had a positive impact on continuing maintenance tasks. "Engineers would like to reduce "if" statements as much as possible I think," quips Kenshi.Many JSON Schemas we see are kept quite simple, but there's a lot of power on offer for those willing to read the documentation. "I was really astonished with the vocabulary of JSON Schema," Kenshi continues, "There are not only simple expressions like type and length, but also complex expressions like oneOf and even If-Then-Else."Conditional validation is new when you consider the long life of JSON Schema. Once you unlock the understanding of the multiple approaches to applying subschemas, composition can be satisfying and powerful. "When I found the rich vocabulary prepared by JSON Schema, I felt confident to use JSON Schema. Very nice!" We happen to agree, Kenshi!Thank you to Kenshi Shiode, Engineer, and Cookpad, for allowing and enabling us to share this case study with you.Note:
Some parts of this case study are originally located in a blog posting by Cookpad, located at https://techlife.cookpad.com/entry/mart-json-schema. Used with permission.Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, December 8, 2021 · 8 min readValidating OpenAPI and JSON SchemaGo back to blogJason Desrosiers@jasondesrosierson this pageWhat is a JSON Schema dialect?The OpenAPI 3.1 Schema dialectValidating with the default dialect



Validating Schema Objects against the default dialect


Supporting multiple dialects

Starting with the release of OpenAPI 3.1, the dialect of JSON Schema used in
OpenAPI documents is configurable. By default, you get the OpenAPI 3.1 Schema
dialect, but you can choose to use draft 2020-12 or any other dialect if you
choose. This brings up the question of how to validate an OpenAPI 3.1 document
if one of its components (JSON Schema) is open-ended. In this article, we'll
cover how to configure the default JSON Schema dialect of an OpenAPI 3.1
document and how to validate that document, including JSON Schemas, no matter
which dialect(s) you choose to use.What is a JSON Schema dialect?Because not everyone is familiar with the term "dialect" in this context, let's
take a moment to define it before moving on. A JSON Schema dialect is any unique
incarnation of JSON Schema. This includes any official release of JSON Schema
such as draft-07 or draft 2020-12, but it also includes custom versions of JSON
Schema. OpenAPI has effectively had three dialects of JSON Schema introduced
with 2.0, 3.0, and 3.1. JSON Schema Dialects are compatible with the core
architecture of JSON Schema but may add keywords, remove keywords, or modify the
behavior of keywords.The OpenAPI 3.1 Schema dialectBy default, schemas in OpenAPI 3.1 are assumed to use OpenAPI 3.1's custom JSON
Schema dialect. This dialect includes full support for all draft 2020-12
features plus a few additional keywords and format values.Validating with the default dialectThere are two schemas available for validating OpenAPI 3.1 documents.
https://spec.openapis.org/oas/3.1/schema includes all the constraints for
validating the document except for schemas. You aren't expected to validate your
OpenAPI documents against this schema by itself. Think of this schema as an
abstract schema that is intended to be extended to include schema validation
support for the JSON Schema dialect you're using.That's why there's also https://spec.openapis.org/oas/3.1/schema-base that
extends the abstract schema with validation support for the OpenAPI 3.1 Schema
dialect. If you're using plain out-of-the-box OpenAPI 3.1, this is the schema
you want to validate your document against. If you want to use a different
dialect, keep reading to see how to extend the main schema to get validation
support for your chosen dialect.This is made possible by dynamic references which were added in JSON Schema
2020-12. The details of how dynamic references work is out of scope for this
article, but we'll cover enough for you to make your own concrete schemas for
any dialect you choose to use in your OpenAPI 3.1 documents.ExamplesThese examples use
@hyperjump/json-schema
to validate OpenAPI documents. Beware that dynamic references are a relatively
new feature of JSON Schema and many validators don't yet support them, or have
limited support, or have bugs.Without schema validation1import { validate } from "@hyperjump/json-schema/openapi-3-1";
2
3const validateOpenApi = await validate("https://spec.openapis.org/oas/3.1/schema");
4
5const example = YAML.parse(await readFile("./example.openapi.json"));
6const result = validateOpenApi(example);
7console.log(result);
8
With OpenAPI Schema dialect schema validation1import { validate } from "@hyperjump/json-schema/openapi-3-1";
2
3(async function () {
4  const validateOpenApi = await validate("https://spec.openapis.org/oas/3.1/schema-base");
5
6  const example = YAML.parse(await readFile("./example.openapi.json"));
7  const result = validateOpenApi(example);
8  console.log(result);
9}());
10
How does it work?To get an idea about how this works, let's take a look at a few selections from
of the OpenAPI 3.1 schemas.This is where the Schema Object is defined. The $dynamicAnchor declares this
sub-schema to be something that can be effectively overridden by another schema.
If it's not overridden, the default behavior is to validate that the value is an
object or a boolean. No other validation is performed on the schema.1$defs:
2  schema:
3    $dynamicAnchor: meta
4    type:
5      - object
6      - boolean
7
When something in this schema wants to reference the Schema Object, instead of
referencing #/$defs/schema like normal, it uses a dynamic reference to the
"meta" dynamic anchor set in the previous selection. Now instead of always
resolving to #/$defs/schema, another schema can potentially override where it
resolves to.1$defs:
2  components:
3    type: object
4    properties:
5      schemas:
6        type: object
7        additionalProperties:
8          $dynamicRef: '#meta'
9
Validating Schema Objects against the default dialectWith those vague building blocks in mind let's derive a schema that "extends"
the abstract schema to create a schema that validates Schema Objects using the
default dialect meta-schema.The first step is to include the abstract schema.1$schema: 'https://json-schema.org/draft/2020-12/schema'
2
3$ref: 'https://spec.openapis.org/oas/3.1/schema/latest'
4
Then we need to add a $dynamicAnchor that matches the one in the abstract
schema to override where dynamic references to "meta" will resolve to. From
there we can reference the meta schema for the default dialect.1$schema: 'https://json-schema.org/draft/2020-12/schema'
2
3$ref: 'https://spec.openapis.org/oas/3.1/schema/latest'
4
5$defs:
6  schema:
7    $dynamicAnchor: meta
8    $ref: 'https://spec.openapis.org/oas/3.1/dialect/base'
9
That's enough to get the Schema Object validation we were after, but there are a
few loose ends we'll want to tie up as well. The jsonSchemaDialect field in
the OpenAPI 3.1 document can be used to change the dialect used. Since this
schema only supports the default dialect, we want to restrict people from
changing that to something else. If they need to change it, they'll need a
different schema to validate against. We also don't want people using the
$schema keyword to change the dialect of individual schemas.1$schema: 'https://json-schema.org/draft/2020-12/schema'
2
3$ref: 'https://spec.openapis.org/oas/3.1/schema'
4properties:
5  jsonSchemaDialect:
6    $ref: '#/$defs/dialect'
7
8$defs:
9  dialect:
10    const: 'https://spec.openapis.org/oas/3.1/dialect/base'
11  schema:
12    $dynamicAnchor: meta
13    $ref: 'https://spec.openapis.org/oas/3.1/dialect/base'
14    properties:
15      $schema:
16        $ref: '#/$defs/dialect'
17
With that, we have exactly what you'll find in the official
https://spec.openapis.org/oas/3.1/schema-base schema.Supporting multiple dialectsWith the adoption of JSON Schema 2020-12 came support for the $id and
$schema keywords, which together allows us to override the default JSON Schema
dialect for a schema. Let's assume we have an OpenAPI 3.1 document where we use
JSON Schema 2020-12 by default, but we also have some legacy JSON Schema
draft-07 schemas that we want to use as well.1jsonSchemaDialect: 'https://json-schema.org/draft/2020-12/schema'
2components:
3  schemas:
4    foo:
5      type: object
6      properties:
7        foo:
8          $ref: '#/components/schemas/baz'
9      unevaluatedProperties: false
10    bar:
11      $id: './schemas/bar'
12      $schema: 'http://json-schema.org/draft-07/schema#'
13      type: object
14      properties:
15        bar:
16          $ref: '#/definitions/number'
17      definitions:
18        number:
19          type: number
20    baz:
21      type: string
22
What's going on hereFirst, we use the jsonSchemaDialect field to set the default dialect for the
document. By setting the default dialect to JSON Schema 2020-12, by default,
schema will not understand the keywords added in the OpenAPI 3.1 vocabulary such
as discriminator. Only standard JSON Schema 2020-12 keywords will be
recognized.The /components/schemas/foo schema is understood to be interpreted as JSON
Schema 2020-12 because that's what we set to be the default.The /components/schemas/bar schema changes the dialect of that schema to be
JSON Schema draft-07. There are a couple of things working together to make this
possible. The $schema keyword sets the dialect for the schema, but $schema
is only allowed at the root of the document it appears in. That's why we also
need to include the $id keyword. The $id keyword effectively makes that
schema a separate document with its own identifier and that location as the
root. It's an independent document embedded inside the OpenAPI 3.1 document. You
can think of it like an iframe in HTML.A consequence of this is that /components/schemas/bar can't use a local
reference like #/components/schemas/foo to reference another schema in
/components/schemas because it's now technically in a different document.
There are two ways to get around this. One option is to use an external
reference to the OpenAPI 3.1 document, such as
myapi.openapi.yml#/components/schemas/foo. The other option is to give
/components/schemas/foo an $id as well and reference that instead,
./schemas/foo.ValidatingNow that we understand how this works, let's derive the schema to validate an
OpenAPI 3.1 document with JSON Schema 2020-12 as the default dialect and JSON
Schema draft-07 as an allowed alternative.1$schema: 'https://json-schema.org/draft/2020-12/schema'
2
3$ref: 'https://spec.openapis.org/oas/3.1/schema'
4properties:
5  jsonSchemaDialect:
6    const: 'https://json-schema.org/draft/2020-12/schema'
7required:
8  - jsonSchemaDialect
9
10$defs:
11  schema:
12    $dynamicAnchor: meta
13    properties:
14      $schema:
15        enum:
16          - 'https://json-schema.org/draft/2020-12/schema'
17          - 'http://json-schema.org/draft-07/schema#'
18    allOf:
19      - if:
20          properties:
21            $schema:
22              const: 'https://json-schema.org/draft/2020-12/schema'
23        then:
24          $ref: 'https://json-schema.org/draft/2020-12/schema'
25      - if:
26          type: object
27          properties:
28            $schema:
29              const: 'http://json-schema.org/draft-07/schema#'
30          required:
31            - $id
32            - $schema
33        then:
34          $ref: 'http://json-schema.org/draft-07/schema'
35
The first change is that the jsonSchemaDialect field is now required because
we are no longer using the default.Next, we have to update the schema definition to only allow $schema values for
the dialects we want to allow.The first if/then will validate the schema as a JSON Schema 2020-12 schema
if there is no $schema keyword used, or $schema is set to JSON Schema
2020-12. Of course it's unnecessary to use $schema in this case, but it is
allowed.The second if/then will validate the schema as a JSON Schema draft-07 schema
if there is an $id and a $schema indicating draft-07.You can extend this pattern for any number of dialects you want to support.Photo by Gonzalo Facello on UnsplashOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, November 24, 2021 · 10 min readWhy JSON Schema needs a Code of ConductGo back to blogBen Hutton@relequestualon this pageMy culture is not your cultureCommunication is mostly non-verbalOur culture and colloquial languageWhy a Code of Conduct?What if we just... did nothing?How do I get involved?If the JSON Schema project had a Code of Conduct in the early days, I suspect we would be years ahead of where we are today. It may seem unlikely, and you may feel like you rarely see a code of conduct in action, but having a Code of Conduct lays some foundational expectations from contributors. You could argue that you shouldn't NEED a Code of Conduct, that people should use common sense and be nice... but it's not so clear cut. Let me explain.My culture is not your cultureStar Trek fans will no doubt be well aware of the "Prime Directive". For the rest of us, the Prime Directive is a top priority general order to not interfere with other cultures and civilizations. The theory goes, humans are more likely to have a disastrous effect regardless of the intent because cultures can be very different.While the failure of an open-source project is unlikely to cause the collapse of another civilization in our reality, the general principle still applies; You cannot presume to know the culture of others. What is normal or acceptable in one culture is not in another.How do these concepts translate from fiction to reality? While there are many extreme examples, one TV advert always stuck with me as a good example of cultural differences causing undesirable results.The advert depicts an English man sitting down for a meal with 10 or so Chinese businessmen. The English man orders an eel, possibly by mistake as he looks worried, but eats the whole thing. The voiceover says, "The English believe it's a slur on your host's food if you don't clear your plate, whereas the Chinese feel you're questioning my generosity if you do." The restaurant brings out another eel, this time much larger.This advert was one of a series published for HSBC, highlighting the importance of "local knowledge". While it makes a nice soundbite, it is a good demonstration of different cultural norms and expectations.Communication is mostly non-verbalAvoiding cultural clashes is even harder when using mostly text to communicate. Experts estimate that only 7% of how we communicate is by using the meaning of the words we use. That leaves 93% attributes to tone and body language. Wow.When you communicate through text with people you usually communicate with in person, it's usually not difficult to fill in for the lack of tone. But, when you've never met or seen the person you're interacting with, you have no reference or basis to make assumptions. What sometimes happens is we fill in those missing parts to draw our own conclusions, which may not match the intent.So how should an open-source project on GitHub avoid cultural clashes and misunderstandings?Emojis can help increase the likelihood of understanding the correct intent, as they can convey tonal and emotional implications. Increasing the level of understanding and intent certainly helps avoid misunderstandings, but this isn't always going to help with cultural differences.Our culture and colloquial languageIt's easy to forget how much culture affects how we interact every day. "Shaka, when the walls fell." You might recognize this as a quote from StarTrek. Imagine you land on a planet and you have a universal translator, but the words just don't make any sense. In this fictional situation, the alien language only uses colloquialisms; phrases that have meaning beyond the words used.We find colloquialisms in one language which are nonsensical to most others. Many of you will find yourself part of various internet cultures, and these too will have their own colloquialisms. With images being a way we can communicate online, we've built visual colloquial language, which we call memes.What I'm implying here is that we can, and do, create our own cultures, and that's OK. We as JSON Schema chose to adopt the Contributor Covenant for several reasons, and this sets our cultural tone. It defines how we should interact, and what our expectations should be when we interact. In addition to the Contributor Covenant, we continue to keep the IETF Guidelines for Conduct (BCP 54), creating our own Code of Conduct.Why a Code of Conduct?We've explored that cultural differences can make it hard to understand intent. But, even if the intent is clear, sometimes specific conduct can be unwelcome.With open-source, people come and go. The people who were super helpful today may be busy tomorrow... or de-prioritise a specific project for years. Aside from making people feel welcome to be nice, it makes good sense in terms of developing and maintaining the project long term. People are more likely to stay if they continue to feel welcomed and valued.Some get involved because it's their job, some because it's fun and rewarding. Some are lucky enough to be able to combine those two aspects. But whatever your reason, we want open source to be a positive experience.While I often suggest people avoid making assumptions, when your communication is limited, you have to make some assumptions or ask for clarification. However, a Code of Conduct allows you to frame your interactions with expectations. "If a comment reads bad, but I assume their intent was good, can I understand the likely meaning differently?"Beyond setting the expectations of good interactions, there is conduct we (agreeing with the Contributor Covenant) defined as not acceptable such as public or private harassment. While it's hard to imagine a culture where that would be acceptable, there are some cultural norms and expectations that are totally unacceptable in many cultures.The Contributor Covenant makes clear the expectations in the form of a pledge and provides examples of meeting those expectations, but it doesn't give any specific hard rules for working (how to do "business"). CBP 54 does give some clear expectations, such as how we should work: "We dispute ideas by using reasoned argument rather than through intimidation or personal attack."We feel the combination we presented and agreed upon in full view and comment from the community aligns with our expectations, and we hope you agree. If that changes or your opinions differ, we will gladly hear them, and try to understand. This is part of what consensus building looks like, some of which is set out in CBP 54.Our choice for the Code of Conduct was partly based on the document's reputation and existing usage. The Contributors Covenant has been adopted by many projects and organizations and has undergone several revisions. It has been developed and updated by many with much experience and knowledge of code of conducts, which is something we can't say for anyone in our team.What if we just... did nothing?Without getting too philosophical, humans seem to often find conflict even when full communication is possible. It's almost inevitable that with text-only communication, there are going to be some misunderstandings, and that drives conflict.JSON Schema as a project previously stalled because the core team (as much as I can tell) had differing expectations. Discussions got heated. Tempers were raised. There was no default laid expectation to frame potential misunderstandings. There was no framework for resolving or remediating conflicts.Right now, there is a fair amount of fragmentation of JSON Schema tooling and version support. We are actively trying to help ease the issue, but my feeling is this only came about where the specification development stopped. If it had continued, and those projects and tools had been supported, we might have found ourselves in an easier situation.We've lost knowledge. We're trying to capture knowledge and decision reasoning moving forward, but there are some things we just simply don't know, and likely now never will. Key people of the previous team that worked on JSON Schema seem to have stepped away from any public open-source work. It may be a coincidence, but based on very public arguments, I suspect not.When we frame our interactions with expectations, we give the benefit of the doubt. With an increasingly wide user base, we have to expect contributors may not have English as their first language, making graceful interpretation increasingly important.One strength of JSON Schema is the ability to use any compliant implementation, and swap out one for another with minimal effort if needed. Do others need to use the schema in another programming language? No problem. That's great for validation, but what about generating types or classes? What about UI generation and database generation? What about generating documentation?Having fixed many problems and inconsistencies, developed many new features, and re-established active development of JSON Schema, the legitimacy and trust of the project are growing. We are now interacting with and guiding several initiatives to define standardized extensions to JSON Schema. Standardized to ensure interoperability.As our community grows, so must our approach with which we engage with our community, and our expectations. Establishing a Code of Conduct is just one of several initiatives that seek to elevate JSON Schema from being an unsung silent hero, into the legitimate, established, and well used critical standard we know it can be. We must learn from our history if we don't want to repeat its mistakes.How do I get involved?We recently updated our homepage to include a few links to our active community and regular activities, but let's recap here anyway.The majority of our discussions happen on our open slack server. Our general channel is for all discussions, including those looking for help. We have other channels for specification development and implementers, the official test suite, even for monitoring GitHub and StackOverflow activity. It's our central hub. But, it is ephemeral, and we lose access to older messages (a limitation of the free account).The more long-living and searchable location for activity and discussion is now our GitHub Discussions. Currently, these are limited to our community repository, but we plan to open these up across other repositories later.Currently, there are two sets of regular calls we hold.First is our JSON Schema Office Hours; an hour every week at the same time where anyone can come and ask questions or just discuss anything JSON Schema related. It has seen low traffic, but it sends an important signal to our community: "We're here to help you as much as we can." Every Tuesday at 15:00 UTC.Second is our Open Community Working Meetings. For these we alternate between times; First Friday of the month at 20:00 UTC, third Friday of the month at 14:00 UTC. This enables the calls to be open to a broader audience. These meetings have a semi-formal agenda and serve as a call to action to gather feedback and thoughts on key decisions and to progress work that needs to be done. We always make sure we capture the resulting action items and follow up in the next session.Both sets of calls are open for anyone to join. Both are recorded, but only the Open Community Working Meeting is shared publicly. The Office Hours session is not shared, hopefully allowing people to speak more freely.Besides Slack, GitHub Discussions, and regular meetings, we do make use of X. You can find me running the @jsonschema account. Any mention of "JSON Schema" feeds into a channel on Slack, so we see most of the discussion, and can lend a hand or point people in a direction as appropriate.Hopefully, this has been a helpful look at why JSON Schema specifically needs a Code of Conduct. Maybe you're considering if your project needs a Code of Conduct. If you have any questions, thoughts, or comments as a result of this article, please feel free to use any of the above methods to make contact.Image by Maike und Björn Bröskamp from PixabayOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubWednesday, August 4, 2021 · 10 min readJSON Schema bundling finally formalisedGo back to blogBen Hutton@relequestualMike Ralphson@PermittedSocon this pageBundling has renewed importanceExisting solutions? New solutions!Bundling fundamentals

Bundling Simple External Resources



OpenAPI Specification Example


But what about...I’ve been known to say “If you haven’t rewritten your OpenAPI bundling implementation recently, then you don’t support OpenAPI 3.1”. This observation may be true, but perhaps some more detail would be helpful? When implementing support for OAS 3.1 and JSON Schema draft 2020-12 in oas-kit, reading the sections of the JSON Schema spec on bundling compound documents, I still wasn’t totally clear on what was expected of compliant tooling. Thankfully, Ben Hutton is here to set the record straight with a worked example. - Mike Ralphson, OAI TSCBundling has renewed importanceOpenAPI has long since put the spotlight on JSON Schema, and the release of OpenAPI 3.1 has huge implications for the future of both projects. I'm truly excited.Developers of platforms and libraries that use OpenAPI haven't had such a shake up before, and my feeling is it may take more than a few releases to correctly implement all the new shiny features full JSON Schema has to offer.While the number of changes from JSON Schema draft-04 to draft 2020-12 are vast and the subject of more blog posts than are likely interesting, one of the key "features" of draft 2020-12 is a defined bundling process. (draft-04 is the version of JSON Schema that OAS used prior to version 3.1.0; or rather, a subset/superset of it.)Indeed, bundling, if anything, is going to be more important to get right than ever. OAS 3.1 ushering in full JSON Schema support dramatically increases the likelihood that developers with existing JSON Schema documents will use them by reference in new and updated OpenAPI definitions. Ultimate source of truth matters, and it's often the JSON Schemas.Many tools don't support referencing external resources.
Bundling is a convenient way to package up schema resources spread across multiple files in a single file for use elsewhere, such as an OpenAPI document.Existing solutions? New solutions!There are several libraries which offer bundling solutions, however they all have caveats, and I haven't seen any to date which are fully JSON Schema aware. The most popular of these libraries is called json-schema-ref-parser, however it reports that it was not intended to be JSON Schema aware, and is only intended to cover the JSON Reference specification (Which has been bundled back into the JSON Schema specification now).We are hoping to provide you with a canonical implementation (Right, Mike?!) and enough information to get started building your own in your language of choice. (Although, it's always best to read the full specification when developing implementations.)Bundling fundamentalsFirstly, let's visit some key definitions in JSON Schema draft 2020-12.
The $id keyword is used to identify a "schema resource". In the example below, the $id is https://jsonschema.dev/schemas/mixins/integer for the resource. schema{  "$id": "https://jsonschema.dev/schemas/mixins/integer",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Must be an integer",  "type": "integer"}﻿
A "Compound Schema Document" is a JSON document which has multiple embedded JSON Schema Resources. Below is a simplified example of one we’ll unpack a bit later. schema{  "$id": "https://jsonschema.dev/schemas/examples/non-negative-integer-bundle",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Must be a non-negative integer",  "$comment": "A JSON Schema Compound Document. Aka a bundled schema.",  "$defs": {    "https://jsonschema.dev/schemas/mixins/integer": {      "$schema": "https://json-schema.org/draft/2020-12/schema",      "$id": "https://jsonschema.dev/schemas/mixins/integer",      "description": "Must be an integer",      "type": "integer"    },    "https://jsonschema.dev/schemas/mixins/non-negative": {      "$schema": "https://json-schema.org/draft/2020-12/schema",      "$id": "https://jsonschema.dev/schemas/mixins/non-negative",      "description": "Not allowed to be negative",      "minimum": 0    },    "nonNegativeInteger": {      "allOf": [        {          "$ref": "/schemas/mixins/integer"        },        {          "$ref": "/schemas/mixins/non-negative"        }      ]    }  },  "$ref": "#/$defs/nonNegativeInteger"}﻿Note that schema bundling and the use of multiple definitions are not necessary to represent non-negative integers.
This example is purely for illustrative purposes and the schema below is perfectly suitable for representing non-negative integers without the use of bundling.data{"type": "integer", "minimum": 0}﻿
Last, let's look at the carefully crafted definition of "bundling" according to the JSON Schema specification:"The bundling process for creating a Compound Schema Document is
   defined as taking references (such as "$ref") to an external Schema
   Resource and embedding the referenced Schema Resources within the
   referring document.  Bundling SHOULD be done in such a way that all
   URIs (used for referencing) in the base document and any referenced/
   embedded documents do not require altering."With these definitions in mind, now we can look at the defined bundling process for JSON Schema resources! We will only cover the ideal situation in this article. The goal here is to have no external Schema Resources.Note, this article does NOT cover "total dereferencing", which is removing all uses of $ref from a schema. This is not advised, and is not always even possible, such as when there are self references.Bundling Simple External ResourcesIn our first example, we have an ideal situation for bundling. Each schema has an $id and $schema defined, making the bundling process simple.
We'll cover various other situations and edge cases in further examples, but having each resource define its own identity and dialect is always preferable.
Our primary schema resource references two other schema resources using the in-place applicator $ref with the value being a relative URI. The relative URI is resolved against the base URI, which in this instance is found in the primary schema resource's $id value. By combining "integer" and "non-negative" schemas, we create a "non-negative integer" schema. schema{  "$id": "https://jsonschema.dev/schemas/mixins/integer",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Must be an integer",  "type": "integer"}﻿
 schema{  "$id": "https://jsonschema.dev/schemas/mixins/non-negative",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Not allowed to be negative",  "minimum": 0}﻿
 schema{  "$id": "https://jsonschema.dev/schemas/examples/non-negative-integer",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Must be a non-negative integer",  "$comment": "A JSON Schema that uses multiple external references",  "$defs": {    "nonNegativeInteger": {      "allOf": [        {          "$ref": "/schemas/mixins/integer"        },        {          "$ref": "/schemas/mixins/non-negative"        }      ]    }  },  "$ref": "#/$defs/nonNegativeInteger"}﻿
Should "non-negative-integer" schema be used as the primary schema in an implementation, the other schemas would need to be available to the implementation. At this point, exactly how that implementation loads in the schemas doesn't matter, as they have fully qualified URIs as their identity defined in $id. Any implementation that loads in schemas should build an internal local index of schema URIs defined in $id to schema resources.Remember, any schema which provides a value for $id is considered a Schema Resource.Let's resolve (dereference) one of the references in our primary schema. "$ref": "/schemas/mixins/integer" resolves to a fully qualified URI of https://jsonschema.dev/schemas/mixins/integer by following the rules for first determining the base URI and then resolving the relative URI against that base URI. The implementation should then check its internal index of schema identifiers and schema resources, finding a match, and using the appropriate previously loaded schema resource.The bundling process is done. The previously externally referenced schemas are copied into $defs in our primary schema, as is. The keys for the $defs object are the identifying URIs, but they can be anything, as those values won't be referenced (They could be UUIDs if you like). Looking at our final bundled schema… I mean "Compound Schema Document", we now have multiple Schema Resources embedded in a single Schema document. schema{  "$id": "https://jsonschema.dev/schemas/examples/non-negative-integer-bundle",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "description": "Must be a non-negative integer",  "$comment": "A JSON Schema Compound Document. Aka a bundled schema.",  "$defs": {    "https://jsonschema.dev/schemas/mixins/integer": {      "$schema": "https://json-schema.org/draft/2020-12/schema",      "$id": "https://jsonschema.dev/schemas/mixins/integer",      "description": "Must be an integer",      "type": "integer"    },    "https://jsonschema.dev/schemas/mixins/non-negative": {      "$schema": "https://json-schema.org/draft/2020-12/schema",      "$id": "https://jsonschema.dev/schemas/mixins/non-negative",      "description": "Not allowed to be negative",      "minimum": 0    },    "nonNegativeInteger": {      "allOf": [        {          "$ref": "/schemas/mixins/integer"        },        {          "$ref": "/schemas/mixins/non-negative"        }      ]    }  },  "$ref": "#/$defs/nonNegativeInteger"}﻿
When the bundled schema is initially loaded and evaluated, the implementation should create its own internal index of schema identifiers and schema resources, just as before. The relative URIs used to reference those schema resources need not change.The simplest way to see this bundled schema working as expected is to paste it into https://json-schema.hyperjump.io and then try different values for the instance. I'm hopeful to bring several updates to https://jsonschema.dev over the next few months, but times are busy as we continue to elevate JSON Schema as an organisation.It’s worth remembering that the example in this article shows the ideal situation, when best practices have been followed. The JSON Schema specification does define additional processes for non-ideal situations and edge cases (such as when $id or $schema are not set), however, some solutions may be indirectly related to Compound JSON Schema Documents. For example, establishing the base URI follows the steps laid out in RFC3986, which JSON Schema does not redefine.OpenAPI Specification ExampleLet’s look at an example of how this might work with an OpenAPI definition.1openapi: 3.1.0
2info:
3  title: API
4  version: 1.0.0
5components:
6  schemas:
7    non-negative-integer:
8      $ref: 'https://jsonschema.dev/schemas/examples/non-negative-integer'
9
We start with our input OpenAPI 3.1.0 specification document. For brevity, we’re only showing the components section with a single component, but let’s assume some other part of the document uses the component schema “non-negative-integer”.“non-negative-integer” has a single reference to a JSON Schema resource. The reference URI is an absolute URI, including domain and path, meaning there’s no need to do any “resolve the relative URI against the base URI” dance.All the schemas required to resolve and bundle the reference are provided to the bundling tooling. After the schemas are loaded into the implementation, their originating physical location no longer matters.1openapi: 3.1.0
2info:
3  title: API
4  version: 1.0.0
5components:
6  schemas:
7    # This name has not changed, or been replaced, as it already existed and is likely to be referenced elsewhere
8    non-negative-integer:
9      # This Reference URI hasn't changed
10      $ref: 'https://jsonschema.dev/schemas/examples/non-negative-integer'
11    # The path name already existed. This key doesn't really matter. It could be anything. It's just for human readers. It could be an MD5!
12    non-negative-integer-2:
13      $schema: 'https://json-schema.org/draft/2020-12/schema'
14      $id: 'https://jsonschema.dev/schemas/examples/non-negative-integer'
15      description: Must be a non-negative integer
16      $comment: A JSON Schema that uses multiple external references
17      $defs:
18        nonNegativeInteger:
19          allOf:
20          # These references remain unchanged because they rely on the base URI of this schema resource
21          - $ref: /schemas/mixins/integer
22          - $ref: /schemas/mixins/non-negative
23      $ref: '#/$defs/nonNegativeInteger'
24    integer:
25      $schema: 'https://json-schema.org/draft/2020-12/schema'
26      $id: 'https://jsonschema.dev/schemas/mixins/integer'
27      description: Must be an integer
28      type: integer
29    non-negative:
30      $schema: 'https://json-schema.org/draft/2020-12/schema'
31      $id: 'https://jsonschema.dev/schemas/mixins/non-negative'
32      description: Not allowed to be negative
33      minimum: 0
34
The schemas are inserted into the components/schemas location of the OAS document. The keys used in the schemas object have no importance for reference resolution, although you will want to avoid potential duplications. References need not change, and a processor of the resulting bundled or Compound Document, should look for the use of embedded Schema Resources within the OAS document, keeping track of the $id values.
But what about...The astute among you might have noticed that Compound Documents may not be correctly validated using a meta-schema for the dialect defined at the document root. One of our principal contributors distilled a great explanation which he has agreed to let us share with you.“If an embedded schema has a different $schema than the parent schema, then a Compound Schema Document can't be validated against a meta-schema without deconstructing it into separate schema resources and applying the appropriate meta-schema to each. That doesn't mean the Compound Schema Document is not usable without deconstruction, it just means that implementations need to be aware that the $schema can change during evaluation and handle such changes appropriately.” - Jason Desrosiers.If you’d like a more in-depth look at edge case situations, please do let us know.You can reach out to us @jsonschema or our Slack server.I hope you’ll agree, Ben has clarified the process for us all here, and we can use this example to fully meet JSON Schema’s bundling expectations when writing tools which bundle multiple resources into compound OpenAPI documents. Thanks, Ben! - MikeBusiness photo created by vanitjan - www.freepik.comThis article was first published on the JSON Schema Blog and is canonically located at https://json-schema.org/blog/posts/bundling-json-schema-compound-documentsOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubBecome a JSON Schema AmbassadorThe JSON Schema Ambassadors Program recognizes the people who drive adoption, innovation, and knowledge sharing in the JSON Schema community.Become a JSON Schema AmbassadorJSON Schema Ambassador ContributionsAmbassadors are passionate about JSON Schema. They share their interest, expertise, and excitement within their communities to help others build better software.Written contentWrite guides, step-by-step tutorials, community documentation, JSON Schema blog posts, and beyond.Podcasts and VideosProduce educational videos, podcasts or livestreams speaking about JSON Schema.Give talksSpeak at meetups and conferences; we'll help with slides, abstract submissions, and travel budget.JSON Schema ContributionsCollaborate with the JSON Schema community via diverse contributions and improvements.Ecosystem ImpactPromote JSON Schema adoption in other ecosystems.Gather Case StudiesCollaborate in the production of case-studies.Join These JSON Schema Ambassadors Learn and share knowledge with community members.Andreas EberhartCEO at DashjoinWith 25 years of professional experience, Andreas is very proficient in the areas of enterprise cloud, linked & big data, as well as systems architecture and development. He co-founded two startups and drove their growth resulting in two acquisitions by silicon valley giants HP and Veritas. Combined with his extensive background in cutting edge research, he has the unique ability to address projects from technical, time to market, and ROI angles. He holds a PhD in Computer Science from the University of Saarbrücken and a Master in Computer Science from Portland State University.Dashjoin, 🇩🇪Show Full DetailsDavid BiesackChief API OfficerChief API Officer at APiture (I design banking APIs with OpenAPI 3.1, JSON Schema 2020/12) and author of the API Design Matters blog, https://apidesignmatters.substack.com/ Apiture, 🇺🇸Show Full DetailsJuan Cruz ViottiFounderFounder at Sourcemeta, consultant, and authorSourcemeta, 🇧🇴Show Full DetailsEsther OkaforTest engineer at StoryblokI am a QA engineer currently working with Storyblok. I am passionate about quality and making sure software design systems are developed with the highest standardsStoryblok, NigeriaShow Full DetailsEge KorkanWeb of Things Expert at SiemensResearch and standardization focused engineer at Siemens with a passion to drive interoperability across all levels.Siemens AG, GermanyShow Full DetailsJeremy FielPrincipal Software Engineer | OpenAPI | JSON Schema | Arazzo | APIsOriginally, an international logistics expert with more than 15 years of professional experience, Jeremy transitioned to software, specifically APIs, about 8 years ago. His passion for learning and contributing back to the community is where he found a love for open source projects. He is now a consistent contributor to projects such as [Redocly](https://github.com/redocly) and the [OpenAPI Initiative](https://github.com/OAI) projects, and a very active community member of JSON Schema.ADP, Inc., USShow Full DetailsBecome a JSON Schema AmbassadorThe JSON Schema Ambassador program is now open for applications! If you're selected, you'll join JSON Schema's mission of helping community members all over the world build the future of JSON Schema.Become AmbassadorLearn MoreOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHub195 Tools195ToolsLanguage.NETCC#C++ClojureCoffeeScriptCommon LispDartDelphiElixirElmErlangGoHaskellHelmJavaJavaScriptJuliaKotlinLua/LuaJITObjective-COpenAPIOrderlyPerlPHPPostgreSQLProtocol BuffersPythonRAMLRubyRustScalaSwiftTypeScriptXSDTooling TypeAnnotationsBenchmarksBundlerCode To SchemaData To SchemaDocumentationEditorEditor PluginsHyper SchemaLDO UtilityLinterLinter PluginsModel To SchemaSchema RepositorySchema To CodeSchema To DataSchema To TypesSchema To Web UIUtil Draft MigrationUtil Format ConversionUtil General ProcessingUtil Schema To SchemaUtil TestingValidatorEnvironmentCOM/ActiveXCommand LineEmbedded platformGithub ActionsiOSLinuxmacOSMicrosoft WindowstvOSvisionOSwatchOSWeb (Online)WindowsDialect2020-122019-097654License(MIT AND Apache-2.0)AFL-2.1 OR BSD-3-ClauseAGPL-3.0AGPL-3.0 and CommercialAGPL-3.0-onlyApache License 2.0Apache-2.0Artistic-2.0BSD-2-ClauseBSD-3-ClauseBSL-1.0CC0-1.0EPL-1.0GPL-1.0+ OR Artistic-1.0GPL-2.0GPL-3.0GPL-3.0-onlyISCLGPL 2.1 or laterLGPL-2.1LGPL-2.1-onlyLGPL-3.0MITMPL-2.0Ms-PLPostgreSQLProprietaryProprietary and FreewareShow obsoleteApply FiltersClear FiltersJSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.JSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on Slack\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHub195 Tools195ToolsLanguage.NETCC#C++ClojureCoffeeScriptCommon LispDartDelphiElixirElmErlangGoHaskellHelmJavaJavaScriptJuliaKotlinLua/LuaJITObjective-COpenAPIOrderlyPerlPHPPostgreSQLProtocol BuffersPythonRAMLRubyRustScalaSwiftTypeScriptXSDTooling TypeAnnotationsBenchmarksBundlerCode To SchemaData To SchemaDocumentationEditorEditor PluginsHyper SchemaLDO UtilityLinterLinter PluginsModel To SchemaSchema RepositorySchema To CodeSchema To DataSchema To TypesSchema To Web UIUtil Draft MigrationUtil Format ConversionUtil General ProcessingUtil Schema To SchemaUtil TestingValidatorEnvironmentCOM/ActiveXCommand LineEmbedded platformGithub ActionsiOSLinuxmacOSMicrosoft WindowstvOSvisionOSwatchOSWeb (Online)WindowsDialect2020-122019-097654License(MIT AND Apache-2.0)AFL-2.1 OR BSD-3-ClauseAGPL-3.0AGPL-3.0 and CommercialAGPL-3.0-onlyApache License 2.0Apache-2.0Artistic-2.0BSD-2-ClauseBSD-3-ClauseBSL-1.0CC0-1.0EPL-1.0GPL-1.0+ OR Artistic-1.0GPL-2.0GPL-3.0GPL-3.0-onlyISCLGPL 2.1 or laterLGPL-2.1LGPL-2.1-onlyLGPL-3.0MITMPL-2.0Ms-PLPostgreSQLProprietaryProprietary and FreewareShow obsoleteApply FiltersClear FiltersJSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.JSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on Slack\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-Schema2020-12 Release NotesThe previous draft (2019-09) introduced a lot of new concepts including
$recursiveRef/$recursiveAnchor, unevaluatedProperties/unevaluatedItems,
vocabularies, and more. Since then, these new features have seen multiple
implementations and usage in real schemas. This draft is mostly dedicated to
changes related to applying the lessons we've learned about implementing and
using these new features in the wild.This document attempts to put information most useful to schema authors toward
the top and information for implementation authors toward the bottom.Changes to items and additionalItemsThe keywords used for defining arrays and tuples have been redesigned to help
lower the learning curve for JSON Schema. Since the items keyword was used for
both types, we would often see people mistakenly defining a tuple when they
meant to define an array and not understand why only the first item in the array
was validating.The items and additionalItems keywords have been replaced with prefixItems
and items where prefixItems has the same functionality as the
array-of-schemas for of the old items and the new items keyword has the same
functionality as the old additionalItems keyword.Although the meaning of items has changed, the syntax for defining arrays
remains the same. Only the syntax for defining tuples has changed. The idea is
that an array has items (items) and optionally has some positionally defined
items that come before the normal items (prefixItems).Here are some examples to illustrate the changes.Open tupleDraft 2019-09Draft 2020-12data{  "items": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ]}﻿data{  "prefixItems": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ]}﻿ Closed tupleDraft 2019-09Draft 2020-12data{  "items": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "additionalItems": false}﻿data{  "prefixItems": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "items": false}﻿ Tuple with constrained additional itemsDraft 2019-09Draft 2020-12data{  "items": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "additionalItems": { "$ref": "#/$defs/baz" }}﻿data{  "prefixItems": [    { "$ref": "#/$defs/foo" },    { "$ref": "#/$defs/bar" }  ],  "items": { "$ref": "#/$defs/baz" }}﻿$dynamicRef and $dynamicAnchorThe $recursiveRef and $recursiveAnchor keywords were replaced by the more
powerful $dynamicRef and $dynamicAnchor keywords. $recursiveRef and
$recursiveAnchor were introduced in the previous draft to solve the problem of
extending recursive schemas. As the "recursive" keywords got some use and we
understood them better, we discovered how we could generalize them to solve even
more types of problems. The name change reflects that these keywords are useful
for more than just extending recursive schemas.A $dynamicAnchor can be thought of like a normal $anchor except that it can
be referenced across schemas rather than just in the schema where it was
defined. You can think of the old $recursiveAnchor as working the same way
except that it only allowed you to create one anchor per schema, it had to be at
the root of the schema, and the anchor name is always empty.$dynamicRef works the same as the old $recursiveRef except that fragments
are no longer empty ("$dynamicRef": "#my-anchor" instead of "$recursiveRef":
"#") and non-fragment-only URIs are allowed. When a $dynamicRef contains a
non-fragment-only URI-Reference, the schema the URI-Reference resolves to is
used as the starting point for dynamic resolution.Here's how you would covert a schema using $recursiveRef to use $dynamicRef.Draft 2019-09Draft 2020-121// tree schema, extensible
2{
3"$schema": "https://json-schema.org/draft/2019-09/schema",
4"$id": "https://example.com/tree",
5"$recursiveAnchor": true,
6"type": "object",
7"properties": {
8"data": true,
9"children": {
10  "type": "array",
11  "items": { "$recursiveRef": "#" }
12}
13}
14}
15// strict-tree schema, guards against misspelled properties
16{
17"$schema": "https://json-schema.org/draft/2019-09/schema",
18"$id": "https://example.com/strict-tree",
19"$recursiveAnchor": true,
20"$ref": "tree",
21"unevaluatedProperties": false
22}
231// tree schema, extensible
2{
3"$schema": "https://json-schema.org/draft/2020-12/schema",
4"$id": "https://example.com/tree",
5"$dynamicAnchor": "node",
6"type": "object",
7"properties": {
8"data": true,
9"children": {
10  "type": "array",
11  "items": { "$dynamicRef": "#node"}
12}
13}
14}
15// strict-tree schema, guards against misspelled properties
16{
17"$schema": "https://json-schema.org/draft/2020-12/schema",
18"$id": "https://example.com/strict-tree",
19"$dynamicAnchor": "node",
20"$ref": "tree",
21"unevaluatedProperties": false
22}
23contains and unevaluatedItemsIn the previous draft, it wasn't specified how or if the contains keyword
affects the unevaluatedItems keyword. This draft specifies that any item in an
array that passes validation of the contains schema is considered "evaluated".This allows you to use contains to express some constraints more cleanly than
you could in previous drafts. This example show how you can express an array
that has some item matching one schema and everything else matching another
schema.Draft 2019-09Draft 2020-12data  {    "type": "array",    "contains": { "type": "string" },    "items": {      "anyOf": [        { "type": "string" },        { "type": "number" }      ]    }  }﻿data  {    "type": "array",    "contains": { "type": "string" },    "unevaluatedItems": { "type": "number" }  }﻿Unfortunately, this change means you may not be able to use contains in some
situations you did before. Consider this draft 2019-09 schema describing a tuple
of two strings where one of the two must be three or more characters long and
any additional items are not allowed. schema{  "$schema": "https://json-schema.org/draft/2019-09/schema",  "type": "array",  "items": [{ "type": "string" }, { "type": "string" }],  "contains": { "type": "string", "minLength": 3 },  "unevaluatedItems": false}﻿
Given this schema, the instance ["a", "b", "ccc"] will fail because "ccc" is
considered unevaluated and fails the unevaluatedItems keyword. Now let's
naively convert that example to a draft 2020-12 schema. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "array",  "prefixItems": [{ "type": "string" }, { "type": "string" }],  "contains": { "type": "string", "minLength": 3 },  "unevaluatedItems": false}﻿
Given this schema, the instance ["a", "b", "ccc"] will pass because "ccc" is
considered evaluated and doesn't not apply to the unevaluatedItems keyword. To
fix this problem we can use the same boolean algebra transformation we used to
use before we had the contains keyword. schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "type": "array",  "prefixItems": [{ "type": "string" }, { "type": "string" }],  "not": {    "items": {      "not": { "type": "string", "minLength": 3 }    }  },  "unevaluatedItems": false}﻿
Given this schema, the instance ["a", "b", "ccc"] will fail because "ccc" is
considered unevaluated and fails the unevaluatedItems keyword like it did in
previous drafts.Regular ExpressionsRegular expressions are now expected (but not strictly required) to support
unicode characters. Previously, this was unspecified and implementations may or
may not support this unicode in regular expressions.Media Type ChangesJSON Schema defines two media types, application/schema+json and
application/schema-instance+json. This draft drops support for the schema
media type parameter. It's caused a lot of confusion and disagreement. Since we
haven't seen any evidence of anyone actually using it, it was decided to remove
it for now.Embedded Schemas and BundlingIn Draft 2019-09, the meaning of $id in a sub-schema changed from indicating a
base URI change within the current schema to indicating an embedded schema
independent of the parent schema. A schema that contains one or more embedded
schemas is called a "Compound Schema Document". This draft introduces guidance
on how bundlers should embedded schemas to create Compound Schema Documents.If you reference an external schema, that schema can declare its own $schema
and that may be different than the $schema of the referencing schema.
Implementations need to be prepared to switch processing modes or throw an
error if they don't support the $schema of the referenced schema. Embedded
schemas work exactly the same way. They may declare a $schema that is not the
same as the parent schema and implementations need to be prepared to handle the
$schema change appropriately.A notable consequence of embedded schemas having a different $schema than its
parent is that implementations can't validate Compound Schema Documents directly
against the meta-schema. The Compound Schema Document needs to be decomposed and
each Schema Resource needs to be validated individually against the appropriate
meta-schema for that schema.This draft introduces official guidance on how to use embedded schemas to
bundle schemas into a Compound Schema Document. The approach is designed to not
have to modify schemas (other than adding to $defs) so that output results
remain as similar as possible whether you are validating the bundled schema or
following external references. Here's an example of a customer schema with
external references that we want to bundle. schema{  "$schema": "https://json-schema.org/draft/2020-12",  "$id": "https://example.com/schema/customer",﻿  "type": "object",  "properties": {    "name": { "type": "string" },    "phone": { "$ref": "/schema/common#/$defs/phone" },    "address": { "$ref": "/schema/address" }  }}﻿
data{  "$schema": "https://json-schema.org/draft/2020-12",  "$id": "https://example.com/schema/address",﻿  "type": "object",  "properties": {    "address": { "type": "string" },    "city": { "type": "string" },    "postalCode": { "$ref": "/schema/common#/$defs/usaPostalCode" },    "state": { "$ref": "/$defs/states" }  },﻿  "$defs": {    "states": {      "enum": [...]    }  }}﻿
data{  "$schema": "https://json-schema.org/draft/2019-09",  "$id": "https://example.com/schema/common",﻿  "$defs": {    "phone": {      "type": "string",      "pattern": "^[\+]?[(]?[0-9]{3}[)]?[- \.]?[0-9]{3}[- \.]?[0-9]{4,6}$"    },    "usaPostalCode": {      "type": "string",      "pattern": "^[0-9]{5}(?:-[0-9]{4})?$"    },    "unsignedInt": {      "type": "integer",      "minimum": 0    }  }}﻿
To bundle these schemas, we simply add each of the referenced schemas as
embedded schemas using $defs. Here's what the bundled schema would look like.data{  "$schema": "https://json-schema.org/draft/2020-12",  "$id": "https://example.com/schema/customer",﻿  "type": "object",  "properties": {    "name": { "type": "string" },    "phone": { "$ref": "/schema/common#/$defs/phone" },    "address": { "$ref": "/schema/address" }  },﻿  "$defs": {    "https://example.com/schema/address": {      "$id": "https://example.com/schema/address",﻿      "type": "object",      "properties": {        "address": { "type": "string" },        "city": { "type": "string" },        "postalCode": { "$ref": "/schema/common#/$defs/usaPostalCode" },        "state": { "$ref": "#/$defs/states" }      },﻿      "$defs": {        "states": {          "enum": [...]        }      }    },    "https://example.com/schema/common": {      "$schema": "https://json-schema.org/draft/2019-09",      "$id": "https://example.com/schema/common",﻿      "$defs": {        "phone": {          "type": "string",          "pattern": "^[\+]?[(]?[0-9]{3}[)]?[- \.]?[0-9]{3}[- \.]?[0-9]{4,6}$"        },        "usaPostalCode": {          "type": "string",          "pattern": "^[0-9]{5}(?:-[0-9]{4})?$"        },        "unsignedInt": {          "type": "integer",          "minimum": 0        }      }    }  }}﻿
Here are a few things you might notice from this example.No $refs were modified. Even local references are unchanged.https://example.com/schema/common#/
$defs/unsignedInt got pulled in with the
common schema even though it isn't used. It's allowed to trim out the extra
definitions, but not necessary.https://example.com/schema/address doesn't declare a $schema. Because it
uses the same $schema as https://example.com/schema/customer, it can skip
that declaration and use the $schema from the schema it's embedded in.https://example.com/schema/common uses a different $schema than the
document it's embedded in. That's allowed.Definitions from https://example.com/schema/common are used in both of the
other schemas and only needs to be included once. It isn't necessary for
bundlers to embed a schema inside another embedded schema.AnnotationsImplementations that collect annotations should now include annotations for
unknown keywords in the "verbose" output format. The annotation value for an
unknown keyword is the keyword's value.Vocabulary ChangesThe unevaluatedProperties and unevaluatedItems keywords have been moved from
the applicator vocabulary to their own designated vocabulary which is required
in the default meta-schema. In Draft 2019-09, these keywords were expected to
throw an error if not implemented. This was a special-case behavior of the
applicator vocabulary. Moving the "unevaluated" keywords into their own
vocabulary allows us to remove that special-case and also allowing for dialects
to be constructed that don't require these keywords.The format vocabulary was broken into two separate vocabularies. The
"format-annotation" vocabulary treats the format keyword as an annotation and
the "format-assertion" vocabulary treats the format keyword as an assertion.
The "format-annotation" vocabulary is used in the default meta-schema and is
required. In Draft 2019-09, format should be evaluated as an annotation by
default and implementations could provide configuration to change the behavior
to evaluate format as an assertion. The separate vocabularies allow for
removing the special configuration requirements and just use the vocabulary
system to express which behavior should be used.Need Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubBuild more. Break less. Empower others.JSON Schema enables the confident and reliable use of the JSON data format.Getting startedJoin SlackSearchSearchUsed byPlease visit the JSON Schema Landscape and discover more companies using JSON Schema.Why JSON Schema?While JSON is probably the most popular format for exchanging data, JSON Schema is the vocabulary that enables JSON data consistency, validity, and interoperability at scale.Streamline testing and validationSimplify your validation logic to reduce your code’s complexity and save time on development. Define constraints for your data structures to catch and prevent errors, inconsistencies, and invalid data.Exchange data seamlesslyEstablish a common language for data exchange, no matter the scale or complexity of your project. Define precise validation rules for your data structures to create shared understanding and increase interoperability across different systems and platforms.Document your dataCreate a clear, standardized representation of your data to improve understanding and collaboration among developers, stakeholders, and collaborators.Vibrant tooling ecosystemAdopt JSON Schema with an expansive range of community-driven tools, libraries, and frameworks across many programming languages.Start learning JSON SchemaRead the docsExplore the JSON Schema EcosystemDiscover JSON Schema tooling to help your organization leverage the benefits of JSON Schema. Because JSON Schema is much more than a Specification, it is a vibrant ecosystem of Validators, Generators, Linters, and other JSON Schema Utilities made by this amazing Community.ExploreWelcome to the JSON Schema CommunityWith over 60 million weekly downloads, JSON Schema has a large and active developer community across the world. Join the Community to learn, share ideas, ask questions, develop JSON Schema tooling and build new connections.Join the JSON Schema Slack Workspace!Join our Slack to ask questions, get feedback on your projects, and connect with +5000 practitioners and experts.Join SlackThe JSON Schema Blog How Oracle is Bridging the Gap Between JSON Schema and Relational DatabasesAs modern multi-model databases increasingly support JSON, it's time to explore what role JSON schema will play.Loïc Lefèvre2025-02-07 · 22 min readRead more JSON Schema Community Meetings & EventsWe hold monthly Office Hours and Open Community Working Meetings. Office Hours are every first Tuesday of the month and by appointment. Open Community Working Meetings are every third Monday of the month at 12:00 PT.Open Community Working MeetingsOffice HoursUpcoming events17JSON Schema Open Community Working MeetingMarch 17th 2025, 20:00 (UTC)26GSoC Office HoursMarch 26th 2025, 19:00 (UTC)1JSON Schema Office Hours (Europe/Americas)April 1st 2025, 14:00 (UTC)21JSON Schema Open Community Working MeetingApril 21st 2025, 19:00 (UTC)6JSON Schema Office Hours (APAC/Americas)May 6th 2025, 22:00 (UTC)19JSON Schema Open Community Working MeetingMay 19th 2025, 19:00 (UTC)3JSON Schema Office Hours (Europe/Americas)June 3rd 2025, 14:00 (UTC)View CalendarStart contributing to JSON SchemaContributeSponsorsIf you ❤️ JSON Schema consider becoming a sponsoror a backer .Support us!Gold SponsorsYour logo hereSilver SponsorsYour logo hereBronze SponsorsYour logo hereSupported byThe following companies support us by letting us use their products.Email us for more info! Open CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaFAQBelow you'll find answers to questions we get asked the most about JSON Schema.GENERALWhat is JSON Schema?+How do I create a simple JSON Schema?+What is the purpose of 'type' in JSON Schema?+How can I define default values in a JSON Schema?+What is the significance of 'required' in JSON Schema?+How can I validate a JSON document against a JSON Schema?+What is the difference between 'object' and 'array' types in JSON Schema?+Can I use JSON Schema to describe nested structures?+Go BackCase StudiesUp NextPro HelpNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema Organizational Code of ConductOur (The JSON Schema Organization) Code of Conduct is a combination of:The IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154)The "Contributor Covenant Code of Conduct" 2.1The OpenJS Foundation Code of ConductApplicable sectionsWe take the whole of the Contributor Covenant Code of Conduct 2.1 as is.We reference the IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154) as a guideline. We do not subscribe to its defined Reporting Transgressions of the Guidelines (Appendix A), as JSON Schema is not part of any IETF working group.We subscribe to the OpenJS Foundation Code of Conduct in full. The OpenJS Foundation Code of Conduct consists of the Contributor Covenant Code of Conduct, commitments relating to reports, and an escalation process.IETF Guidelines for ConductWhile the JSON Schema project is not formally part of the IETF, historically the project was initially published and updated as "personal drafts" through the IETF process. The project members have found the approach and assumptions defined as Guidelines for Conduct to be well informed and a good foundation of behaviour and expectations.The IETF defined BCP 54 (Best Current Practice), also assinged RFC 7154.
Some extracts are provided which are found to be key principles.
Please see BCP 54/RFC 7154 document for full details.BCP 54 provides a set of guidelines for personal interaction in the Internet Engineering Task Force.  The guidelines recognize the diversity of IETF participants, emphasize the value of mutual respect, and stress the broad applicability of our work.The work of the IETF relies on cooperation among a diverse range of people with different ideas and communication styles.  The IETF strives, through these guidelines for conduct, to create and maintain an environment in which every person is treated with dignity, decency, and respect.We dispute ideas by using reasoned argument rather than through intimidation or personal attack.The IETF puts its emphasis on technical competence, rough consensus, and individual participation, and it needs to be open to competent input from any source.IETF participants use their best engineering judgment to find the best solution for the whole Internet, not just the best solution for any particular network, technology, vendor, or user.Some thoughts on "consensus": https://datatracker.ietf.org/doc/html/rfc7282Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our
community include:Demonstrating empathy and kindness toward other peopleBeing respectful of differing opinions, viewpoints, and experiencesGiving and gracefully accepting constructive feedbackAccepting responsibility and apologizing to those affected by our mistakes,
and learning from the experienceFocusing on what is best not just for us as individuals, but for the
overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or
advances of any kindTrolling, insulting or derogatory comments, and personal or political attacksPublic or private harassmentPublishing others' private information, such as a physical or email
address, without their explicit permissionOther conduct which could reasonably be considered inappropriate in a
professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[email protected].
All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the
reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series
of actions.Consequence: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including
sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within
the community.Conflicts of InterestIn the event of any conflict of interest, a community leader must immediately notify the other leaders, and recuse themselves if necessary.The OpenJS Foundation Code of ConductThe OpenJS Foundation Code of Conduct is mostly formed from the Contributor Covenant Code of Conduct.
Significantly, we copy here the defined issue escalation process.Privacy ExpectationsAs per Code of Conduct requirements set out by the OpenJS Foundation, recipients of reports will maintain the confidentiality with regard to the reporter of an incident.
For the purposes of tracking between Code of Conduct review members, incidents may be tracked in a private organizational GitHub Repository.
In addition to any Code of Conduct review team, GitHub organizational owners will have access to view details of reports by way of having full GitHub organizational admin access.EscalationThe OpenJS Foundation provides an escalation path should you feel your report has not been handled appropriatly. Recipients of reports commit to participate in the defined path of escalation when required, as required by the OpenJS Foundation Code of Conduct.The OpenJS Foundation maintains a Code of Conduct Panel (CoCP). This is a foundation-wide team established to manage escalation when a reporter believes that a report to a member project or the CPC has not been properly handled. In order to escalate to the CoCP send an email to [email protected].
Enforcement responsabilitiesIf a Code of Conduct report involves a community leader, that member will not participate in the investigation or any decisions related to that report. If the report involves multiple community leaders, mediation will defer to the OpenJS Code of Conduct Panel (CoCP).For more information, refer to the full
Code of Conduct governance document.AttributionThis Code of Conduct is adapted from the Contributor Covenant,
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.Community Impact Guidelines were inspired by
Mozilla's code of conduct enforcement ladder.For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.Go BackSimilar-TechnologiesUp NextGetting StartedNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema Organizational Code of ConductOur (The JSON Schema Organization) Code of Conduct is a combination of:The IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154)The "Contributor Covenant Code of Conduct" 2.1The OpenJS Foundation Code of ConductApplicable sectionsWe take the whole of the Contributor Covenant Code of Conduct 2.1 as is.We reference the IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154) as a guideline. We do not subscribe to its defined Reporting Transgressions of the Guidelines (Appendix A), as JSON Schema is not part of any IETF working group.We subscribe to the OpenJS Foundation Code of Conduct in full. The OpenJS Foundation Code of Conduct consists of the Contributor Covenant Code of Conduct, commitments relating to reports, and an escalation process.IETF Guidelines for ConductWhile the JSON Schema project is not formally part of the IETF, historically the project was initially published and updated as "personal drafts" through the IETF process. The project members have found the approach and assumptions defined as Guidelines for Conduct to be well informed and a good foundation of behaviour and expectations.The IETF defined BCP 54 (Best Current Practice), also assinged RFC 7154.
Some extracts are provided which are found to be key principles.
Please see BCP 54/RFC 7154 document for full details.BCP 54 provides a set of guidelines for personal interaction in the Internet Engineering Task Force.  The guidelines recognize the diversity of IETF participants, emphasize the value of mutual respect, and stress the broad applicability of our work.The work of the IETF relies on cooperation among a diverse range of people with different ideas and communication styles.  The IETF strives, through these guidelines for conduct, to create and maintain an environment in which every person is treated with dignity, decency, and respect.We dispute ideas by using reasoned argument rather than through intimidation or personal attack.The IETF puts its emphasis on technical competence, rough consensus, and individual participation, and it needs to be open to competent input from any source.IETF participants use their best engineering judgment to find the best solution for the whole Internet, not just the best solution for any particular network, technology, vendor, or user.Some thoughts on "consensus": https://datatracker.ietf.org/doc/html/rfc7282Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our
community include:Demonstrating empathy and kindness toward other peopleBeing respectful of differing opinions, viewpoints, and experiencesGiving and gracefully accepting constructive feedbackAccepting responsibility and apologizing to those affected by our mistakes,
and learning from the experienceFocusing on what is best not just for us as individuals, but for the
overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or
advances of any kindTrolling, insulting or derogatory comments, and personal or political attacksPublic or private harassmentPublishing others' private information, such as a physical or email
address, without their explicit permissionOther conduct which could reasonably be considered inappropriate in a
professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[email protected].
All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the
reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series
of actions.Consequence: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including
sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within
the community.Conflicts of InterestIn the event of any conflict of interest, a community leader must immediately notify the other leaders, and recuse themselves if necessary.The OpenJS Foundation Code of ConductThe OpenJS Foundation Code of Conduct is mostly formed from the Contributor Covenant Code of Conduct.
Significantly, we copy here the defined issue escalation process.Privacy ExpectationsAs per Code of Conduct requirements set out by the OpenJS Foundation, recipients of reports will maintain the confidentiality with regard to the reporter of an incident.
For the purposes of tracking between Code of Conduct review members, incidents may be tracked in a private organizational GitHub Repository.
In addition to any Code of Conduct review team, GitHub organizational owners will have access to view details of reports by way of having full GitHub organizational admin access.EscalationThe OpenJS Foundation provides an escalation path should you feel your report has not been handled appropriatly. Recipients of reports commit to participate in the defined path of escalation when required, as required by the OpenJS Foundation Code of Conduct.The OpenJS Foundation maintains a Code of Conduct Panel (CoCP). This is a foundation-wide team established to manage escalation when a reporter believes that a report to a member project or the CPC has not been properly handled. In order to escalate to the CoCP send an email to [email protected].
Enforcement responsabilitiesIf a Code of Conduct report involves a community leader, that member will not participate in the investigation or any decisions related to that report. If the report involves multiple community leaders, mediation will defer to the OpenJS Code of Conduct Panel (CoCP).For more information, refer to the full
Code of Conduct governance document.AttributionThis Code of Conduct is adapted from the Contributor Covenant,
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.Community Impact Guidelines were inspired by
Mozilla's code of conduct enforcement ladder.For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.Go BackSimilar-TechnologiesUp NextGetting StartedNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubIntroductionIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema Organizational Code of ConductOur (The JSON Schema Organization) Code of Conduct is a combination of:The IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154)The "Contributor Covenant Code of Conduct" 2.1The OpenJS Foundation Code of ConductApplicable sectionsWe take the whole of the Contributor Covenant Code of Conduct 2.1 as is.We reference the IETF BCP 54 "IETF Guidelines for Conduct" (RFC7154) as a guideline. We do not subscribe to its defined Reporting Transgressions of the Guidelines (Appendix A), as JSON Schema is not part of any IETF working group.We subscribe to the OpenJS Foundation Code of Conduct in full. The OpenJS Foundation Code of Conduct consists of the Contributor Covenant Code of Conduct, commitments relating to reports, and an escalation process.IETF Guidelines for ConductWhile the JSON Schema project is not formally part of the IETF, historically the project was initially published and updated as "personal drafts" through the IETF process. The project members have found the approach and assumptions defined as Guidelines for Conduct to be well informed and a good foundation of behaviour and expectations.The IETF defined BCP 54 (Best Current Practice), also assinged RFC 7154.
Some extracts are provided which are found to be key principles.
Please see BCP 54/RFC 7154 document for full details.BCP 54 provides a set of guidelines for personal interaction in the Internet Engineering Task Force.  The guidelines recognize the diversity of IETF participants, emphasize the value of mutual respect, and stress the broad applicability of our work.The work of the IETF relies on cooperation among a diverse range of people with different ideas and communication styles.  The IETF strives, through these guidelines for conduct, to create and maintain an environment in which every person is treated with dignity, decency, and respect.We dispute ideas by using reasoned argument rather than through intimidation or personal attack.The IETF puts its emphasis on technical competence, rough consensus, and individual participation, and it needs to be open to competent input from any source.IETF participants use their best engineering judgment to find the best solution for the whole Internet, not just the best solution for any particular network, technology, vendor, or user.Some thoughts on "consensus": https://datatracker.ietf.org/doc/html/rfc7282Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual identity
and orientation.We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our
community include:Demonstrating empathy and kindness toward other peopleBeing respectful of differing opinions, viewpoints, and experiencesGiving and gracefully accepting constructive feedbackAccepting responsibility and apologizing to those affected by our mistakes,
and learning from the experienceFocusing on what is best not just for us as individuals, but for the
overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or
advances of any kindTrolling, insulting or derogatory comments, and personal or political attacksPublic or private harassmentPublishing others' private information, such as a physical or email
address, without their explicit permissionOther conduct which could reasonably be considered inappropriate in a
professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[email protected].
All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the
reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series
of actions.Consequence: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including
sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within
the community.Conflicts of InterestIn the event of any conflict of interest, a community leader must immediately notify the other leaders, and recuse themselves if necessary.The OpenJS Foundation Code of ConductThe OpenJS Foundation Code of Conduct is mostly formed from the Contributor Covenant Code of Conduct.
Significantly, we copy here the defined issue escalation process.Privacy ExpectationsAs per Code of Conduct requirements set out by the OpenJS Foundation, recipients of reports will maintain the confidentiality with regard to the reporter of an incident.
For the purposes of tracking between Code of Conduct review members, incidents may be tracked in a private organizational GitHub Repository.
In addition to any Code of Conduct review team, GitHub organizational owners will have access to view details of reports by way of having full GitHub organizational admin access.EscalationThe OpenJS Foundation provides an escalation path should you feel your report has not been handled appropriatly. Recipients of reports commit to participate in the defined path of escalation when required, as required by the OpenJS Foundation Code of Conduct.The OpenJS Foundation maintains a Code of Conduct Panel (CoCP). This is a foundation-wide team established to manage escalation when a reporter believes that a report to a member project or the CPC has not been properly handled. In order to escalate to the CoCP send an email to [email protected].
Enforcement responsabilitiesIf a Code of Conduct report involves a community leader, that member will not participate in the investigation or any decisions related to that report. If the report involves multiple community leaders, mediation will defer to the OpenJS Code of Conduct Panel (CoCP).For more information, refer to the full
Code of Conduct governance document.AttributionThis Code of Conduct is adapted from the Contributor Covenant,
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.Community Impact Guidelines were inspired by
Mozilla's code of conduct enforcement ladder.For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.Go BackSimilar-TechnologiesUp NextGetting StartedNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaDialect and vocabulary declarationA version of JSON Schema is called a dialect. A dialect represents the
set of keywords and semantics that can be used to evaluate a schema.
Each JSON Schema release is a new dialect of JSON Schema. JSON Schema
provides a way for you to declare which dialect a schema conforms to and
provides ways to describe your own custom dialects.$schemaThe $schema keyword is used to declare which dialect of JSON Schema
the schema was written for. The value of the $schema keyword is also
the identifier for a schema that can be used to verify that the schema
is valid according to the dialect $schema identifies. A schema that
describes another schema is called a "meta-schema".$schema applies to the entire document and must be at the root level.
It does not apply to externally referenced ($ref, $dynamicRef)
documents. Those schemas need to declare their own $schema.If $schema is not used, an implementation might allow you to specify a
value externally or it might make assumptions about which specification
version should be used to evaluate the schema. It's recommended that
all JSON Schemas have a $schema keyword to communicate to readers and
tooling which specification version is intended. Therefore most of the
time, you'll want this at the root of your schema:1"$schema": "https://json-schema.org/draft/2020-12/schema"
2Draft-specific info:Draft 4Draft 6Draft 7Draft 2019-09The identifier for Draft 4 is http://json-schema.org/draft-04/schema#.Draft 4 defined a value for $schema without a specific dialect
(http://json-schema.org/schema#) which meant, use the latest
dialect. This has since been deprecated and should no longer be
used.You might come across references to Draft 5. There is no Draft 5
release of JSON Schema. Draft 5 refers to a no-change revision of
the Draft 4 release. It does not add, remove, or change any
functionality. It only updates references, makes clarifications,
and fixes bugs. Draft 5 describes the Draft 4 release. If you came
here looking for information about Draft 5, you'll find it under
Draft 4. We no longer use the "draft" terminology to refer to
patch releases to avoid this confusion.VocabulariesNew in draft 2019-09Documentation Coming SoonDraft-specific infoBefore the introduction of Vocabularies, you could still extend
   JSON Schema with your custom keywords but the process was much less
   formalized. The first thing you'll need is a meta-schema that
   includes your custom keywords. The best way to do this is to make a
   copy of the meta-schema for the version you want to extend and make
   your changes to your copy. You will need to choose a custom URI to
   identify your custom version. This URI must not be one of the URIs
   used to identify official JSON Schema specification drafts and
   should probably include a domain name you own. You can use this URI
   with the $schema keyword to declare that your schemas use your
   custom version.

Not all implementations support custom meta-schemas and custom
keyword implementations.
GuidelinesOne of the strengths of JSON Schema is that it can be written in JSON
and used in a variety of environments. For example, it can be used for
both front-end and back-end HTML Form validation. The problem with using
custom vocabularies is that every environment where you want to use your
schemas needs to understand how to evaluate your vocabulary's keywords.
Meta-schemas can be used to ensure that schemas are written correctly,
but each implementation will need custom code to understand how to
evaluate the vocabulary's keywords.Meta-data keywords are the most interoperable because they don't affect
validation. For example, you could add a units keyword. This will
always work as expecting with an compliant validator. schema{  "type": "number",  "units": "kg"}﻿data42﻿compliant to schemadata"42"﻿not compliant to schema
The next best candidates for custom keywords are keywords that don't
apply other schemas and don't modify the behavior of existing keywords.
An isEven keyword is an example. In contexts where some validation is
better than no validation such as validating an HTML Form in the
browser, this schema will perform as well as can be expected. Full
validation would still be required and should use a validator that
understands the custom keyword. schema{  "type": "integer",  "isEven": true}﻿data2﻿compliant to schemaThis passes because the validator doesn't understand isEvendata3﻿compliant to schemaThe schema isn't completely impaired because it doesn't understand isEvendata"3"﻿not compliant to schema
The least interoperable type of custom keyword is one that applies other
schemas or modifies the behavior of existing keywords. An example would
be something like requiredProperties that declares properties and
makes them required. This example shows how the schema becomes almost
completely useless when evaluated with a validator that doesn't
understand the custom keyword. That doesn't necessarily mean that
requiredProperties is a bad idea for a keyword, it's just not the
right choice if the schema might need to be used in a context that
doesn't understand custom keywords. schema{  "type": "object",  "requiredProperties": {    "foo": { "type": "string" }  }}﻿data{ "foo": "bar" }﻿compliant to schemaThis passes because requiredProperties is not understooddata{}﻿compliant to schemaThis passes because requiredProperties is not understooddata{ "foo": 42 }﻿compliant to schemaGo BackstringUp NextValue restrictionsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubReferenceIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaModular JSON Schema combinationIntroductionWhen writing computer programs of even moderate complexity, it's
commonly accepted that "structuring" the program into reusable
functions is better than duplicating code. Similarly, in JSON Schema, structuring your schema into reusable components is highly beneficial for anything beyond the most trivial cases.Here, you will learn about the keywords used to combine JSON schemas modularly and see examples of their application.Schema IdentificationLike any other code, schemas are easier to maintain if they can be
broken down into logical units that reference each other as necessary.
In order to reference a schema, we need a way to identify a schema.
Schema documents are identified by non-relative URIs.Schema documents are not required to have an identifier, but you will
need one if you want to reference one schema from another. In this
documentation, we will refer to schemas with no identifier as
"anonymous schemas".In the following sections we will see how the "identifier" for a
schema is determined.URI terminology can sometimes be unintuitive. In this document, the
following definitions are used.URI
  [1] or
  non-relative URI: A full URI containing a scheme (https). It
  may contain a URI fragment (#foo). Sometimes this document will
  use "non-relative URI" to make it extra clear that relative URIs
  are not allowed.relative reference
  [2]:
  A partial URI that does not contain a scheme (https). It may
  contain a fragment (#foo).URI-reference
  [3]:
  A relative reference or non-relative URI. It may contain a URI
  fragment (#foo).absolute URI
 [4] A
 full URI containing a scheme (https) but not a URI fragment
 (#foo).

Even though schemas are identified by URIs, those identifiers are not
necessarily network-addressable. They are just identifiers. Generally,
implementations don't make HTTP requests (https://) or read from the
file system (file://) to fetch schemas. Instead, they provide a way to
load schemas into an internal schema database. When a schema is
referenced by it's URI identifier, the schema is retrieved from the
internal schema database.
Base URIUsing non-relative URIs can be cumbersome, so any URIs used in JSON
Schema can be URI-references that resolve against the schema's base URI
resulting in a non-relative URI. This section describes how a schema's
base URI is determined.Base URI determination and relative reference resolution is defined by
RFC-3986. If
you are familiar with how this works in HTML, this section should feel
very familiar.
Retrieval URIThe URI used to fetch a schema is known as the "retrieval URI". It's
often possible to pass an anonymous schema to an implementation in which
case that schema would have no retrieval URI.Let's assume a schema is referenced using the URI
https://example.com/schemas/address and the following schema is
retrieved. schema{  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
The base URI for this schema is the same as the retrieval URI, https://example.com/schemas/address.$idYou can set the base URI by using the $id keyword at the root of the
schema. The value of $id is a URI-reference without a fragment that
resolves against the retrieval-uri. The resulting URI is
the base URI for the schema.Draft-specific info:Draft 4Draft 4-7In Draft 4, $id is just id (without the dollar sign).This is analogous to the <base> tag in HTML.
When the $id keyword appears in a subschema, it means something slightly different. See the bundling section for more.
Let's assume the URIs https://example.com/schema/address and
https://example.com/schema/billing-address both identify the following
schema. schema{  "$id": "/schemas/address",﻿  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
No matter which of the two URIs is used to retrieve this schema, the
base URI will be https://example.com/schemas/address, which is the
result of the $id URI-reference resolving against the
Retrieval URI.However, using a relative reference when setting a base URI can be
problematic. For example, we couldn't use this schema as an anonymous
schema because there would be no Retrieval URI and you
can't resolve a relative reference against nothing. For this and other
reasons, it's recommended that you always use an absolute URI when
declaring a base URI with $id.The base URI of the following schema will always be
https://example.com/schemas/address no matter what the
Retrieval URI was or if it's used as an anonymous schema. schema{  "$id": "https://example.com/schemas/address",﻿  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
JSON PointerIn addition to identifying a schema document, you can also identify
subschemas. The most common way to do that is to use a JSON
Pointer in the URI fragment that
points to the subschema.A JSON Pointer describes a slash-separated path to traverse the keys in
the objects in the document. Therefore, /properties/street_address
means:1)  find the value of the key properties2)  within that object, find the value of the key street_addressThe URI https://example.com/schemas/address#/properties/street_address
identifies the highlighted subschema in the following schema. schema{  "$id": "https://example.com/schemas/address",  "type": "object",  "properties": {    "street_address": { "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },  "required": ["street_address", "city", "state"]}﻿
$anchorA less common way to identify a subschema is to create a named anchor in
the schema using the $anchor keyword and using that name in the URI
fragment. Anchors must start with a letter followed by any number of
letters, digits, -, _, :, or ..Draft-specific info:Draft 4Draft 6-7In Draft 4, you declare an anchor the same way you do in Draft 6-7
except that $id is just id (without the dollar sign).If a named anchor is defined that doesn't follow these naming rules,
then behavior is undefined. Your anchors might work in some
implementation, but not others.
The URI https://example.com/schemas/address#street_address identifies
the subschema on the highlighted part of the following schema. schema{  "$id": "https://example.com/schemas/address",  "type": "object",  "properties": {    "street_address": { "$anchor": "street_address", "type": "string" },    "city": { "type": "string" },    "state": { "type": "string" }  },   "required": ["street_address", "city", "state"]}﻿
$refA schema can reference another schema using the $ref keyword. The
value of $ref is a URI-reference that is resolved against the
schema's Base URI. When evaluating a $ref, an
implementation uses the resolved identifier to retrieve the referenced
schema and applies that schema to the instance.
Draft-specific infoIn Draft 4-7, $ref behaves a little differently. When an
   object contains a $ref property, the object is considered a
   reference, not a schema. Therefore, any other properties you put
   in that object will not be treated as JSON Schema keywords and will
   be ignored by the validator. $ref can only be used where a
   schema is expected.
For this example, let's say we want to define a customer record, where
each customer may have both a shipping and a billing address. Addresses
are always the same — they have a street address, city and
state — so we don't want to duplicate that part of the schema
everywhere we want to store an address. Not only would that make the
schema more verbose, but it makes updating it in the future more
difficult. If our imaginary company were to start doing international
business in the future and we wanted to add a country field to all the
addresses, it would be better to do this in a single place rather than
everywhere that addresses are used. schema{  "$id": "https://example.com/schemas/customer",﻿  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "shipping_address": { "$ref": "/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"]}﻿
The URI-references in $ref resolve against the schema's
Base URI (https://example.com/schemas/customer) which
results in https://example.com/schemas/address. The implementation
retrieves that schema and uses it to evaluate the "shipping_address"
and "billing_address" properties.When using $ref in an anonymous schema, relative references may not be
resolvable. Let's assume this example is used as an anonymous schema
 schema{  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "shipping_address": { "$ref": "https://example.com/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"]}﻿  
The $ref at /properties/shipping_address can resolve just fine
without a non-relative base URI to resolve against, but the $ref at
/properties/billing_address can't resolve to a non-relative URI and
therefore can't be used to retrieve the address schema.
$defsSometimes we have small subschemas that are only intended for use in the
current schema and it doesn't make sense to define them as separate
schemas. Although we can identify any subschema using JSON Pointers or
named anchors, the $defs keyword gives us a standardized place to keep
subschemas intended for reuse in the current schema document.Let's extend the previous customer schema example to use a common
schema for the name properties. It doesn't make sense to define a new
schema for this and it will only be used in this schema, so it's a good
candidate for using $defs. schema{  "$id": "https://example.com/schemas/customer",﻿  "type": "object",  "properties": {    "first_name": { "$ref": "#/$defs/name" },    "last_name": { "$ref": "#/$defs/name" },    "shipping_address": { "$ref": "/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"],﻿  "$defs": {    "name": { "type": "string" }  }}﻿
$defs isn't just good for avoiding duplication. It can also be useful
for writing schemas that are easier to read and maintain. Complex parts
of the schema can be defined in $defs with descriptive names and
referenced where it's needed. This allows readers of the schema to more
quickly and easily understand the schema at a high level before diving
into the more complex parts.It's possible to reference an external subschema, but generally you
want to limit a $ref to referencing either an external schema or an
internal subschema defined in $defs.
RecursionThe $ref keyword may be used to create recursive schemas that refer to
themselves. For example, you might have a person schema that has an
array of children, each of which are also person instances. schema{  "type": "object",  "properties": {    "name": { "type": "string" },    "children": {      "type": "array",      "items": { "$ref": "#" }    }  }}﻿A snippet of the British royal family treedata{  "name": "Elizabeth",  "children": [    {      "name": "Charles",      "children": [        {          "name": "William",          "children": [            { "name": "George" },            { "name": "Charlotte" }          ]        },        {          "name": "Harry"        }      ]    }  ]}﻿compliant to schema
Above, we created a schema that refers to itself, effectively creating a
"loop" in the validator, which is both allowed and useful. Note,
however, that a $ref referring to another $ref could cause an
infinite loop in the resolver, and is explicitly disallowed. schema{  "$defs": {    "alice": { "$ref": "#/$defs/bob" },    "bob": { "$ref": "#/$defs/alice" }  }}﻿
Extending Recursive SchemasNew in draft 2019-09Documentation Coming SoonBundlingWorking with multiple schema documents is convenient for development,
but it's often more convenient for distribution to bundle all of your
schemas into a single schema document. This can be done using the $id
keyword in a subschema. When $id is used in a subschema, it indicates
an embedded schema. The identifier for the embedded schema is the value
of $id resolved against the Base URI of the schema it
appears in. A schema document that includes embedded schemas is called a
Compound Schema Document. Each schema with an $id in a Compound Schema
Document is called a Schema Resource.Draft-specific info:Draft 4Draft 4-7In Draft 4, $id is just id (without the dollar sign).This is analogous to the <iframe> tag in HTML.
It is unusual to use embedded schemas when developing schemas. It's
generally best not to use this feature explicitly and use schema
bundling tools to construct bundled schemas if such a thing is needed.
:::
This example shows the customer schema example and the address schema
example bundled into a Compound Schema Document. schema{  "$id": "https://example.com/schemas/customer",  "$schema": "https://json-schema.org/draft/2020-12/schema",﻿  "type": "object",  "properties": {    "first_name": { "type": "string" },    "last_name": { "type": "string" },    "shipping_address": { "$ref": "/schemas/address" },    "billing_address": { "$ref": "/schemas/address" }  },  "required": ["first_name", "last_name", "shipping_address", "billing_address"],﻿  "$defs": {    "address": {      "$id": "https://example.com/schemas/address",      "$schema": "http://json-schema.org/draft-07/schema#",﻿      "type": "object",      "properties": {        "street_address": { "type": "string" },        "city": { "type": "string" },        "state": { "$ref": "#/definitions/state" }      },      "required": ["street_address", "city", "state"],﻿      "definitions": {        "state": { "enum": ["CA", "NY", "... etc ..."] }      }    }  }}﻿
All references in a Compound Schema Document need to be the same whether
the Schema Resources are bundled or not. Notice that the $ref keywords
from the customer schema have not changed. The only difference is that
the address schema is now defined at /$defs/address instead of a
separate schema document. You couldn't use #/$defs/address to
reference the address schema because if you unbundled the schema, that
reference would no longer point to the address schema.Draft-specific infoIn Draft 4-7, both of these URIs are valid because a subschema
   $id only represented a base URI change, not an embedded schema.
   However, even though it's allowed, it's still highly recommended
   that JSON Pointers don't cross a schema with a base URI change.
You should also see that "$ref": "#/definitions/state" resolves to the
definitions keyword in the address schema rather than the one at the
top level schema like it would if the embedded schema wasn't used.Each Schema Resource is evaluated independently and may use different
JSON Schema dialects. The example above has the address Schema Resource
using Draft 7 while the customer Schema Resource uses Draft 2020-12. If
no $schema is declared in an embedded schema, it defaults to using the
dialect of the parent schema.Draft-specific infoIn Draft 4-7, a subschema $id is just a base URI change and not
   considered an independent Schema Resource. Because $schema is
   only allowed at the root of a Schema Resource, all schemas bundled
   using subschema $id must use the same dialect.
Draft-specific infoIn Draft 2020-12, support for changing dialects in an embedded schema 
   (using $schema with a different value than the parent schema) was added.Go BackBoolean JSON Schema combinationUp NextMedia: string-encoding non-JSON dataNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaCreating your first schemaJSON Schema is a vocabulary that you can use to annotate and validate JSON documents. This tutorial guides you through the process of creating a JSON Schema.After creating your JSON Schema, you can then validate example data against your schema by using a validator in a language of your choice. Please, visit Tools and select the validator that better suit your needs.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Table of Contents●Overview
●Introduction to JSON Schema

●Create a schema definition
●Define properties



●Create a nested data structure
●Add an external reference

●Validate JSON data against the schemaOverviewThe example we use in this guide is a product catalog that stores its data using JSON objects, like the following:data{  "productId": 1,  "productName": "A green door",  "price": 12.50,  "tags": [ "home", "green" ]}﻿
Each product in the catalog has:productId: an identifier for the productproductName: the product nameprice: the cost to the consumertags: an optional array of identifying tagsThe JSON object is human-readable, but it doesn’t include any context or metadata. There’s no way to tell from looking at the object what the keys mean or what the possible inputs are. JSON Schema is a standard for providing answers to these questions. In this guide, you will create a JSON Schema document that describes the structure, constraints, and data types for a set of JSON data.Introduction to JSON SchemaThe instance is the JSON document that is being validated or described, and the schema is the document that contains the description.The most basic schema is a blank JSON object, which constrains nothing, allows anything, and describes nothing:data{}﻿
By adding validation keywords to the schema, you can apply constraints to an instance. For example, you can use the type keyword to constrain an instance to an object, array, string, number, boolean, or null:data{ "type": "string" }﻿
JSON Schema is hypermedia-ready and ideal for annotating your existing JSON-based HTTP API. JSON Schema documents are identified by URIs, which can be used in HTTP link headers and within JSON Schema documents to allow for recursive definitions.Create a schema definitionTo create a basic schema definition, define the following keywords:$schema: specifies which draft of the JSON Schema standard the schema adheres to.$id: sets a URI for the schema. You can use this unique URI to refer to elements of the schema from inside the same document or from external JSON documents.title and description: state the intent of the schema. These keywords don’t add any constraints to the data being validated.type: defines the first constraint on the JSON data. In the product catalog example below, this keyword specifies that the data must be a JSON object.For example: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product in the catalog",  "type": "object"}﻿
The keywords are defined using JSON keys. Typically, the data being validated is contained in a JSON data document, but JSON Schema can also validate JSON data contained in other content types, such as text or XML files.In JSON Schema terminology, $schema and $id are schema keywords, title and description are schema annotations, and type is a validation keyword.Define propertiesThis section adds the properties keyword. In JSON Schema terms, properties is a validation keyword. When you define properties, you create an object where each property represents a key in the JSON data that’s being validated. You can also specify which properties defined in the object are required.Add the properties objectUsing the product catalog example, productId is a numeric value that uniquely identifies a product. Since this is the canonical identifier for the product, it’s required.To add the properties object to the schema:Add the properties validation keyword to the end of the schema:1 ...
2   "title": "Product",
3   "description": "A product from Acme's catalog",
4   "type": "object",
5   "properties": {
6     "productId": {}
7   }
8 
Add the productId keyword, along with the following schema annotations:description: describes what productId is. In this case, it’s the product’s unique identifier.type: defines what kind of data is expected. For this example, since the product identifier is a numeric value, use integer.1...
2  "properties": {
3    "productId": {
4      "description": "The unique identifier for a product",
5      "type": "integer"
6    }
7  }
8
With the new properties validation keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    }  }}﻿
The following example adds another required key, productName. This value is a string: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    }  }}﻿
The properties object now includes two keys, productId and productName. When JSON data is validated against this schema, validation fails for any documents that contain invalid data in either of these fields.Define required propertiesThis section describes how to specify that certain properties are required. This example makes the two existing keys required and adds another required key named price. The price key has a description and type just like the other keys, but it also specifies a minimum value. Because nothing in the store is free, each product requires a price value that’s above zero. Define this using the exclusiveMinimum validation keyword.To define a required property:Inside the properties object, add the price key. Include the usual schema annotations description and type, where type is a number:1   "properties": {
2     ...
3     "price": {
4       "description": "The price of the product",
5       "type": "number"
6     }
7   }
8
Add the exclusiveMinimum validation keyword and set the value to zero:1   "price": {
2     "description": "The price of the product",
3     "type": "number",
4     "exclusiveMinimum": 0
5   }
6 
Add the required validation keyword to the end of the schema, after the properties object. Add productID, productName, and the new price key to the array:1 ...
2   "properties": {
3     ...
4     "price": {
5       "description": "The price of the product",
6       "type": "number",
7       "exclusiveMinimum": 0
8     },
9   },
10   "required": [ "productId", "productName", "price" ]
11 
With the new required keyword and price key, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    }  },  "required": [ "productId", "productName", "price" ]}﻿
The exclusiveMinimum validation keyword is set to zero, which means that only values above zero are considered valid. To include zero as a valid option, you could use the minimum validation keyword instead.Define optional propertiesThis section describes how to define an optional property. For this example, define a keyword named tags using the following criteria:The tags keyword is optional.If tags is included, it must contain at least one item.All tags must be unique.All tags must be text.To define an optional property:Inside the properties object, add the tags keyword. Include the usual schema annotations description and type, and define type as an array:1 ...
2   "properties": {
3     ...
4     "tags": {
5       "description": "Tags for the product",
6       "type": "array"
7     }
8   }
9 
Add a new validation keyword for items to define what appears in the array. For example, string:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       }
8     }
9 
To make sure there is at least one item in the array, use the minItems validation keyword:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1
9     }
10 
To make sure that every item in the array is unique, use the uniqueItems validation keyword and set it to true:1 ...
2     "tags": {
3       "description": "Tags for the product",
4       "type": "array",
5       "items": {
6         "type": "string"
7       },
8       "minItems": 1,
9       "uniqueItems": true
10     }
11 
With the new tags keyword, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    }  },  "required": [ "productId", "productName", "price" ]}﻿
Because the new keyword is not required, there are no changes to the required section.Create a nested data structureThe earlier examples describe a flat schema with only one level. This section describes how to use nested data structures in JSON Schema.To create a nested data structure:Inside the properties object, create a new key called dimensions:1 ...
2   "properties": {
3   ...
4     "dimensions": {}
5   }
6 
Define the type validation keyword as object:1 ...
2   "dimensions": {
3     "type": "object"
4   }
5
Add the properties validation keyword to contain the nested data structure. Inside the new properties keyword, add keywords for length, width, and height that all use the number type:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     }
15   }
16
To make each of these properties required, add a required validation keyword inside the dimensions object:1 ...
2   "dimensions": {
3     "type": "object",
4     "properties": {
5       "length": {
6         "type": "number"
7       },
8       "width": {
9         "type": "number"
10       },
11       "height": {
12         "type": "number"
13       }
14     },
15     "required": [ "length", "width", "height" ]
16 }
17 
Using the new nested data structures, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    }  },  "required": [ "productId", "productName", "price" ]}﻿
The new required validation keyword only applies within the scope of the dimensions key.Add an external referenceThis section describes how to reference resources outside of the schema. Sharing schemas across many data structures is a common way to make them easier to use, read, and keep up-to-date. So far, the product catalog schema is self-contained. This section creates a new schema and then references it in the product catalog schema.The following schema validates a geographical location: schema{  "$id": "https://example.com/geographical-location.schema.json",  "$schema": "https://json-schema.org/draft/2020-12/schema",  "title": "Longitude and Latitude",  "description": "A geographical coordinate on a planet (most commonly Earth).",  "required": [ "latitude", "longitude" ],  "type": "object",  "properties": {    "latitude": {      "type": "number",      "minimum": -90,      "maximum": 90    },    "longitude": {      "type": "number",      "minimum": -180,      "maximum": 180    }  }}﻿
To reference this schema in the product catalog schema:Inside the properties object, add a key named warehouseLocation:1 ...
2   "properties": {
3   ...
4     "warehouseLocation": {}
5   }
6 
To link to the external geographical location schema, add the $ref schema keyword and the schema URL:1 ...
2   "warehouseLocation": {
3     "description": "Coordinates of the warehouse where the product is located.",
4     "$ref": "https://example.com/geographical-location.schema.json"
5   }
6 
With the external schema reference, the overall schema looks like this: schema{  "$schema": "https://json-schema.org/draft/2020-12/schema",  "$id": "https://example.com/product.schema.json",  "title": "Product",  "description": "A product from Acme's catalog",  "type": "object",  "properties": {    "productId": {      "description": "The unique identifier for a product",      "type": "integer"    },    "productName": {      "description": "Name of the product",      "type": "string"    },    "price": {      "description": "The price of the product",      "type": "number",      "exclusiveMinimum": 0    },    "tags": {      "description": "Tags for the product",      "type": "array",      "items": {        "type": "string"      },      "minItems": 1,      "uniqueItems": true    },    "dimensions": {      "type": "object",      "properties": {        "length": {          "type": "number"        },        "width": {          "type": "number"        },        "height": {          "type": "number"        }      },      "required": [ "length", "width", "height" ]    },    "warehouseLocation": {      "description": "Coordinates of the warehouse where the product is located.",      "$ref": "https://example.com/geographical-location.schema.json"    }  },  "required": [ "productId", "productName", "price" ]}﻿
Validate JSON data against the schemaNow that you have your JSON Schema, it is time to validate JSON data against it using a JSON Schema Validator.A Validator is a tool that implements the JSON Schema specification. All validators works in a similar way: they take a JSON Schema and a JSON Instance as input and they return the validation result as output.To try it yourself, please visit Tools and select the validator that best suits your needs, or use the editors available below to explore the different Schemas and Instances and see the different validation results.JSON SchemaSelect a Schema:1JSON InstanceSelect an Instance:1Validation ResultDownloadWhat Next?Now that you know how to create a JSON Schema and use it to validate JSON data, we'd invite you to continue your JSON Schema journey:Learn more about JSON Schema by visiting the reference documentation.Explore the details of the current version of the Spec 2020-12.If you already know how to create JSON Schemas and you are looking for different JSON Schema use cases like schema generation, code generation, documentation, UI generation or JSON Schema processing or conversion, please visit Tools and explore the amazing tooling available in the JSON Schema Ecosystem.Go BackOverviewUp NextMiscellaneous examplesNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nExpires 18 December 2022\nWorkgroup:
Internet Engineering Task Force
Internet-Draft:
draft-bhutton-json-schema-01
Published:

16 June 2022
    
Intended Status:
Informational
Expires:
18 December 2022
Authors:


      A. Wright, Ed.



      H. Andrews, Ed.



      B. Hutton, Ed.

Postman


      G. Dennis\nB. Hutton, Ed.

Postman\nJSON Schema: A Media Type for Describing JSON Documents\nJSON Schema defines the media type "application/schema+json", a JSON-based format
                for describing the structure of JSON data.
                JSON Schema asserts what a JSON document must look like,
                ways to extract information from it,
                and how to interact with it.
                The "application/schema-instance+json" media type provides additional
                feature-rich integration with "application/schema+json" beyond what can be offered
                for "application/json" documents.¶\nThe issues list for this draft can be found at
                https://github.com/json-schema-org/json-schema-spec/issues.¶\nhttps://github.com/json-schema-org/json-schema-spec/issues\nhttps://github.com/json-schema-org/json-schema-spec/issues\nFor additional information, see https://json-schema.org/.¶\nhttps://json-schema.org/\nhttps://json-schema.org/\nTo provide feedback, use this issue tracker, the communication methods listed on the
                homepage, or email the document editors.¶\nStatus of This Memo
        

        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.¶

        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at https://datatracker.ietf.org/drafts/current/.¶

        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."¶

        This Internet-Draft will expire on 18 December 2022.¶\nThis Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.¶\nInternet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at https://datatracker.ietf.org/drafts/current/.¶\nhttps://datatracker.ietf.org/drafts/current/\nhttps://datatracker.ietf.org/drafts/current/\nInternet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."¶\nThis Internet-Draft will expire on 18 December 2022.¶\nCopyright Notice
        

            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶

            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶\nCopyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶\nThis document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶\nhttps://trustee.ietf.org/license-info\nhttps://trustee.ietf.org/license-info\n▲
Table of Contents
        


            1.  Introduction

          
            2.  Conventions and Terminology

          
            3.  Overview

          
            4.  Definitions


                4.1.  JSON Document

              
                4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances

                

              
                4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources

                

            

          
            5.  Fragment Identifiers

          
            6.  General Considerations


                6.1.  Range of JSON Values

              
                6.2.  Programming Language Independence

              
                6.3.  Mathematical Integers

              
                6.4.  Regular Expressions

              
                6.5.  Extending JSON Schema

            

          
            7.  Keyword Behaviors


                7.1.  Lexical Scope and Dynamic Scope

              
                7.2.  Keyword Interactions

              
                7.3.  Default Behaviors

              
                7.4.  Identifiers

              
                7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas

                

              
                7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types

                

              
                7.7.  Annotations


                    7.7.1.  Collecting Annotations

                

              
                7.8.  Reserved Locations

              
                7.9.  Loading Instance Data

            

          
            8.  The JSON Schema Core Vocabulary


                8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs

                

              
                8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"

                

              
                8.3.  Comments With "$comment"

            

          
            9.  Loading and Processing Schemas


                9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema

                

              
                9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources

                

              
                9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating

                

              
                9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas

                

              
                9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia

                

            

          
            10. A Vocabulary for Applying Subschemas


                10.1.  Keyword Independence

              
                10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally

                

              
                10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects

                

            

          
            11. A Vocabulary for Unevaluated Locations


                11.1.  Keyword Independence

              
                11.2.  unevaluatedItems

              
                11.3.  unevaluatedProperties

            

          
            12. Output Formatting


                12.1.  Format

              
                12.2.  Output Formats

              
                12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results

                

              
                12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas

                

            

          
            13. Security Considerations

          
            14. IANA Considerations


                14.1.  application/schema+json

              
                14.2.  application/schema-instance+json

            

          
            15. References


                15.1.  Normative References

              
                15.2.  Informative References

            

          
            Appendix A.  Schema identification examples

          
            Appendix B.  Manipulating schema documents and references


                B.1.  Bundling schema resources into a single document

              
                B.2.  Reference removal is not always safe

            

          
            Appendix C.  Example of recursive schema extension

          
            Appendix D.  Working with vocabularies


                D.1.  Best practices for vocabulary and meta-schema authors

              
                D.2.  Example meta-schema with vocabulary declarations

            

          
            Appendix E.  References and generative use cases

          
            Appendix F.  Acknowledgments

          
            Appendix G.  ChangeLog

          
            Authors' Addresses\n2.  Conventions and Terminology\n2.  Conventions and Terminology\nConventions and Terminology\n4.  Definitions


                4.1.  JSON Document

              
                4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances

                

              
                4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources\n4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances\n4.2.1.  Instance Data Model\n4.2.1.  Instance Data Model\n4.2.2.  Instance Equality\n4.2.2.  Instance Equality\n4.2.3.  Non-JSON Instances\n4.2.3.  Non-JSON Instances\n4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources\n4.3.  JSON Schema Documents\nJSON Schema Documents\n4.3.1.  JSON Schema Objects and Keywords\n4.3.1.  JSON Schema Objects and Keywords\nJSON Schema Objects and Keywords\n4.3.2.  Boolean JSON Schemas\n4.3.2.  Boolean JSON Schemas\n4.3.3.  Schema Vocabularies\n4.3.3.  Schema Vocabularies\n4.3.5.  Root Schema and Subschemas and Resources\n4.3.5.  Root Schema and Subschemas and Resources\nRoot Schema and Subschemas and Resources\n5.  Fragment Identifiers\n5.  Fragment Identifiers\n6.  General Considerations


                6.1.  Range of JSON Values

              
                6.2.  Programming Language Independence

              
                6.3.  Mathematical Integers

              
                6.4.  Regular Expressions

              
                6.5.  Extending JSON Schema\n6.  General Considerations\nGeneral Considerations\n6.1.  Range of JSON Values\n6.1.  Range of JSON Values\n6.2.  Programming Language Independence\n6.2.  Programming Language Independence\nProgramming Language Independence\n6.3.  Mathematical Integers\n6.3.  Mathematical Integers\nMathematical Integers\n6.4.  Regular Expressions\n6.4.  Regular Expressions\n6.5.  Extending JSON Schema\n6.5.  Extending JSON Schema\nExtending JSON Schema\n7.  Keyword Behaviors


                7.1.  Lexical Scope and Dynamic Scope

              
                7.2.  Keyword Interactions

              
                7.3.  Default Behaviors

              
                7.4.  Identifiers

              
                7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas

                

              
                7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types

                

              
                7.7.  Annotations


                    7.7.1.  Collecting Annotations

                

              
                7.8.  Reserved Locations

              
                7.9.  Loading Instance Data\n7.  Keyword Behaviors\n7.1.  Lexical Scope and Dynamic Scope\n7.1.  Lexical Scope and Dynamic Scope\nLexical Scope and Dynamic Scope\n7.2.  Keyword Interactions\n7.2.  Keyword Interactions\n7.3.  Default Behaviors\n7.3.  Default Behaviors\n7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas\n7.5.1.  Referenced and Referencing Schemas\n7.5.1.  Referenced and Referencing Schemas\nReferenced and Referencing Schemas\n7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types\n7.6.1.  Assertions and Instance Primitive Types\n7.6.1.  Assertions and Instance Primitive Types\nAssertions and Instance Primitive Types\n7.7.  Annotations


                    7.7.1.  Collecting Annotations\n7.7.1.  Collecting Annotations\n7.7.1.  Collecting Annotations\nCollecting Annotations\n7.8.  Reserved Locations\n7.8.  Reserved Locations\n7.9.  Loading Instance Data\n7.9.  Loading Instance Data\nLoading Instance Data\n8.  The JSON Schema Core Vocabulary


                8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs

                

              
                8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"

                

              
                8.3.  Comments With "$comment"\n8.  The JSON Schema Core Vocabulary\nThe JSON Schema Core Vocabulary\n8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs\n8.1.  Meta-Schemas and Vocabularies\nMeta-Schemas and Vocabularies\n8.1.1.  The "$schema" Keyword\n8.1.1.  The "$schema" Keyword\nThe "$schema" Keyword\n8.1.2.  The "$vocabulary" Keyword\n8.1.2.  The "$vocabulary" Keyword\nThe "$vocabulary" Keyword\n8.1.3.  Updates to Meta-Schema and Vocabulary URIs\n8.1.3.  Updates to Meta-Schema and Vocabulary URIs\nUpdates to Meta-Schema and Vocabulary URIs\n8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"\n8.2.  Base URI, Anchors, and Dereferencing\nBase URI, Anchors, and Dereferencing\n8.2.1.  The "$id" Keyword\n8.2.1.  The "$id" Keyword\n8.2.2.  Defining location-independent identifiers\n8.2.2.  Defining location-independent identifiers\nDefining location-independent identifiers\n8.2.3.  Schema References\n8.2.3.  Schema References\n8.2.4.  Schema Re-Use With "$defs"\n8.2.4.  Schema Re-Use With "$defs"\nSchema Re-Use With "$defs"\n8.3.  Comments With "$comment"\n8.3.  Comments With "$comment"\nComments With "$comment"\n9.  Loading and Processing Schemas


                9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema

                

              
                9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources

                

              
                9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating

                

              
                9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas

                

              
                9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia\n9.  Loading and Processing Schemas\nLoading and Processing Schemas\n9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema\n9.1.  Loading a Schema\n9.1.1.  Initial Base URI\n9.1.1.  Initial Base URI\n9.1.2.  Loading a referenced schema\n9.1.2.  Loading a referenced schema\nLoading a referenced schema\n9.1.3.  Detecting a Meta-Schema\n9.1.3.  Detecting a Meta-Schema\nDetecting a Meta-Schema\n9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources\n9.2.1.  JSON Pointer fragments and embedded schema resources\n9.2.1.  JSON Pointer fragments and embedded schema resources\nJSON Pointer fragments and embedded schema resources\n9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating\n9.3.  Compound Documents\n9.3.2.  Differing and Default Dialects\n9.3.2.  Differing and Default Dialects\nDiffering and Default Dialects\n9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas\n9.4.1.  Guarding Against Infinite Recursion\n9.4.1.  Guarding Against Infinite Recursion\nGuarding Against Infinite Recursion\n9.4.2.  References to Possible Non-Schemas\n9.4.2.  References to Possible Non-Schemas\nReferences to Possible Non-Schemas\n9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia\n9.5.  Associating Instances and Schemas\nAssociating Instances and Schemas\n9.5.1.  Usage for Hypermedia\n9.5.1.  Usage for Hypermedia\n10. A Vocabulary for Applying Subschemas


                10.1.  Keyword Independence

              
                10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally

                

              
                10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects\n10. A Vocabulary for Applying Subschemas\nA Vocabulary for Applying Subschemas\n10.1.  Keyword Independence\n10.1.  Keyword Independence\n10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally\n10.2.  Keywords for Applying Subschemas in Place\nKeywords for Applying Subschemas in Place\n10.2.1.  Keywords for Applying Subschemas With Logic\n10.2.1.  Keywords for Applying Subschemas With Logic\nKeywords for Applying Subschemas With Logic\n10.2.2.  Keywords for Applying Subschemas Conditionally\n10.2.2.  Keywords for Applying Subschemas Conditionally\nKeywords for Applying Subschemas Conditionally\n10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects\n10.3.  Keywords for Applying Subschemas to Child Instances\nKeywords for Applying Subschemas to Child Instances\n10.3.1.  Keywords for Applying Subschemas to Arrays\n10.3.1.  Keywords for Applying Subschemas to Arrays\nKeywords for Applying Subschemas to Arrays\n10.3.2.  Keywords for Applying Subschemas to Objects\n10.3.2.  Keywords for Applying Subschemas to Objects\nKeywords for Applying Subschemas to Objects\n11. A Vocabulary for Unevaluated Locations


                11.1.  Keyword Independence

              
                11.2.  unevaluatedItems

              
                11.3.  unevaluatedProperties\n11. A Vocabulary for Unevaluated Locations\nA Vocabulary for Unevaluated Locations\n11.1.  Keyword Independence\n11.1.  Keyword Independence\n11.2.  unevaluatedItems\n11.2.  unevaluatedItems\n11.3.  unevaluatedProperties\n11.3.  unevaluatedProperties\nunevaluatedProperties\n12. Output Formatting


                12.1.  Format

              
                12.2.  Output Formats

              
                12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results

                

              
                12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas\n12. Output Formatting\n12.2.  Output Formats\n12.2.  Output Formats\n12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results\n12.3.  Minimum Information\n12.3.1.  Keyword Relative Location\n12.3.1.  Keyword Relative Location\nKeyword Relative Location\n12.3.2.  Keyword Absolute Location\n12.3.2.  Keyword Absolute Location\nKeyword Absolute Location\n12.3.3.  Instance Location\n12.3.3.  Instance Location\n12.3.4.  Error or Annotation\n12.3.4.  Error or Annotation\n12.3.5.  Nested Results\n12.3.5.  Nested Results\n12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas\n12.4.  Output Structure\n12.4.5.  Output validation schemas\n12.4.5.  Output validation schemas\nOutput validation schemas\n13. Security Considerations\n13. Security Considerations\nSecurity Considerations\n14. IANA Considerations


                14.1.  application/schema+json

              
                14.2.  application/schema-instance+json\n14. IANA Considerations\n14.1.  application/schema+json\n14.1.  application/schema+json\napplication/schema+json\n14.2.  application/schema-instance+json\n14.2.  application/schema-instance+json\napplication/schema-instance+json\n15. References


                15.1.  Normative References

              
                15.2.  Informative References\n15.1.  Normative References\n15.1.  Normative References\n15.2.  Informative References\n15.2.  Informative References\nInformative References\nAppendix A.  Schema identification examples\nAppendix A.  Schema identification examples\nSchema identification examples\nAppendix B.  Manipulating schema documents and references


                B.1.  Bundling schema resources into a single document

              
                B.2.  Reference removal is not always safe\nAppendix B.  Manipulating schema documents and references\nManipulating schema documents and references\nB.1.  Bundling schema resources into a single document\nB.1.  Bundling schema resources into a single document\nBundling schema resources into a single document\nB.2.  Reference removal is not always safe\nB.2.  Reference removal is not always safe\nReference removal is not always safe\nAppendix C.  Example of recursive schema extension\nAppendix C.  Example of recursive schema extension\nExample of recursive schema extension\nAppendix D.  Working with vocabularies


                D.1.  Best practices for vocabulary and meta-schema authors

              
                D.2.  Example meta-schema with vocabulary declarations\nAppendix D.  Working with vocabularies\nWorking with vocabularies\nD.1.  Best practices for vocabulary and meta-schema authors\nD.1.  Best practices for vocabulary and meta-schema authors\nBest practices for vocabulary and meta-schema authors\nD.2.  Example meta-schema with vocabulary declarations\nD.2.  Example meta-schema with vocabulary declarations\nExample meta-schema with vocabulary declarations\nAppendix E.  References and generative use cases\nAppendix E.  References and generative use cases\nReferences and generative use cases\nAppendix F.  Acknowledgments\nAppendix F.  Acknowledgments\nAppendix G.  ChangeLog\nAppendix G.  ChangeLog\nJSON Schema is a JSON media type for defining the structure of JSON data. JSON Schema
                is intended to define validation, documentation, hyperlink navigation, and interaction
                control of JSON data.¶\nThis specification defines JSON Schema core terminology and mechanisms, including
                pointing to another JSON Schema by reference,
                dereferencing a JSON Schema reference,
                specifying the dialect being used,
                specifying a dialect's vocabulary requirements,
                and defining the expected output.¶\nOther specifications define the vocabularies that perform assertions about validation,
                linking, annotation, navigation, and interaction.¶\n2. Conventions and Terminology\nConventions and Terminology\nThe key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in RFC 2119 [RFC2119].¶\nThe terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in RFC 8259 [RFC8259].¶\nThis document proposes a new media type "application/schema+json" to identify a JSON
                Schema for describing JSON data.
                It also proposes a further optional media type, "application/schema-instance+json",
                to provide additional integration features.
                JSON Schemas are themselves JSON documents.
                This, and related specifications, define keywords allowing authors to describe JSON
                data in several ways.¶\nJSON Schema uses keywords to assert constraints on JSON instances or annotate those
                instances with additional information.  Additional keywords are used to apply
                assertions and annotations to more complex JSON data structures, or based on
                some sort of condition.¶\nTo facilitate re-use, keywords can be organized into vocabularies. A vocabulary
                consists of a list of keywords, together with their syntax and semantics.
                A dialect is defined as a set of vocabularies and their required support
                identified in a meta-schema.¶\nJSON Schema can be extended either by defining additional vocabularies,
                or less formally by defining additional keywords outside of any vocabulary.
                Unrecognized individual keywords simply have their values collected as annotations,
                while the behavior with respect to an unrecognized vocabulary can be controlled
                when declaring which vocabularies are in use.¶\nThis document defines a core vocabulary that MUST be supported by any
                implementation, and cannot be disabled.  Its keywords are each prefixed
                with a "$" character to emphasize their required nature.  This vocabulary
                is essential to the functioning of the "application/schema+json" media
                type, and is used to bootstrap the loading of other vocabularies.¶\nAdditionally, this document defines a RECOMMENDED vocabulary of keywords
                for applying subschemas conditionally, and for applying subschemas to
                the contents of objects and arrays.  Either this vocabulary or one very
                much like it is required to write schemas for non-trivial JSON instances,
                whether those schemas are intended for assertion validation, annotation,
                or both.  While not part of the required core vocabulary, for maximum
                interoperability this additional vocabulary is included in this document
                and its use is strongly encouraged.¶\nFurther vocabularies for purposes such as structural validation or
                hypermedia annotation are defined in other documents.  These other
                documents each define a dialect collecting the standard sets of
                vocabularies needed to write schemas for that document's purpose.¶\nA JSON document is an information resource (series of octets) described by the
                    application/json media type.¶\nIn JSON Schema, the terms "JSON document", "JSON text", and "JSON value" are
                    interchangeable because of the data model it defines.¶\nJSON Schema is only defined over JSON documents. However, any document or memory
                    structure that can be parsed into or processed according to the JSON Schema data
                    model can be interpreted against a JSON Schema, including media types like
                    CBOR [RFC7049].¶\nA JSON document to which a schema is applied is known as an "instance".¶\nJSON Schema is defined over "application/json" or compatible documents,
                    including media types with the "+json" structured syntax suffix.¶\nAmong these, this specification defines the "application/schema-instance+json"
                    media type which defines handling for fragments in the URI.¶\n4.2.1. Instance Data Model\nJSON Schema interprets documents according to a data model. A JSON value
                        interpreted according to this data model is called an "instance".¶\nAn instance has one of six primitive types, and a range of possible values
                        depending on the type:¶\nWhitespace and formatting concerns, including different lexical
                        representations of numbers that are equal within the data model, are thus
                        outside the scope of JSON Schema.  JSON Schema
                        vocabularies (Section 8.1) that wish
                        to work with such differences in lexical representations SHOULD define
                        keywords to precisely interpret formatted strings within the data model
                        rather than relying on having the original JSON representation Unicode
                        characters available.¶\nvocabularies (Section 8.1)\nSince an object cannot have two properties with the same key, behavior for a
                        JSON document that tries to define two properties with
                        the same key in a single object is undefined.¶\nNote that JSON Schema vocabularies are free to define their own extended
                        type system.  This should not be confused with the core data model types
                        defined here.  As an example, "integer" is a reasonable type for a
                        vocabulary to define as a value for a keyword, but the data model
                        makes no distinction between integers and other numbers.¶\n4.2.2. Instance Equality\nTwo JSON instances are said to be equal if and only if they are of the same type
                        and have the same value according to the data model. Specifically, this means:¶\nboth are strings, and are the same codepoint-for-codepoint; or¶\nboth are numbers, and have the same mathematical value; or¶\nboth are arrays, and have an equal value item-for-item; or¶\nboth are objects, and each property in one has exactly one property with
                                a key equal to the other's, and that other property has an equal
                                value.¶\nImplied in this definition is that arrays must be the same length,
                        objects must have the same number of members,
                        properties in objects are unordered,
                        there is no way to define multiple properties with the same key,
                        and mere formatting differences (indentation, placement of commas, trailing
                        zeros) are insignificant.¶\n4.2.3. Non-JSON Instances\nIt is possible to use JSON Schema with a superset of the JSON Schema data model,
                        where an instance may be outside any of the six JSON data types.¶\nIn this case, annotations still apply; but most validation keywords will not be useful,
                        as they will always pass or always fail.¶\nA custom vocabulary may define support for a superset of the core data model.
                        The schema itself may only be expressible in this superset;
                        for example, to make use of the "const" keyword.¶\n4.3. JSON Schema Documents
        

                    A JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema can itself be interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".¶

                    A JSON Schema MUST be an object or a boolean.¶

          
4.3.1. JSON Schema Objects and Keywords
          

                        Object properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of five categories:¶

            identifiers:
            
                                control schema identification through setting a URI
                                for the schema and/or changing how the base URI is determined¶

            
assertions:
            
                                produce a boolean result when applied to an instance¶

            
annotations:
            
                                attach information to an instance for application use¶

            
applicators:
            
                                apply one or more subschemas to a particular location
                                in the instance, and combine or modify their results¶

            
reserved locations:
            
                                do not directly affect results, but reserve a place
                                for a specific purpose to ensure interoperability¶

          


                        Keywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.¶

                        Keywords which are properties within the same schema object are referred to as adjacent keywords.¶

                        Extension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.¶

                        A JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be treated as annotations, where the value
                        of the keyword is the value of the annotation.¶

                        An empty schema is a JSON Schema with no properties, or only unknown
                        properties.¶


          
4.3.2. Boolean JSON Schemas
          

                        The boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertion results, regardless of the
                        instance value.  They never produce annotation results.¶

                        These boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).¶

            true:
            
                                Always passes validation, as if the empty schema {}¶

            
false:
            
                                Always fails validation, as if the schema { "not": {} }¶

          


                        While the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.¶


          
4.3.3. Schema Vocabularies
          

                        A schema vocabulary, or simply a vocabulary, is a set of keywords,
                        their syntax, and their semantics.  A vocabulary is generally organized
                        around a particular purpose.  Different uses of JSON Schema, such
                        as validation, hypermedia, or user interface generation, will
                        involve different sets of vocabularies.¶

                        Vocabularies are the primary unit of re-use in JSON Schema, as schema
                        authors can indicate what vocabularies are required or optional in
                        order to process the schema.  Since vocabularies are identified by URIs
                        in the meta-schema, generic implementations can load extensions to support
                        previously unknown vocabularies.  While keywords can be supported outside
                        of any vocabulary, there is no analogous mechanism to indicate individual
                        keyword usage.¶

                        A schema vocabulary can be defined by anything from an informal description
                        to a standards proposal, depending on the audience and interoperability
                        expectations.  In particular, in order to facilitate vocabulary use within
                        non-public organizations, a vocabulary specification need not be published
                        outside of its scope of use.¶


          
4.3.4. Meta-Schemas
          

                        A schema that itself describes a schema is called a meta-schema.
                        Meta-schemas are used to validate JSON Schemas and specify which vocabularies
                        they are using.¶

                        Typically, a meta-schema will specify a set of vocabularies, and validate
                        schemas that conform to the syntax of those vocabularies.  However, meta-schemas
                        and vocabularies are separate in order to allow meta-schemas to validate
                        schema conformance more strictly or more loosely than the vocabularies'
                        specifications call for.  Meta-schemas may also describe and validate
                        additional keywords that are not part of a formal vocabulary.¶



          
4.3.5. Root Schema and Subschemas and Resources
          

                        A JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶

                        The root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶

                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:¶


{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶


                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶

                        As with the root schema, a subschema is either an object or a boolean.¶

                        As discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶

                        Whether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n4.3. JSON Schema Documents\nJSON Schema Documents\nA JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema can itself be interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".¶\nA JSON Schema MUST be an object or a boolean.¶\n4.3.1. JSON Schema Objects and Keywords\nJSON Schema Objects and Keywords\nObject properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of five categories:¶\nKeywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.¶\nKeywords which are properties within the same schema object are referred to as adjacent keywords.¶\nExtension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.¶\nA JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be treated as annotations, where the value
                        of the keyword is the value of the annotation.¶\nAn empty schema is a JSON Schema with no properties, or only unknown
                        properties.¶\n4.3.2. Boolean JSON Schemas\nThe boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertion results, regardless of the
                        instance value.  They never produce annotation results.¶\nThese boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).¶\nWhile the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.¶\n4.3.3. Schema Vocabularies\nA schema vocabulary, or simply a vocabulary, is a set of keywords,
                        their syntax, and their semantics.  A vocabulary is generally organized
                        around a particular purpose.  Different uses of JSON Schema, such
                        as validation, hypermedia, or user interface generation, will
                        involve different sets of vocabularies.¶\nVocabularies are the primary unit of re-use in JSON Schema, as schema
                        authors can indicate what vocabularies are required or optional in
                        order to process the schema.  Since vocabularies are identified by URIs
                        in the meta-schema, generic implementations can load extensions to support
                        previously unknown vocabularies.  While keywords can be supported outside
                        of any vocabulary, there is no analogous mechanism to indicate individual
                        keyword usage.¶\nA schema vocabulary can be defined by anything from an informal description
                        to a standards proposal, depending on the audience and interoperability
                        expectations.  In particular, in order to facilitate vocabulary use within
                        non-public organizations, a vocabulary specification need not be published
                        outside of its scope of use.¶\nA schema that itself describes a schema is called a meta-schema.
                        Meta-schemas are used to validate JSON Schemas and specify which vocabularies
                        they are using.¶\nTypically, a meta-schema will specify a set of vocabularies, and validate
                        schemas that conform to the syntax of those vocabularies.  However, meta-schemas
                        and vocabularies are separate in order to allow meta-schemas to validate
                        schema conformance more strictly or more loosely than the vocabularies'
                        specifications call for.  Meta-schemas may also describe and validate
                        additional keywords that are not part of a formal vocabulary.¶\n4.3.5. Root Schema and Subschemas and Resources
          

                        A JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶

                        The root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶

                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:¶


{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶


                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶

                        As with the root schema, a subschema is either an object or a boolean.¶

                        As discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶

                        Whether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n4.3.5. Root Schema and Subschemas and Resources\nRoot Schema and Subschemas and Resources\nA JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶\ncanonically [RFC6596]\nabsolute URI [RFC3986]\nsection 3.5 of RFC 3986 [RFC3986]\nsection 3.5 of RFC 3986\nThe root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶\nNote that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.\nSome keywords take schemas themselves, allowing JSON Schemas to be nested:¶\n{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶\nIn this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶\nAs with the root schema, a subschema is either an object or a boolean.¶\nAs discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶\nWhether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n5. Fragment Identifiers
      

                In accordance with section 3.1 of RFC 6839 [RFC6839],
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)¶

                Additionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.¶

                The use of JSON Pointers as URI fragment identifiers is described in
                RFC 6901 [RFC6901].
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.¶

                Per the W3C's
                best practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025],
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.¶

                Defining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the "$anchor" keyword (Section 8.2.2) section.¶\n5. Fragment Identifiers\nIn accordance with section 3.1 of RFC 6839 [RFC6839],
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)¶\nAdditionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.¶\nThe use of JSON Pointers as URI fragment identifiers is described in
                RFC 6901 [RFC6901].
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.¶\nPer the W3C's
                best practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025],
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.¶\nbest practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025]\nbest practices for fragment identifiers\nW3C.WD-fragid-best-practices-20121025\nDefining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the "$anchor" keyword (Section 8.2.2) section.¶\n"$anchor" keyword (Section 8.2.2)\n6. General Considerations\nGeneral Considerations\n6.1. Range of JSON Values\nAn instance may be any valid JSON value as defined by JSON [RFC8259].
                    JSON Schema imposes no restrictions on type: JSON Schema can describe any JSON
                    value, including, for example, null.¶\n6.2. Programming Language Independence
        

                    JSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.¶\n6.2. Programming Language Independence\nProgramming Language Independence\nJSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.¶\n6.3. Mathematical Integers
        

                    Some programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.¶

                    For consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.¶\n6.3. Mathematical Integers\nMathematical Integers\nSome programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.¶\nFor consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.¶\n6.4. Regular Expressions
        

                    Keywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                    These regular expressions SHOULD be valid according to the regular expression
                    dialect described in ECMA-262, section 21.2.1 [ecma262].¶

                    Regular expressions SHOULD be built with the "u" flag (or equivalent) to provide
                    Unicode support, or processed in such a way which provides Unicode support as
                    defined by ECMA-262.¶

                    Furthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:¶

individual Unicode characters, as defined by the JSON specification [RFC8259];¶

          simple character classes ([abc]), range character classes ([a-z]);¶

          complemented character classes ([^abc], [^a-z]);¶

          simple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");¶

          range quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;¶

          the beginning-of-input ("^") and end-of-input ("$") anchors;¶

          simple grouping ("(...)") and alternation ("|").¶

        

                    Finally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".¶\n6.4. Regular Expressions\nKeywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                    These regular expressions SHOULD be valid according to the regular expression
                    dialect described in ECMA-262, section 21.2.1 [ecma262].¶\nECMA-262, section 21.2.1 [ecma262]\nECMA-262, section 21.2.1\nRegular expressions SHOULD be built with the "u" flag (or equivalent) to provide
                    Unicode support, or processed in such a way which provides Unicode support as
                    defined by ECMA-262.¶\nFurthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:¶\nindividual Unicode characters, as defined by the JSON specification [RFC8259];¶\nJSON specification [RFC8259]\nsimple character classes ([abc]), range character classes ([a-z]);¶\ncomplemented character classes ([^abc], [^a-z]);¶\nsimple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");¶\nrange quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;¶\nthe beginning-of-input ("^") and end-of-input ("$") anchors;¶\nsimple grouping ("(...)") and alternation ("|").¶\nFinally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".¶\n6.5. Extending JSON Schema
        

                    Additional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD treat keywords they do not support as annotations,
                    where the value of the keyword is the value of the annotation.¶

                    Implementations MAY provide the ability to register or load handlers
                    for vocabularies that they do not support directly.  The exact mechanism
                    for registering and implementing such handlers is implementation-dependent.¶\n6.5. Extending JSON Schema\nExtending JSON Schema\nAdditional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD treat keywords they do not support as annotations,
                    where the value of the keyword is the value of the annotation.¶\nImplementations MAY provide the ability to register or load handlers
                    for vocabularies that they do not support directly.  The exact mechanism
                    for registering and implementing such handlers is implementation-dependent.¶\nJSON Schema keywords fall into several general behavior categories.
                Assertions validate that an instance satisfies constraints, producing
                a boolean result.  Annotations attach information that applications
                may use in any way they see fit.
                Applicators apply subschemas to parts of the instance and combine
                their results.¶\nExtension keywords SHOULD stay within these categories, keeping in mind
                that annotations in particular are extremely flexible.  Complex behavior
                is usually better delegated to applications on the basis of annotation
                data than implemented directly as schema keywords.  However, extension
                keywords MAY define other behaviors for specialized purposes.¶\nEvaluating an instance against a schema involves processing all of the
                keywords in the schema against the appropriate locations within the instance.
                Typically, applicator keywords are processed until a schema object with no
                applicators (and therefore no subschemas) is reached.  The appropriate
                location in the instance is evaluated against the assertion and
                annotation keywords in the schema object, and their results are gathered
                into the parent schema according to the rules of the applicator.¶\nEvaluation of a parent schema object can complete once all of its
                subschemas have been evaluated, although in some circumstances evaluation
                may be short-circuited due to assertion results.  When annotations are
                being collected, some assertion result short-circuiting is not possible
                due to the need to examine all subschemas for annotation collection, including
                those that cannot further change the assertion result.¶\n7.1. Lexical Scope and Dynamic Scope
        

                    While most JSON Schema keywords can be evaluated on their own,
                    or at most need to take into account the values or results of
                    adjacent keywords in the same schema object, a few have more
                    complex behavior.¶

                    The lexical scope of a keyword is determined by the nested JSON
                    data structure of objects and arrays.  The largest such scope
                    is an entire schema document.  The smallest scope is a single
                    schema object with no subschemas.¶

                    Keywords MAY be defined with a partial value, such as a URI-reference,
                    which must be resolved against another value, such as another
                    URI-reference or a full URI, which is found through the lexical
                    structure of the JSON document.  The "$id", "$ref", and
                    "$dynamicRef" core keywords, and the "base" JSON Hyper-Schema
                    keyword, are examples of this sort of behavior.¶

                    Note that some keywords, such as "$schema", apply to the lexical
                    scope of the entire schema resource, and therefore MUST only
                    appear in a schema resource's root schema.¶

                    Other keywords may take into account the dynamic scope that
                    exists during the evaluation of a schema, typically together
                    with an instance document.
                    The outermost dynamic scope is the schema object at
                    which processing begins, even if it is not a schema resource root.
                    The path from this root schema to any particular keyword (that
                    includes any "$ref" and "$dynamicRef" keywords that may have
                    been resolved) is considered the keyword's "validation path."¶

                    Lexical and dynamic scopes align until a reference keyword
                    is encountered.  While following the reference keyword moves processing
                    from one lexical scope into a different one, from the perspective
                    of dynamic scope, following a reference is no different from descending
                    into a subschema present as a value.  A keyword on the far side of
                    that reference that resolves information through the dynamic scope
                    will consider the originating side of the reference to be their
                    dynamic parent, rather than examining the local lexically enclosing parent.¶

                    The concept of dynamic scope is primarily used with "$dynamicRef" and
                    "$dynamicAnchor", and should be considered an advanced feature
                    and used with caution when defining additional keywords.  It also appears
                    when reporting errors and collected annotations, as it may be possible
                    to revisit the same lexical scope repeatedly with different dynamic
                    scopes.  In such cases, it is important to inform the user of the
                    dynamic path that produced the error or annotation.¶\n7.1. Lexical Scope and Dynamic Scope\nLexical Scope and Dynamic Scope\nWhile most JSON Schema keywords can be evaluated on their own,
                    or at most need to take into account the values or results of
                    adjacent keywords in the same schema object, a few have more
                    complex behavior.¶\nThe lexical scope of a keyword is determined by the nested JSON
                    data structure of objects and arrays.  The largest such scope
                    is an entire schema document.  The smallest scope is a single
                    schema object with no subschemas.¶\nKeywords MAY be defined with a partial value, such as a URI-reference,
                    which must be resolved against another value, such as another
                    URI-reference or a full URI, which is found through the lexical
                    structure of the JSON document.  The "$id", "$ref", and
                    "$dynamicRef" core keywords, and the "base" JSON Hyper-Schema
                    keyword, are examples of this sort of behavior.¶\nNote that some keywords, such as "$schema", apply to the lexical
                    scope of the entire schema resource, and therefore MUST only
                    appear in a schema resource's root schema.¶\nOther keywords may take into account the dynamic scope that
                    exists during the evaluation of a schema, typically together
                    with an instance document.
                    The outermost dynamic scope is the schema object at
                    which processing begins, even if it is not a schema resource root.
                    The path from this root schema to any particular keyword (that
                    includes any "$ref" and "$dynamicRef" keywords that may have
                    been resolved) is considered the keyword's "validation path."¶\nLexical and dynamic scopes align until a reference keyword
                    is encountered.  While following the reference keyword moves processing
                    from one lexical scope into a different one, from the perspective
                    of dynamic scope, following a reference is no different from descending
                    into a subschema present as a value.  A keyword on the far side of
                    that reference that resolves information through the dynamic scope
                    will consider the originating side of the reference to be their
                    dynamic parent, rather than examining the local lexically enclosing parent.¶\nThe concept of dynamic scope is primarily used with "$dynamicRef" and
                    "$dynamicAnchor", and should be considered an advanced feature
                    and used with caution when defining additional keywords.  It also appears
                    when reporting errors and collected annotations, as it may be possible
                    to revisit the same lexical scope repeatedly with different dynamic
                    scopes.  In such cases, it is important to inform the user of the
                    dynamic path that produced the error or annotation.¶\n7.2. Keyword Interactions\nKeyword behavior MAY be defined in terms of the annotation results
                    of subschemas (Section 4.3.5) and/or adjacent keywords
                    (keywords within the same schema object) and their subschemas.
                    Such keywords MUST NOT result in a circular dependency.
                    Keywords MAY modify their behavior based on the presence or absence
                    of another keyword in the same
                    schema object (Section 4.3).¶\nsubschemas (Section 4.3.5)\nschema object (Section 4.3)\n7.3. Default Behaviors\nA missing keyword MUST NOT produce a false assertion result, MUST
                    NOT produce annotation results, and MUST NOT cause any other schema
                    to be evaluated as part of its own behavioral definition.
                    However, given that missing keywords do not contribute annotations,
                    the lack of annotation results may indirectly change the behavior
                    of other keywords.¶\nIn some cases, the missing keyword assertion behavior of a keyword is
                    identical to that produced by a certain value, and keyword definitions
                    SHOULD note such values where known.  However, even if the value which
                    produces the default behavior would produce annotation results if
                    present, the default behavior still MUST NOT result in annotations.¶\nBecause annotation collection can add significant cost in terms of both
                    computation and memory, implementations MAY opt out of this feature.
                    Keywords that are specified in terms of collected annotations SHOULD
                    describe reasonable alternate approaches when appropriate.
                    This approach is demonstrated by the
                    "items" and
                    "additionalProperties" keywords in this
                    document.¶\nNote that when no such alternate approach is possible for a keyword,
                    implementations that do not support annotation collections will not
                    be able to support those keywords or vocabularies that contain them.¶\nIdentifiers define URIs for a schema, or affect how such URIs are
                    resolved in references (Section 8.2.3), or both.
                    The Core vocabulary defined in this document defines several
                    identifying keywords, most notably "$id".¶\nreferences (Section 8.2.3)\nCanonical schema URIs MUST NOT change while processing an instance, but
                    keywords that affect URI-reference resolution MAY have behavior that
                    is only fully determined at runtime.¶\nWhile custom identifier keywords are possible, vocabulary designers should
                    take care not to disrupt the functioning of core keywords. For example,
                    the "$dynamicAnchor" keyword in this specification limits its URI resolution
                    effects to the matching "$dynamicRef" keyword, leaving the behavior
                    of "$ref" undisturbed.¶\n7.5. Applicators
        

                    Applicators allow for building more complex schemas than can be accomplished
                    with a single schema object.  Evaluation of an instance against a
                    schema document (Section 4.3) begins by applying
                    the root schema (Section 4.3.5) to the complete instance
                    document.  From there, keywords known as applicators are used to determine
                    which additional schemas are applied.  Such schemas may be applied in-place
                    to the current location, or to a child location.¶

                    The schemas to be applied may be present as subschemas comprising all or
                    part of the keyword's value.  Alternatively, an applicator may refer to
                    a schema elsewhere in the same schema document, or in a different one.
                    The mechanism for identifying such referenced schemas is defined by the
                    keyword.¶

                    Applicator keywords also define how subschema or referenced schema
                    boolean assertion (Section 7.6)
                    results are modified and/or combined to produce the boolean result
                    of the applicator.  Applicators may apply any boolean logic operation
                    to the assertion results of subschemas, but MUST NOT introduce new
                    assertion conditions of their own.¶

                    Annotation (Section 7.7) results are
                    preserved along with the instance location and the location of
                    the schema keyword, so that applications can decide how to
                    interpret multiple values.¶


          
7.5.1. Referenced and Referencing Schemas
          

                        As noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶

                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶

                        For some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\nApplicators allow for building more complex schemas than can be accomplished
                    with a single schema object.  Evaluation of an instance against a
                    schema document (Section 4.3) begins by applying
                    the root schema (Section 4.3.5) to the complete instance
                    document.  From there, keywords known as applicators are used to determine
                    which additional schemas are applied.  Such schemas may be applied in-place
                    to the current location, or to a child location.¶\nschema document (Section 4.3)\nroot schema (Section 4.3.5)\nThe schemas to be applied may be present as subschemas comprising all or
                    part of the keyword's value.  Alternatively, an applicator may refer to
                    a schema elsewhere in the same schema document, or in a different one.
                    The mechanism for identifying such referenced schemas is defined by the
                    keyword.¶\nApplicator keywords also define how subschema or referenced schema
                    boolean assertion (Section 7.6)
                    results are modified and/or combined to produce the boolean result
                    of the applicator.  Applicators may apply any boolean logic operation
                    to the assertion results of subschemas, but MUST NOT introduce new
                    assertion conditions of their own.¶\nassertion (Section 7.6)\nAnnotation (Section 7.7) results are
                    preserved along with the instance location and the location of
                    the schema keyword, so that applications can decide how to
                    interpret multiple values.¶\nAnnotation (Section 7.7)\n7.5.1. Referenced and Referencing Schemas
          

                        As noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶

                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶

                        For some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\n7.5.1. Referenced and Referencing Schemas\nReferenced and Referencing Schemas\nAs noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶\nWhile root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶\nFor some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\n"$ref" (Section 8.2.3.1)\n7.6. Assertions
        

                    JSON Schema can be used to assert constraints on a JSON document, which
                    either passes or fails the assertions.  This approach can be used to validate
                    conformance with the constraints, or document what is needed to satisfy them.¶

                    JSON Schema implementations produce a single boolean result when evaluating
                    an instance against schema assertions.¶

                    An instance can only fail an assertion that is present in the schema.¶

          
7.6.1. Assertions and Instance Primitive Types
          

                        Most assertions only constrain values within a certain
                        primitive type.  When the type of the instance is not of the type
                        targeted by the keyword, the instance is considered to conform
                        to the assertion.¶

                        For example, the "maxLength" keyword from the companion
                        validation vocabulary [json-schema-validation]:
                        will only restrict certain strings
                        (that are too long) from being valid.  If the instance is a number,
                        boolean, null, array, or object, then it is valid against this assertion.¶

                        This behavior allows keywords to be used more easily with instances
                        that can be of multiple primitive types.  The companion validation
                        vocabulary also includes a "type" keyword which can independently
                        restrict the instance to one or more primitive types.  This allows
                        for a concise expression of use cases such as a function that might
                        return either a string of a certain length or a null value:¶


{
    "type": ["string", "null"],
    "maxLength": 255
}

¶


                            If "maxLength" also restricted the instance type to be a string,
                            then this would be substantially more cumbersome to express because
                            the example as written would not actually allow null values.
                            Each keyword is evaluated separately unless explicitly specified
                            otherwise, so if "maxLength" restricted the instance to strings,
                            then including "null" in "type" would not have any useful effect.¶\nJSON Schema can be used to assert constraints on a JSON document, which
                    either passes or fails the assertions.  This approach can be used to validate
                    conformance with the constraints, or document what is needed to satisfy them.¶\nJSON Schema implementations produce a single boolean result when evaluating
                    an instance against schema assertions.¶\nAn instance can only fail an assertion that is present in the schema.¶\n7.6.1. Assertions and Instance Primitive Types\nAssertions and Instance Primitive Types\nMost assertions only constrain values within a certain
                        primitive type.  When the type of the instance is not of the type
                        targeted by the keyword, the instance is considered to conform
                        to the assertion.¶\nFor example, the "maxLength" keyword from the companion
                        validation vocabulary [json-schema-validation]:
                        will only restrict certain strings
                        (that are too long) from being valid.  If the instance is a number,
                        boolean, null, array, or object, then it is valid against this assertion.¶\nvalidation vocabulary [json-schema-validation]\nvalidation vocabulary\njson-schema-validation\nThis behavior allows keywords to be used more easily with instances
                        that can be of multiple primitive types.  The companion validation
                        vocabulary also includes a "type" keyword which can independently
                        restrict the instance to one or more primitive types.  This allows
                        for a concise expression of use cases such as a function that might
                        return either a string of a certain length or a null value:¶\n{
    "type": ["string", "null"],
    "maxLength": 255
}

¶\nIf "maxLength" also restricted the instance type to be a string,
                            then this would be substantially more cumbersome to express because
                            the example as written would not actually allow null values.
                            Each keyword is evaluated separately unless explicitly specified
                            otherwise, so if "maxLength" restricted the instance to strings,
                            then including "null" in "type" would not have any useful effect.¶\n7.7. Annotations
        

                    JSON Schema can annotate an instance with information, whenever the instance
                    validates against the schema object containing the annotation, and all of its
                    parent schema objects.  The information can be a simple value, or can be
                    calculated based on the instance contents.¶

                    Annotations are attached to specific locations in an instance.
                    Since many subschemas can be applied to any single
                    location, applications may need to decide how to handle differing
                    annotation values being attached to the same instance location by
                    the same schema keyword in different schema objects.¶

                    Unlike assertion results, annotation data can take a wide variety of forms,
                    which are provided to applications to use as they see fit.  JSON Schema
                    implementations are not expected to make use of the collected information
                    on behalf of applications.¶

                    Unless otherwise specified, the value of an annotation keyword
                    is the keyword's value.  However, other behaviors are possible.
                    For example, JSON Hyper-Schema's [json-hyper-schema]
                    "links" keyword is a complex annotation that produces a value based
                    in part on the instance data.¶

                    While "short-circuit" evaluation is possible for assertions, collecting
                    annotations requires examining all schemas that apply to an instance
                    location, even if they cannot change the overall assertion result.
                    The only exception is that subschemas of a schema object that has
                    failed validation MAY be skipped, as annotations are not retained
                    for failing schemas.¶

          
7.7.1. Collecting Annotations
          

                        Annotations are collected by keywords that explicitly define
                        annotation-collecting behavior.  Note that boolean schemas cannot
                        produce annotations as they do not make use of keywords.¶

                        A collected annotation MUST include the following information:¶


                                The name of the keyword that produces the annotation¶

            
                                The instance location to which it is attached, as a JSON Pointer¶

            
                                The schema location path, indicating how reference keywords
                                such as "$ref" were followed to reach the absolute schema location.¶

            
                                The absolute schema location of the attaching keyword, as a URI.
                                This MAY be omitted if it is the same as the schema location path
                                from above.¶

            
                                The attached value(s)¶

          

            
7.7.1.1. Distinguishing Among Multiple Values
            

                            Applications MAY make decisions on which of multiple annotation values
                            to use based on the schema location that contributed the value.
                            This is intended to allow flexible usage.  Collecting the schema location
                            facilitates such usage.¶

                            For example, consider this schema, which uses annotations and assertions from
                            the Validation specification [json-schema-validation]:¶

                                Note that some lines are wrapped for clarity.¶


{
    "title": "Feature list",
    "type": "array",
    "prefixItems": [
        {
            "title": "Feature A",
            "properties": {
                "enabled": {
                    "$ref": "#/$defs/enabledToggle",
                    "default": true
                }
            }
        },
        {
            "title": "Feature B",
            "properties": {
                "enabled": {
                    "description": "If set to null, Feature B
                                    inherits the enabled
                                    value from Feature A",
                    "$ref": "#/$defs/enabledToggle"
                }
            }
        }
    ],
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}

¶


                            In this example, both Feature A and Feature B make use of the re-usable
                            "enabledToggle" schema.  That schema uses the "title", "description",
                            and "default" annotations.  Therefore the application has to decide how
                            to handle the additional "default" value for Feature A, and the additional
                            "description" value for Feature B.¶

                            The application programmer and the schema author need to agree on the
                            usage.  For this example, let's assume that they agree that the most
                            specific "default" value will be used, and any additional, more generic
                            "default" values will be silently ignored.  Let's also assume that they
                            agree that all "description" text is to be used, starting with the most
                            generic, and ending with the most specific.  This requires the schema
                            author to write descriptions that work when combined in this way.¶

                            The application can use the schema location path to determine which
                            values are which.  The values in the feature's immediate "enabled"
                            property schema are more specific, while the values under the re-usable
                            schema that is referenced to with "$ref" are more generic.  The schema
                            location path will show whether each value was found by crossing a
                            "$ref" or not.¶

                            Feature A will therefore use a default value of true, while Feature B
                            will use the generic default value of null.  Feature A will only
                            have the generic description from the "enabledToggle" schema, while
                            Feature B will use that description, and also append its locally
                            defined description that explains how to interpret a null value.¶

                            Note that there are other reasonable approaches that a different application
                            might take.  For example, an application may consider the presence of
                            two different values for "default" to be an error, regardless of their
                            schema locations.¶


            
7.7.1.2. Annotations and Assertions
            

                            Schema objects that produce a false assertion result MUST NOT
                            produce any annotation results, whether from their own keywords
                            or from keywords in subschemas.¶

                            Note that the overall schema results may still include annotations
                            collected from other schema locations.  Given this schema:¶


{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}

¶


                            Against the instance "This is a string", the
                            title annotation "Integer Value" is discarded because the type assertion
                            in that schema object fails.  The title annotation "String Value"
                            is kept, as the instance passes the string type assertions.¶


            
7.7.1.3. Annotations and Applicators
            

                            In addition to possibly defining annotation results of their own,
                            applicator keywords aggregate the annotations collected in their
                            subschema(s) or referenced schema(s).¶\nJSON Schema can annotate an instance with information, whenever the instance
                    validates against the schema object containing the annotation, and all of its
                    parent schema objects.  The information can be a simple value, or can be
                    calculated based on the instance contents.¶\nAnnotations are attached to specific locations in an instance.
                    Since many subschemas can be applied to any single
                    location, applications may need to decide how to handle differing
                    annotation values being attached to the same instance location by
                    the same schema keyword in different schema objects.¶\nUnlike assertion results, annotation data can take a wide variety of forms,
                    which are provided to applications to use as they see fit.  JSON Schema
                    implementations are not expected to make use of the collected information
                    on behalf of applications.¶\nUnless otherwise specified, the value of an annotation keyword
                    is the keyword's value.  However, other behaviors are possible.
                    For example, JSON Hyper-Schema's [json-hyper-schema]
                    "links" keyword is a complex annotation that produces a value based
                    in part on the instance data.¶\nJSON Hyper-Schema's [json-hyper-schema]\nWhile "short-circuit" evaluation is possible for assertions, collecting
                    annotations requires examining all schemas that apply to an instance
                    location, even if they cannot change the overall assertion result.
                    The only exception is that subschemas of a schema object that has
                    failed validation MAY be skipped, as annotations are not retained
                    for failing schemas.¶\n7.7.1. Collecting Annotations\nCollecting Annotations\nAnnotations are collected by keywords that explicitly define
                        annotation-collecting behavior.  Note that boolean schemas cannot
                        produce annotations as they do not make use of keywords.¶\nA collected annotation MUST include the following information:¶\nThe name of the keyword that produces the annotation¶\nThe instance location to which it is attached, as a JSON Pointer¶\nThe schema location path, indicating how reference keywords
                                such as "$ref" were followed to reach the absolute schema location.¶\nThe absolute schema location of the attaching keyword, as a URI.
                                This MAY be omitted if it is the same as the schema location path
                                from above.¶\nThe attached value(s)¶\n7.7.1.1. Distinguishing Among Multiple Values\nDistinguishing Among Multiple Values\nApplications MAY make decisions on which of multiple annotation values
                            to use based on the schema location that contributed the value.
                            This is intended to allow flexible usage.  Collecting the schema location
                            facilitates such usage.¶\nFor example, consider this schema, which uses annotations and assertions from
                            the Validation specification [json-schema-validation]:¶\nValidation specification [json-schema-validation]\nValidation specification\njson-schema-validation\nNote that some lines are wrapped for clarity.¶\n{
    "title": "Feature list",
    "type": "array",
    "prefixItems": [
        {
            "title": "Feature A",
            "properties": {
                "enabled": {
                    "$ref": "#/$defs/enabledToggle",
                    "default": true
                }
            }
        },
        {
            "title": "Feature B",
            "properties": {
                "enabled": {
                    "description": "If set to null, Feature B
                                    inherits the enabled
                                    value from Feature A",
                    "$ref": "#/$defs/enabledToggle"
                }
            }
        }
    ],
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}

¶\nIn this example, both Feature A and Feature B make use of the re-usable
                            "enabledToggle" schema.  That schema uses the "title", "description",
                            and "default" annotations.  Therefore the application has to decide how
                            to handle the additional "default" value for Feature A, and the additional
                            "description" value for Feature B.¶\nThe application programmer and the schema author need to agree on the
                            usage.  For this example, let's assume that they agree that the most
                            specific "default" value will be used, and any additional, more generic
                            "default" values will be silently ignored.  Let's also assume that they
                            agree that all "description" text is to be used, starting with the most
                            generic, and ending with the most specific.  This requires the schema
                            author to write descriptions that work when combined in this way.¶\nThe application can use the schema location path to determine which
                            values are which.  The values in the feature's immediate "enabled"
                            property schema are more specific, while the values under the re-usable
                            schema that is referenced to with "$ref" are more generic.  The schema
                            location path will show whether each value was found by crossing a
                            "$ref" or not.¶\nFeature A will therefore use a default value of true, while Feature B
                            will use the generic default value of null.  Feature A will only
                            have the generic description from the "enabledToggle" schema, while
                            Feature B will use that description, and also append its locally
                            defined description that explains how to interpret a null value.¶\nNote that there are other reasonable approaches that a different application
                            might take.  For example, an application may consider the presence of
                            two different values for "default" to be an error, regardless of their
                            schema locations.¶\n7.7.1.2. Annotations and Assertions\nAnnotations and Assertions\nSchema objects that produce a false assertion result MUST NOT
                            produce any annotation results, whether from their own keywords
                            or from keywords in subschemas.¶\nNote that the overall schema results may still include annotations
                            collected from other schema locations.  Given this schema:¶\n{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}

¶\nAgainst the instance "This is a string", the
                            title annotation "Integer Value" is discarded because the type assertion
                            in that schema object fails.  The title annotation "String Value"
                            is kept, as the instance passes the string type assertions.¶\n7.7.1.3. Annotations and Applicators\nAnnotations and Applicators\nIn addition to possibly defining annotation results of their own,
                            applicator keywords aggregate the annotations collected in their
                            subschema(s) or referenced schema(s).¶\n7.8. Reserved Locations\nA fourth category of keywords simply reserve a location to hold re-usable
                    components or data of interest to schema authors that is not suitable
                    for re-use.  These keywords do not affect validation or annotation results.
                    Their purpose in the core vocabulary is to ensure that locations are
                    available for certain purposes and will not be redefined by extension
                    keywords.¶\nWhile these keywords do not directly affect results, as explained in section
                    9.4.2 unrecognized
                    extension keywords that reserve locations for re-usable schemas may have
                    undesirable interactions with references in certain circumstances.¶\n7.9. Loading Instance Data\nLoading Instance Data\nWhile none of the vocabularies defined as part of this or the associated documents
                    define a keyword which may target and/or load instance data, it is possible that
                    other vocabularies may wish to do so.¶\nKeywords MAY be defined to use JSON Pointers or Relative JSON Pointers to examine
                    parts of an instance outside the current evaluation location.¶\nKeywords that allow adjusting the location using a Relative JSON Pointer SHOULD
                    default to using the current location if a default is desireable.¶\n8. The JSON Schema Core Vocabulary\nThe JSON Schema Core Vocabulary\nKeywords declared in this section, which all begin with "$", make up
                the JSON Schema Core vocabulary.  These keywords are either required in
                order to process any schema or meta-schema, including those split across
                multiple documents, or exist to reserve keywords for purposes that
                require guaranteed interoperability.¶\nThe Core vocabulary MUST be considered mandatory at all times, in order
                to bootstrap the processing of further vocabularies.  Meta-schemas
                that use the "$vocabulary" (Section 8.1) keyword
                to declare the vocabularies in use MUST explicitly list the Core vocabulary,
                which MUST have a value of true indicating that it is required.¶\n"$vocabulary" (Section 8.1)\nThe behavior of a false value for this vocabulary (and only this
                vocabulary) is undefined, as is the behavior when "$vocabulary"
                is present but the Core vocabulary is not included.  However, it
                is RECOMMENDED that implementations detect these cases and raise
                an error when they occur.  It is not meaningful to declare that
                a meta-schema optionally uses Core.¶\nMeta-schemas that do not use "$vocabulary" MUST be considered to
                require the Core vocabulary as if its URI were present with a value of true.¶\nThe current URI for the Core vocabulary is:
                <https://json-schema.org/draft/2020-12/vocab/core>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/core.¶\nhttps://json-schema.org/draft/2020-12/meta/core\nhttps://json-schema.org/draft/2020-12/meta/core\nWhile the "$" prefix is not formally reserved for the Core vocabulary,
                it is RECOMMENDED that extension keywords (in vocabularies or otherwise)
                begin with a character other than "$" to avoid possible future collisions.¶\n8.1. Meta-Schemas and Vocabularies
        

                    Two concepts, meta-schemas and vocabularies, are used to inform an implementation
                    how to interpret a schema.  Every schema has a meta-schema, which can be declared
                    using the "$schema" keyword.¶

                    The meta-schema serves two purposes:¶

          Declaring the vocabularies in use
          
                            The "$vocabulary" keyword, when it appears in a meta-schema, declares
                            which vocabularies are available to be used in schemas that refer
                            to that meta-schema.  Vocabularies define keyword semantics,
                            as well as their general syntax.¶

          
Describing valid schema syntax
          
                            A schema MUST successfully validate against its meta-schema, which
                            constrains the syntax of the available keywords.  The syntax described
                            is expected to be compatible with the vocabularies declared; while
                            it is possible to describe an incompatible syntax, such a meta-schema
                            would be unlikely to be useful.¶

        


                    Meta-schemas are separate from vocabularies to allow for
                    vocabularies to be combined in different ways, and for meta-schema authors
                    to impose additional constraints such as forbidding certain keywords, or
                    performing unusually strict syntactical validation, as might be done
                    during a development and testing cycle.  Each vocabulary typically identifies
                    a meta-schema consisting only of the vocabulary's keywords.¶

                    Meta-schema authoring is an advanced usage of JSON Schema, so the design of
                    meta-schema features emphasizes flexibility over simplicity.¶


          
8.1.1. The "$schema" Keyword
          

                        The "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶

                        The value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶

                        If this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶

                        The "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶

                        Values for this property are defined elsewhere in this and other documents,
                        and by other parties.¶



          
8.1.2. The "$vocabulary" Keyword
          

                        The "$vocabulary" keyword is used in meta-schemas to identify the
                        vocabularies available for use in schemas described by that meta-schema.
                        It is also used to indicate whether each vocabulary is required or optional,
                        in the sense that an implementation MUST understand the required vocabularies
                        in order to successfully process the schema. Together, this information forms
                        a dialect. Any vocabulary that is understood by the implementation MUST be
                        processed in a manner consistent with the semantic definitions contained
                        within the vocabulary.¶

                        The value of this keyword MUST be an object.  The property names in the
                        object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                        Each URI that appears as a property name identifies a specific set of
                        keywords and their semantics.¶

                        The URI MAY be a URL, but the nature of the retrievable resource is
                        currently undefined, and reserved for future use.  Vocabulary authors
                        MAY use the URL of the vocabulary specification, in a human-readable
                        media type such as text/html or text/plain, as the vocabulary URI.
                        
                            Vocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.
            ¶

                        The values of the object properties MUST be booleans.
                        If the value is true, then implementations that do not recognize
                        the vocabulary MUST refuse to process any schemas that declare
                        this meta-schema with "$schema".  If the value is false, implementations
                        that do not recognize the vocabulary SHOULD proceed with processing
                        such schemas.  The value has no impact if the implementation
                        understands the vocabulary.¶

                        Per 6.5, unrecognized
                        keywords SHOULD be treated as annotations.
                        This remains the case for keywords defined
                        by unrecognized vocabularies.  It is not currently possible to distinguish
                        between unrecognized keywords that are defined in vocabularies from
                        those that are not part of any vocabulary.¶

                        The "$vocabulary" keyword SHOULD be used in the root schema of any schema
                        document intended for use as a meta-schema.  It MUST NOT appear in subschemas.¶

                        The "$vocabulary" keyword MUST be ignored in schema documents that
                        are not being processed as a meta-schema.  This allows validating
                        a meta-schema M against its own meta-schema M' without requiring
                        the validator to understand the vocabularies declared by M.¶

            
8.1.2.1. Default vocabularies
            

                            If "$vocabulary" is absent, an implementation MAY determine
                            behavior based on the meta-schema if it is recognized from the
                            URI value of the referring schema's "$schema" keyword.
                            This is how behavior (such as Hyper-Schema usage) has been
                            recognized prior to the existence of vocabularies.¶

                            If the meta-schema, as referenced by the schema, is not recognized,
                            or is missing, then the behavior is implementation-defined.
                            If the implementation
                            proceeds with processing the schema, it MUST assume the use of the
                            core vocabulary.  If the implementation is built for a specific purpose,
                            then it SHOULD assume the use of all of the most relevant vocabularies
                            for that purpose.¶

                            For example, an implementation that is a validator
                            SHOULD assume the use of all vocabularies in this
                            specification and the companion Validation specification.¶


            
8.1.2.2. Non-inheritability of vocabularies
            

                            Note that the processing restrictions on "$vocabulary" mean that
                            meta-schemas that reference other meta-schemas using "$ref" or
                            similar keywords do not automatically inherit the vocabulary
                            declarations of those other meta-schemas.  All such declarations
                            must be repeated in the root of each schema document intended
                            for use as a meta-schema.  This is demonstrated in
                            the example meta-schema (Appendix D.2).
                            
                                This requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.
              ¶



          
8.1.3. Updates to Meta-Schema and Vocabulary URIs
          

                        Updated vocabulary and meta-schema URIs MAY be published between
                        specification drafts in order to correct errors.  Implementations
                        SHOULD consider URIs dated after this specification draft and
                        before the next to indicate the same syntax and semantics
                        as those listed here.¶\n8.1. Meta-Schemas and Vocabularies\nMeta-Schemas and Vocabularies\nTwo concepts, meta-schemas and vocabularies, are used to inform an implementation
                    how to interpret a schema.  Every schema has a meta-schema, which can be declared
                    using the "$schema" keyword.¶\nThe meta-schema serves two purposes:¶\nMeta-schemas are separate from vocabularies to allow for
                    vocabularies to be combined in different ways, and for meta-schema authors
                    to impose additional constraints such as forbidding certain keywords, or
                    performing unusually strict syntactical validation, as might be done
                    during a development and testing cycle.  Each vocabulary typically identifies
                    a meta-schema consisting only of the vocabulary's keywords.¶\nMeta-schema authoring is an advanced usage of JSON Schema, so the design of
                    meta-schema features emphasizes flexibility over simplicity.¶\n8.1.1. The "$schema" Keyword
          

                        The "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶

                        The value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶

                        If this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶

                        The "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶

                        Values for this property are defined elsewhere in this and other documents,
                        and by other parties.¶\n8.1.1. The "$schema" Keyword\nThe "$schema" Keyword\nThe "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶\nThe value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶\nIf this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶\nThe "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶\nValues for this property are defined elsewhere in this and other documents,
                        and by other parties.¶\n8.1.2. The "$vocabulary" Keyword\nThe "$vocabulary" Keyword\nThe "$vocabulary" keyword is used in meta-schemas to identify the
                        vocabularies available for use in schemas described by that meta-schema.
                        It is also used to indicate whether each vocabulary is required or optional,
                        in the sense that an implementation MUST understand the required vocabularies
                        in order to successfully process the schema. Together, this information forms
                        a dialect. Any vocabulary that is understood by the implementation MUST be
                        processed in a manner consistent with the semantic definitions contained
                        within the vocabulary.¶\nThe value of this keyword MUST be an object.  The property names in the
                        object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                        Each URI that appears as a property name identifies a specific set of
                        keywords and their semantics.¶\nThe URI MAY be a URL, but the nature of the retrievable resource is
                        currently undefined, and reserved for future use.  Vocabulary authors
                        MAY use the URL of the vocabulary specification, in a human-readable
                        media type such as text/html or text/plain, as the vocabulary URI.
                        
                            Vocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.
            ¶\nVocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.\nThe values of the object properties MUST be booleans.
                        If the value is true, then implementations that do not recognize
                        the vocabulary MUST refuse to process any schemas that declare
                        this meta-schema with "$schema".  If the value is false, implementations
                        that do not recognize the vocabulary SHOULD proceed with processing
                        such schemas.  The value has no impact if the implementation
                        understands the vocabulary.¶\nPer 6.5, unrecognized
                        keywords SHOULD be treated as annotations.
                        This remains the case for keywords defined
                        by unrecognized vocabularies.  It is not currently possible to distinguish
                        between unrecognized keywords that are defined in vocabularies from
                        those that are not part of any vocabulary.¶\nThe "$vocabulary" keyword SHOULD be used in the root schema of any schema
                        document intended for use as a meta-schema.  It MUST NOT appear in subschemas.¶\nThe "$vocabulary" keyword MUST be ignored in schema documents that
                        are not being processed as a meta-schema.  This allows validating
                        a meta-schema M against its own meta-schema M' without requiring
                        the validator to understand the vocabularies declared by M.¶\n8.1.2.1. Default vocabularies\nIf "$vocabulary" is absent, an implementation MAY determine
                            behavior based on the meta-schema if it is recognized from the
                            URI value of the referring schema's "$schema" keyword.
                            This is how behavior (such as Hyper-Schema usage) has been
                            recognized prior to the existence of vocabularies.¶\nIf the meta-schema, as referenced by the schema, is not recognized,
                            or is missing, then the behavior is implementation-defined.
                            If the implementation
                            proceeds with processing the schema, it MUST assume the use of the
                            core vocabulary.  If the implementation is built for a specific purpose,
                            then it SHOULD assume the use of all of the most relevant vocabularies
                            for that purpose.¶\nFor example, an implementation that is a validator
                            SHOULD assume the use of all vocabularies in this
                            specification and the companion Validation specification.¶\n8.1.2.2. Non-inheritability of vocabularies\nNon-inheritability of vocabularies\nNote that the processing restrictions on "$vocabulary" mean that
                            meta-schemas that reference other meta-schemas using "$ref" or
                            similar keywords do not automatically inherit the vocabulary
                            declarations of those other meta-schemas.  All such declarations
                            must be repeated in the root of each schema document intended
                            for use as a meta-schema.  This is demonstrated in
                            the example meta-schema (Appendix D.2).
                            
                                This requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.
              ¶\nthe example meta-schema (Appendix D.2)\nthe example meta-schema\nThis requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.\n8.1.3. Updates to Meta-Schema and Vocabulary URIs\nUpdates to Meta-Schema and Vocabulary URIs\nUpdated vocabulary and meta-schema URIs MAY be published between
                        specification drafts in order to correct errors.  Implementations
                        SHOULD consider URIs dated after this specification draft and
                        before the next to indicate the same syntax and semantics
                        as those listed here.¶\n8.2. Base URI, Anchors, and Dereferencing\nBase URI, Anchors, and Dereferencing\nTo differentiate between schemas in a vast ecosystem, schemas are
                    identified by URI [RFC3986], and can embed references
                    to other schemas by specifying their URI.¶\nSeveral keywords can accept a relative URI-reference [RFC3986],
                    or a value used to construct a relative URI-reference.  For these keywords,
                    it is necessary to establish a base URI in order to resolve the reference.¶\nURI-reference [RFC3986]\n8.2.1. The "$id" Keyword
          

                        The "$id" keyword identifies a schema resource with its
                        canonical [RFC6596] URI.¶

                        Note that this URI is an identifier and not necessarily a network locator.
                        In the case of a network-addressable URL, a schema need not be downloadable
                        from its canonical URI.¶

                        If present, the value for this keyword MUST be a string, and MUST represent a
                        valid URI-reference [RFC3986].  This URI-reference
                        SHOULD be normalized, and MUST resolve to an
                        absolute-URI [RFC3986] (without a fragment),
                        or to a URI with an empty fragment.¶

                        The empty fragment form is NOT RECOMMENDED and is retained only
                        for backwards compatibility, and because the
                        application/schema+json media type defines that a URI with an
                        empty fragment identifies the same resource as the same URI
                        with the fragment removed.  However, since this equivalence is not
                        part of the RFC 3986 normalization process [RFC3986],
                        implementers and schema authors cannot rely on generic URI libraries
                        understanding it.¶

                        Therefore, "$id" MUST NOT contain a non-empty fragment, and SHOULD NOT
                        contain an empty fragment.  The absolute-URI form MUST be considered
                        the canonical URI, regardless of the presence or absence of an empty fragment.
                        
                            An empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".
            ¶

                        The absolute-URI also serves as the base URI for relative URI-references
                        in keywords within the schema resource, in accordance with
                        RFC 3986 section 5.1.1 [RFC3986] regarding base URIs
                        embedded in content.¶

                        The presence of "$id" in a subschema indicates that the subschema constitutes
                        a distinct schema resource within a single schema document.  Furthermore,
                        in accordance with RFC 3986 section 5.1.2 [RFC3986]
                        regarding encapsulating entities, if an "$id" in a subschema is a relative
                        URI-reference, the base URI for resolving that reference is the URI of
                        the parent schema resource.¶

                        If no parent schema object explicitly identifies itself as a resource
                        with "$id", the base URI is that of the entire document, as established
                        by the steps given in the previous section. (Section 9.1.1)¶

            
8.2.1.1. Identifying the root schema
            

                            The root schema of a JSON Schema document SHOULD contain an "$id" keyword
                            with an absolute-URI [RFC3986] (containing a scheme,
                            but no fragment).¶\n8.2.1. The "$id" Keyword\nThe "$id" keyword identifies a schema resource with its
                        canonical [RFC6596] URI.¶\nNote that this URI is an identifier and not necessarily a network locator.
                        In the case of a network-addressable URL, a schema need not be downloadable
                        from its canonical URI.¶\nIf present, the value for this keyword MUST be a string, and MUST represent a
                        valid URI-reference [RFC3986].  This URI-reference
                        SHOULD be normalized, and MUST resolve to an
                        absolute-URI [RFC3986] (without a fragment),
                        or to a URI with an empty fragment.¶\nURI-reference [RFC3986]\nabsolute-URI [RFC3986]\nThe empty fragment form is NOT RECOMMENDED and is retained only
                        for backwards compatibility, and because the
                        application/schema+json media type defines that a URI with an
                        empty fragment identifies the same resource as the same URI
                        with the fragment removed.  However, since this equivalence is not
                        part of the RFC 3986 normalization process [RFC3986],
                        implementers and schema authors cannot rely on generic URI libraries
                        understanding it.¶\nRFC 3986 normalization process [RFC3986]\nRFC 3986 normalization process\nTherefore, "$id" MUST NOT contain a non-empty fragment, and SHOULD NOT
                        contain an empty fragment.  The absolute-URI form MUST be considered
                        the canonical URI, regardless of the presence or absence of an empty fragment.
                        
                            An empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".
            ¶\nAn empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".\nThe absolute-URI also serves as the base URI for relative URI-references
                        in keywords within the schema resource, in accordance with
                        RFC 3986 section 5.1.1 [RFC3986] regarding base URIs
                        embedded in content.¶\nRFC 3986 section 5.1.1 [RFC3986]\nRFC 3986 section 5.1.1\nThe presence of "$id" in a subschema indicates that the subschema constitutes
                        a distinct schema resource within a single schema document.  Furthermore,
                        in accordance with RFC 3986 section 5.1.2 [RFC3986]
                        regarding encapsulating entities, if an "$id" in a subschema is a relative
                        URI-reference, the base URI for resolving that reference is the URI of
                        the parent schema resource.¶\nRFC 3986 section 5.1.2 [RFC3986]\nRFC 3986 section 5.1.2\nIf no parent schema object explicitly identifies itself as a resource
                        with "$id", the base URI is that of the entire document, as established
                        by the steps given in the previous section. (Section 9.1.1)¶\nprevious section. (Section 9.1.1)\n8.2.1.1. Identifying the root schema\nIdentifying the root schema\nThe root schema of a JSON Schema document SHOULD contain an "$id" keyword
                            with an absolute-URI [RFC3986] (containing a scheme,
                            but no fragment).¶\nabsolute-URI [RFC3986]\n8.2.2. Defining location-independent identifiers
          

                        Using JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.¶

                        The "$anchor" and "$dynamicAnchor" keywords are used to specify such
                        fragments.  They are identifier keywords that can only be used to create
                        plain name fragments, rather than absolute URIs as seen with "$id".¶

                        The base URI to which the resulting fragment is appended is the canonical
                        URI of the schema resource containing the "$anchor" or "$dynamicAnchor"
                        in question.  As discussed in the previous section, this is either the
                        nearest "$id" in the same or parent schema object, or the base URI
                        for the document as determined according to RFC 3986.¶

                        Separately from the usual usage of URIs, "$dynamicAnchor"
                        indicates that the fragment is an extension point when used with
                        the "$dynamicRef" keyword.  This low-level, advanced feature
                        makes it easier to extend recursive schemas such as the meta-schemas,
                        without imposing any particular semantics on that extension.
                        See the section on "$dynamicRef" (Section 8.2.3.2)
                        for details.¶

                        In most cases, the normal fragment behavior both suffices and
                        is more intuitive.  Therefore it is RECOMMENDED that "$anchor"
                        be used to create plain name fragments unless there is a clear
                        need for "$dynamicAnchor".¶

                        If present, the value of this keyword MUST be a string and MUST start with
                        a letter ([A-Za-z]) or underscore ("_"), followed by any number of letters,
                        digits ([0-9]), hyphens ("-"), underscores ("_"), and periods (".").
                        This matches the US-ASCII part of XML's
                        NCName production [xml-names].
                        
                            Note that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.
            ¶

                        The effect of specifying the same fragment name multiple times within
                        the same resource, using any combination of "$anchor" and/or
                        "$dynamicAnchor", is undefined.  Implementations MAY
                        raise an error if such usage is detected.¶\n8.2.2. Defining location-independent identifiers\nDefining location-independent identifiers\nUsing JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.¶\nThe "$anchor" and "$dynamicAnchor" keywords are used to specify such
                        fragments.  They are identifier keywords that can only be used to create
                        plain name fragments, rather than absolute URIs as seen with "$id".¶\nThe base URI to which the resulting fragment is appended is the canonical
                        URI of the schema resource containing the "$anchor" or "$dynamicAnchor"
                        in question.  As discussed in the previous section, this is either the
                        nearest "$id" in the same or parent schema object, or the base URI
                        for the document as determined according to RFC 3986.¶\nSeparately from the usual usage of URIs, "$dynamicAnchor"
                        indicates that the fragment is an extension point when used with
                        the "$dynamicRef" keyword.  This low-level, advanced feature
                        makes it easier to extend recursive schemas such as the meta-schemas,
                        without imposing any particular semantics on that extension.
                        See the section on "$dynamicRef" (Section 8.2.3.2)
                        for details.¶\n"$dynamicRef" (Section 8.2.3.2)\nIn most cases, the normal fragment behavior both suffices and
                        is more intuitive.  Therefore it is RECOMMENDED that "$anchor"
                        be used to create plain name fragments unless there is a clear
                        need for "$dynamicAnchor".¶\nIf present, the value of this keyword MUST be a string and MUST start with
                        a letter ([A-Za-z]) or underscore ("_"), followed by any number of letters,
                        digits ([0-9]), hyphens ("-"), underscores ("_"), and periods (".").
                        This matches the US-ASCII part of XML's
                        NCName production [xml-names].
                        
                            Note that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.
            ¶\nNCName production [xml-names]\nNote that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.\nThe effect of specifying the same fragment name multiple times within
                        the same resource, using any combination of "$anchor" and/or
                        "$dynamicAnchor", is undefined.  Implementations MAY
                        raise an error if such usage is detected.¶\n8.2.3. Schema References
          

                        Several keywords can be used to reference a schema which is to be applied to the
                        current instance location. "$ref" and "$dynamicRef" are applicator
                        keywords, applying the referenced schema to the instance.¶

                        As the values of "$ref" and "$dynamicRef" are URI References, this allows
                        the possibility to externalise or divide a schema across multiple files,
                        and provides the ability to validate recursive structures through
                        self-reference.¶

                        The resolved URI produced by these keywords is not necessarily a network
                        locator, only an identifier. A schema need not be downloadable from the
                        address if it is a network-addressable URL, and implementations SHOULD NOT
                        assume they should perform a network operation when they encounter
                        a network-addressable URI.¶


            
8.2.3.1. Direct References with "$ref"
            

                            The "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶

                            The value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶




            
8.2.3.2. Dynamic References with "$dynamicRef"
            

                            The "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶

                            Together with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶

                            The value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶

                            If the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶

                            Otherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶

                            For a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\n8.2.3. Schema References\nSeveral keywords can be used to reference a schema which is to be applied to the
                        current instance location. "$ref" and "$dynamicRef" are applicator
                        keywords, applying the referenced schema to the instance.¶\nAs the values of "$ref" and "$dynamicRef" are URI References, this allows
                        the possibility to externalise or divide a schema across multiple files,
                        and provides the ability to validate recursive structures through
                        self-reference.¶\nThe resolved URI produced by these keywords is not necessarily a network
                        locator, only an identifier. A schema need not be downloadable from the
                        address if it is a network-addressable URL, and implementations SHOULD NOT
                        assume they should perform a network operation when they encounter
                        a network-addressable URI.¶\n8.2.3.1. Direct References with "$ref"
            

                            The "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶

                            The value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶\n8.2.3.1. Direct References with "$ref"\nDirect References with "$ref"\nThe "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶\nNote that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.\nThe value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶\n8.2.3.2. Dynamic References with "$dynamicRef"
            

                            The "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶

                            Together with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶

                            The value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶

                            If the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶

                            Otherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶

                            For a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\n8.2.3.2. Dynamic References with "$dynamicRef"\nDynamic References with "$dynamicRef"\nThe "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶\nTogether with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶\nThe value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶\nIf the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶\ndynamic scope (Section 7.1)\nOtherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶\nFor a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\nThe difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.\n8.2.4. Schema Re-Use With "$defs"
          

                        The "$defs" keyword reserves a location for schema
                        authors to inline re-usable JSON Schemas into a more general schema.
                        The keyword does not directly affect the validation result.¶

                        This keyword's value MUST be an object.
                        Each member value of this object MUST be a valid JSON Schema.¶

                        As an example, here is a schema describing an array of positive
                        integers, where the positive integer constraint is a subschema in
                        "$defs":¶


{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}

¶\n8.2.4. Schema Re-Use With "$defs"\nSchema Re-Use With "$defs"\nThe "$defs" keyword reserves a location for schema
                        authors to inline re-usable JSON Schemas into a more general schema.
                        The keyword does not directly affect the validation result.¶\nThis keyword's value MUST be an object.
                        Each member value of this object MUST be a valid JSON Schema.¶\nAs an example, here is a schema describing an array of positive
                        integers, where the positive integer constraint is a subschema in
                        "$defs":¶\n{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}

¶\n8.3. Comments With "$comment"\nComments With "$comment"\nThis keyword reserves a location for comments from schema authors
                    to readers or maintainers of the schema.¶\nThe value of this keyword MUST be a string. Implementations MUST NOT present this
                    string to end users.  Tools for editing schemas SHOULD support displaying and
                    editing this keyword.  The value of this keyword MAY be used in debug or error
                    output which is intended for developers making use of schemas.¶\nSchema vocabularies SHOULD allow "$comment" within any object containing
                    vocabulary keywords.  Implementations MAY assume "$comment" is allowed
                    unless the vocabulary specifically forbids it.  Vocabularies MUST NOT
                    specify any effect of "$comment" beyond what is described in this
                    specification.¶\nTools that translate other media types or programming languages
                    to and from application/schema+json MAY choose to convert that media type or
                    programming language's native comments to or from "$comment" values.
                    The behavior of such translation when both native comments and "$comment"
                    properties are present is implementation-dependent.¶\nImplementations MAY strip "$comment" values at any point during processing.
                    In particular, this allows for shortening schemas when the size of deployed
                    schemas is a concern.¶\nImplementations MUST NOT take any other action based on the presence, absence,
                    or contents of "$comment" properties.  In particular, the value of "$comment"
                    MUST NOT be collected as an annotation result.¶\n9. Loading and Processing Schemas\nLoading and Processing Schemas\n9.1. Loading a Schema\n9.1.1. Initial Base URI
          

                        RFC3986 Section 5.1 [RFC3986] defines how to determine the
                        default base URI of a document.¶

                        Informatively, the initial base URI of a schema is the URI at which it was
                        found, whether that was a network location, a local filesystem, or any other
                        situation identifiable by a URI of any known scheme.¶

                        If a schema document defines no explicit base URI with "$id"
                        (embedded in content), the base URI is that determined per
                        RFC 3986 section 5 [RFC3986].¶

                        If no source is known, or no URI scheme is known for the source, a suitable
                        implementation-specific default URI MAY be used as described in
                        RFC 3986 Section 5.1.4 [RFC3986].  It is RECOMMENDED
                        that implementations document any default base URI that they assume.¶

                        If a schema object is embedded in a document of another media type, then
                        the initial base URI is determined according to the rules of that
                        media type.¶

                        Unless the "$id" keyword described in an earlier section is present in the
                        root schema, this base URI SHOULD be considered the canonical URI of the
                        schema document's root schema resource.¶\n9.1.1. Initial Base URI\nRFC3986 Section 5.1 [RFC3986] defines how to determine the
                        default base URI of a document.¶\nRFC3986 Section 5.1 [RFC3986]\nInformatively, the initial base URI of a schema is the URI at which it was
                        found, whether that was a network location, a local filesystem, or any other
                        situation identifiable by a URI of any known scheme.¶\nIf a schema document defines no explicit base URI with "$id"
                        (embedded in content), the base URI is that determined per
                        RFC 3986 section 5 [RFC3986].¶\nRFC 3986 section 5 [RFC3986]\nIf no source is known, or no URI scheme is known for the source, a suitable
                        implementation-specific default URI MAY be used as described in
                        RFC 3986 Section 5.1.4 [RFC3986].  It is RECOMMENDED
                        that implementations document any default base URI that they assume.¶\nRFC 3986 Section 5.1.4 [RFC3986]\nRFC 3986 Section 5.1.4\nIf a schema object is embedded in a document of another media type, then
                        the initial base URI is determined according to the rules of that
                        media type.¶\nUnless the "$id" keyword described in an earlier section is present in the
                        root schema, this base URI SHOULD be considered the canonical URI of the
                        schema document's root schema resource.¶\n9.1.2. Loading a referenced schema\nLoading a referenced schema\nThe use of URIs to identify remote schemas does not necessarily mean anything is downloaded,
                        but instead JSON Schema implementations SHOULD understand ahead of time which schemas they will be using,
                        and the URIs that identify them.¶\nWhen schemas are downloaded,
                        for example by a generic user-agent that does not know until runtime which schemas to download,
                        see Usage for Hypermedia (Section 9.5.1).¶\nUsage for Hypermedia (Section 9.5.1)\nImplementations SHOULD be able to associate arbitrary URIs with an arbitrary
                        schema and/or automatically associate a schema's "$id"-given URI, depending
                        on the trust that the validator has in the schema.  Such URIs and schemas
                        can be supplied to an implementation prior to processing instances, or may
                        be noted within a schema document as it is processed, producing associations
                        as shown in appendix A.¶\nA schema MAY (and likely will) have multiple URIs, but there is no way for a
                        URI to identify more than one schema. When multiple schemas try to identify
                        as the same URI, validators SHOULD raise an error condition.¶\n9.1.3. Detecting a Meta-Schema\nDetecting a Meta-Schema\nImplementations MUST recognize a schema as a meta-schema if it
                        is being examined because it was identified as such by another
                        schema's "$schema" keyword.  This means that a single schema
                        document might sometimes be considered a regular schema, and
                        other times be considered a meta-schema.¶\nIn the case of examining a schema which is its own meta-schema,
                        when an implementation begins processing it as a regular schema,
                        it is processed under those rules.  However, when loaded a second
                        time as a result of checking its own "$schema" value, it is treated
                        as a meta-schema.  So the same document is processed both ways in
                        the course of one session.¶\nImplementations MAY allow a schema to be explicitly passed as a meta-schema,
                        for implementation-specific purposes, such as pre-loading a commonly
                        used meta-schema and checking its vocabulary support requirements
                        up front.  Meta-schema authors MUST NOT expect such features to be
                        interoperable across implementations.¶\nSchemas can be identified by any URI that has been given to them, including
                    a JSON Pointer or their URI given directly by "$id".  In all cases,
                    dereferencing a "$ref" reference involves first resolving its value as a
                    URI reference against the current base URI per
                    RFC 3986 [RFC3986].¶\nIf the resulting URI identifies a schema within the current document, or
                    within another schema document that has been made available to the implementation,
                    then that schema SHOULD be used automatically.¶\nFor example, consider this schema:¶\n{
    "$id": "https://example.net/root.json",
    "items": {
        "type": "array",
        "items": { "$ref": "#item" }
    },
    "$defs": {
        "single": {
            "$anchor": "item",
            "type": "object",
            "additionalProperties": { "$ref": "other.json" }
        }
    }
}

¶\nWhen an implementation encounters the <#/$defs/single> schema,
                    it resolves the "$anchor" value as a fragment name against the current
                    base URI to form <https://example.net/root.json#item>.¶\nWhen an implementation then looks inside the <#/items> schema, it
                    encounters the <#item> reference, and resolves this to
                    <https://example.net/root.json#item>, which it has seen defined in
                    this same document and can therefore use automatically.¶\nWhen an implementation encounters the reference to "other.json", it resolves
                    this to <https://example.net/other.json>, which is not defined in this
                    document.  If a schema with that identifier has otherwise been supplied to
                    the implementation, it can also be used automatically.
                    
                        What should implementations do when the referenced schema is not known?
                        Are there circumstances in which automatic network dereferencing is
                        allowed?  A same origin policy?  A user-configurable option?  In the
                        case of an evolving API described by Hyper-Schema, it is expected that
                        new schemas will be added to the system dynamically, so placing an
                        absolute requirement of pre-loading schema documents is not feasible.
          ¶\nWhat should implementations do when the referenced schema is not known?
                        Are there circumstances in which automatic network dereferencing is
                        allowed?  A same origin policy?  A user-configurable option?  In the
                        case of an evolving API described by Hyper-Schema, it is expected that
                        new schemas will be added to the system dynamically, so placing an
                        absolute requirement of pre-loading schema documents is not feasible.\n9.2.1. JSON Pointer fragments and embedded schema resources
          

                        Since JSON Pointer URI fragments are constructed based on the structure
                        of the schema document, an embedded schema resource and its subschemas
                        can be identified by JSON Pointer fragments relative to either its own
                        canonical URI, or relative to any containing resource's URI.¶

                        Conceptually, a set of linked schema resources should behave
                        identically whether each resource is a separate document connected with
                        schema references (Section 8.2.3), or is structured as
                        a single document with one or more schema resources embedded as
                        subschemas.¶

                        Since URIs involving JSON Pointer fragments relative to the parent
                        schema resource's URI cease to be valid when the embedded schema
                        is moved to a separate document and referenced, applications and schemas
                        SHOULD NOT use such URIs to identify embedded schema resources or
                        locations within them.¶

                            Consider the following schema document that contains another
                            schema resource embedded within it:¶


{
    "$id": "https://example.com/foo",
    "items": {
        "$id": "https://example.com/bar",
        "additionalProperties": { }
    }
}

¶


                        The URI "https://example.com/foo#/items" points to the "items" schema,
                        which is an embedded resource.  The canonical URI of that schema
                        resource, however, is "https://example.com/bar".¶

                        For the "additionalProperties" schema within that embedded resource,
                        the URI "https://example.com/foo#/items/additionalProperties" points
                        to the correct object, but that object's URI relative to its resource's
                        canonical URI is "https://example.com/bar#/additionalProperties".¶

                            Now consider the following two schema resources linked by reference
                            using a URI value for "$ref":¶


{
    "$id": "https://example.com/foo",
    "items": {
        "$ref": "bar"
    }
}

{
    "$id": "https://example.com/bar",
    "additionalProperties": { }
}

¶


                            Here we see that "https://example.com/bar#/additionalProperties",
                            using a JSON Pointer fragment appended to the canonical URI of
                            the "bar" schema resource, is still valid, while
                            "https://example.com/foo#/items/additionalProperties", which relied
                            on a JSON Pointer fragment appended to the canonical URI of the
                            "foo" schema resource, no longer resolves to anything.¶

                        Note also that "https://example.com/foo#/items" is valid in both
                        arrangements, but resolves to a different value.  This URI ends up
                        functioning similarly to a retrieval URI for a resource.  While this URI
                        is valid, it is more robust to use the "$id" of the embedded or referenced
                        resource unless it is specifically desired to identify the object containing
                        the "$ref" in the second (non-embedded) arrangement.¶

                        An implementation MAY choose not to support addressing schema resource
                        contents by URIs using a base other than the resource's canonical URI,
                        plus a JSON Pointer fragment relative to that base.  Therefore, schema
                        authors SHOULD NOT rely on such URIs, as using them may reduce interoperability.
                        
                            This is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)
            ¶

                        Further examples of such non-canonical URI construction, as well as
                        the appropriate canonical URI-based fragments to use instead,
                        are provided in appendix A.¶\n9.2.1. JSON Pointer fragments and embedded schema resources\nJSON Pointer fragments and embedded schema resources\nSince JSON Pointer URI fragments are constructed based on the structure
                        of the schema document, an embedded schema resource and its subschemas
                        can be identified by JSON Pointer fragments relative to either its own
                        canonical URI, or relative to any containing resource's URI.¶\nConceptually, a set of linked schema resources should behave
                        identically whether each resource is a separate document connected with
                        schema references (Section 8.2.3), or is structured as
                        a single document with one or more schema resources embedded as
                        subschemas.¶\nschema references (Section 8.2.3)\nSince URIs involving JSON Pointer fragments relative to the parent
                        schema resource's URI cease to be valid when the embedded schema
                        is moved to a separate document and referenced, applications and schemas
                        SHOULD NOT use such URIs to identify embedded schema resources or
                        locations within them.¶\nConsider the following schema document that contains another
                            schema resource embedded within it:¶\n{
    "$id": "https://example.com/foo",
    "items": {
        "$id": "https://example.com/bar",
        "additionalProperties": { }
    }
}

¶\nThe URI "https://example.com/foo#/items" points to the "items" schema,
                        which is an embedded resource.  The canonical URI of that schema
                        resource, however, is "https://example.com/bar".¶\nFor the "additionalProperties" schema within that embedded resource,
                        the URI "https://example.com/foo#/items/additionalProperties" points
                        to the correct object, but that object's URI relative to its resource's
                        canonical URI is "https://example.com/bar#/additionalProperties".¶\nNow consider the following two schema resources linked by reference
                            using a URI value for "$ref":¶\n{
    "$id": "https://example.com/foo",
    "items": {
        "$ref": "bar"
    }
}

{
    "$id": "https://example.com/bar",
    "additionalProperties": { }
}

¶\nHere we see that "https://example.com/bar#/additionalProperties",
                            using a JSON Pointer fragment appended to the canonical URI of
                            the "bar" schema resource, is still valid, while
                            "https://example.com/foo#/items/additionalProperties", which relied
                            on a JSON Pointer fragment appended to the canonical URI of the
                            "foo" schema resource, no longer resolves to anything.¶\nNote also that "https://example.com/foo#/items" is valid in both
                        arrangements, but resolves to a different value.  This URI ends up
                        functioning similarly to a retrieval URI for a resource.  While this URI
                        is valid, it is more robust to use the "$id" of the embedded or referenced
                        resource unless it is specifically desired to identify the object containing
                        the "$ref" in the second (non-embedded) arrangement.¶\nAn implementation MAY choose not to support addressing schema resource
                        contents by URIs using a base other than the resource's canonical URI,
                        plus a JSON Pointer fragment relative to that base.  Therefore, schema
                        authors SHOULD NOT rely on such URIs, as using them may reduce interoperability.
                        
                            This is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)
            ¶\nThis is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)\nFurther examples of such non-canonical URI construction, as well as
                        the appropriate canonical URI-based fragments to use instead,
                        are provided in appendix A.¶\n9.3. Compound Documents\nA Compound Schema Document is defined as a JSON document (sometimes called a "bundled" schema)
                    which has multiple embedded JSON Schema Resources bundled into the same document to
                    ease transportation.¶\nEach embedded Schema Resource MUST be treated as an individual Schema Resource, following standard
                    schema loading and processing requirements, including determining vocabulary support.¶\nThe bundling process for creating a Compound Schema Document is defined as taking
                        references (such as "$ref") to an external Schema Resource and embedding the referenced
                        Schema Resources within the referring document. Bundling SHOULD be done in such a way that
                        all URIs (used for referencing) in the base document and any referenced/embedded
                        documents do not require altering.¶\nEach embedded JSON Schema Resource MUST identify itself with a URI using the "$id" keyword,
                        and SHOULD make use of the "$schema" keyword to identify the dialect it is using, in the root of the
                        schema resource. It is RECOMMENDED that the URI identifier value of "$id" be an Absolute URI.¶\nWhen the Schema Resource referenced by a by-reference applicator is bundled, it is RECOMMENDED that
                        the Schema Resource be located as a value of a "$defs" object at the containing schema's root.
                        The key of the "$defs" for the now embedded Schema Resource MAY be the "$id" of the bundled schema
                        or some other form of application defined unique identifier (such as a UUID). This key is not
                        intended to be referenced in JSON Schema, but may be used by an application to aid the
                        bundling process.¶\nA Schema Resource MAY be embedded in a location other than "$defs" where the location is defined
                        as a schema value.¶\nA Bundled Schema Resource MUST NOT be bundled by replacing the schema object from which it was
                        referenced, or by wrapping the Schema Resource in other applicator keywords.¶\nIn order to produce identical output, references in the containing schema document to the
                        previously external Schema Resources MUST NOT be changed, and now resolve to a schema using the
                        "$id" of an embedded Schema Resource. Such identical output includes validation evaluation and URIs
                        or paths used in resulting annotations or errors.¶\nWhile the bundling process will often be the main method for creating a Compound Schema Document,
                        it is also possible and expected that some will be created by hand, potentially without individual
                        Schema Resources existing on their own previously.¶\n9.3.2. Differing and Default Dialects\nDiffering and Default Dialects\nWhen multiple schema resources are present in a single document,
                        schema resources which do not define with which dialect they should be processed
                        MUST be processed with the same dialect as the enclosing resource.¶\nSince any schema that can be referenced can also be embedded, embedded schema resources MAY
                        specify different processing dialects using the "$schema" values from their enclosing resource.¶\nGiven that a Compound Schema Document may have embedded resources which identify as using different
                        dialects, these documents SHOULD NOT be validated by applying a meta-schema
                        to the Compound Schema Document as an instance. It is RECOMMENDED that an alternate
                        validation process be provided in order to validate Schema Documents. Each Schema Resource
                        SHOULD be separately validated against its associated meta-schema.
                        
                            If you know a schema is what's being validated, you can identify if the schemas
                            is a Compound Schema Document or not, by way of use of "$id", which identifies an
                            embedded resource when used not at the document's root.
            ¶\nIf you know a schema is what's being validated, you can identify if the schemas
                            is a Compound Schema Document or not, by way of use of "$id", which identifies an
                            embedded resource when used not at the document's root.\nA Compound Schema Document in which all embedded resources identify as using the same
                        dialect, or in which "$schema" is omitted and therefore defaults to that of the enclosing resource,
                        MAY be validated by applying the appropriate meta-schema.¶\n9.4.1. Guarding Against Infinite Recursion\nGuarding Against Infinite Recursion\nA schema MUST NOT be run into an infinite loop against an instance. For
                        example, if two schemas "#alice" and "#bob" both have an "allOf" property
                        that refers to the other, a naive validator might get stuck in an infinite
                        recursive loop trying to validate the instance.  Schemas SHOULD NOT make
                        use of infinite recursive nesting like this; the behavior is undefined.¶\n9.4.2. References to Possible Non-Schemas
          

                        Subschema objects (or booleans) are recognized by their use with known
                        applicator keywords or with location-reserving keywords such as
                        "$defs" (Section 8.2.4) that take one or more subschemas
                        as a value.  These keywords may be "$defs" and the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.¶

                        Multi-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
            ¶

                        Note that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.¶\n9.4.2. References to Possible Non-Schemas\nReferences to Possible Non-Schemas\nSubschema objects (or booleans) are recognized by their use with known
                        applicator keywords or with location-reserving keywords such as
                        "$defs" (Section 8.2.4) that take one or more subschemas
                        as a value.  These keywords may be "$defs" and the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.¶\n"$defs" (Section 8.2.4)\nMulti-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
            ¶\nThese scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.\nNote that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.¶\n9.5. Associating Instances and Schemas\nAssociating Instances and Schemas\n9.5.1. Usage for Hypermedia
          

                        JSON has been adopted widely by HTTP servers for automated APIs and robots. This
                        section describes how to enhance processing of JSON documents in a more RESTful
                        manner when used with protocols that support media types and
                        Web linking [RFC8288].¶

            
9.5.1.1. Linking to a Schema
            

                            It is RECOMMENDED that instances described by a schema provide a link to
                            a downloadable JSON Schema using the link relation "describedby", as defined by
                            Linked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226].¶

                            In HTTP, such links can be attached to any response using the
                            Link header [RFC8288]. An example of such a header would be:¶


        Link: <https://example.com/my-hyper-schema>; rel="describedby"

¶



            
9.5.1.2. Usage Over HTTP
            

                            When used for hypermedia systems over a network,
                            HTTP [RFC7231] is frequently the protocol of choice for
                            distributing schemas. Misbehaving clients can pose problems for server
                            maintainers if they pull a schema over the network more frequently than
                            necessary, when it's instead possible to cache a schema for a long period of
                            time.¶

                            HTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                            HTTP clients SHOULD observe caching headers and not re-request documents within
                            their freshness period.
                            Distributed systems SHOULD make use of a shared cache and/or caching proxy.¶

                            Clients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                            implementation or software product. Since symbols are listed in decreasing order
                            of significance, the JSON Schema library name/version should precede the more
                            generic HTTP library name (if any). For example:¶


        User-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

¶


                            Clients SHOULD be able to make requests with a "From" header so that server
                            operators can contact the owner of a potentially misbehaving script.¶\n9.5.1. Usage for Hypermedia\nJSON has been adopted widely by HTTP servers for automated APIs and robots. This
                        section describes how to enhance processing of JSON documents in a more RESTful
                        manner when used with protocols that support media types and
                        Web linking [RFC8288].¶\nWeb linking [RFC8288]\n9.5.1.1. Linking to a Schema\nIt is RECOMMENDED that instances described by a schema provide a link to
                            a downloadable JSON Schema using the link relation "describedby", as defined by
                            Linked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226].¶\nLinked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226]\nLinked Data Protocol 1.0, section 8.1\nIn HTTP, such links can be attached to any response using the
                            Link header [RFC8288]. An example of such a header would be:¶\nLink header [RFC8288]\nLink: <https://example.com/my-hyper-schema>; rel="describedby"

¶\n9.5.1.2. Usage Over HTTP\nWhen used for hypermedia systems over a network,
                            HTTP [RFC7231] is frequently the protocol of choice for
                            distributing schemas. Misbehaving clients can pose problems for server
                            maintainers if they pull a schema over the network more frequently than
                            necessary, when it's instead possible to cache a schema for a long period of
                            time.¶\nHTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                            HTTP clients SHOULD observe caching headers and not re-request documents within
                            their freshness period.
                            Distributed systems SHOULD make use of a shared cache and/or caching proxy.¶\nClients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                            implementation or software product. Since symbols are listed in decreasing order
                            of significance, the JSON Schema library name/version should precede the more
                            generic HTTP library name (if any). For example:¶\nUser-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

¶\nClients SHOULD be able to make requests with a "From" header so that server
                            operators can contact the owner of a potentially misbehaving script.¶\n10. A Vocabulary for Applying Subschemas\nA Vocabulary for Applying Subschemas\nThis section defines a vocabulary of applicator keywords that
                are RECOMMENDED for use as the basis of other vocabularies.¶\nMeta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.¶\nThe current URI for this vocabulary, known as the Applicator vocabulary, is:
                <https://json-schema.org/draft/2020-12/vocab/applicator>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/applicator.¶\nhttps://json-schema.org/draft/2020-12/meta/applicator\nhttps://json-schema.org/draft/2020-12/meta/applicator\n10.1. Keyword Independence\nSchema keywords typically operate independently, without
                    affecting each other's outcomes.¶\nFor schema author convenience, there are some exceptions among the
                    keywords in this vocabulary:¶\n"additionalProperties", whose behavior is defined in terms of
                            "properties" and "patternProperties"¶\n"items", whose behavior is defined in terms of "prefixItems"¶\n"contains", whose behavior is affected by the presence and value of
                            "minContains", in the Validation vocabulary¶\n10.2. Keywords for Applying Subschemas in Place
        

                    These keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.¶

                    Subschemas of these keywords evaluate the instance completely independently
                    such that the results of one such subschema MUST NOT impact the results of sibling
                    subschemas.  Therefore subschemas may be applied in
                    any order.¶


          
10.2.1. Keywords for Applying Subschemas With Logic
          

                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶


            
10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶



            
10.2.1.2. anyOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶


            
10.2.1.3. oneOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶



            
10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶






          
10.2.2. Keywords for Applying Subschemas Conditionally
          

                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶

                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶

                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶

            
10.2.2.1. if
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶

                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶

                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶

                            If annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶


            
10.2.2.2. then
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.3. else
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.4. dependentSchemas
            

                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶

                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶

                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶

                            Omitting this keyword has the same behavior as an empty object.¶\n10.2. Keywords for Applying Subschemas in Place\nKeywords for Applying Subschemas in Place\nThese keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.¶\nSubschemas of these keywords evaluate the instance completely independently
                    such that the results of one such subschema MUST NOT impact the results of sibling
                    subschemas.  Therefore subschemas may be applied in
                    any order.¶\n10.2.1. Keywords for Applying Subschemas With Logic
          

                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶


            
10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶



            
10.2.1.2. anyOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶


            
10.2.1.3. oneOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶



            
10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\n10.2.1. Keywords for Applying Subschemas With Logic\nKeywords for Applying Subschemas With Logic\nThese keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶\n10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶\n10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nAn instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\n10.2.2. Keywords for Applying Subschemas Conditionally
          

                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶

                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶

                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶

            
10.2.2.1. if
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶

                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶

                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶

                            If annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶


            
10.2.2.2. then
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.3. else
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.4. dependentSchemas
            

                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶

                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶

                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶

                            Omitting this keyword has the same behavior as an empty object.¶\n10.2.2. Keywords for Applying Subschemas Conditionally\nKeywords for Applying Subschemas Conditionally\nThree of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶\n"if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶\nThere is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nThis validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶\nInstances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶\nInstances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶\nIf annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶\nannotations (Section 7.7)\nThis keyword's value MUST be a valid JSON Schema.¶\nWhen "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶\nThis keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nWhen "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶\nThis keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶\n10.2.2.4. dependentSchemas\nThis keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶\nThis keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶\nIf the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶\nOmitting this keyword has the same behavior as an empty object.¶\n10.3. Keywords for Applying Subschemas to Child Instances\nKeywords for Applying Subschemas to Child Instances\nEach of these keywords defines a rule for applying its
                    subschema(s) to child instances, specifically object
                    properties and array items, and combining their results.¶\n10.3.1. Keywords for Applying Subschemas to Arrays\nKeywords for Applying Subschemas to Arrays\n10.3.1.1. prefixItems\nThe value of "prefixItems" MUST be a non-empty array of valid JSON Schemas.¶\nValidation succeeds if each element of the instance validates
                            against the schema at the same position, if any.  This keyword
                            does not constrain the length of the array.  If the array is longer
                            than this keyword's value, this keyword validates only the
                            prefix of matching length.¶\nThis keyword produces an annotation value which is the largest
                            index to which this keyword applied a subschema.  The value
                            MAY be a boolean true if a subschema was applied to every
                            index of the instance, such as is produced by the "items" keyword.
                            This annotation affects the behavior of "items" and "unevaluatedItems".¶\nOmitting this keyword has the same assertion behavior as
                            an empty array.¶\n10.3.1.2. items
            

                            The value of "items" MUST be a valid JSON Schema.¶

                            This keyword applies its subschema to all instance elements
                            at indexes greater than the length of the "prefixItems" array
                            in the same schema object, as reported by the annotation result
                            of that "prefixItems" keyword.  If no such annotation
                            result exists, "items" applies its subschema to all instance
                            array elements.
                            
                                Note that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.
              ¶

                            If the "items" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, indicating that all remaining array
                            elements have been evaluated against this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary.¶

                            Omitting this keyword has the same assertion behavior as
                            an empty schema.¶

                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of a "prefixItems" array.
                            Implementations that do not support annotation collection MUST do so.¶\nThe value of "items" MUST be a valid JSON Schema.¶\nThis keyword applies its subschema to all instance elements
                            at indexes greater than the length of the "prefixItems" array
                            in the same schema object, as reported by the annotation result
                            of that "prefixItems" keyword.  If no such annotation
                            result exists, "items" applies its subschema to all instance
                            array elements.
                            
                                Note that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.
              ¶\nNote that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.\nIf the "items" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, indicating that all remaining array
                            elements have been evaluated against this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty schema.¶\nImplementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of a "prefixItems" array.
                            Implementations that do not support annotation collection MUST do so.¶\nThe value of this keyword MUST be a valid JSON Schema.¶\nAn array instance is valid against "contains" if at least one of
                            its elements is valid against the given schema,
                            except when "minContains" is present and has a value of 0, in which
                            case an array instance MUST be considered valid against the "contains" keyword,
                            even if none of its elements is valid against the given schema.¶\nThis keyword produces an annotation value which is an array of
                            the indexes to which this keyword validates successfully when applying
                            its subschema, in ascending order. The value MAY be a boolean "true" if
                            the subschema validates successfully when applied to every index of the
                            instance. The annotation MUST be present if the instance array to which
                            this keyword's schema applies is empty.¶\nThis annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary, and MAY also be used to implement the
                            "minContains" and "maxContains" keywords in the Validation vocabulary.¶\nThe subschema MUST be applied to every array element even after the first
                            match has been found, in order to collect annotations for use by other
                            keywords. This is to ensure that all possible annotations are collected.¶\n10.3.2. Keywords for Applying Subschemas to Objects\nKeywords for Applying Subschemas to Objects\nThe value of "properties" MUST be an object.
                            Each value of this object MUST be a valid JSON Schema.¶\nValidation succeeds if, for each name that appears in both
                            the instance and as a name within this keyword's value, the child
                            instance for that name successfully validates against the
                            corresponding schema.¶\nThe annotation result of this keyword is the set of instance
                            property names matched by this keyword.
                            This annotation affects the behavior of "additionalProperties" (in
                            this vocabulary) and "unevaluatedProperties" in the Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty object.¶\n10.3.2.2. patternProperties\nThe value of "patternProperties" MUST be an object. Each property name
                            of this object SHOULD be a valid regular expression, according to the
                            ECMA-262 regular expression dialect. Each property value of this object
                            MUST be a valid JSON Schema.¶\nValidation succeeds if, for each instance name that matches any
                            regular expressions that appear as a property name in this keyword's value,
                            the child instance for that name successfully validates against each
                            schema that corresponds to a matching regular expression.¶\nThe annotation result of this keyword is the set of instance
                            property names matched by this keyword.
                            This annotation affects the behavior of "additionalProperties" (in this
                            vocabulary) and "unevaluatedProperties" (in the Unevaluated vocabulary).¶\nOmitting this keyword has the same assertion behavior as
                            an empty object.¶\n10.3.2.3. additionalProperties
            

                            The value of "additionalProperties" MUST be a valid JSON Schema.¶

                            The behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".¶

                            For all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.¶

                            The annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedProperties"
                            in the Unevaluated vocabulary.¶

                            Omitting this keyword has the same assertion behavior as
                            an empty schema.¶

                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                            
                                In defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.
              ¶\n10.3.2.3. additionalProperties\nThe value of "additionalProperties" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".¶\nFor all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.¶\nThe annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedProperties"
                            in the Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty schema.¶\nImplementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                            
                                In defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.
              ¶\nIn defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.\n10.3.2.4. propertyNames\nThe value of "propertyNames" MUST be a valid JSON Schema.¶\nIf the instance is an object, this keyword validates if every property name in
                            the instance validates against the provided schema.
                            Note the property name that the schema is testing will always be a string.¶\nOmitting this keyword has the same behavior as an empty schema.¶\n11. A Vocabulary for Unevaluated Locations\nA Vocabulary for Unevaluated Locations\nThe purpose of these keywords is to enable schema authors to apply
                subschemas to array items or object properties that have not been
                successfully evaluated against any dynamic-scope subschema of any
                adjacent keywords.¶\nThese instance items or properties may have been unsuccessfully evaluated
                against one or more adjacent keyword subschemas, such as when an assertion
                in a branch of an "anyOf" fails.  Such failed evaluations are not considered
                to contribute to whether or not the item or property has been evaluated.
                Only successful evaluations are considered.¶\nIf an item in an array or an object property is "successfully evaluated", it
                is logically considered to be valid in terms of the representation of the
                object or array that's expected. For example if a subschema represents a car,
                which requires between 2-4 wheels, and the value of "wheels" is 6, the instance
                object is not "evaluated" to be a car, and the "wheels" property is considered
                "unevaluated (successfully as a known thing)", and does not retain any annotations.¶\nRecall that adjacent keywords are keywords within the same schema object,
                and that the dynamic-scope subschemas include reference targets as well as
                lexical subschemas.¶\nThe behavior of these keywords depend on the annotation results of
                adjacent keywords that apply to the instance location being validated.¶\nMeta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.¶\nThe current URI for this vocabulary, known as the Unevaluated Applicator
                vocabulary, is:
                <https://json-schema.org/draft/2020-12/vocab/unevaluated>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/unevaluated.¶\nhttps://json-schema.org/draft/2020-12/meta/unevaluated\nhttps://json-schema.org/draft/2020-12/meta/unevaluated\n11.1. Keyword Independence\nSchema keywords typically operate independently, without
                    affecting each other's outcomes. However, the keywords in this
                    vocabulary are notable exceptions:¶\n"unevaluatedItems", whose behavior is defined in terms of annotations
                            from "prefixItems", "items", "contains", and itself¶\n"unevaluatedProperties", whose behavior is defined in terms of
                            annotations from "properties", "patternProperties",
                            "additionalProperties" and itself¶\n11.2. unevaluatedItems
        

                    The value of "unevaluatedItems" MUST be a valid JSON Schema.¶

                    The behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "prefixItems", "items", and "contains",
                    which can come from those keywords when they are adjacent to the
                    "unevaluatedItems" keyword. Those three annotations, as well as
                    "unevaluatedItems", can also result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶

                    If no relevant annotations are present, the "unevaluatedItems"
                    subschema MUST be applied to all locations in the array.
                    If a boolean true value is present from any of the relevant annotations,
                    "unevaluatedItems" MUST be ignored.  Otherwise, the subschema
                    MUST be applied to any index greater than the largest annotation
                    value for "prefixItems", which does not appear in any annotation
                    value for "contains".¶

                    This means that "prefixItems", "items", "contains", and all in-place
                    applicators MUST be evaluated before this keyword can be evaluated.
                    Authors of extension keywords MUST NOT define an in-place applicator
                    that would need to be evaluated after this keyword.¶

                    If the "unevaluatedItems" subschema is applied to any
                    positions within the instance array, it produces an
                    annotation result of boolean true, analogous to the
                    behavior of "items".
                    This annotation affects the behavior of "unevaluatedItems" in parent schemas.¶

                    Omitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.2. unevaluatedItems\nThe value of "unevaluatedItems" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "prefixItems", "items", and "contains",
                    which can come from those keywords when they are adjacent to the
                    "unevaluatedItems" keyword. Those three annotations, as well as
                    "unevaluatedItems", can also result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶\nin-place applicator (Section 10.2)\nIf no relevant annotations are present, the "unevaluatedItems"
                    subschema MUST be applied to all locations in the array.
                    If a boolean true value is present from any of the relevant annotations,
                    "unevaluatedItems" MUST be ignored.  Otherwise, the subschema
                    MUST be applied to any index greater than the largest annotation
                    value for "prefixItems", which does not appear in any annotation
                    value for "contains".¶\nThis means that "prefixItems", "items", "contains", and all in-place
                    applicators MUST be evaluated before this keyword can be evaluated.
                    Authors of extension keywords MUST NOT define an in-place applicator
                    that would need to be evaluated after this keyword.¶\nIf the "unevaluatedItems" subschema is applied to any
                    positions within the instance array, it produces an
                    annotation result of boolean true, analogous to the
                    behavior of "items".
                    This annotation affects the behavior of "unevaluatedItems" in parent schemas.¶\nOmitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.3. unevaluatedProperties
        

                    The value of "unevaluatedProperties" MUST be a valid JSON Schema.¶

                    The behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "properties", "patternProperties",
                    and "additionalProperties", which can come from those keywords when
                    they are adjacent to the "unevaluatedProperties" keyword.  Those
                    three annotations, as well as "unevaluatedProperties", can also
                    result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶

                    Validation with "unevaluatedProperties" applies only to the child
                    values of instance names that do not appear in the "properties",
                    "patternProperties", "additionalProperties", or
                    "unevaluatedProperties" annotation results that apply to the
                    instance location being validated.¶

                    For all such properties, validation succeeds if the child instance
                    validates against the "unevaluatedProperties" schema.¶

                    This means that "properties", "patternProperties", "additionalProperties",
                    and all in-place applicators MUST be evaluated before this keyword can
                    be evaluated.  Authors of extension keywords MUST NOT define an in-place
                    applicator that would need to be evaluated after this keyword.¶

                    The annotation result of this keyword is the set of instance
                    property names validated by this keyword's subschema.
                    This annotation affects the behavior of "unevaluatedProperties" in parent schemas.¶

                    Omitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.3. unevaluatedProperties\nunevaluatedProperties\nThe value of "unevaluatedProperties" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "properties", "patternProperties",
                    and "additionalProperties", which can come from those keywords when
                    they are adjacent to the "unevaluatedProperties" keyword.  Those
                    three annotations, as well as "unevaluatedProperties", can also
                    result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶\nin-place applicator (Section 10.2)\nValidation with "unevaluatedProperties" applies only to the child
                    values of instance names that do not appear in the "properties",
                    "patternProperties", "additionalProperties", or
                    "unevaluatedProperties" annotation results that apply to the
                    instance location being validated.¶\nFor all such properties, validation succeeds if the child instance
                    validates against the "unevaluatedProperties" schema.¶\nThis means that "properties", "patternProperties", "additionalProperties",
                    and all in-place applicators MUST be evaluated before this keyword can
                    be evaluated.  Authors of extension keywords MUST NOT define an in-place
                    applicator that would need to be evaluated after this keyword.¶\nThe annotation result of this keyword is the set of instance
                    property names validated by this keyword's subschema.
                    This annotation affects the behavior of "unevaluatedProperties" in parent schemas.¶\nOmitting this keyword has the same assertion behavior as
                    an empty schema.¶\n12. Output Formatting
      

                JSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.¶

        
12.1. Format
        

                    JSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.¶


        
12.2. Output Formats
        

                    This specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.¶


                            Flag - A boolean which simply indicates the overall validation result
                            with no further details.¶

          
                            Basic - Provides validation information in a flat list structure.¶

          
                            Detailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.¶

          
                            Verbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.¶

        

                    An implementation SHOULD provide at least one of the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    "detailed" or "verbose" formats, it MUST also provide the "flag" format.
                    Implementations SHOULD specify in their documentation which formats they support.¶


        
12.3. Minimum Information
        

                    Beyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.¶

                    A single object that contains all of these components is considered an
                    output unit.¶

                    Implementations MAY elect to provide additional information.¶

          
12.3.1. Keyword Relative Location
          

                        The relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$dynamicRef".¶


/properties/width/$ref/minimum

¶


                    Note that this pointer may not be resolvable by the normal JSON Pointer process
                    due to the inclusion of these by-reference applicator keywords.¶

                        The JSON key for this information is "keywordLocation".¶


          
12.3.2. Keyword Absolute Location
          

                        The absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as a full URI using the canonical URI of the relevant schema resource
                        with a JSON Pointer fragment, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$dynamicRef" as non-terminal path components.
                        It MAY end in such keywords if the error or annotation is for that
                        keyword, such as an unresolvable reference.
                        
                            Note that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.
            ¶


https://example.com/schemas/common#/$defs/count/minimum

¶


                        This information MAY be omitted only if either the dynamic scope did not pass
                        over a reference or if the schema does not declare an absolute URI as its "$id".¶

                        The JSON key for this information is "absoluteKeywordLocation".¶


          
12.3.3. Instance Location
          

                        The location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.¶

                        The JSON key for this information is "instanceLocation".¶


          
12.3.4. Error or Annotation
          

                        The error or annotation that is produced by the validation.¶

                        For errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.¶

                        For annotations, each keyword that produces an annotation specifies its
                        format.  By default, it is the keyword's value.¶

                        The JSON key for failed validations is "error"; for successful validations
                        it is "annotation".¶


          
12.3.5. Nested Results
          

                        For the two hierarchical structures, this property will hold nested errors
                        and annotations.¶

                        The JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".  Note the plural forms, as
                        a keyword with nested results can also have a local error or annotation.¶



        
12.4. Output Structure
        

                    The output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.¶


                            "valid" - a boolean value indicating the overall validation success or
                            failure¶

          
                            "errors" - the collection of errors or annotations produced by a failed
                            validation¶

          
                            "annotations" - the collection of errors or annotations produced by a
                            successful validation¶

        

                    For these examples, the following schema and instance will be used.¶


{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3
  },
  {
    "x": 1,
    "z": 6.7
  }
]

¶


                    This instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.¶

                    Specifically, the errors it will produce are:¶


                            The second object is missing a "y" property.¶

          
                            The second object has a disallowed "z" property.¶

          
                            There are only two objects, but three are required.¶

        

                    Note that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.¶

          
12.4.1. Flag
          

                        In the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.¶


{
  "valid": false
}

¶


                        Because no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.¶


          
12.4.2. Basic
          

                        The "Basic" structure is a flat list of output units.¶


{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "",
      "instanceLocation": "",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref/required",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/required",
      "instanceLocation": "/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/additionalProperties",
      "instanceLocation": "/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶



          
12.4.3. Detailed
          

                        The "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correlation is more easily identified.¶

                        The following rules govern the construction of the results object:¶


                                All applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.¶

            
                                Nodes that have no children are removed.¶

            
                                Nodes that have a single child are replaced by the child.¶

          

                        Branch nodes do not require an error message or an annotation.¶


{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/items/$ref/required",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/required",
          "instanceLocation": "/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/additionalProperties",
          "instanceLocation": "/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶



          
12.4.4. Verbose
          

                        The "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.¶

                        The primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.¶

                        Because this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        https://json-schema.org/draft/2020-12/output/verbose-example.¶


// schema
{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "/type",
      "instanceLocation": ""
    },
    {
      "valid": true,
      "keywordLocation": "/properties",
      "instanceLocation": ""
    },
    {
      "valid": false,
      "keywordLocation": "/additionalProperties",
      "instanceLocation": "",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/additionalProperties",
          "instanceLocation": "/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}

¶



          
12.4.5. Output validation schemas
          

                        For convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        https://json-schema.org/draft/2020-12/output/schema.¶\n12. Output Formatting\nJSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.¶\nJSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.¶\nThis specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.¶\nFlag - A boolean which simply indicates the overall validation result
                            with no further details.¶\nBasic - Provides validation information in a flat list structure.¶\nDetailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.¶\nVerbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.¶\nAn implementation SHOULD provide at least one of the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    "detailed" or "verbose" formats, it MUST also provide the "flag" format.
                    Implementations SHOULD specify in their documentation which formats they support.¶\n12.3. Minimum Information\nBeyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.¶\nA single object that contains all of these components is considered an
                    output unit.¶\nImplementations MAY elect to provide additional information.¶\n12.3.1. Keyword Relative Location\nKeyword Relative Location\nThe relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$dynamicRef".¶\n/properties/width/$ref/minimum

¶\nNote that this pointer may not be resolvable by the normal JSON Pointer process
                    due to the inclusion of these by-reference applicator keywords.¶\nThe JSON key for this information is "keywordLocation".¶\n12.3.2. Keyword Absolute Location\nKeyword Absolute Location\nThe absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as a full URI using the canonical URI of the relevant schema resource
                        with a JSON Pointer fragment, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$dynamicRef" as non-terminal path components.
                        It MAY end in such keywords if the error or annotation is for that
                        keyword, such as an unresolvable reference.
                        
                            Note that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.
            ¶\nNote that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.\nhttps://example.com/schemas/common#/$defs/count/minimum

¶\nThis information MAY be omitted only if either the dynamic scope did not pass
                        over a reference or if the schema does not declare an absolute URI as its "$id".¶\nThe JSON key for this information is "absoluteKeywordLocation".¶\n12.3.3. Instance Location\nThe location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.¶\nThe JSON key for this information is "instanceLocation".¶\n12.3.4. Error or Annotation\nThe error or annotation that is produced by the validation.¶\nFor errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.¶\nFor annotations, each keyword that produces an annotation specifies its
                        format.  By default, it is the keyword's value.¶\nThe JSON key for failed validations is "error"; for successful validations
                        it is "annotation".¶\n12.3.5. Nested Results\nFor the two hierarchical structures, this property will hold nested errors
                        and annotations.¶\nThe JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".  Note the plural forms, as
                        a keyword with nested results can also have a local error or annotation.¶\n12.4. Output Structure\nThe output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.¶\n"valid" - a boolean value indicating the overall validation success or
                            failure¶\n"errors" - the collection of errors or annotations produced by a failed
                            validation¶\n"annotations" - the collection of errors or annotations produced by a
                            successful validation¶\nFor these examples, the following schema and instance will be used.¶\n{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3
  },
  {
    "x": 1,
    "z": 6.7
  }
]

¶\nThis instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.¶\nSpecifically, the errors it will produce are:¶\nThe second object is missing a "y" property.¶\nThe second object has a disallowed "z" property.¶\nThere are only two objects, but three are required.¶\nNote that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.¶\nIn the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.¶\n{
  "valid": false
}

¶\nBecause no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.¶\nThe "Basic" structure is a flat list of output units.¶\n{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "",
      "instanceLocation": "",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref/required",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/required",
      "instanceLocation": "/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/additionalProperties",
      "instanceLocation": "/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶\nThe "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correlation is more easily identified.¶\nThe following rules govern the construction of the results object:¶\nAll applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.¶\nNodes that have no children are removed.¶\nNodes that have a single child are replaced by the child.¶\nBranch nodes do not require an error message or an annotation.¶\n{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/items/$ref/required",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/required",
          "instanceLocation": "/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/additionalProperties",
          "instanceLocation": "/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶\nThe "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.¶\nThe primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.¶\nBecause this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        https://json-schema.org/draft/2020-12/output/verbose-example.¶\nhttps://json-schema.org/draft/2020-12/output/verbose-example\nhttps://json-schema.org/draft/2020-12/output/verbose-example\n// schema
{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "/type",
      "instanceLocation": ""
    },
    {
      "valid": true,
      "keywordLocation": "/properties",
      "instanceLocation": ""
    },
    {
      "valid": false,
      "keywordLocation": "/additionalProperties",
      "instanceLocation": "",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/additionalProperties",
          "instanceLocation": "/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}

¶\n12.4.5. Output validation schemas\nOutput validation schemas\nFor convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        https://json-schema.org/draft/2020-12/output/schema.¶\nhttps://json-schema.org/draft/2020-12/output/schema\nhttps://json-schema.org/draft/2020-12/output/schema\n13. Security Considerations
      

                Both schemas and instances are JSON values. As such, all security considerations
                defined in RFC 8259 [RFC8259] apply.¶

                Instances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas does not consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.¶

                A malicious party could cause an implementation to repeatedly collect a copy
                of a very large value as an annotation.  Implementations SHOULD guard against
                excessive consumption of system resources in such a scenario.¶

                Servers MUST ensure that malicious parties cannot change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".¶

                Individual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.¶

                Schema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.¶

                A malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.¶\n13. Security Considerations\nSecurity Considerations\nBoth schemas and instances are JSON values. As such, all security considerations
                defined in RFC 8259 [RFC8259] apply.¶\nInstances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas does not consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.¶\nA malicious party could cause an implementation to repeatedly collect a copy
                of a very large value as an annotation.  Implementations SHOULD guard against
                excessive consumption of system resources in such a scenario.¶\nServers MUST ensure that malicious parties cannot change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".¶\nIndividual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.¶\nSchema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.¶\nA malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.¶\n14. IANA Considerations\n14.1. application/schema+json\napplication/schema+json\nThe proposed MIME media type for JSON Schema is defined as follows:¶\nType name: application¶\nSubtype name: schema+json¶\nRequired parameters: N/A¶\nEncoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See JSON [RFC8259].¶\nSecurity considerations: See Section
                            13 above.¶\nInteroperability considerations: See Sections
                            6.2,
                            6.3, and
                            6.4 above.¶\nFragment identifier considerations: See Section
                            5¶\n14.2. application/schema-instance+json\napplication/schema-instance+json\nThe proposed MIME media type for JSON Schema Instances that require
                    a JSON Schema-specific media type is defined as follows:¶\nType name: application¶\nSubtype name: schema-instance+json¶\nRequired parameters: N/A¶\nEncoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See JSON [RFC8259].¶\nSecurity considerations: See Section
                            13 above.¶\nInteroperability considerations: See Sections
                            6.2,
                            6.3, and
                            6.4 above.¶\nFragment identifier considerations: See Section
                            5¶\n15.1. Normative References\n"Key words for use in RFCs to Indicate Requirement Levels"\n<https://www.rfc-editor.org/info/rfc2119>\nhttps://www.rfc-editor.org/info/rfc2119\n"Uniform Resource Identifier (URI): Generic Syntax"\n<https://www.rfc-editor.org/info/rfc3986>\nhttps://www.rfc-editor.org/info/rfc3986\n"Additional Media Type Structured Syntax Suffixes"\n<https://www.rfc-editor.org/info/rfc6839>\nhttps://www.rfc-editor.org/info/rfc6839\n"JavaScript Object Notation (JSON) Pointer"\n<https://www.rfc-editor.org/info/rfc6901>\nhttps://www.rfc-editor.org/info/rfc6901\n"The JavaScript Object Notation (JSON) Data Interchange Format"\n<https://www.rfc-editor.org/info/rfc8259>\nhttps://www.rfc-editor.org/info/rfc8259\n"Linked Data Platform 1.0"\nWorld Wide Web Consortium Recommendation REC-ldp-20150226\n<https://www.w3.org/TR/2015/REC-ldp-20150226>\nhttps://www.w3.org/TR/2015/REC-ldp-20150226\n"ECMA-262, 11th edition specification"\n<https://www.ecma-international.org/ecma-262/11.0/index.html>\nhttps://www.ecma-international.org/ecma-262/11.0/index.html\n15.2. Informative References\nInformative References\n"The Canonical Link Relation"\n<https://www.rfc-editor.org/info/rfc6596>\nhttps://www.rfc-editor.org/info/rfc6596\n"Concise Binary Object Representation (CBOR)"\n<https://www.rfc-editor.org/info/rfc7049>\nhttps://www.rfc-editor.org/info/rfc7049\n"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"\n<https://www.rfc-editor.org/info/rfc7231>\nhttps://www.rfc-editor.org/info/rfc7231\n<https://www.rfc-editor.org/info/rfc8288>\nhttps://www.rfc-editor.org/info/rfc8288\n"Best Practices for Fragment Identifiers and Media Type Definitions"\nWorld Wide Web Consortium WD WD-fragid-best-practices-20121025\n<https://www.w3.org/TR/2012/WD-fragid-best-practices-20121025>\nhttps://www.w3.org/TR/2012/WD-fragid-best-practices-20121025\n"JSON Schema Validation: A Vocabulary for Structural Validation of JSON"\nInternet-Draft, draft-bhutton-json-schema-validation-01\n<https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01>\nhttps://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01\n"JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON"\nInternet-Draft, draft-handrews-json-schema-hyperschema-02\n<https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-02>\nhttps://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-02\n"Namespaces in XML 1.1 (Second Edition)"\n<http://www.w3.org/TR/2006/REC-xml-names11-20060816>\nhttp://www.w3.org/TR/2006/REC-xml-names11-20060816\nAppendix A. Schema identification examples
      

                    Consider the following schema, which shows "$id" being used to identify
                    both the root schema and various subschemas, and "$anchor" being used
                    to define plain name fragment identifiers.¶


{
    "$id": "https://example.com/root.json",
    "$defs": {
        "A": { "$anchor": "foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$anchor": "bar" },
                "Y": {
                    "$id": "t/inner.json",
                    "$anchor": "bar"
                }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

¶


                The schemas at the following URI-encoded JSON
                Pointers [RFC6901] (relative to the root schema) have the following
                base URIs, and are identifiable by any listed URI in accordance with
                sections 5 and
                9.2.1 above.¶

        # (document root)
        
          
            canonical (and base) URI
            
                                https://example.com/root.json¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/root.json#¶

          


        
#/$defs/A
        
          
            base URI
            https://example.com/root.json¶

            
canonical resource URI plus plain fragment
            
                                https://example.com/root.json#foo¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/root.json#/$defs/A¶

          


        
#/$defs/B
        
          
            canonical (and base) URI
            https://example.com/other.json¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/other.json#¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B¶

          


        
#/$defs/B/$defs/X
        
          
            base URI
            https://example.com/other.json¶

            
canonical resource URI plus plain fragment
            
                                https://example.com/other.json#bar¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/other.json#/$defs/X¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B/$defs/X¶

          


        
#/$defs/B/$defs/Y
        
          
            canonical (and base) URI
            https://example.com/t/inner.json¶

            
canonical URI plus plain fragment
            
                                https://example.com/t/inner.json#bar¶

            
canonical URI plus pointer fragment
            
                                https://example.com/t/inner.json#¶

            
base URI of enclosing (other.json) resource plus fragment
            
                                https://example.com/other.json#/$defs/Y¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B/$defs/Y¶

          


        
#/$defs/C
        
          
            canonical (and base) URI
            
                                urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f¶

            
canonical URI plus pointer fragment
            
                                urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f#¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/C¶

          


      


                Note: The fragment part of the URI does not make it canonical or non-canonical,
                rather, the base URI used (as part of the full URI with any fragment) is what
                determines the canonical nature of the resulting full URI.
                
                    Multiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.
        ¶\nAppendix A. Schema identification examples\nSchema identification examples\nConsider the following schema, which shows "$id" being used to identify
                    both the root schema and various subschemas, and "$anchor" being used
                    to define plain name fragment identifiers.¶\n{
    "$id": "https://example.com/root.json",
    "$defs": {
        "A": { "$anchor": "foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$anchor": "bar" },
                "Y": {
                    "$id": "t/inner.json",
                    "$anchor": "bar"
                }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

¶\nThe schemas at the following URI-encoded JSON
                Pointers [RFC6901] (relative to the root schema) have the following
                base URIs, and are identifiable by any listed URI in accordance with
                sections 5 and
                9.2.1 above.¶\nJSON
                Pointers [RFC6901]\nJSON
                Pointers\nNote: The fragment part of the URI does not make it canonical or non-canonical,
                rather, the base URI used (as part of the full URI with any fragment) is what
                determines the canonical nature of the resulting full URI.
                
                    Multiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.
        ¶\nMultiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.\nJSON Pointer fragments and embedded schema resources (Section 9.2.1)\nJSON Pointer fragments and embedded schema resources\nAppendix B. Manipulating schema documents and references\nManipulating schema documents and references\nVarious tools have been created to rearrange schema documents
                based on how and where references ("$ref") appear.  This appendix discusses
                which use cases and actions are compliant with this specification.¶\nB.1. Bundling schema resources into a single document\nBundling schema resources into a single document\nA set of schema resources intended for use together can be organized
                    with each in its own schema document, all in the same schema document,
                    or any granularity of document grouping in between.¶\nNumerous tools exist to perform various sorts of reference removal.
                    A common case of this is producing a single file where all references
                    can be resolved within that file.  This is typically done to simplify
                    distribution, or to simplify coding so that various invocations
                    of JSON Schema libraries do not have to keep track of and load
                    a large number of resources.¶\nThis transformation can be safely and reversibly done as long as
                    all static references (e.g. "$ref") use URI-references that resolve
                    to URIs using the canonical resource URI as the base, and all schema
                    resources have an absolute-URI as the "$id" in their root schema.¶\nWith these conditions met, each external resource can be copied
                    under "$defs", without breaking any references among the resources'
                    schema objects, and without changing any aspect of validation or
                    annotation results.  The names of the schemas under "$defs" do
                    not affect behavior, assuming they are each unique, as they
                    do not appear in the canonical URIs for the embedded resources.¶\nB.2. Reference removal is not always safe\nReference removal is not always safe\nAttempting to remove all references and produce a single schema document does not,
                    in all cases, produce a schema with identical behavior to the original form.¶\nSince "$ref" is now treated like any other keyword, with other keywords allowed
                    in the same schema objects, fully supporting non-recursive "$ref" removal in
                    all cases can require relatively complex schema manipulations.  It is beyond
                    the scope of this specification to determine or provide a set of safe "$ref"
                    removal transformations, as they depend not only on the schema structure
                    but also on the intended usage.¶\nAppendix C. Example of recursive schema extension
      

                    Consider the following two schemas describing a simple
                    recursive tree structure, where each node in the tree
                    can have a "data" field of any type.  The first schema
                    allows and ignores other instance properties.  The second is
                    more strict and only allows the "data" and "children" properties.
                    An example instance with "data" misspelled as "daat" is also shown.¶


// tree schema, extensible
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/tree",
    "$dynamicAnchor": "node",

    "type": "object",
    "properties": {
        "data": true,
        "children": {
            "type": "array",
            "items": {
                "$dynamicRef": "#node"
            }
        }
    }
}

// strict-tree schema, guards against misspelled properties
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/strict-tree",
    "$dynamicAnchor": "node",

    "$ref": "tree",
    "unevaluatedProperties": false
}

// instance with misspelled field
{
    "children": [ { "daat": 1 } ]
}

¶


                When we load these two schemas, we will notice the "$dynamicAnchor"
                named "node" (note the lack of "#" as this is just the name)
                present in each, resulting in the following full schema URIs:¶

"https://example.com/tree#node"¶

        "https://example.com/strict-tree#node"¶

      

                In addition, JSON Schema implementations keep track of the fact
                that these fragments were created with "$dynamicAnchor".¶

                If we apply the "strict-tree" schema to the instance, we will follow
                the "$ref" to the "tree" schema, examine its "children" subschema,
                and find the "$dynamicRef": to "#node" (note the "#" for URI fragment syntax)
                in its "items" subschema.  That reference resolves to
                "https://example.com/tree#node", which is a URI with a fragment
                created by "$dynamicAnchor".  Therefore we must examine the dynamic
                scope before following the reference.¶

                At this point, the dynamic path is
                "#/$ref/properties/children/items/$dynamicRef", with a dynamic scope
                containing (from the outermost scope to the innermost):¶

"https://example.com/strict-tree#"¶

        "https://example.com/tree#"¶

        "https://example.com/tree#/properties/children"¶

        "https://example.com/tree#/properties/children/items"¶

      

                Since we are looking for a plain name fragment, which can be
                defined anywhere within a schema resource, the JSON Pointer fragments
                are irrelevant to this check.  That means that we can remove those
                fragments and eliminate consecutive duplicates, producing:¶

"https://example.com/strict-tree"¶

        "https://example.com/tree"¶

      

                In this case, the outermost resource also has a "node" fragment
                defined by "$dynamicAnchor".  Therefore instead of resolving the
                "$dynamicRef" to "https://example.com/tree#node", we resolve it to
                "https://example.com/strict-tree#node".¶

                This way, the recursion in the "tree" schema recurses to the root
                of "strict-tree", instead of only applying "strict-tree" to the
                instance root, but applying "tree" to instance children.¶

                This example shows both "$dynamicAnchor"s in the same place
                in each schema, specifically the resource root schema.
                Since plain-name fragments are independent of the JSON structure,
                this would work just as well if one or both of the node schema objects
                were moved under "$defs".  It is the matching "$dynamicAnchor" values
                which tell us how to resolve the dynamic reference, not any sort of
                correlation in JSON structure.¶\nAppendix C. Example of recursive schema extension\nExample of recursive schema extension\nConsider the following two schemas describing a simple
                    recursive tree structure, where each node in the tree
                    can have a "data" field of any type.  The first schema
                    allows and ignores other instance properties.  The second is
                    more strict and only allows the "data" and "children" properties.
                    An example instance with "data" misspelled as "daat" is also shown.¶\n// tree schema, extensible
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/tree",
    "$dynamicAnchor": "node",

    "type": "object",
    "properties": {
        "data": true,
        "children": {
            "type": "array",
            "items": {
                "$dynamicRef": "#node"
            }
        }
    }
}

// strict-tree schema, guards against misspelled properties
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/strict-tree",
    "$dynamicAnchor": "node",

    "$ref": "tree",
    "unevaluatedProperties": false
}

// instance with misspelled field
{
    "children": [ { "daat": 1 } ]
}

¶\nWhen we load these two schemas, we will notice the "$dynamicAnchor"
                named "node" (note the lack of "#" as this is just the name)
                present in each, resulting in the following full schema URIs:¶\n"https://example.com/tree#node"¶\n"https://example.com/strict-tree#node"¶\nIn addition, JSON Schema implementations keep track of the fact
                that these fragments were created with "$dynamicAnchor".¶\nIf we apply the "strict-tree" schema to the instance, we will follow
                the "$ref" to the "tree" schema, examine its "children" subschema,
                and find the "$dynamicRef": to "#node" (note the "#" for URI fragment syntax)
                in its "items" subschema.  That reference resolves to
                "https://example.com/tree#node", which is a URI with a fragment
                created by "$dynamicAnchor".  Therefore we must examine the dynamic
                scope before following the reference.¶\nAt this point, the dynamic path is
                "#/$ref/properties/children/items/$dynamicRef", with a dynamic scope
                containing (from the outermost scope to the innermost):¶\n"https://example.com/strict-tree#"¶\n"https://example.com/tree#"¶\n"https://example.com/tree#/properties/children"¶\n"https://example.com/tree#/properties/children/items"¶\nSince we are looking for a plain name fragment, which can be
                defined anywhere within a schema resource, the JSON Pointer fragments
                are irrelevant to this check.  That means that we can remove those
                fragments and eliminate consecutive duplicates, producing:¶\n"https://example.com/strict-tree"¶\n"https://example.com/tree"¶\nIn this case, the outermost resource also has a "node" fragment
                defined by "$dynamicAnchor".  Therefore instead of resolving the
                "$dynamicRef" to "https://example.com/tree#node", we resolve it to
                "https://example.com/strict-tree#node".¶\nThis way, the recursion in the "tree" schema recurses to the root
                of "strict-tree", instead of only applying "strict-tree" to the
                instance root, but applying "tree" to instance children.¶\nThis example shows both "$dynamicAnchor"s in the same place
                in each schema, specifically the resource root schema.
                Since plain-name fragments are independent of the JSON structure,
                this would work just as well if one or both of the node schema objects
                were moved under "$defs".  It is the matching "$dynamicAnchor" values
                which tell us how to resolve the dynamic reference, not any sort of
                correlation in JSON structure.¶\nAppendix D. Working with vocabularies\nWorking with vocabularies\nD.1. Best practices for vocabulary and meta-schema authors\nBest practices for vocabulary and meta-schema authors\nVocabulary authors should
                    take care to avoid keyword name collisions if the vocabulary is intended
                    for broad use, and potentially combined with other vocabularies.  JSON
                    Schema does not provide any formal namespacing system, but also does
                    not constrain keyword names, allowing for any number of namespacing
                    approaches.¶\nVocabularies may build on each other, such as by defining the behavior
                    of their keywords with respect to the behavior of keywords from another
                    vocabulary, or by using a keyword from another vocabulary with
                    a restricted or expanded set of acceptable values.  Not all such
                    vocabulary re-use will result in a new vocabulary that is compatible
                    with the vocabulary on which it is built.  Vocabulary authors should
                    clearly document what level of compatibility, if any, is expected.¶\nMeta-schema authors should not use "$vocabulary" to combine multiple
                    vocabularies that define conflicting syntax or semantics for the same
                    keyword.  As semantic conflicts are not generally detectable through
                    schema validation, implementations are not expected to detect such
                    conflicts.  If conflicting vocabularies are declared, the resulting
                    behavior is undefined.¶\nVocabulary authors SHOULD provide a meta-schema that validates the
                    expected usage of the vocabulary's keywords on their own.  Such meta-schemas
                    SHOULD not forbid additional keywords, and MUST not forbid any
                    keywords from the Core vocabulary.¶\nIt is recommended that meta-schema authors reference each vocabulary's
                    meta-schema using the "allOf" (Section 10.2.1.1) keyword,
                    although other mechanisms for constructing the meta-schema may be
                    appropriate for certain use cases.¶\n"allOf" (Section 10.2.1.1)\nThe recursive nature of meta-schemas makes the "$dynamicAnchor"
                    and "$dynamicRef" keywords particularly useful for extending
                    existing meta-schemas, as can be seen in the JSON Hyper-Schema meta-schema
                    which extends the Validation meta-schema.¶\nMeta-schemas may impose additional constraints, including describing
                    keywords not present in any vocabulary, beyond what the meta-schemas
                    associated with the declared vocabularies describe.  This allows for
                    restricting usage to a subset of a vocabulary, and for validating
                    locally defined keywords not intended for re-use.¶\nHowever, meta-schemas should not contradict any vocabularies that
                    they declare, such as by requiring a different JSON type than
                    the vocabulary expects.  The resulting behavior is undefined.¶\nMeta-schemas intended for local use, with no need to test for
                    vocabulary support in arbitrary implementations, can safely omit
                    "$vocabulary" entirely.¶\nD.2. Example meta-schema with vocabulary declarations
        

                    This meta-schema explicitly declares both the Core and Applicator vocabularies,
                    together with an extension vocabulary, and combines their meta-schemas with
                    an "allOf".  The extension vocabulary's meta-schema, which describes only the
                    keywords in that vocabulary, is shown after the main example meta-schema.¶

                    The main example meta-schema also restricts the usage of the Unevaluated
                    vocabulary by forbidding the keywords prefixed with "unevaluated", which
                    are particularly complex to implement.  This does not change the semantics
                    or set of keywords defined by the other vocabularies. It just ensures
                    that schemas using this meta-schema that attempt to use the keywords
                    prefixed with "unevaluated" will fail validation against this meta-schema.¶

                    Finally, this meta-schema describes the syntax of a keyword, "localKeyword",
                    that is not part of any vocabulary.  Presumably, the implementors and users
                    of this meta-schema will understand the semantics of "localKeyword".
                    JSON Schema does not define any mechanism for expressing keyword semantics
                    outside of vocabularies, making them unsuitable for use except in a
                    specific environment in which they are understood.¶

                        This meta-schema combines several vocabularies for general use.¶


{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/general-use-example",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://example.com/vocab/example-vocab": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2020-12/meta/core"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/applicator"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/validation"},
    {"$ref": "https://example.com/meta/example-vocab"}
  ],
  "patternProperties": {
    "^unevaluated": false
  },
  "properties": {
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}

¶


                        This meta-schema describes only a single extension vocabulary.¶


{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/example-vocab",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://example.com/vocab/example-vocab": true,
  },
  "type": ["object", "boolean"],
  "properties": {
    "minDate": {
      "type": "string",
      "pattern": "\d\d\d\d-\d\d-\d\d",
      "format": "date",
    }
  }
}

¶


                    As shown above, even though each of the single-vocabulary meta-schemas
                    referenced in the general-use meta-schema's "allOf" declares its
                    corresponding vocabulary, this new meta-schema must re-declare them.¶

                    The standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.¶

                    While the general-use meta-schema can validate the syntax of "minDate",
                    it is the vocabulary that defines the logic behind the semantic meaning
                    of "minDate".  Without an understanding of the semantics (in this example,
                    that the instance value must be a date equal to or after the date
                    provided as the keyword's value in the schema), an implementation can
                    only validate the syntactic usage.  In this case, that means validating
                    that it is a date-formatted string (using "pattern" to ensure that it is
                    validated even when "format" functions purely as an annotation, as explained
                    in the Validation specification [json-schema-validation].¶\nD.2. Example meta-schema with vocabulary declarations\nExample meta-schema with vocabulary declarations\nThis meta-schema explicitly declares both the Core and Applicator vocabularies,
                    together with an extension vocabulary, and combines their meta-schemas with
                    an "allOf".  The extension vocabulary's meta-schema, which describes only the
                    keywords in that vocabulary, is shown after the main example meta-schema.¶\nThe main example meta-schema also restricts the usage of the Unevaluated
                    vocabulary by forbidding the keywords prefixed with "unevaluated", which
                    are particularly complex to implement.  This does not change the semantics
                    or set of keywords defined by the other vocabularies. It just ensures
                    that schemas using this meta-schema that attempt to use the keywords
                    prefixed with "unevaluated" will fail validation against this meta-schema.¶\nFinally, this meta-schema describes the syntax of a keyword, "localKeyword",
                    that is not part of any vocabulary.  Presumably, the implementors and users
                    of this meta-schema will understand the semantics of "localKeyword".
                    JSON Schema does not define any mechanism for expressing keyword semantics
                    outside of vocabularies, making them unsuitable for use except in a
                    specific environment in which they are understood.¶\nThis meta-schema combines several vocabularies for general use.¶\n{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/general-use-example",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://example.com/vocab/example-vocab": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2020-12/meta/core"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/applicator"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/validation"},
    {"$ref": "https://example.com/meta/example-vocab"}
  ],
  "patternProperties": {
    "^unevaluated": false
  },
  "properties": {
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}

¶\nThis meta-schema describes only a single extension vocabulary.¶\n{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/example-vocab",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://example.com/vocab/example-vocab": true,
  },
  "type": ["object", "boolean"],
  "properties": {
    "minDate": {
      "type": "string",
      "pattern": "\d\d\d\d-\d\d-\d\d",
      "format": "date",
    }
  }
}

¶\nAs shown above, even though each of the single-vocabulary meta-schemas
                    referenced in the general-use meta-schema's "allOf" declares its
                    corresponding vocabulary, this new meta-schema must re-declare them.¶\nThe standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.¶\nWhile the general-use meta-schema can validate the syntax of "minDate",
                    it is the vocabulary that defines the logic behind the semantic meaning
                    of "minDate".  Without an understanding of the semantics (in this example,
                    that the instance value must be a date equal to or after the date
                    provided as the keyword's value in the schema), an implementation can
                    only validate the syntactic usage.  In this case, that means validating
                    that it is a date-formatted string (using "pattern" to ensure that it is
                    validated even when "format" functions purely as an annotation, as explained
                    in the Validation specification [json-schema-validation].¶\nValidation specification [json-schema-validation]\nValidation specification\njson-schema-validation\nAppendix E. References and generative use cases\nReferences and generative use cases\nWhile the presence of references is expected to be transparent
                to validation results, generative use cases such as code generators
                and UI renderers often consider references to be semantically significant.¶\nTo make such use case-specific semantics explicit, the best practice
                is to create an annotation keyword for use in the same
                schema object alongside of a reference keyword such as "$ref".¶\nFor example, here is a hypothetical keyword for determining
                    whether a code generator should consider the reference
                    target to be a distinct class, and how those classes are related.
                    Note that this example is solely for illustrative purposes, and is
                    not intended to propose a functional code generation keyword.¶\n{
    "allOf": [
        {
            "classRelation": "is-a",
            "$ref": "classes/base.json"
        },
        {
            "$ref": "fields/common.json"
        }
    ],
    "properties": {
        "foo": {
            "classRelation": "has-a",
            "$ref": "classes/foo.json"
        },
        "date": {
            "$ref": "types/dateStruct.json",
        }
    }
}

¶\nHere, this schema represents some sort of object-oriented class.
                The first reference in the "allOf" is noted as the base class.
                The second is not assigned a class relationship, meaning that the
                code generator should combine the target's definition with this
                one as if no reference were involved.¶\nLooking at the properties, "foo" is flagged as object composition,
                while the "date" property is not.  It is simply a field with
                sub-fields, rather than an instance of a distinct class.¶\nThis style of usage requires the annotation to be in the same object
                as the reference, which must be recognizable as a reference.¶\nAppendix F. Acknowledgments\nThanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.¶\nThanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Evgeny Poberezkin,
                Brad Bowman,
                Gowry Sankar,
                Donald Pipowitch,
                Dave Finlay,
                Denis Laxalde,
                Phil Sturgeon,
                Shawn Silverman,
                and Karen Etheridge
                for their submissions and patches to the document.¶\nAppendix G. ChangeLog\nThis section to be removed before leaving Internet-Draft status.¶\nThis section to be removed before leaving Internet-Draft status.\nImprove and clarify the "type", "contains", "unevaluatedProperties", and "unevaluatedItems" keyword explanations¶\nClarify various aspects of "canonical URIs"¶\nComment on ambiguity around annotations and "additionalProperties"¶\nClarify Vocabularies need not be formally defined¶\nRemove references to remaining media-type parameters¶\nFix multiple examples¶\n"$schema" MAY change for embedded resources¶\nArray-value "items" functionality is now "prefixItems"¶\n"items" subsumes the old function of "additionalItems"¶\n"contains" annotation behavior, and "contains" and "unevaluatedItems" interactions now specified¶\nRename $recursive* to $dynamic*, with behavior modification¶\n$dynamicAnchor defines a fragment like $anchor¶\n$dynamic* (previously $recursive) no longer use runtime base URI determination¶\nDefine Compound Schema Documents (bundle) and processing¶\nReference ECMA-262, 11th edition for regular expression support¶\nRegular expression should support unicode¶\nRemove media type parameters¶\nSpecify Unknown keywords are collected as annotations¶\nMoved "unevaluatedItems" and "unevaluatedProperties" from core into their own vocabulary¶\nUpdate to RFC 8259 for JSON specification¶\nMoved "definitions" from the Validation specification here as "$defs"¶\nMoved applicator keywords from the Validation specification as their own vocabulary¶\nMoved the schema form of "dependencies" from the Validation specification as "dependentSchemas"¶\nFormalized annotation collection¶\nSpecified recommended output formats¶\nDefined keyword interactions in terms of annotation and assertion results¶\nAdded "unevaluatedProperties" and "unevaluatedItems"¶\nDefine "$ref" behavior in terms of the assertion, applicator, and annotation model¶\nAllow keywords adjacent to "$ref"¶\nNote undefined behavior for "$ref" targets involving unknown keywords¶\nAdd recursive referencing, primarily for meta-schema extension¶\nAdd the concept of formal vocabularies, and how they can be recognized through meta-schemas¶\nAdditional guidance on initial base URIs beyond network retrieval¶\nAllow "schema" media type parameter for "application/schema+json"¶\nBetter explanation of media type parameters and the HTTP Accept header¶\nUse "$id" to establish canonical and base absolute-URIs only, no fragments¶\nReplace plain-name-fragment-only form of "$id" with "$anchor"¶\nClarified that the behavior of JSON Pointers across "$id" boundary is unreliable¶\nThis draft is purely a clarification with no functional changes¶\nEmphasized annotations as a primary usage of JSON Schema¶\nClarified $id by use cases¶\nExhaustive schema identification examples¶\nReplaced "external referencing" with how and when an implementation might know of a schema from another document¶\nReplaced "internal referencing" with how an implementation should recognized schema identifiers during parsing¶\nDereferencing the former "internal" or "external" references is always the same process¶\nMinor formatting improvements¶\nMake the concept of a schema keyword vocabulary more clear¶\nNote that the concept of "integer" is from a vocabulary, not the data model¶\nClassify keywords as assertions or annotations and describe their general behavior¶\nExplain the boolean schemas in terms of generalized assertions¶\nReserve "$comment" for non-user-visible notes about the schema¶\nWording improvements around "$id" and fragments¶\nNote the challenges of extending meta-schemas with recursive references¶\nAdd "application/schema-instance+json" media type¶\nRecommend a "schema" link relation / parameter instead of "profile"¶\nAllowed for any schema to be a boolean¶\n"$schema" SHOULD NOT appear in subschemas, although that may change¶\nChanged "id" to "$id"; all core keywords prefixed with "$"¶\nClarify and formalize fragments for application/schema+json¶\nNote applicability to formats such as CBOR that can be represented in the JSON data model¶\nUpdated references to JSON¶\nUpdated references to HTTP¶\nUpdated references to JSON Pointer¶\nBehavior for "id" is now specified in terms of RFC3986¶\nAligned vocabulary usage for URIs with RFC3986¶\nRemoved reference to draft-pbryan-zyp-json-ref-03¶\nLimited use of "$ref" to wherever a schema is expected¶\nAdded definition of the "JSON Schema data model"¶\nAdded additional security considerations¶\nDefined use of subschema identifiers for "id"¶\nRewrote section on usage with HTTP¶\nRewrote section on usage with rel="describedBy" and rel="profile"¶\nFixed numerous invalid examples¶\nSalvaged from draft v3.¶\nSplit validation keywords into separate document.¶\nSplit hypermedia keywords into separate document.¶\nInitial post-split draft.¶\nMandate the use of JSON Reference, JSON Pointer.¶\nDefine the role of "id". Define URI resolution scope.¶\nAdd interoperability considerations.¶\nAuthors' Addresses
      

        Austin Wright (editor)

Email:
[email protected]



        Henry Andrews (editor)

Email:
[email protected]



        Ben Hutton (editor)
Postman

Email:
[email protected]


URI:
https://jsonschema.dev



        Greg Dennis

Email:
[email protected]


URI:
https://github.com/gregsdennis\nAustin Wright (editor)\nAustin Wright (editor)\nEmail:
[email protected]\nHenry Andrews (editor)\nHenry Andrews (editor)\nEmail:
[email protected]\nEmail:
[email protected]\nURI:
https://jsonschema.dev\nhttps://jsonschema.dev\nEmail:
[email protected]\nURI:
https://github.com/gregsdennis\nhttps://github.com/gregsdennis\n\n\n8. A Vocabulary for the Contents of String-Encoded Data
      

        
8.1. Foreword
        

                    Annotations defined in this section indicate that an instance contains
                    non-JSON data encoded in a JSON string.¶

                    These properties provide additional information required to interpret JSON data
                    as rich multimedia documents.  They describe the type of content, how it is encoded,
                    and/or how it may be validated.  They do not function as validation assertions;
                    a malformed string-encoded document MUST NOT cause the containing instance
                    to be considered invalid.¶

                    Meta-schemas that do not use "$vocabulary" SHOULD be considered to
                    require this vocabulary as if its URI were present with a value of true.¶

                    The current URI for this vocabulary, known as the Content vocabulary, is:
                    <https://json-schema.org/draft/2020-12/vocab/content>.¶

                    The current URI for the corresponding meta-schema is:
                    https://json-schema.org/draft/2020-12/meta/content.¶


        
8.2. Implementation Requirements
        

                    Due to security and performance concerns, as well as the open-ended nature of
                    possible content types, implementations MUST NOT automatically decode, parse,
                    and/or validate the string contents by default.  This additionally supports
                    the use case of embedded documents intended for processing by a different
                    consumer than that which processed the containing document.¶

                    All keywords in this section apply only to strings, and have no
                    effect on other data types.¶

                    Implementations MAY offer the ability to decode, parse, and/or validate
                    the string contents automatically.  However, it MUST NOT perform these
                    operations by default, and MUST provide the validation result of each
                    string-encoded document separately from the enclosing document.  This
                    process SHOULD be equivalent to fully evaluating the instance against
                    the original schema, followed by using the annotations to decode, parse,
                    and/or validate each string-encoded document.
                    
                        For now, the exact mechanism of performing and returning parsed
                        data and/or validation results from such an automatic decoding, parsing,
                        and validating feature is left unspecified.  Should such a feature
                        prove popular, it may be specified more thoroughly in a future draft.
          ¶

                    See also the Security Considerations (Section 10)
                    sections for possible vulnerabilities introduced by automatically
                    processing the instance string according to these keywords.¶


        
8.3. contentEncoding
        

                    If the instance value is a string, this property defines that the string
                    SHOULD be interpreted as encoded binary data and decoded using the encoding
                    named by this property.¶

                    Possible values indicating base 16, 32, and 64 encodings with several
                    variations are listed in RFC 4648 [RFC4648].  Additionally,
                    sections 6.7 and 6.8 of RFC 2045 [RFC2045] provide
                    encodings used in MIME. This keyword is derived from MIME's
                    Content-Transfer-Encoding header, which was designed to map binary data
                    into ASCII characters.  It is not related to HTTP's Content-Encoding header,
                    which is used to encode (e.g. compress or encrypt)
                    the content of HTTP request and responses.¶

                    As "base64" is defined in both RFCs, the definition
                    from RFC 4648 SHOULD be assumed unless the string is specifically intended
                    for use in a MIME context.  Note that all of these encodings result in
                    strings consisting only of 7-bit ASCII characters.  Therefore, this keyword
                    has no meaning for strings containing characters outside of that range.¶

                    If this keyword is absent, but "contentMediaType" is present, this
                    indicates that the encoding is the identity encoding, meaning that
                    no transformation was needed in order to represent the content in
                    a UTF-8 string.¶

                    The value of this property MUST be a string.¶


        
8.4. contentMediaType
        

                    If the instance is a string, this property indicates the media type
                    of the contents of the string.  If "contentEncoding" is present,
                    this property describes the decoded string.¶

                    The value of this property MUST be a string, which MUST be a media type,
                    as defined by RFC 2046 [RFC2046].¶


        
8.5. contentSchema
        

                    If the instance is a string, and if "contentMediaType" is present, this
                    property contains a schema which describes the structure of the string.¶

                    This keyword MAY be used with any media type that can be mapped into
                    JSON Schema's data model.¶

                    The value of this property MUST be a valid JSON schema. It SHOULD be ignored if
                    "contentMediaType" is not present.¶


        
8.6. Example
        

                        Here is an example schema, illustrating the use of "contentEncoding" and
                        "contentMediaType":¶


{
    "type": "string",
    "contentEncoding": "base64",
    "contentMediaType": "image/png"
}

¶


                        Instances described by this schema are expected to be strings,
                        and their values should be interpretable as base64-encoded PNG images.¶

                        Another example:¶


{
    "type": "string",
    "contentMediaType": "text/html"
}

¶


                        Instances described by this schema are expected to be strings containing HTML,
                        using whatever character set the JSON string was decoded into.
                        Per section 8.1 of
                        RFC 8259 [RFC8259], outside of an entirely closed
                        system, this MUST be UTF-8.¶

                        This example describes a JWT that is MACed using the HMAC SHA-256
                        algorithm, and requires the "iss" and "exp" fields in its claim set.¶


{
    "type": "string",
    "contentMediaType": "application/jwt",
    "contentSchema": {
        "type": "array",
        "minItems": 2,
        "prefixItems": [
            {
                "const": {
                    "typ": "JWT",
                    "alg": "HS256"
                }
            },
            {
                "type": "object",
                "required": ["iss", "exp"],
                "properties": {
                    "iss": {"type": "string"},
                    "exp": {"type": "integer"}
                }
            }
        ]
    }
}
¶


                        Note that "contentEncoding" does not appear.  While the "application/jwt"
                        media type makes use of base64url encoding, that is defined by the media
                        type, which determines how the JWT string is decoded into a list of two
                        JSON data structures: first the header, and then the payload.  Since the
                        JWT media type ensures that the JWT can be represented in a JSON string,
                        there is no need for further encoding or decoding.¶\n\n\n\n8. A Vocabulary for the Contents of String-Encoded Data
      

        
8.1. Foreword
        

                    Annotations defined in this section indicate that an instance contains
                    non-JSON data encoded in a JSON string.¶

                    These properties provide additional information required to interpret JSON data
                    as rich multimedia documents.  They describe the type of content, how it is encoded,
                    and/or how it may be validated.  They do not function as validation assertions;
                    a malformed string-encoded document MUST NOT cause the containing instance
                    to be considered invalid.¶

                    Meta-schemas that do not use "$vocabulary" SHOULD be considered to
                    require this vocabulary as if its URI were present with a value of true.¶

                    The current URI for this vocabulary, known as the Content vocabulary, is:
                    <https://json-schema.org/draft/2020-12/vocab/content>.¶

                    The current URI for the corresponding meta-schema is:
                    https://json-schema.org/draft/2020-12/meta/content.¶


        
8.2. Implementation Requirements
        

                    Due to security and performance concerns, as well as the open-ended nature of
                    possible content types, implementations MUST NOT automatically decode, parse,
                    and/or validate the string contents by default.  This additionally supports
                    the use case of embedded documents intended for processing by a different
                    consumer than that which processed the containing document.¶

                    All keywords in this section apply only to strings, and have no
                    effect on other data types.¶

                    Implementations MAY offer the ability to decode, parse, and/or validate
                    the string contents automatically.  However, it MUST NOT perform these
                    operations by default, and MUST provide the validation result of each
                    string-encoded document separately from the enclosing document.  This
                    process SHOULD be equivalent to fully evaluating the instance against
                    the original schema, followed by using the annotations to decode, parse,
                    and/or validate each string-encoded document.
                    
                        For now, the exact mechanism of performing and returning parsed
                        data and/or validation results from such an automatic decoding, parsing,
                        and validating feature is left unspecified.  Should such a feature
                        prove popular, it may be specified more thoroughly in a future draft.
          ¶

                    See also the Security Considerations (Section 10)
                    sections for possible vulnerabilities introduced by automatically
                    processing the instance string according to these keywords.¶


        
8.3. contentEncoding
        

                    If the instance value is a string, this property defines that the string
                    SHOULD be interpreted as encoded binary data and decoded using the encoding
                    named by this property.¶

                    Possible values indicating base 16, 32, and 64 encodings with several
                    variations are listed in RFC 4648 [RFC4648].  Additionally,
                    sections 6.7 and 6.8 of RFC 2045 [RFC2045] provide
                    encodings used in MIME. This keyword is derived from MIME's
                    Content-Transfer-Encoding header, which was designed to map binary data
                    into ASCII characters.  It is not related to HTTP's Content-Encoding header,
                    which is used to encode (e.g. compress or encrypt)
                    the content of HTTP request and responses.¶

                    As "base64" is defined in both RFCs, the definition
                    from RFC 4648 SHOULD be assumed unless the string is specifically intended
                    for use in a MIME context.  Note that all of these encodings result in
                    strings consisting only of 7-bit ASCII characters.  Therefore, this keyword
                    has no meaning for strings containing characters outside of that range.¶

                    If this keyword is absent, but "contentMediaType" is present, this
                    indicates that the encoding is the identity encoding, meaning that
                    no transformation was needed in order to represent the content in
                    a UTF-8 string.¶

                    The value of this property MUST be a string.¶


        
8.4. contentMediaType
        

                    If the instance is a string, this property indicates the media type
                    of the contents of the string.  If "contentEncoding" is present,
                    this property describes the decoded string.¶

                    The value of this property MUST be a string, which MUST be a media type,
                    as defined by RFC 2046 [RFC2046].¶


        
8.5. contentSchema
        

                    If the instance is a string, and if "contentMediaType" is present, this
                    property contains a schema which describes the structure of the string.¶

                    This keyword MAY be used with any media type that can be mapped into
                    JSON Schema's data model.¶

                    The value of this property MUST be a valid JSON schema. It SHOULD be ignored if
                    "contentMediaType" is not present.¶


        
8.6. Example
        

                        Here is an example schema, illustrating the use of "contentEncoding" and
                        "contentMediaType":¶


{
    "type": "string",
    "contentEncoding": "base64",
    "contentMediaType": "image/png"
}

¶


                        Instances described by this schema are expected to be strings,
                        and their values should be interpretable as base64-encoded PNG images.¶

                        Another example:¶


{
    "type": "string",
    "contentMediaType": "text/html"
}

¶


                        Instances described by this schema are expected to be strings containing HTML,
                        using whatever character set the JSON string was decoded into.
                        Per section 8.1 of
                        RFC 8259 [RFC8259], outside of an entirely closed
                        system, this MUST be UTF-8.¶

                        This example describes a JWT that is MACed using the HMAC SHA-256
                        algorithm, and requires the "iss" and "exp" fields in its claim set.¶


{
    "type": "string",
    "contentMediaType": "application/jwt",
    "contentSchema": {
        "type": "array",
        "minItems": 2,
        "prefixItems": [
            {
                "const": {
                    "typ": "JWT",
                    "alg": "HS256"
                }
            },
            {
                "type": "object",
                "required": ["iss", "exp"],
                "properties": {
                    "iss": {"type": "string"},
                    "exp": {"type": "integer"}
                }
            }
        ]
    }
}
¶


                        Note that "contentEncoding" does not appear.  While the "application/jwt"
                        media type makes use of base64url encoding, that is defined by the media
                        type, which determines how the JWT string is decoded into a list of two
                        JSON data structures: first the header, and then the payload.  Since the
                        JWT media type ensures that the JWT can be represented in a JSON string,
                        there is no need for further encoding or decoding.¶\n\n\n\nExpires 18 December 2022\nWorkgroup:
Internet Engineering Task Force
Internet-Draft:
draft-bhutton-json-schema-01
Published:

16 June 2022
    
Intended Status:
Informational
Expires:
18 December 2022
Authors:


      A. Wright, Ed.



      H. Andrews, Ed.



      B. Hutton, Ed.

Postman


      G. Dennis\nB. Hutton, Ed.

Postman\nJSON Schema: A Media Type for Describing JSON Documents\nJSON Schema defines the media type "application/schema+json", a JSON-based format
                for describing the structure of JSON data.
                JSON Schema asserts what a JSON document must look like,
                ways to extract information from it,
                and how to interact with it.
                The "application/schema-instance+json" media type provides additional
                feature-rich integration with "application/schema+json" beyond what can be offered
                for "application/json" documents.¶\nThe issues list for this draft can be found at
                https://github.com/json-schema-org/json-schema-spec/issues.¶\nhttps://github.com/json-schema-org/json-schema-spec/issues\nhttps://github.com/json-schema-org/json-schema-spec/issues\nFor additional information, see https://json-schema.org/.¶\nhttps://json-schema.org/\nhttps://json-schema.org/\nTo provide feedback, use this issue tracker, the communication methods listed on the
                homepage, or email the document editors.¶\nStatus of This Memo
        

        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.¶

        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at https://datatracker.ietf.org/drafts/current/.¶

        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."¶

        This Internet-Draft will expire on 18 December 2022.¶\nThis Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.¶\nInternet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at https://datatracker.ietf.org/drafts/current/.¶\nhttps://datatracker.ietf.org/drafts/current/\nhttps://datatracker.ietf.org/drafts/current/\nInternet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."¶\nThis Internet-Draft will expire on 18 December 2022.¶\nCopyright Notice
        

            Copyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶

            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶\nCopyright (c) 2022 IETF Trust and the persons identified as the
            document authors. All rights reserved.¶\nThis document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (https://trustee.ietf.org/license-info) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.¶\nhttps://trustee.ietf.org/license-info\nhttps://trustee.ietf.org/license-info\n▲
Table of Contents
        


            1.  Introduction

          
            2.  Conventions and Terminology

          
            3.  Overview

          
            4.  Definitions


                4.1.  JSON Document

              
                4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances

                

              
                4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources

                

            

          
            5.  Fragment Identifiers

          
            6.  General Considerations


                6.1.  Range of JSON Values

              
                6.2.  Programming Language Independence

              
                6.3.  Mathematical Integers

              
                6.4.  Regular Expressions

              
                6.5.  Extending JSON Schema

            

          
            7.  Keyword Behaviors


                7.1.  Lexical Scope and Dynamic Scope

              
                7.2.  Keyword Interactions

              
                7.3.  Default Behaviors

              
                7.4.  Identifiers

              
                7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas

                

              
                7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types

                

              
                7.7.  Annotations


                    7.7.1.  Collecting Annotations

                

              
                7.8.  Reserved Locations

              
                7.9.  Loading Instance Data

            

          
            8.  The JSON Schema Core Vocabulary


                8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs

                

              
                8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"

                

              
                8.3.  Comments With "$comment"

            

          
            9.  Loading and Processing Schemas


                9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema

                

              
                9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources

                

              
                9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating

                

              
                9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas

                

              
                9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia

                

            

          
            10. A Vocabulary for Applying Subschemas


                10.1.  Keyword Independence

              
                10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally

                

              
                10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects

                

            

          
            11. A Vocabulary for Unevaluated Locations


                11.1.  Keyword Independence

              
                11.2.  unevaluatedItems

              
                11.3.  unevaluatedProperties

            

          
            12. Output Formatting


                12.1.  Format

              
                12.2.  Output Formats

              
                12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results

                

              
                12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas

                

            

          
            13. Security Considerations

          
            14. IANA Considerations


                14.1.  application/schema+json

              
                14.2.  application/schema-instance+json

            

          
            15. References


                15.1.  Normative References

              
                15.2.  Informative References

            

          
            Appendix A.  Schema identification examples

          
            Appendix B.  Manipulating schema documents and references


                B.1.  Bundling schema resources into a single document

              
                B.2.  Reference removal is not always safe

            

          
            Appendix C.  Example of recursive schema extension

          
            Appendix D.  Working with vocabularies


                D.1.  Best practices for vocabulary and meta-schema authors

              
                D.2.  Example meta-schema with vocabulary declarations

            

          
            Appendix E.  References and generative use cases

          
            Appendix F.  Acknowledgments

          
            Appendix G.  ChangeLog

          
            Authors' Addresses\n2.  Conventions and Terminology\n2.  Conventions and Terminology\nConventions and Terminology\n4.  Definitions


                4.1.  JSON Document

              
                4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances

                

              
                4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources\n4.2.  Instance


                    4.2.1.  Instance Data Model

                  
                    4.2.2.  Instance Equality

                  
                    4.2.3.  Non-JSON Instances\n4.2.1.  Instance Data Model\n4.2.1.  Instance Data Model\n4.2.2.  Instance Equality\n4.2.2.  Instance Equality\n4.2.3.  Non-JSON Instances\n4.2.3.  Non-JSON Instances\n4.3.  JSON Schema Documents


                    4.3.1.  JSON Schema Objects and Keywords

                  
                    4.3.2.  Boolean JSON Schemas

                  
                    4.3.3.  Schema Vocabularies

                  
                    4.3.4.  Meta-Schemas

                  
                    4.3.5.  Root Schema and Subschemas and Resources\n4.3.  JSON Schema Documents\nJSON Schema Documents\n4.3.1.  JSON Schema Objects and Keywords\n4.3.1.  JSON Schema Objects and Keywords\nJSON Schema Objects and Keywords\n4.3.2.  Boolean JSON Schemas\n4.3.2.  Boolean JSON Schemas\n4.3.3.  Schema Vocabularies\n4.3.3.  Schema Vocabularies\n4.3.5.  Root Schema and Subschemas and Resources\n4.3.5.  Root Schema and Subschemas and Resources\nRoot Schema and Subschemas and Resources\n5.  Fragment Identifiers\n5.  Fragment Identifiers\n6.  General Considerations


                6.1.  Range of JSON Values

              
                6.2.  Programming Language Independence

              
                6.3.  Mathematical Integers

              
                6.4.  Regular Expressions

              
                6.5.  Extending JSON Schema\n6.  General Considerations\nGeneral Considerations\n6.1.  Range of JSON Values\n6.1.  Range of JSON Values\n6.2.  Programming Language Independence\n6.2.  Programming Language Independence\nProgramming Language Independence\n6.3.  Mathematical Integers\n6.3.  Mathematical Integers\nMathematical Integers\n6.4.  Regular Expressions\n6.4.  Regular Expressions\n6.5.  Extending JSON Schema\n6.5.  Extending JSON Schema\nExtending JSON Schema\n7.  Keyword Behaviors


                7.1.  Lexical Scope and Dynamic Scope

              
                7.2.  Keyword Interactions

              
                7.3.  Default Behaviors

              
                7.4.  Identifiers

              
                7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas

                

              
                7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types

                

              
                7.7.  Annotations


                    7.7.1.  Collecting Annotations

                

              
                7.8.  Reserved Locations

              
                7.9.  Loading Instance Data\n7.  Keyword Behaviors\n7.1.  Lexical Scope and Dynamic Scope\n7.1.  Lexical Scope and Dynamic Scope\nLexical Scope and Dynamic Scope\n7.2.  Keyword Interactions\n7.2.  Keyword Interactions\n7.3.  Default Behaviors\n7.3.  Default Behaviors\n7.5.  Applicators


                    7.5.1.  Referenced and Referencing Schemas\n7.5.1.  Referenced and Referencing Schemas\n7.5.1.  Referenced and Referencing Schemas\nReferenced and Referencing Schemas\n7.6.  Assertions


                    7.6.1.  Assertions and Instance Primitive Types\n7.6.1.  Assertions and Instance Primitive Types\n7.6.1.  Assertions and Instance Primitive Types\nAssertions and Instance Primitive Types\n7.7.  Annotations


                    7.7.1.  Collecting Annotations\n7.7.1.  Collecting Annotations\n7.7.1.  Collecting Annotations\nCollecting Annotations\n7.8.  Reserved Locations\n7.8.  Reserved Locations\n7.9.  Loading Instance Data\n7.9.  Loading Instance Data\nLoading Instance Data\n8.  The JSON Schema Core Vocabulary


                8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs

                

              
                8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"

                

              
                8.3.  Comments With "$comment"\n8.  The JSON Schema Core Vocabulary\nThe JSON Schema Core Vocabulary\n8.1.  Meta-Schemas and Vocabularies


                    8.1.1.  The "$schema" Keyword

                  
                    8.1.2.  The "$vocabulary" Keyword

                  
                    8.1.3.  Updates to Meta-Schema and Vocabulary URIs\n8.1.  Meta-Schemas and Vocabularies\nMeta-Schemas and Vocabularies\n8.1.1.  The "$schema" Keyword\n8.1.1.  The "$schema" Keyword\nThe "$schema" Keyword\n8.1.2.  The "$vocabulary" Keyword\n8.1.2.  The "$vocabulary" Keyword\nThe "$vocabulary" Keyword\n8.1.3.  Updates to Meta-Schema and Vocabulary URIs\n8.1.3.  Updates to Meta-Schema and Vocabulary URIs\nUpdates to Meta-Schema and Vocabulary URIs\n8.2.  Base URI, Anchors, and Dereferencing


                    8.2.1.  The "$id" Keyword

                  
                    8.2.2.  Defining location-independent identifiers

                  
                    8.2.3.  Schema References

                  
                    8.2.4.  Schema Re-Use With "$defs"\n8.2.  Base URI, Anchors, and Dereferencing\nBase URI, Anchors, and Dereferencing\n8.2.1.  The "$id" Keyword\n8.2.1.  The "$id" Keyword\n8.2.2.  Defining location-independent identifiers\n8.2.2.  Defining location-independent identifiers\nDefining location-independent identifiers\n8.2.3.  Schema References\n8.2.3.  Schema References\n8.2.4.  Schema Re-Use With "$defs"\n8.2.4.  Schema Re-Use With "$defs"\nSchema Re-Use With "$defs"\n8.3.  Comments With "$comment"\n8.3.  Comments With "$comment"\nComments With "$comment"\n9.  Loading and Processing Schemas


                9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema

                

              
                9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources

                

              
                9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating

                

              
                9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas

                

              
                9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia\n9.  Loading and Processing Schemas\nLoading and Processing Schemas\n9.1.  Loading a Schema


                    9.1.1.  Initial Base URI

                  
                    9.1.2.  Loading a referenced schema

                  
                    9.1.3.  Detecting a Meta-Schema\n9.1.  Loading a Schema\n9.1.1.  Initial Base URI\n9.1.1.  Initial Base URI\n9.1.2.  Loading a referenced schema\n9.1.2.  Loading a referenced schema\nLoading a referenced schema\n9.1.3.  Detecting a Meta-Schema\n9.1.3.  Detecting a Meta-Schema\nDetecting a Meta-Schema\n9.2.  Dereferencing


                    9.2.1.  JSON Pointer fragments and embedded schema resources\n9.2.1.  JSON Pointer fragments and embedded schema resources\n9.2.1.  JSON Pointer fragments and embedded schema resources\nJSON Pointer fragments and embedded schema resources\n9.3.  Compound Documents


                    9.3.1.  Bundling

                  
                    9.3.2.  Differing and Default Dialects

                  
                    9.3.3.  Validating\n9.3.  Compound Documents\n9.3.2.  Differing and Default Dialects\n9.3.2.  Differing and Default Dialects\nDiffering and Default Dialects\n9.4.  Caveats


                    9.4.1.  Guarding Against Infinite Recursion

                  
                    9.4.2.  References to Possible Non-Schemas\n9.4.1.  Guarding Against Infinite Recursion\n9.4.1.  Guarding Against Infinite Recursion\nGuarding Against Infinite Recursion\n9.4.2.  References to Possible Non-Schemas\n9.4.2.  References to Possible Non-Schemas\nReferences to Possible Non-Schemas\n9.5.  Associating Instances and Schemas


                    9.5.1.  Usage for Hypermedia\n9.5.  Associating Instances and Schemas\nAssociating Instances and Schemas\n9.5.1.  Usage for Hypermedia\n9.5.1.  Usage for Hypermedia\n10. A Vocabulary for Applying Subschemas


                10.1.  Keyword Independence

              
                10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally

                

              
                10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects\n10. A Vocabulary for Applying Subschemas\nA Vocabulary for Applying Subschemas\n10.1.  Keyword Independence\n10.1.  Keyword Independence\n10.2.  Keywords for Applying Subschemas in Place


                    10.2.1.  Keywords for Applying Subschemas With Logic

                  
                    10.2.2.  Keywords for Applying Subschemas Conditionally\n10.2.  Keywords for Applying Subschemas in Place\nKeywords for Applying Subschemas in Place\n10.2.1.  Keywords for Applying Subschemas With Logic\n10.2.1.  Keywords for Applying Subschemas With Logic\nKeywords for Applying Subschemas With Logic\n10.2.2.  Keywords for Applying Subschemas Conditionally\n10.2.2.  Keywords for Applying Subschemas Conditionally\nKeywords for Applying Subschemas Conditionally\n10.3.  Keywords for Applying Subschemas to Child Instances


                    10.3.1.  Keywords for Applying Subschemas to Arrays

                  
                    10.3.2.  Keywords for Applying Subschemas to Objects\n10.3.  Keywords for Applying Subschemas to Child Instances\nKeywords for Applying Subschemas to Child Instances\n10.3.1.  Keywords for Applying Subschemas to Arrays\n10.3.1.  Keywords for Applying Subschemas to Arrays\nKeywords for Applying Subschemas to Arrays\n10.3.2.  Keywords for Applying Subschemas to Objects\n10.3.2.  Keywords for Applying Subschemas to Objects\nKeywords for Applying Subschemas to Objects\n11. A Vocabulary for Unevaluated Locations


                11.1.  Keyword Independence

              
                11.2.  unevaluatedItems

              
                11.3.  unevaluatedProperties\n11. A Vocabulary for Unevaluated Locations\nA Vocabulary for Unevaluated Locations\n11.1.  Keyword Independence\n11.1.  Keyword Independence\n11.2.  unevaluatedItems\n11.2.  unevaluatedItems\n11.3.  unevaluatedProperties\n11.3.  unevaluatedProperties\nunevaluatedProperties\n12. Output Formatting


                12.1.  Format

              
                12.2.  Output Formats

              
                12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results

                

              
                12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas\n12. Output Formatting\n12.2.  Output Formats\n12.2.  Output Formats\n12.3.  Minimum Information


                    12.3.1.  Keyword Relative Location

                  
                    12.3.2.  Keyword Absolute Location

                  
                    12.3.3.  Instance Location

                  
                    12.3.4.  Error or Annotation

                  
                    12.3.5.  Nested Results\n12.3.  Minimum Information\n12.3.1.  Keyword Relative Location\n12.3.1.  Keyword Relative Location\nKeyword Relative Location\n12.3.2.  Keyword Absolute Location\n12.3.2.  Keyword Absolute Location\nKeyword Absolute Location\n12.3.3.  Instance Location\n12.3.3.  Instance Location\n12.3.4.  Error or Annotation\n12.3.4.  Error or Annotation\n12.3.5.  Nested Results\n12.3.5.  Nested Results\n12.4.  Output Structure


                    12.4.1.  Flag

                  
                    12.4.2.  Basic

                  
                    12.4.3.  Detailed

                  
                    12.4.4.  Verbose

                  
                    12.4.5.  Output validation schemas\n12.4.  Output Structure\n12.4.5.  Output validation schemas\n12.4.5.  Output validation schemas\nOutput validation schemas\n13. Security Considerations\n13. Security Considerations\nSecurity Considerations\n14. IANA Considerations


                14.1.  application/schema+json

              
                14.2.  application/schema-instance+json\n14. IANA Considerations\n14.1.  application/schema+json\n14.1.  application/schema+json\napplication/schema+json\n14.2.  application/schema-instance+json\n14.2.  application/schema-instance+json\napplication/schema-instance+json\n15. References


                15.1.  Normative References

              
                15.2.  Informative References\n15.1.  Normative References\n15.1.  Normative References\n15.2.  Informative References\n15.2.  Informative References\nInformative References\nAppendix A.  Schema identification examples\nAppendix A.  Schema identification examples\nSchema identification examples\nAppendix B.  Manipulating schema documents and references


                B.1.  Bundling schema resources into a single document

              
                B.2.  Reference removal is not always safe\nAppendix B.  Manipulating schema documents and references\nManipulating schema documents and references\nB.1.  Bundling schema resources into a single document\nB.1.  Bundling schema resources into a single document\nBundling schema resources into a single document\nB.2.  Reference removal is not always safe\nB.2.  Reference removal is not always safe\nReference removal is not always safe\nAppendix C.  Example of recursive schema extension\nAppendix C.  Example of recursive schema extension\nExample of recursive schema extension\nAppendix D.  Working with vocabularies


                D.1.  Best practices for vocabulary and meta-schema authors

              
                D.2.  Example meta-schema with vocabulary declarations\nAppendix D.  Working with vocabularies\nWorking with vocabularies\nD.1.  Best practices for vocabulary and meta-schema authors\nD.1.  Best practices for vocabulary and meta-schema authors\nBest practices for vocabulary and meta-schema authors\nD.2.  Example meta-schema with vocabulary declarations\nD.2.  Example meta-schema with vocabulary declarations\nExample meta-schema with vocabulary declarations\nAppendix E.  References and generative use cases\nAppendix E.  References and generative use cases\nReferences and generative use cases\nAppendix F.  Acknowledgments\nAppendix F.  Acknowledgments\nAppendix G.  ChangeLog\nAppendix G.  ChangeLog\nJSON Schema is a JSON media type for defining the structure of JSON data. JSON Schema
                is intended to define validation, documentation, hyperlink navigation, and interaction
                control of JSON data.¶\nThis specification defines JSON Schema core terminology and mechanisms, including
                pointing to another JSON Schema by reference,
                dereferencing a JSON Schema reference,
                specifying the dialect being used,
                specifying a dialect's vocabulary requirements,
                and defining the expected output.¶\nOther specifications define the vocabularies that perform assertions about validation,
                linking, annotation, navigation, and interaction.¶\n2. Conventions and Terminology\nConventions and Terminology\nThe key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in RFC 2119 [RFC2119].¶\nThe terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in RFC 8259 [RFC8259].¶\nThis document proposes a new media type "application/schema+json" to identify a JSON
                Schema for describing JSON data.
                It also proposes a further optional media type, "application/schema-instance+json",
                to provide additional integration features.
                JSON Schemas are themselves JSON documents.
                This, and related specifications, define keywords allowing authors to describe JSON
                data in several ways.¶\nJSON Schema uses keywords to assert constraints on JSON instances or annotate those
                instances with additional information.  Additional keywords are used to apply
                assertions and annotations to more complex JSON data structures, or based on
                some sort of condition.¶\nTo facilitate re-use, keywords can be organized into vocabularies. A vocabulary
                consists of a list of keywords, together with their syntax and semantics.
                A dialect is defined as a set of vocabularies and their required support
                identified in a meta-schema.¶\nJSON Schema can be extended either by defining additional vocabularies,
                or less formally by defining additional keywords outside of any vocabulary.
                Unrecognized individual keywords simply have their values collected as annotations,
                while the behavior with respect to an unrecognized vocabulary can be controlled
                when declaring which vocabularies are in use.¶\nThis document defines a core vocabulary that MUST be supported by any
                implementation, and cannot be disabled.  Its keywords are each prefixed
                with a "$" character to emphasize their required nature.  This vocabulary
                is essential to the functioning of the "application/schema+json" media
                type, and is used to bootstrap the loading of other vocabularies.¶\nAdditionally, this document defines a RECOMMENDED vocabulary of keywords
                for applying subschemas conditionally, and for applying subschemas to
                the contents of objects and arrays.  Either this vocabulary or one very
                much like it is required to write schemas for non-trivial JSON instances,
                whether those schemas are intended for assertion validation, annotation,
                or both.  While not part of the required core vocabulary, for maximum
                interoperability this additional vocabulary is included in this document
                and its use is strongly encouraged.¶\nFurther vocabularies for purposes such as structural validation or
                hypermedia annotation are defined in other documents.  These other
                documents each define a dialect collecting the standard sets of
                vocabularies needed to write schemas for that document's purpose.¶\nA JSON document is an information resource (series of octets) described by the
                    application/json media type.¶\nIn JSON Schema, the terms "JSON document", "JSON text", and "JSON value" are
                    interchangeable because of the data model it defines.¶\nJSON Schema is only defined over JSON documents. However, any document or memory
                    structure that can be parsed into or processed according to the JSON Schema data
                    model can be interpreted against a JSON Schema, including media types like
                    CBOR [RFC7049].¶\nA JSON document to which a schema is applied is known as an "instance".¶\nJSON Schema is defined over "application/json" or compatible documents,
                    including media types with the "+json" structured syntax suffix.¶\nAmong these, this specification defines the "application/schema-instance+json"
                    media type which defines handling for fragments in the URI.¶\n4.2.1. Instance Data Model\nJSON Schema interprets documents according to a data model. A JSON value
                        interpreted according to this data model is called an "instance".¶\nAn instance has one of six primitive types, and a range of possible values
                        depending on the type:¶\nWhitespace and formatting concerns, including different lexical
                        representations of numbers that are equal within the data model, are thus
                        outside the scope of JSON Schema.  JSON Schema
                        vocabularies (Section 8.1) that wish
                        to work with such differences in lexical representations SHOULD define
                        keywords to precisely interpret formatted strings within the data model
                        rather than relying on having the original JSON representation Unicode
                        characters available.¶\nvocabularies (Section 8.1)\nSince an object cannot have two properties with the same key, behavior for a
                        JSON document that tries to define two properties with
                        the same key in a single object is undefined.¶\nNote that JSON Schema vocabularies are free to define their own extended
                        type system.  This should not be confused with the core data model types
                        defined here.  As an example, "integer" is a reasonable type for a
                        vocabulary to define as a value for a keyword, but the data model
                        makes no distinction between integers and other numbers.¶\n4.2.2. Instance Equality\nTwo JSON instances are said to be equal if and only if they are of the same type
                        and have the same value according to the data model. Specifically, this means:¶\nboth are strings, and are the same codepoint-for-codepoint; or¶\nboth are numbers, and have the same mathematical value; or¶\nboth are arrays, and have an equal value item-for-item; or¶\nboth are objects, and each property in one has exactly one property with
                                a key equal to the other's, and that other property has an equal
                                value.¶\nImplied in this definition is that arrays must be the same length,
                        objects must have the same number of members,
                        properties in objects are unordered,
                        there is no way to define multiple properties with the same key,
                        and mere formatting differences (indentation, placement of commas, trailing
                        zeros) are insignificant.¶\n4.2.3. Non-JSON Instances\nIt is possible to use JSON Schema with a superset of the JSON Schema data model,
                        where an instance may be outside any of the six JSON data types.¶\nIn this case, annotations still apply; but most validation keywords will not be useful,
                        as they will always pass or always fail.¶\nA custom vocabulary may define support for a superset of the core data model.
                        The schema itself may only be expressible in this superset;
                        for example, to make use of the "const" keyword.¶\n4.3. JSON Schema Documents
        

                    A JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema can itself be interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".¶

                    A JSON Schema MUST be an object or a boolean.¶

          
4.3.1. JSON Schema Objects and Keywords
          

                        Object properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of five categories:¶

            identifiers:
            
                                control schema identification through setting a URI
                                for the schema and/or changing how the base URI is determined¶

            
assertions:
            
                                produce a boolean result when applied to an instance¶

            
annotations:
            
                                attach information to an instance for application use¶

            
applicators:
            
                                apply one or more subschemas to a particular location
                                in the instance, and combine or modify their results¶

            
reserved locations:
            
                                do not directly affect results, but reserve a place
                                for a specific purpose to ensure interoperability¶

          


                        Keywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.¶

                        Keywords which are properties within the same schema object are referred to as adjacent keywords.¶

                        Extension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.¶

                        A JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be treated as annotations, where the value
                        of the keyword is the value of the annotation.¶

                        An empty schema is a JSON Schema with no properties, or only unknown
                        properties.¶


          
4.3.2. Boolean JSON Schemas
          

                        The boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertion results, regardless of the
                        instance value.  They never produce annotation results.¶

                        These boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).¶

            true:
            
                                Always passes validation, as if the empty schema {}¶

            
false:
            
                                Always fails validation, as if the schema { "not": {} }¶

          


                        While the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.¶


          
4.3.3. Schema Vocabularies
          

                        A schema vocabulary, or simply a vocabulary, is a set of keywords,
                        their syntax, and their semantics.  A vocabulary is generally organized
                        around a particular purpose.  Different uses of JSON Schema, such
                        as validation, hypermedia, or user interface generation, will
                        involve different sets of vocabularies.¶

                        Vocabularies are the primary unit of re-use in JSON Schema, as schema
                        authors can indicate what vocabularies are required or optional in
                        order to process the schema.  Since vocabularies are identified by URIs
                        in the meta-schema, generic implementations can load extensions to support
                        previously unknown vocabularies.  While keywords can be supported outside
                        of any vocabulary, there is no analogous mechanism to indicate individual
                        keyword usage.¶

                        A schema vocabulary can be defined by anything from an informal description
                        to a standards proposal, depending on the audience and interoperability
                        expectations.  In particular, in order to facilitate vocabulary use within
                        non-public organizations, a vocabulary specification need not be published
                        outside of its scope of use.¶


          
4.3.4. Meta-Schemas
          

                        A schema that itself describes a schema is called a meta-schema.
                        Meta-schemas are used to validate JSON Schemas and specify which vocabularies
                        they are using.¶

                        Typically, a meta-schema will specify a set of vocabularies, and validate
                        schemas that conform to the syntax of those vocabularies.  However, meta-schemas
                        and vocabularies are separate in order to allow meta-schemas to validate
                        schema conformance more strictly or more loosely than the vocabularies'
                        specifications call for.  Meta-schemas may also describe and validate
                        additional keywords that are not part of a formal vocabulary.¶



          
4.3.5. Root Schema and Subschemas and Resources
          

                        A JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶

                        The root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶

                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:¶


{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶


                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶

                        As with the root schema, a subschema is either an object or a boolean.¶

                        As discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶

                        Whether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n4.3. JSON Schema Documents\nJSON Schema Documents\nA JSON Schema document, or simply a schema, is a JSON document used to describe
                    an instance.
                    A schema can itself be interpreted as an instance, but SHOULD always be given
                    the media type "application/schema+json" rather than
                    "application/schema-instance+json".  The "application/schema+json" media
                    type is defined to offer a superset of the
                    fragment identifier syntax and semantics provided by
                    "application/schema-instance+json".¶\nA JSON Schema MUST be an object or a boolean.¶\n4.3.1. JSON Schema Objects and Keywords\nJSON Schema Objects and Keywords\nObject properties that are applied to the instance are called keywords,
                        or schema keywords.  Broadly speaking, keywords fall into one
                        of five categories:¶\nKeywords may fall into multiple categories, although applicators
                        SHOULD only produce assertion results based on their subschemas'
                        results.  They should not define additional constraints independent
                        of their subschemas.¶\nKeywords which are properties within the same schema object are referred to as adjacent keywords.¶\nExtension keywords, meaning those defined outside of this document
                        and its companions, are free to define other behaviors as well.¶\nA JSON Schema MAY contain properties which are not schema keywords.
                        Unknown keywords SHOULD be treated as annotations, where the value
                        of the keyword is the value of the annotation.¶\nAn empty schema is a JSON Schema with no properties, or only unknown
                        properties.¶\n4.3.2. Boolean JSON Schemas\nThe boolean schema values "true" and "false" are trivial schemas that
                        always produce themselves as assertion results, regardless of the
                        instance value.  They never produce annotation results.¶\nThese boolean schemas exist to clarify schema author intent and
                        facilitate schema processing optimizations.  They behave identically
                        to the following schema objects (where "not" is part of the
                        subschema application vocabulary defined in this document).¶\nWhile the empty schema object is unambiguous, there are many
                        possible equivalents to the "false" schema.  Using the boolean
                        values ensures that the intent is clear to both human readers
                        and implementations.¶\n4.3.3. Schema Vocabularies\nA schema vocabulary, or simply a vocabulary, is a set of keywords,
                        their syntax, and their semantics.  A vocabulary is generally organized
                        around a particular purpose.  Different uses of JSON Schema, such
                        as validation, hypermedia, or user interface generation, will
                        involve different sets of vocabularies.¶\nVocabularies are the primary unit of re-use in JSON Schema, as schema
                        authors can indicate what vocabularies are required or optional in
                        order to process the schema.  Since vocabularies are identified by URIs
                        in the meta-schema, generic implementations can load extensions to support
                        previously unknown vocabularies.  While keywords can be supported outside
                        of any vocabulary, there is no analogous mechanism to indicate individual
                        keyword usage.¶\nA schema vocabulary can be defined by anything from an informal description
                        to a standards proposal, depending on the audience and interoperability
                        expectations.  In particular, in order to facilitate vocabulary use within
                        non-public organizations, a vocabulary specification need not be published
                        outside of its scope of use.¶\nA schema that itself describes a schema is called a meta-schema.
                        Meta-schemas are used to validate JSON Schemas and specify which vocabularies
                        they are using.¶\nTypically, a meta-schema will specify a set of vocabularies, and validate
                        schemas that conform to the syntax of those vocabularies.  However, meta-schemas
                        and vocabularies are separate in order to allow meta-schemas to validate
                        schema conformance more strictly or more loosely than the vocabularies'
                        specifications call for.  Meta-schemas may also describe and validate
                        additional keywords that are not part of a formal vocabulary.¶\n4.3.5. Root Schema and Subschemas and Resources
          

                        A JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶

                        The root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶

                        Some keywords take schemas themselves, allowing JSON Schemas to be nested:¶


{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶


                        In this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶

                        As with the root schema, a subschema is either an object or a boolean.¶

                        As discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶

                        Whether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n4.3.5. Root Schema and Subschemas and Resources\nRoot Schema and Subschemas and Resources\nA JSON Schema resource is a schema which is
                        canonically [RFC6596] identified by an
                        absolute URI [RFC3986].  Schema resources MAY
                        also be identified by URIs, including URIs with fragments,
                        if the resulting secondary resource (as defined by
                        section 3.5 of RFC 3986 [RFC3986]) is identical
                        to the primary resource.  This can occur with the empty fragment,
                        or when one schema resource is embedded in another.  Any such URIs
                        with fragments are considered to be non-canonical.¶\ncanonically [RFC6596]\nabsolute URI [RFC3986]\nsection 3.5 of RFC 3986 [RFC3986]\nsection 3.5 of RFC 3986\nThe root schema is the schema that comprises the entire JSON document
                        in question.  The root schema is always a schema resource, where the
                        URI is determined as described in section
                        9.1.1.
                        
                            Note that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.
            ¶\nNote that documents that embed schemas in another format will not
                            have a root schema resource in this sense.  Exactly how such usages
                            fit with the JSON Schema document and resource concepts will be
                            clarified in a future draft.\nSome keywords take schemas themselves, allowing JSON Schemas to be nested:¶\n{
    "title": "root",
    "items": {
        "title": "array item"
    }
}

¶\nIn this example document, the schema titled "array item" is a subschema,
                        and the schema titled "root" is the root schema.¶\nAs with the root schema, a subschema is either an object or a boolean.¶\nAs discussed in section
                        8.2.1, a JSON Schema document
                        can contain multiple JSON Schema resources.  When used without qualification,
                        the term "root schema" refers to the document's root schema.  In some
                        cases, resource root schemas are discussed.  A resource's root schema
                        is its top-level schema object, which would also be a document root schema
                        if the resource were to be extracted to a standalone JSON Schema document.¶\nWhether multiple schema resources are embedded or linked with a reference,
                        they are processed in the same way, with the same available behaviors.¶\n5. Fragment Identifiers
      

                In accordance with section 3.1 of RFC 6839 [RFC6839],
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)¶

                Additionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.¶

                The use of JSON Pointers as URI fragment identifiers is described in
                RFC 6901 [RFC6901].
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.¶

                Per the W3C's
                best practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025],
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.¶

                Defining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the "$anchor" keyword (Section 8.2.2) section.¶\n5. Fragment Identifiers\nIn accordance with section 3.1 of RFC 6839 [RFC6839],
                the syntax and semantics of fragment identifiers specified for
                any +json media type SHOULD be as specified for "application/json".
                (At publication of this document, there is no fragment identification
                syntax defined for "application/json".)¶\nAdditionally, the "application/schema+json" media type supports two
                fragment identifier structures: plain names and JSON Pointers.
                The "application/schema-instance+json" media type supports one
                fragment identifier structure: JSON Pointers.¶\nThe use of JSON Pointers as URI fragment identifiers is described in
                RFC 6901 [RFC6901].
                For "application/schema+json", which supports two fragment identifier syntaxes,
                fragment identifiers matching the JSON Pointer syntax, including the empty string,
                MUST be interpreted as JSON Pointer fragment identifiers.¶\nPer the W3C's
                best practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025],
                plain name fragment identifiers in "application/schema+json" are reserved for referencing
                locally named schemas.  All fragment identifiers that do
                not match the JSON Pointer syntax MUST be interpreted as
                plain name fragment identifiers.¶\nbest practices for fragment identifiers [W3C.WD-fragid-best-practices-20121025]\nbest practices for fragment identifiers\nW3C.WD-fragid-best-practices-20121025\nDefining and referencing a plain name fragment identifier within an
                "application/schema+json" document are specified
                in the "$anchor" keyword (Section 8.2.2) section.¶\n"$anchor" keyword (Section 8.2.2)\n6. General Considerations\nGeneral Considerations\n6.1. Range of JSON Values\nAn instance may be any valid JSON value as defined by JSON [RFC8259].
                    JSON Schema imposes no restrictions on type: JSON Schema can describe any JSON
                    value, including, for example, null.¶\n6.2. Programming Language Independence
        

                    JSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.¶\n6.2. Programming Language Independence\nProgramming Language Independence\nJSON Schema is programming language agnostic, and supports the full range of
                    values described in the data model.
                    Be aware, however, that some languages and JSON parsers may not be able to
                    represent in memory the full range of values describable by JSON.¶\n6.3. Mathematical Integers
        

                    Some programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.¶

                    For consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.¶\n6.3. Mathematical Integers\nMathematical Integers\nSome programming languages and parsers use different internal representations
                    for floating point numbers than they do for integers.¶\nFor consistency, integer JSON numbers SHOULD NOT be encoded with a fractional
                    part.¶\n6.4. Regular Expressions
        

                    Keywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                    These regular expressions SHOULD be valid according to the regular expression
                    dialect described in ECMA-262, section 21.2.1 [ecma262].¶

                    Regular expressions SHOULD be built with the "u" flag (or equivalent) to provide
                    Unicode support, or processed in such a way which provides Unicode support as
                    defined by ECMA-262.¶

                    Furthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:¶

individual Unicode characters, as defined by the JSON specification [RFC8259];¶

          simple character classes ([abc]), range character classes ([a-z]);¶

          complemented character classes ([^abc], [^a-z]);¶

          simple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");¶

          range quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;¶

          the beginning-of-input ("^") and end-of-input ("$") anchors;¶

          simple grouping ("(...)") and alternation ("|").¶

        

                    Finally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".¶\n6.4. Regular Expressions\nKeywords MAY use regular expressions to express constraints, or constrain
                    the instance value to be a regular expression.
                    These regular expressions SHOULD be valid according to the regular expression
                    dialect described in ECMA-262, section 21.2.1 [ecma262].¶\nECMA-262, section 21.2.1 [ecma262]\nECMA-262, section 21.2.1\nRegular expressions SHOULD be built with the "u" flag (or equivalent) to provide
                    Unicode support, or processed in such a way which provides Unicode support as
                    defined by ECMA-262.¶\nFurthermore, given the high disparity in regular expression constructs support,
                    schema authors SHOULD limit themselves to the following regular expression
                    tokens:¶\nindividual Unicode characters, as defined by the JSON specification [RFC8259];¶\nJSON specification [RFC8259]\nsimple character classes ([abc]), range character classes ([a-z]);¶\ncomplemented character classes ([^abc], [^a-z]);¶\nsimple quantifiers: "+" (one or more), "*" (zero or more), "?" (zero or
                        one), and their lazy versions ("+?", "*?", "??");¶\nrange quantifiers: "{x}" (exactly x occurrences), "{x,y}" (at least x, at
                        most y, occurrences), {x,} (x occurrences or more), and their lazy
                        versions;¶\nthe beginning-of-input ("^") and end-of-input ("$") anchors;¶\nsimple grouping ("(...)") and alternation ("|").¶\nFinally, implementations MUST NOT take regular expressions to be
                    anchored, neither at the beginning nor at the end. This means, for instance,
                    the pattern "es" matches "expression".¶\n6.5. Extending JSON Schema
        

                    Additional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD treat keywords they do not support as annotations,
                    where the value of the keyword is the value of the annotation.¶

                    Implementations MAY provide the ability to register or load handlers
                    for vocabularies that they do not support directly.  The exact mechanism
                    for registering and implementing such handlers is implementation-dependent.¶\n6.5. Extending JSON Schema\nExtending JSON Schema\nAdditional schema keywords and schema vocabularies MAY be defined
                    by any entity.  Save for explicit agreement, schema authors SHALL NOT
                    expect these additional keywords and vocabularies to be supported by
                    implementations that do not explicitly document such support.
                    Implementations SHOULD treat keywords they do not support as annotations,
                    where the value of the keyword is the value of the annotation.¶\nImplementations MAY provide the ability to register or load handlers
                    for vocabularies that they do not support directly.  The exact mechanism
                    for registering and implementing such handlers is implementation-dependent.¶\nJSON Schema keywords fall into several general behavior categories.
                Assertions validate that an instance satisfies constraints, producing
                a boolean result.  Annotations attach information that applications
                may use in any way they see fit.
                Applicators apply subschemas to parts of the instance and combine
                their results.¶\nExtension keywords SHOULD stay within these categories, keeping in mind
                that annotations in particular are extremely flexible.  Complex behavior
                is usually better delegated to applications on the basis of annotation
                data than implemented directly as schema keywords.  However, extension
                keywords MAY define other behaviors for specialized purposes.¶\nEvaluating an instance against a schema involves processing all of the
                keywords in the schema against the appropriate locations within the instance.
                Typically, applicator keywords are processed until a schema object with no
                applicators (and therefore no subschemas) is reached.  The appropriate
                location in the instance is evaluated against the assertion and
                annotation keywords in the schema object, and their results are gathered
                into the parent schema according to the rules of the applicator.¶\nEvaluation of a parent schema object can complete once all of its
                subschemas have been evaluated, although in some circumstances evaluation
                may be short-circuited due to assertion results.  When annotations are
                being collected, some assertion result short-circuiting is not possible
                due to the need to examine all subschemas for annotation collection, including
                those that cannot further change the assertion result.¶\n7.1. Lexical Scope and Dynamic Scope
        

                    While most JSON Schema keywords can be evaluated on their own,
                    or at most need to take into account the values or results of
                    adjacent keywords in the same schema object, a few have more
                    complex behavior.¶

                    The lexical scope of a keyword is determined by the nested JSON
                    data structure of objects and arrays.  The largest such scope
                    is an entire schema document.  The smallest scope is a single
                    schema object with no subschemas.¶

                    Keywords MAY be defined with a partial value, such as a URI-reference,
                    which must be resolved against another value, such as another
                    URI-reference or a full URI, which is found through the lexical
                    structure of the JSON document.  The "$id", "$ref", and
                    "$dynamicRef" core keywords, and the "base" JSON Hyper-Schema
                    keyword, are examples of this sort of behavior.¶

                    Note that some keywords, such as "$schema", apply to the lexical
                    scope of the entire schema resource, and therefore MUST only
                    appear in a schema resource's root schema.¶

                    Other keywords may take into account the dynamic scope that
                    exists during the evaluation of a schema, typically together
                    with an instance document.
                    The outermost dynamic scope is the schema object at
                    which processing begins, even if it is not a schema resource root.
                    The path from this root schema to any particular keyword (that
                    includes any "$ref" and "$dynamicRef" keywords that may have
                    been resolved) is considered the keyword's "validation path."¶

                    Lexical and dynamic scopes align until a reference keyword
                    is encountered.  While following the reference keyword moves processing
                    from one lexical scope into a different one, from the perspective
                    of dynamic scope, following a reference is no different from descending
                    into a subschema present as a value.  A keyword on the far side of
                    that reference that resolves information through the dynamic scope
                    will consider the originating side of the reference to be their
                    dynamic parent, rather than examining the local lexically enclosing parent.¶

                    The concept of dynamic scope is primarily used with "$dynamicRef" and
                    "$dynamicAnchor", and should be considered an advanced feature
                    and used with caution when defining additional keywords.  It also appears
                    when reporting errors and collected annotations, as it may be possible
                    to revisit the same lexical scope repeatedly with different dynamic
                    scopes.  In such cases, it is important to inform the user of the
                    dynamic path that produced the error or annotation.¶\n7.1. Lexical Scope and Dynamic Scope\nLexical Scope and Dynamic Scope\nWhile most JSON Schema keywords can be evaluated on their own,
                    or at most need to take into account the values or results of
                    adjacent keywords in the same schema object, a few have more
                    complex behavior.¶\nThe lexical scope of a keyword is determined by the nested JSON
                    data structure of objects and arrays.  The largest such scope
                    is an entire schema document.  The smallest scope is a single
                    schema object with no subschemas.¶\nKeywords MAY be defined with a partial value, such as a URI-reference,
                    which must be resolved against another value, such as another
                    URI-reference or a full URI, which is found through the lexical
                    structure of the JSON document.  The "$id", "$ref", and
                    "$dynamicRef" core keywords, and the "base" JSON Hyper-Schema
                    keyword, are examples of this sort of behavior.¶\nNote that some keywords, such as "$schema", apply to the lexical
                    scope of the entire schema resource, and therefore MUST only
                    appear in a schema resource's root schema.¶\nOther keywords may take into account the dynamic scope that
                    exists during the evaluation of a schema, typically together
                    with an instance document.
                    The outermost dynamic scope is the schema object at
                    which processing begins, even if it is not a schema resource root.
                    The path from this root schema to any particular keyword (that
                    includes any "$ref" and "$dynamicRef" keywords that may have
                    been resolved) is considered the keyword's "validation path."¶\nLexical and dynamic scopes align until a reference keyword
                    is encountered.  While following the reference keyword moves processing
                    from one lexical scope into a different one, from the perspective
                    of dynamic scope, following a reference is no different from descending
                    into a subschema present as a value.  A keyword on the far side of
                    that reference that resolves information through the dynamic scope
                    will consider the originating side of the reference to be their
                    dynamic parent, rather than examining the local lexically enclosing parent.¶\nThe concept of dynamic scope is primarily used with "$dynamicRef" and
                    "$dynamicAnchor", and should be considered an advanced feature
                    and used with caution when defining additional keywords.  It also appears
                    when reporting errors and collected annotations, as it may be possible
                    to revisit the same lexical scope repeatedly with different dynamic
                    scopes.  In such cases, it is important to inform the user of the
                    dynamic path that produced the error or annotation.¶\n7.2. Keyword Interactions\nKeyword behavior MAY be defined in terms of the annotation results
                    of subschemas (Section 4.3.5) and/or adjacent keywords
                    (keywords within the same schema object) and their subschemas.
                    Such keywords MUST NOT result in a circular dependency.
                    Keywords MAY modify their behavior based on the presence or absence
                    of another keyword in the same
                    schema object (Section 4.3).¶\nsubschemas (Section 4.3.5)\nschema object (Section 4.3)\n7.3. Default Behaviors\nA missing keyword MUST NOT produce a false assertion result, MUST
                    NOT produce annotation results, and MUST NOT cause any other schema
                    to be evaluated as part of its own behavioral definition.
                    However, given that missing keywords do not contribute annotations,
                    the lack of annotation results may indirectly change the behavior
                    of other keywords.¶\nIn some cases, the missing keyword assertion behavior of a keyword is
                    identical to that produced by a certain value, and keyword definitions
                    SHOULD note such values where known.  However, even if the value which
                    produces the default behavior would produce annotation results if
                    present, the default behavior still MUST NOT result in annotations.¶\nBecause annotation collection can add significant cost in terms of both
                    computation and memory, implementations MAY opt out of this feature.
                    Keywords that are specified in terms of collected annotations SHOULD
                    describe reasonable alternate approaches when appropriate.
                    This approach is demonstrated by the
                    "items" and
                    "additionalProperties" keywords in this
                    document.¶\nNote that when no such alternate approach is possible for a keyword,
                    implementations that do not support annotation collections will not
                    be able to support those keywords or vocabularies that contain them.¶\nIdentifiers define URIs for a schema, or affect how such URIs are
                    resolved in references (Section 8.2.3), or both.
                    The Core vocabulary defined in this document defines several
                    identifying keywords, most notably "$id".¶\nreferences (Section 8.2.3)\nCanonical schema URIs MUST NOT change while processing an instance, but
                    keywords that affect URI-reference resolution MAY have behavior that
                    is only fully determined at runtime.¶\nWhile custom identifier keywords are possible, vocabulary designers should
                    take care not to disrupt the functioning of core keywords. For example,
                    the "$dynamicAnchor" keyword in this specification limits its URI resolution
                    effects to the matching "$dynamicRef" keyword, leaving the behavior
                    of "$ref" undisturbed.¶\n7.5. Applicators
        

                    Applicators allow for building more complex schemas than can be accomplished
                    with a single schema object.  Evaluation of an instance against a
                    schema document (Section 4.3) begins by applying
                    the root schema (Section 4.3.5) to the complete instance
                    document.  From there, keywords known as applicators are used to determine
                    which additional schemas are applied.  Such schemas may be applied in-place
                    to the current location, or to a child location.¶

                    The schemas to be applied may be present as subschemas comprising all or
                    part of the keyword's value.  Alternatively, an applicator may refer to
                    a schema elsewhere in the same schema document, or in a different one.
                    The mechanism for identifying such referenced schemas is defined by the
                    keyword.¶

                    Applicator keywords also define how subschema or referenced schema
                    boolean assertion (Section 7.6)
                    results are modified and/or combined to produce the boolean result
                    of the applicator.  Applicators may apply any boolean logic operation
                    to the assertion results of subschemas, but MUST NOT introduce new
                    assertion conditions of their own.¶

                    Annotation (Section 7.7) results are
                    preserved along with the instance location and the location of
                    the schema keyword, so that applications can decide how to
                    interpret multiple values.¶


          
7.5.1. Referenced and Referencing Schemas
          

                        As noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶

                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶

                        For some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\nApplicators allow for building more complex schemas than can be accomplished
                    with a single schema object.  Evaluation of an instance against a
                    schema document (Section 4.3) begins by applying
                    the root schema (Section 4.3.5) to the complete instance
                    document.  From there, keywords known as applicators are used to determine
                    which additional schemas are applied.  Such schemas may be applied in-place
                    to the current location, or to a child location.¶\nschema document (Section 4.3)\nroot schema (Section 4.3.5)\nThe schemas to be applied may be present as subschemas comprising all or
                    part of the keyword's value.  Alternatively, an applicator may refer to
                    a schema elsewhere in the same schema document, or in a different one.
                    The mechanism for identifying such referenced schemas is defined by the
                    keyword.¶\nApplicator keywords also define how subschema or referenced schema
                    boolean assertion (Section 7.6)
                    results are modified and/or combined to produce the boolean result
                    of the applicator.  Applicators may apply any boolean logic operation
                    to the assertion results of subschemas, but MUST NOT introduce new
                    assertion conditions of their own.¶\nassertion (Section 7.6)\nAnnotation (Section 7.7) results are
                    preserved along with the instance location and the location of
                    the schema keyword, so that applications can decide how to
                    interpret multiple values.¶\nAnnotation (Section 7.7)\n7.5.1. Referenced and Referencing Schemas
          

                        As noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶

                        While root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶

                        For some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\n7.5.1. Referenced and Referencing Schemas\nReferenced and Referencing Schemas\nAs noted in Section 7.5, an applicator keyword may
                        refer to a schema to be applied, rather than including it as a
                        subschema in the applicator's value.  In such situations, the
                        schema being applied is known as the referenced schema, while
                        the schema containing the applicator keyword is the referencing schema.¶\nWhile root schemas and subschemas are static concepts based on a
                        schema's position within a schema document, referenced and referencing
                        schemas are dynamic.  Different pairs of schemas may find themselves
                        in various referenced and referencing arrangements during the evaluation
                        of an instance against a schema.¶\nFor some by-reference applicators, such as
                        "$ref" (Section 8.2.3.1), the referenced schema can be determined
                        by static analysis of the schema document's lexical scope.  Others,
                        such as "$dynamicRef" (with "$dynamicAnchor"), may make use of dynamic
                        scoping, and therefore only be resolvable in the process of evaluating
                        the schema with an instance.¶\n"$ref" (Section 8.2.3.1)\n7.6. Assertions
        

                    JSON Schema can be used to assert constraints on a JSON document, which
                    either passes or fails the assertions.  This approach can be used to validate
                    conformance with the constraints, or document what is needed to satisfy them.¶

                    JSON Schema implementations produce a single boolean result when evaluating
                    an instance against schema assertions.¶

                    An instance can only fail an assertion that is present in the schema.¶

          
7.6.1. Assertions and Instance Primitive Types
          

                        Most assertions only constrain values within a certain
                        primitive type.  When the type of the instance is not of the type
                        targeted by the keyword, the instance is considered to conform
                        to the assertion.¶

                        For example, the "maxLength" keyword from the companion
                        validation vocabulary [json-schema-validation]:
                        will only restrict certain strings
                        (that are too long) from being valid.  If the instance is a number,
                        boolean, null, array, or object, then it is valid against this assertion.¶

                        This behavior allows keywords to be used more easily with instances
                        that can be of multiple primitive types.  The companion validation
                        vocabulary also includes a "type" keyword which can independently
                        restrict the instance to one or more primitive types.  This allows
                        for a concise expression of use cases such as a function that might
                        return either a string of a certain length or a null value:¶


{
    "type": ["string", "null"],
    "maxLength": 255
}

¶


                            If "maxLength" also restricted the instance type to be a string,
                            then this would be substantially more cumbersome to express because
                            the example as written would not actually allow null values.
                            Each keyword is evaluated separately unless explicitly specified
                            otherwise, so if "maxLength" restricted the instance to strings,
                            then including "null" in "type" would not have any useful effect.¶\nJSON Schema can be used to assert constraints on a JSON document, which
                    either passes or fails the assertions.  This approach can be used to validate
                    conformance with the constraints, or document what is needed to satisfy them.¶\nJSON Schema implementations produce a single boolean result when evaluating
                    an instance against schema assertions.¶\nAn instance can only fail an assertion that is present in the schema.¶\n7.6.1. Assertions and Instance Primitive Types\nAssertions and Instance Primitive Types\nMost assertions only constrain values within a certain
                        primitive type.  When the type of the instance is not of the type
                        targeted by the keyword, the instance is considered to conform
                        to the assertion.¶\nFor example, the "maxLength" keyword from the companion
                        validation vocabulary [json-schema-validation]:
                        will only restrict certain strings
                        (that are too long) from being valid.  If the instance is a number,
                        boolean, null, array, or object, then it is valid against this assertion.¶\nvalidation vocabulary [json-schema-validation]\nvalidation vocabulary\njson-schema-validation\nThis behavior allows keywords to be used more easily with instances
                        that can be of multiple primitive types.  The companion validation
                        vocabulary also includes a "type" keyword which can independently
                        restrict the instance to one or more primitive types.  This allows
                        for a concise expression of use cases such as a function that might
                        return either a string of a certain length or a null value:¶\n{
    "type": ["string", "null"],
    "maxLength": 255
}

¶\nIf "maxLength" also restricted the instance type to be a string,
                            then this would be substantially more cumbersome to express because
                            the example as written would not actually allow null values.
                            Each keyword is evaluated separately unless explicitly specified
                            otherwise, so if "maxLength" restricted the instance to strings,
                            then including "null" in "type" would not have any useful effect.¶\n7.7. Annotations
        

                    JSON Schema can annotate an instance with information, whenever the instance
                    validates against the schema object containing the annotation, and all of its
                    parent schema objects.  The information can be a simple value, or can be
                    calculated based on the instance contents.¶

                    Annotations are attached to specific locations in an instance.
                    Since many subschemas can be applied to any single
                    location, applications may need to decide how to handle differing
                    annotation values being attached to the same instance location by
                    the same schema keyword in different schema objects.¶

                    Unlike assertion results, annotation data can take a wide variety of forms,
                    which are provided to applications to use as they see fit.  JSON Schema
                    implementations are not expected to make use of the collected information
                    on behalf of applications.¶

                    Unless otherwise specified, the value of an annotation keyword
                    is the keyword's value.  However, other behaviors are possible.
                    For example, JSON Hyper-Schema's [json-hyper-schema]
                    "links" keyword is a complex annotation that produces a value based
                    in part on the instance data.¶

                    While "short-circuit" evaluation is possible for assertions, collecting
                    annotations requires examining all schemas that apply to an instance
                    location, even if they cannot change the overall assertion result.
                    The only exception is that subschemas of a schema object that has
                    failed validation MAY be skipped, as annotations are not retained
                    for failing schemas.¶

          
7.7.1. Collecting Annotations
          

                        Annotations are collected by keywords that explicitly define
                        annotation-collecting behavior.  Note that boolean schemas cannot
                        produce annotations as they do not make use of keywords.¶

                        A collected annotation MUST include the following information:¶


                                The name of the keyword that produces the annotation¶

            
                                The instance location to which it is attached, as a JSON Pointer¶

            
                                The schema location path, indicating how reference keywords
                                such as "$ref" were followed to reach the absolute schema location.¶

            
                                The absolute schema location of the attaching keyword, as a URI.
                                This MAY be omitted if it is the same as the schema location path
                                from above.¶

            
                                The attached value(s)¶

          

            
7.7.1.1. Distinguishing Among Multiple Values
            

                            Applications MAY make decisions on which of multiple annotation values
                            to use based on the schema location that contributed the value.
                            This is intended to allow flexible usage.  Collecting the schema location
                            facilitates such usage.¶

                            For example, consider this schema, which uses annotations and assertions from
                            the Validation specification [json-schema-validation]:¶

                                Note that some lines are wrapped for clarity.¶


{
    "title": "Feature list",
    "type": "array",
    "prefixItems": [
        {
            "title": "Feature A",
            "properties": {
                "enabled": {
                    "$ref": "#/$defs/enabledToggle",
                    "default": true
                }
            }
        },
        {
            "title": "Feature B",
            "properties": {
                "enabled": {
                    "description": "If set to null, Feature B
                                    inherits the enabled
                                    value from Feature A",
                    "$ref": "#/$defs/enabledToggle"
                }
            }
        }
    ],
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}

¶


                            In this example, both Feature A and Feature B make use of the re-usable
                            "enabledToggle" schema.  That schema uses the "title", "description",
                            and "default" annotations.  Therefore the application has to decide how
                            to handle the additional "default" value for Feature A, and the additional
                            "description" value for Feature B.¶

                            The application programmer and the schema author need to agree on the
                            usage.  For this example, let's assume that they agree that the most
                            specific "default" value will be used, and any additional, more generic
                            "default" values will be silently ignored.  Let's also assume that they
                            agree that all "description" text is to be used, starting with the most
                            generic, and ending with the most specific.  This requires the schema
                            author to write descriptions that work when combined in this way.¶

                            The application can use the schema location path to determine which
                            values are which.  The values in the feature's immediate "enabled"
                            property schema are more specific, while the values under the re-usable
                            schema that is referenced to with "$ref" are more generic.  The schema
                            location path will show whether each value was found by crossing a
                            "$ref" or not.¶

                            Feature A will therefore use a default value of true, while Feature B
                            will use the generic default value of null.  Feature A will only
                            have the generic description from the "enabledToggle" schema, while
                            Feature B will use that description, and also append its locally
                            defined description that explains how to interpret a null value.¶

                            Note that there are other reasonable approaches that a different application
                            might take.  For example, an application may consider the presence of
                            two different values for "default" to be an error, regardless of their
                            schema locations.¶


            
7.7.1.2. Annotations and Assertions
            

                            Schema objects that produce a false assertion result MUST NOT
                            produce any annotation results, whether from their own keywords
                            or from keywords in subschemas.¶

                            Note that the overall schema results may still include annotations
                            collected from other schema locations.  Given this schema:¶


{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}

¶


                            Against the instance "This is a string", the
                            title annotation "Integer Value" is discarded because the type assertion
                            in that schema object fails.  The title annotation "String Value"
                            is kept, as the instance passes the string type assertions.¶


            
7.7.1.3. Annotations and Applicators
            

                            In addition to possibly defining annotation results of their own,
                            applicator keywords aggregate the annotations collected in their
                            subschema(s) or referenced schema(s).¶\nJSON Schema can annotate an instance with information, whenever the instance
                    validates against the schema object containing the annotation, and all of its
                    parent schema objects.  The information can be a simple value, or can be
                    calculated based on the instance contents.¶\nAnnotations are attached to specific locations in an instance.
                    Since many subschemas can be applied to any single
                    location, applications may need to decide how to handle differing
                    annotation values being attached to the same instance location by
                    the same schema keyword in different schema objects.¶\nUnlike assertion results, annotation data can take a wide variety of forms,
                    which are provided to applications to use as they see fit.  JSON Schema
                    implementations are not expected to make use of the collected information
                    on behalf of applications.¶\nUnless otherwise specified, the value of an annotation keyword
                    is the keyword's value.  However, other behaviors are possible.
                    For example, JSON Hyper-Schema's [json-hyper-schema]
                    "links" keyword is a complex annotation that produces a value based
                    in part on the instance data.¶\nJSON Hyper-Schema's [json-hyper-schema]\nWhile "short-circuit" evaluation is possible for assertions, collecting
                    annotations requires examining all schemas that apply to an instance
                    location, even if they cannot change the overall assertion result.
                    The only exception is that subschemas of a schema object that has
                    failed validation MAY be skipped, as annotations are not retained
                    for failing schemas.¶\n7.7.1. Collecting Annotations\nCollecting Annotations\nAnnotations are collected by keywords that explicitly define
                        annotation-collecting behavior.  Note that boolean schemas cannot
                        produce annotations as they do not make use of keywords.¶\nA collected annotation MUST include the following information:¶\nThe name of the keyword that produces the annotation¶\nThe instance location to which it is attached, as a JSON Pointer¶\nThe schema location path, indicating how reference keywords
                                such as "$ref" were followed to reach the absolute schema location.¶\nThe absolute schema location of the attaching keyword, as a URI.
                                This MAY be omitted if it is the same as the schema location path
                                from above.¶\nThe attached value(s)¶\n7.7.1.1. Distinguishing Among Multiple Values\nDistinguishing Among Multiple Values\nApplications MAY make decisions on which of multiple annotation values
                            to use based on the schema location that contributed the value.
                            This is intended to allow flexible usage.  Collecting the schema location
                            facilitates such usage.¶\nFor example, consider this schema, which uses annotations and assertions from
                            the Validation specification [json-schema-validation]:¶\nValidation specification [json-schema-validation]\nValidation specification\njson-schema-validation\nNote that some lines are wrapped for clarity.¶\n{
    "title": "Feature list",
    "type": "array",
    "prefixItems": [
        {
            "title": "Feature A",
            "properties": {
                "enabled": {
                    "$ref": "#/$defs/enabledToggle",
                    "default": true
                }
            }
        },
        {
            "title": "Feature B",
            "properties": {
                "enabled": {
                    "description": "If set to null, Feature B
                                    inherits the enabled
                                    value from Feature A",
                    "$ref": "#/$defs/enabledToggle"
                }
            }
        }
    ],
    "$defs": {
        "enabledToggle": {
            "title": "Enabled",
            "description": "Whether the feature is enabled (true),
                            disabled (false), or under
                            automatic control (null)",
            "type": ["boolean", "null"],
            "default": null
        }
    }
}

¶\nIn this example, both Feature A and Feature B make use of the re-usable
                            "enabledToggle" schema.  That schema uses the "title", "description",
                            and "default" annotations.  Therefore the application has to decide how
                            to handle the additional "default" value for Feature A, and the additional
                            "description" value for Feature B.¶\nThe application programmer and the schema author need to agree on the
                            usage.  For this example, let's assume that they agree that the most
                            specific "default" value will be used, and any additional, more generic
                            "default" values will be silently ignored.  Let's also assume that they
                            agree that all "description" text is to be used, starting with the most
                            generic, and ending with the most specific.  This requires the schema
                            author to write descriptions that work when combined in this way.¶\nThe application can use the schema location path to determine which
                            values are which.  The values in the feature's immediate "enabled"
                            property schema are more specific, while the values under the re-usable
                            schema that is referenced to with "$ref" are more generic.  The schema
                            location path will show whether each value was found by crossing a
                            "$ref" or not.¶\nFeature A will therefore use a default value of true, while Feature B
                            will use the generic default value of null.  Feature A will only
                            have the generic description from the "enabledToggle" schema, while
                            Feature B will use that description, and also append its locally
                            defined description that explains how to interpret a null value.¶\nNote that there are other reasonable approaches that a different application
                            might take.  For example, an application may consider the presence of
                            two different values for "default" to be an error, regardless of their
                            schema locations.¶\n7.7.1.2. Annotations and Assertions\nAnnotations and Assertions\nSchema objects that produce a false assertion result MUST NOT
                            produce any annotation results, whether from their own keywords
                            or from keywords in subschemas.¶\nNote that the overall schema results may still include annotations
                            collected from other schema locations.  Given this schema:¶\n{
    "oneOf": [
        {
            "title": "Integer Value",
            "type": "integer"
        },
        {
            "title": "String Value",
            "type": "string"
        }
    ]
}

¶\nAgainst the instance "This is a string", the
                            title annotation "Integer Value" is discarded because the type assertion
                            in that schema object fails.  The title annotation "String Value"
                            is kept, as the instance passes the string type assertions.¶\n7.7.1.3. Annotations and Applicators\nAnnotations and Applicators\nIn addition to possibly defining annotation results of their own,
                            applicator keywords aggregate the annotations collected in their
                            subschema(s) or referenced schema(s).¶\n7.8. Reserved Locations\nA fourth category of keywords simply reserve a location to hold re-usable
                    components or data of interest to schema authors that is not suitable
                    for re-use.  These keywords do not affect validation or annotation results.
                    Their purpose in the core vocabulary is to ensure that locations are
                    available for certain purposes and will not be redefined by extension
                    keywords.¶\nWhile these keywords do not directly affect results, as explained in section
                    9.4.2 unrecognized
                    extension keywords that reserve locations for re-usable schemas may have
                    undesirable interactions with references in certain circumstances.¶\n7.9. Loading Instance Data\nLoading Instance Data\nWhile none of the vocabularies defined as part of this or the associated documents
                    define a keyword which may target and/or load instance data, it is possible that
                    other vocabularies may wish to do so.¶\nKeywords MAY be defined to use JSON Pointers or Relative JSON Pointers to examine
                    parts of an instance outside the current evaluation location.¶\nKeywords that allow adjusting the location using a Relative JSON Pointer SHOULD
                    default to using the current location if a default is desireable.¶\n8. The JSON Schema Core Vocabulary\nThe JSON Schema Core Vocabulary\nKeywords declared in this section, which all begin with "$", make up
                the JSON Schema Core vocabulary.  These keywords are either required in
                order to process any schema or meta-schema, including those split across
                multiple documents, or exist to reserve keywords for purposes that
                require guaranteed interoperability.¶\nThe Core vocabulary MUST be considered mandatory at all times, in order
                to bootstrap the processing of further vocabularies.  Meta-schemas
                that use the "$vocabulary" (Section 8.1) keyword
                to declare the vocabularies in use MUST explicitly list the Core vocabulary,
                which MUST have a value of true indicating that it is required.¶\n"$vocabulary" (Section 8.1)\nThe behavior of a false value for this vocabulary (and only this
                vocabulary) is undefined, as is the behavior when "$vocabulary"
                is present but the Core vocabulary is not included.  However, it
                is RECOMMENDED that implementations detect these cases and raise
                an error when they occur.  It is not meaningful to declare that
                a meta-schema optionally uses Core.¶\nMeta-schemas that do not use "$vocabulary" MUST be considered to
                require the Core vocabulary as if its URI were present with a value of true.¶\nThe current URI for the Core vocabulary is:
                <https://json-schema.org/draft/2020-12/vocab/core>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/core.¶\nhttps://json-schema.org/draft/2020-12/meta/core\nhttps://json-schema.org/draft/2020-12/meta/core\nWhile the "$" prefix is not formally reserved for the Core vocabulary,
                it is RECOMMENDED that extension keywords (in vocabularies or otherwise)
                begin with a character other than "$" to avoid possible future collisions.¶\n8.1. Meta-Schemas and Vocabularies
        

                    Two concepts, meta-schemas and vocabularies, are used to inform an implementation
                    how to interpret a schema.  Every schema has a meta-schema, which can be declared
                    using the "$schema" keyword.¶

                    The meta-schema serves two purposes:¶

          Declaring the vocabularies in use
          
                            The "$vocabulary" keyword, when it appears in a meta-schema, declares
                            which vocabularies are available to be used in schemas that refer
                            to that meta-schema.  Vocabularies define keyword semantics,
                            as well as their general syntax.¶

          
Describing valid schema syntax
          
                            A schema MUST successfully validate against its meta-schema, which
                            constrains the syntax of the available keywords.  The syntax described
                            is expected to be compatible with the vocabularies declared; while
                            it is possible to describe an incompatible syntax, such a meta-schema
                            would be unlikely to be useful.¶

        


                    Meta-schemas are separate from vocabularies to allow for
                    vocabularies to be combined in different ways, and for meta-schema authors
                    to impose additional constraints such as forbidding certain keywords, or
                    performing unusually strict syntactical validation, as might be done
                    during a development and testing cycle.  Each vocabulary typically identifies
                    a meta-schema consisting only of the vocabulary's keywords.¶

                    Meta-schema authoring is an advanced usage of JSON Schema, so the design of
                    meta-schema features emphasizes flexibility over simplicity.¶


          
8.1.1. The "$schema" Keyword
          

                        The "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶

                        The value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶

                        If this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶

                        The "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶

                        Values for this property are defined elsewhere in this and other documents,
                        and by other parties.¶



          
8.1.2. The "$vocabulary" Keyword
          

                        The "$vocabulary" keyword is used in meta-schemas to identify the
                        vocabularies available for use in schemas described by that meta-schema.
                        It is also used to indicate whether each vocabulary is required or optional,
                        in the sense that an implementation MUST understand the required vocabularies
                        in order to successfully process the schema. Together, this information forms
                        a dialect. Any vocabulary that is understood by the implementation MUST be
                        processed in a manner consistent with the semantic definitions contained
                        within the vocabulary.¶

                        The value of this keyword MUST be an object.  The property names in the
                        object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                        Each URI that appears as a property name identifies a specific set of
                        keywords and their semantics.¶

                        The URI MAY be a URL, but the nature of the retrievable resource is
                        currently undefined, and reserved for future use.  Vocabulary authors
                        MAY use the URL of the vocabulary specification, in a human-readable
                        media type such as text/html or text/plain, as the vocabulary URI.
                        
                            Vocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.
            ¶

                        The values of the object properties MUST be booleans.
                        If the value is true, then implementations that do not recognize
                        the vocabulary MUST refuse to process any schemas that declare
                        this meta-schema with "$schema".  If the value is false, implementations
                        that do not recognize the vocabulary SHOULD proceed with processing
                        such schemas.  The value has no impact if the implementation
                        understands the vocabulary.¶

                        Per 6.5, unrecognized
                        keywords SHOULD be treated as annotations.
                        This remains the case for keywords defined
                        by unrecognized vocabularies.  It is not currently possible to distinguish
                        between unrecognized keywords that are defined in vocabularies from
                        those that are not part of any vocabulary.¶

                        The "$vocabulary" keyword SHOULD be used in the root schema of any schema
                        document intended for use as a meta-schema.  It MUST NOT appear in subschemas.¶

                        The "$vocabulary" keyword MUST be ignored in schema documents that
                        are not being processed as a meta-schema.  This allows validating
                        a meta-schema M against its own meta-schema M' without requiring
                        the validator to understand the vocabularies declared by M.¶

            
8.1.2.1. Default vocabularies
            

                            If "$vocabulary" is absent, an implementation MAY determine
                            behavior based on the meta-schema if it is recognized from the
                            URI value of the referring schema's "$schema" keyword.
                            This is how behavior (such as Hyper-Schema usage) has been
                            recognized prior to the existence of vocabularies.¶

                            If the meta-schema, as referenced by the schema, is not recognized,
                            or is missing, then the behavior is implementation-defined.
                            If the implementation
                            proceeds with processing the schema, it MUST assume the use of the
                            core vocabulary.  If the implementation is built for a specific purpose,
                            then it SHOULD assume the use of all of the most relevant vocabularies
                            for that purpose.¶

                            For example, an implementation that is a validator
                            SHOULD assume the use of all vocabularies in this
                            specification and the companion Validation specification.¶


            
8.1.2.2. Non-inheritability of vocabularies
            

                            Note that the processing restrictions on "$vocabulary" mean that
                            meta-schemas that reference other meta-schemas using "$ref" or
                            similar keywords do not automatically inherit the vocabulary
                            declarations of those other meta-schemas.  All such declarations
                            must be repeated in the root of each schema document intended
                            for use as a meta-schema.  This is demonstrated in
                            the example meta-schema (Appendix D.2).
                            
                                This requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.
              ¶



          
8.1.3. Updates to Meta-Schema and Vocabulary URIs
          

                        Updated vocabulary and meta-schema URIs MAY be published between
                        specification drafts in order to correct errors.  Implementations
                        SHOULD consider URIs dated after this specification draft and
                        before the next to indicate the same syntax and semantics
                        as those listed here.¶\n8.1. Meta-Schemas and Vocabularies\nMeta-Schemas and Vocabularies\nTwo concepts, meta-schemas and vocabularies, are used to inform an implementation
                    how to interpret a schema.  Every schema has a meta-schema, which can be declared
                    using the "$schema" keyword.¶\nThe meta-schema serves two purposes:¶\nMeta-schemas are separate from vocabularies to allow for
                    vocabularies to be combined in different ways, and for meta-schema authors
                    to impose additional constraints such as forbidding certain keywords, or
                    performing unusually strict syntactical validation, as might be done
                    during a development and testing cycle.  Each vocabulary typically identifies
                    a meta-schema consisting only of the vocabulary's keywords.¶\nMeta-schema authoring is an advanced usage of JSON Schema, so the design of
                    meta-schema features emphasizes flexibility over simplicity.¶\n8.1.1. The "$schema" Keyword
          

                        The "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶

                        The value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶

                        If this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶

                        The "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶

                        Values for this property are defined elsewhere in this and other documents,
                        and by other parties.¶\n8.1.1. The "$schema" Keyword\nThe "$schema" Keyword\nThe "$schema" keyword is both used as a JSON Schema dialect identifier and
                        as the identifier of a resource which is itself a JSON Schema, which describes the
                        set of valid schemas written for this particular dialect.¶\nThe value of this keyword MUST be a URI [RFC3986]
                        (containing a scheme) and this URI MUST be normalized.
                        The current schema MUST be valid against the meta-schema identified by this URI.¶\nIf this URI identifies a retrievable resource, that resource SHOULD be of
                        media type "application/schema+json".¶\nThe "$schema" keyword SHOULD be used in the document root schema object,
                        and MAY be used in the root schema objects of embedded schema resources.
                        It MUST NOT appear in non-resource root schema objects.  If absent from
                        the document root schema, the resulting behavior is implementation-defined.¶\nValues for this property are defined elsewhere in this and other documents,
                        and by other parties.¶\n8.1.2. The "$vocabulary" Keyword\nThe "$vocabulary" Keyword\nThe "$vocabulary" keyword is used in meta-schemas to identify the
                        vocabularies available for use in schemas described by that meta-schema.
                        It is also used to indicate whether each vocabulary is required or optional,
                        in the sense that an implementation MUST understand the required vocabularies
                        in order to successfully process the schema. Together, this information forms
                        a dialect. Any vocabulary that is understood by the implementation MUST be
                        processed in a manner consistent with the semantic definitions contained
                        within the vocabulary.¶\nThe value of this keyword MUST be an object.  The property names in the
                        object MUST be URIs (containing a scheme) and this URI MUST be normalized.
                        Each URI that appears as a property name identifies a specific set of
                        keywords and their semantics.¶\nThe URI MAY be a URL, but the nature of the retrievable resource is
                        currently undefined, and reserved for future use.  Vocabulary authors
                        MAY use the URL of the vocabulary specification, in a human-readable
                        media type such as text/html or text/plain, as the vocabulary URI.
                        
                            Vocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.
            ¶\nVocabulary documents may be added in forthcoming drafts.
                            For now, identifying the keyword set is deemed sufficient as that,
                            along with meta-schema validation, is how the current "vocabularies"
                            work today.  Any future vocabulary document format will be specified
                            as a JSON document, so using text/html or other non-JSON formats
                            in the meantime will not produce any future ambiguity.\nThe values of the object properties MUST be booleans.
                        If the value is true, then implementations that do not recognize
                        the vocabulary MUST refuse to process any schemas that declare
                        this meta-schema with "$schema".  If the value is false, implementations
                        that do not recognize the vocabulary SHOULD proceed with processing
                        such schemas.  The value has no impact if the implementation
                        understands the vocabulary.¶\nPer 6.5, unrecognized
                        keywords SHOULD be treated as annotations.
                        This remains the case for keywords defined
                        by unrecognized vocabularies.  It is not currently possible to distinguish
                        between unrecognized keywords that are defined in vocabularies from
                        those that are not part of any vocabulary.¶\nThe "$vocabulary" keyword SHOULD be used in the root schema of any schema
                        document intended for use as a meta-schema.  It MUST NOT appear in subschemas.¶\nThe "$vocabulary" keyword MUST be ignored in schema documents that
                        are not being processed as a meta-schema.  This allows validating
                        a meta-schema M against its own meta-schema M' without requiring
                        the validator to understand the vocabularies declared by M.¶\n8.1.2.1. Default vocabularies\nIf "$vocabulary" is absent, an implementation MAY determine
                            behavior based on the meta-schema if it is recognized from the
                            URI value of the referring schema's "$schema" keyword.
                            This is how behavior (such as Hyper-Schema usage) has been
                            recognized prior to the existence of vocabularies.¶\nIf the meta-schema, as referenced by the schema, is not recognized,
                            or is missing, then the behavior is implementation-defined.
                            If the implementation
                            proceeds with processing the schema, it MUST assume the use of the
                            core vocabulary.  If the implementation is built for a specific purpose,
                            then it SHOULD assume the use of all of the most relevant vocabularies
                            for that purpose.¶\nFor example, an implementation that is a validator
                            SHOULD assume the use of all vocabularies in this
                            specification and the companion Validation specification.¶\n8.1.2.2. Non-inheritability of vocabularies\nNon-inheritability of vocabularies\nNote that the processing restrictions on "$vocabulary" mean that
                            meta-schemas that reference other meta-schemas using "$ref" or
                            similar keywords do not automatically inherit the vocabulary
                            declarations of those other meta-schemas.  All such declarations
                            must be repeated in the root of each schema document intended
                            for use as a meta-schema.  This is demonstrated in
                            the example meta-schema (Appendix D.2).
                            
                                This requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.
              ¶\nthe example meta-schema (Appendix D.2)\nthe example meta-schema\nThis requirement allows implementations to find all vocabulary
                                requirement information in a single place for each meta-schema.
                                As schema extensibility means that there are endless potential
                                ways to combine more fine-grained meta-schemas by reference,
                                requiring implementations to anticipate all possibilities and
                                search for vocabularies in referenced meta-schemas would
                                be overly burdensome.\n8.1.3. Updates to Meta-Schema and Vocabulary URIs\nUpdates to Meta-Schema and Vocabulary URIs\nUpdated vocabulary and meta-schema URIs MAY be published between
                        specification drafts in order to correct errors.  Implementations
                        SHOULD consider URIs dated after this specification draft and
                        before the next to indicate the same syntax and semantics
                        as those listed here.¶\n8.2. Base URI, Anchors, and Dereferencing\nBase URI, Anchors, and Dereferencing\nTo differentiate between schemas in a vast ecosystem, schemas are
                    identified by URI [RFC3986], and can embed references
                    to other schemas by specifying their URI.¶\nSeveral keywords can accept a relative URI-reference [RFC3986],
                    or a value used to construct a relative URI-reference.  For these keywords,
                    it is necessary to establish a base URI in order to resolve the reference.¶\nURI-reference [RFC3986]\n8.2.1. The "$id" Keyword
          

                        The "$id" keyword identifies a schema resource with its
                        canonical [RFC6596] URI.¶

                        Note that this URI is an identifier and not necessarily a network locator.
                        In the case of a network-addressable URL, a schema need not be downloadable
                        from its canonical URI.¶

                        If present, the value for this keyword MUST be a string, and MUST represent a
                        valid URI-reference [RFC3986].  This URI-reference
                        SHOULD be normalized, and MUST resolve to an
                        absolute-URI [RFC3986] (without a fragment),
                        or to a URI with an empty fragment.¶

                        The empty fragment form is NOT RECOMMENDED and is retained only
                        for backwards compatibility, and because the
                        application/schema+json media type defines that a URI with an
                        empty fragment identifies the same resource as the same URI
                        with the fragment removed.  However, since this equivalence is not
                        part of the RFC 3986 normalization process [RFC3986],
                        implementers and schema authors cannot rely on generic URI libraries
                        understanding it.¶

                        Therefore, "$id" MUST NOT contain a non-empty fragment, and SHOULD NOT
                        contain an empty fragment.  The absolute-URI form MUST be considered
                        the canonical URI, regardless of the presence or absence of an empty fragment.
                        
                            An empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".
            ¶

                        The absolute-URI also serves as the base URI for relative URI-references
                        in keywords within the schema resource, in accordance with
                        RFC 3986 section 5.1.1 [RFC3986] regarding base URIs
                        embedded in content.¶

                        The presence of "$id" in a subschema indicates that the subschema constitutes
                        a distinct schema resource within a single schema document.  Furthermore,
                        in accordance with RFC 3986 section 5.1.2 [RFC3986]
                        regarding encapsulating entities, if an "$id" in a subschema is a relative
                        URI-reference, the base URI for resolving that reference is the URI of
                        the parent schema resource.¶

                        If no parent schema object explicitly identifies itself as a resource
                        with "$id", the base URI is that of the entire document, as established
                        by the steps given in the previous section. (Section 9.1.1)¶

            
8.2.1.1. Identifying the root schema
            

                            The root schema of a JSON Schema document SHOULD contain an "$id" keyword
                            with an absolute-URI [RFC3986] (containing a scheme,
                            but no fragment).¶\n8.2.1. The "$id" Keyword\nThe "$id" keyword identifies a schema resource with its
                        canonical [RFC6596] URI.¶\nNote that this URI is an identifier and not necessarily a network locator.
                        In the case of a network-addressable URL, a schema need not be downloadable
                        from its canonical URI.¶\nIf present, the value for this keyword MUST be a string, and MUST represent a
                        valid URI-reference [RFC3986].  This URI-reference
                        SHOULD be normalized, and MUST resolve to an
                        absolute-URI [RFC3986] (without a fragment),
                        or to a URI with an empty fragment.¶\nURI-reference [RFC3986]\nabsolute-URI [RFC3986]\nThe empty fragment form is NOT RECOMMENDED and is retained only
                        for backwards compatibility, and because the
                        application/schema+json media type defines that a URI with an
                        empty fragment identifies the same resource as the same URI
                        with the fragment removed.  However, since this equivalence is not
                        part of the RFC 3986 normalization process [RFC3986],
                        implementers and schema authors cannot rely on generic URI libraries
                        understanding it.¶\nRFC 3986 normalization process [RFC3986]\nRFC 3986 normalization process\nTherefore, "$id" MUST NOT contain a non-empty fragment, and SHOULD NOT
                        contain an empty fragment.  The absolute-URI form MUST be considered
                        the canonical URI, regardless of the presence or absence of an empty fragment.
                        
                            An empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".
            ¶\nAn empty fragment is currently allowed because older meta-schemas have
                            an empty fragment in their $id (or previously, id).
                            A future draft may outright forbid even empty fragments in "$id".\nThe absolute-URI also serves as the base URI for relative URI-references
                        in keywords within the schema resource, in accordance with
                        RFC 3986 section 5.1.1 [RFC3986] regarding base URIs
                        embedded in content.¶\nRFC 3986 section 5.1.1 [RFC3986]\nRFC 3986 section 5.1.1\nThe presence of "$id" in a subschema indicates that the subschema constitutes
                        a distinct schema resource within a single schema document.  Furthermore,
                        in accordance with RFC 3986 section 5.1.2 [RFC3986]
                        regarding encapsulating entities, if an "$id" in a subschema is a relative
                        URI-reference, the base URI for resolving that reference is the URI of
                        the parent schema resource.¶\nRFC 3986 section 5.1.2 [RFC3986]\nRFC 3986 section 5.1.2\nIf no parent schema object explicitly identifies itself as a resource
                        with "$id", the base URI is that of the entire document, as established
                        by the steps given in the previous section. (Section 9.1.1)¶\nprevious section. (Section 9.1.1)\n8.2.1.1. Identifying the root schema\nIdentifying the root schema\nThe root schema of a JSON Schema document SHOULD contain an "$id" keyword
                            with an absolute-URI [RFC3986] (containing a scheme,
                            but no fragment).¶\nabsolute-URI [RFC3986]\n8.2.2. Defining location-independent identifiers
          

                        Using JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.¶

                        The "$anchor" and "$dynamicAnchor" keywords are used to specify such
                        fragments.  They are identifier keywords that can only be used to create
                        plain name fragments, rather than absolute URIs as seen with "$id".¶

                        The base URI to which the resulting fragment is appended is the canonical
                        URI of the schema resource containing the "$anchor" or "$dynamicAnchor"
                        in question.  As discussed in the previous section, this is either the
                        nearest "$id" in the same or parent schema object, or the base URI
                        for the document as determined according to RFC 3986.¶

                        Separately from the usual usage of URIs, "$dynamicAnchor"
                        indicates that the fragment is an extension point when used with
                        the "$dynamicRef" keyword.  This low-level, advanced feature
                        makes it easier to extend recursive schemas such as the meta-schemas,
                        without imposing any particular semantics on that extension.
                        See the section on "$dynamicRef" (Section 8.2.3.2)
                        for details.¶

                        In most cases, the normal fragment behavior both suffices and
                        is more intuitive.  Therefore it is RECOMMENDED that "$anchor"
                        be used to create plain name fragments unless there is a clear
                        need for "$dynamicAnchor".¶

                        If present, the value of this keyword MUST be a string and MUST start with
                        a letter ([A-Za-z]) or underscore ("_"), followed by any number of letters,
                        digits ([0-9]), hyphens ("-"), underscores ("_"), and periods (".").
                        This matches the US-ASCII part of XML's
                        NCName production [xml-names].
                        
                            Note that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.
            ¶

                        The effect of specifying the same fragment name multiple times within
                        the same resource, using any combination of "$anchor" and/or
                        "$dynamicAnchor", is undefined.  Implementations MAY
                        raise an error if such usage is detected.¶\n8.2.2. Defining location-independent identifiers\nDefining location-independent identifiers\nUsing JSON Pointer fragments requires knowledge of the structure of the schema.
                        When writing schema documents with the intention to provide re-usable
                        schemas, it may be preferable to use a plain name fragment that is not tied to
                        any particular structural location.  This allows a subschema to be relocated
                        without requiring JSON Pointer references to be updated.¶\nThe "$anchor" and "$dynamicAnchor" keywords are used to specify such
                        fragments.  They are identifier keywords that can only be used to create
                        plain name fragments, rather than absolute URIs as seen with "$id".¶\nThe base URI to which the resulting fragment is appended is the canonical
                        URI of the schema resource containing the "$anchor" or "$dynamicAnchor"
                        in question.  As discussed in the previous section, this is either the
                        nearest "$id" in the same or parent schema object, or the base URI
                        for the document as determined according to RFC 3986.¶\nSeparately from the usual usage of URIs, "$dynamicAnchor"
                        indicates that the fragment is an extension point when used with
                        the "$dynamicRef" keyword.  This low-level, advanced feature
                        makes it easier to extend recursive schemas such as the meta-schemas,
                        without imposing any particular semantics on that extension.
                        See the section on "$dynamicRef" (Section 8.2.3.2)
                        for details.¶\n"$dynamicRef" (Section 8.2.3.2)\nIn most cases, the normal fragment behavior both suffices and
                        is more intuitive.  Therefore it is RECOMMENDED that "$anchor"
                        be used to create plain name fragments unless there is a clear
                        need for "$dynamicAnchor".¶\nIf present, the value of this keyword MUST be a string and MUST start with
                        a letter ([A-Za-z]) or underscore ("_"), followed by any number of letters,
                        digits ([0-9]), hyphens ("-"), underscores ("_"), and periods (".").
                        This matches the US-ASCII part of XML's
                        NCName production [xml-names].
                        
                            Note that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.
            ¶\nNCName production [xml-names]\nNote that the anchor string does not include the "#" character,
                            as it is not a URI-reference.  An "$anchor": "foo" becomes the
                            fragment "#foo" when used in a URI.  See below for full examples.\nThe effect of specifying the same fragment name multiple times within
                        the same resource, using any combination of "$anchor" and/or
                        "$dynamicAnchor", is undefined.  Implementations MAY
                        raise an error if such usage is detected.¶\n8.2.3. Schema References
          

                        Several keywords can be used to reference a schema which is to be applied to the
                        current instance location. "$ref" and "$dynamicRef" are applicator
                        keywords, applying the referenced schema to the instance.¶

                        As the values of "$ref" and "$dynamicRef" are URI References, this allows
                        the possibility to externalise or divide a schema across multiple files,
                        and provides the ability to validate recursive structures through
                        self-reference.¶

                        The resolved URI produced by these keywords is not necessarily a network
                        locator, only an identifier. A schema need not be downloadable from the
                        address if it is a network-addressable URL, and implementations SHOULD NOT
                        assume they should perform a network operation when they encounter
                        a network-addressable URI.¶


            
8.2.3.1. Direct References with "$ref"
            

                            The "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶

                            The value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶




            
8.2.3.2. Dynamic References with "$dynamicRef"
            

                            The "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶

                            Together with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶

                            The value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶

                            If the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶

                            Otherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶

                            For a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\n8.2.3. Schema References\nSeveral keywords can be used to reference a schema which is to be applied to the
                        current instance location. "$ref" and "$dynamicRef" are applicator
                        keywords, applying the referenced schema to the instance.¶\nAs the values of "$ref" and "$dynamicRef" are URI References, this allows
                        the possibility to externalise or divide a schema across multiple files,
                        and provides the ability to validate recursive structures through
                        self-reference.¶\nThe resolved URI produced by these keywords is not necessarily a network
                        locator, only an identifier. A schema need not be downloadable from the
                        address if it is a network-addressable URL, and implementations SHOULD NOT
                        assume they should perform a network operation when they encounter
                        a network-addressable URI.¶\n8.2.3.1. Direct References with "$ref"
            

                            The "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶

                            The value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶\n8.2.3.1. Direct References with "$ref"\nDirect References with "$ref"\nThe "$ref" keyword is an applicator that is used to reference a statically
                            identified schema.  Its results are the results of the referenced schema.
                            
                                Note that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.
              ¶\nNote that this definition of how the results are determined means that
                                other keywords can appear alongside of "$ref" in the same schema object.\nThe value of the "$ref" keyword MUST be a string which is a URI-Reference.
                            Resolved against the current URI base, it produces the URI of the schema
                            to apply.  This resolution is safe to perform on schema load, as the
                            process of evaluating an instance cannot change how the reference resolves.¶\n8.2.3.2. Dynamic References with "$dynamicRef"
            

                            The "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶

                            Together with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶

                            The value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶

                            If the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶

                            Otherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶

                            For a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\n8.2.3.2. Dynamic References with "$dynamicRef"\nDynamic References with "$dynamicRef"\nThe "$dynamicRef" keyword is an applicator that allows for deferring the
                            full resolution until runtime, at which point it is resolved each time it is
                            encountered while evaluating an instance.¶\nTogether with "$dynamicAnchor", "$dynamicRef" implements a cooperative
                            extension mechanism that is primarily useful with recursive schemas
                            (schemas that reference themselves).  Both the extension point and the
                            runtime-determined extension target are defined with "$dynamicAnchor",
                            and only exhibit runtime dynamic behavior when referenced with
                            "$dynamicRef".¶\nThe value of the "$dynamicRef" property MUST be a string which is
                            a URI-Reference.  Resolved against the current URI base, it produces
                            the URI used as the starting point for runtime resolution.  This initial
                            resolution is safe to perform on schema load.¶\nIf the initially resolved starting point URI includes a fragment that
                            was created by the "$dynamicAnchor" keyword, the initial URI MUST be
                            replaced by the URI (including the fragment) for the outermost schema
                            resource in the dynamic scope (Section 7.1) that defines
                            an identically named fragment with "$dynamicAnchor".¶\ndynamic scope (Section 7.1)\nOtherwise, its behavior is identical to "$ref", and no runtime
                            resolution is needed.¶\nFor a full example using these keyword, see appendix
                            C.
                            
                                The difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.
              ¶\nThe difference between the hyper-schema meta-schema in pre-2019
                                drafts and an this draft dramatically demonstrates the utility
                                of these keywords.\n8.2.4. Schema Re-Use With "$defs"
          

                        The "$defs" keyword reserves a location for schema
                        authors to inline re-usable JSON Schemas into a more general schema.
                        The keyword does not directly affect the validation result.¶

                        This keyword's value MUST be an object.
                        Each member value of this object MUST be a valid JSON Schema.¶

                        As an example, here is a schema describing an array of positive
                        integers, where the positive integer constraint is a subschema in
                        "$defs":¶


{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}

¶\n8.2.4. Schema Re-Use With "$defs"\nSchema Re-Use With "$defs"\nThe "$defs" keyword reserves a location for schema
                        authors to inline re-usable JSON Schemas into a more general schema.
                        The keyword does not directly affect the validation result.¶\nThis keyword's value MUST be an object.
                        Each member value of this object MUST be a valid JSON Schema.¶\nAs an example, here is a schema describing an array of positive
                        integers, where the positive integer constraint is a subschema in
                        "$defs":¶\n{
    "type": "array",
    "items": { "$ref": "#/$defs/positiveInteger" },
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "exclusiveMinimum": 0
        }
    }
}

¶\n8.3. Comments With "$comment"\nComments With "$comment"\nThis keyword reserves a location for comments from schema authors
                    to readers or maintainers of the schema.¶\nThe value of this keyword MUST be a string. Implementations MUST NOT present this
                    string to end users.  Tools for editing schemas SHOULD support displaying and
                    editing this keyword.  The value of this keyword MAY be used in debug or error
                    output which is intended for developers making use of schemas.¶\nSchema vocabularies SHOULD allow "$comment" within any object containing
                    vocabulary keywords.  Implementations MAY assume "$comment" is allowed
                    unless the vocabulary specifically forbids it.  Vocabularies MUST NOT
                    specify any effect of "$comment" beyond what is described in this
                    specification.¶\nTools that translate other media types or programming languages
                    to and from application/schema+json MAY choose to convert that media type or
                    programming language's native comments to or from "$comment" values.
                    The behavior of such translation when both native comments and "$comment"
                    properties are present is implementation-dependent.¶\nImplementations MAY strip "$comment" values at any point during processing.
                    In particular, this allows for shortening schemas when the size of deployed
                    schemas is a concern.¶\nImplementations MUST NOT take any other action based on the presence, absence,
                    or contents of "$comment" properties.  In particular, the value of "$comment"
                    MUST NOT be collected as an annotation result.¶\n9. Loading and Processing Schemas\nLoading and Processing Schemas\n9.1. Loading a Schema\n9.1.1. Initial Base URI
          

                        RFC3986 Section 5.1 [RFC3986] defines how to determine the
                        default base URI of a document.¶

                        Informatively, the initial base URI of a schema is the URI at which it was
                        found, whether that was a network location, a local filesystem, or any other
                        situation identifiable by a URI of any known scheme.¶

                        If a schema document defines no explicit base URI with "$id"
                        (embedded in content), the base URI is that determined per
                        RFC 3986 section 5 [RFC3986].¶

                        If no source is known, or no URI scheme is known for the source, a suitable
                        implementation-specific default URI MAY be used as described in
                        RFC 3986 Section 5.1.4 [RFC3986].  It is RECOMMENDED
                        that implementations document any default base URI that they assume.¶

                        If a schema object is embedded in a document of another media type, then
                        the initial base URI is determined according to the rules of that
                        media type.¶

                        Unless the "$id" keyword described in an earlier section is present in the
                        root schema, this base URI SHOULD be considered the canonical URI of the
                        schema document's root schema resource.¶\n9.1.1. Initial Base URI\nRFC3986 Section 5.1 [RFC3986] defines how to determine the
                        default base URI of a document.¶\nRFC3986 Section 5.1 [RFC3986]\nInformatively, the initial base URI of a schema is the URI at which it was
                        found, whether that was a network location, a local filesystem, or any other
                        situation identifiable by a URI of any known scheme.¶\nIf a schema document defines no explicit base URI with "$id"
                        (embedded in content), the base URI is that determined per
                        RFC 3986 section 5 [RFC3986].¶\nRFC 3986 section 5 [RFC3986]\nIf no source is known, or no URI scheme is known for the source, a suitable
                        implementation-specific default URI MAY be used as described in
                        RFC 3986 Section 5.1.4 [RFC3986].  It is RECOMMENDED
                        that implementations document any default base URI that they assume.¶\nRFC 3986 Section 5.1.4 [RFC3986]\nRFC 3986 Section 5.1.4\nIf a schema object is embedded in a document of another media type, then
                        the initial base URI is determined according to the rules of that
                        media type.¶\nUnless the "$id" keyword described in an earlier section is present in the
                        root schema, this base URI SHOULD be considered the canonical URI of the
                        schema document's root schema resource.¶\n9.1.2. Loading a referenced schema\nLoading a referenced schema\nThe use of URIs to identify remote schemas does not necessarily mean anything is downloaded,
                        but instead JSON Schema implementations SHOULD understand ahead of time which schemas they will be using,
                        and the URIs that identify them.¶\nWhen schemas are downloaded,
                        for example by a generic user-agent that does not know until runtime which schemas to download,
                        see Usage for Hypermedia (Section 9.5.1).¶\nUsage for Hypermedia (Section 9.5.1)\nImplementations SHOULD be able to associate arbitrary URIs with an arbitrary
                        schema and/or automatically associate a schema's "$id"-given URI, depending
                        on the trust that the validator has in the schema.  Such URIs and schemas
                        can be supplied to an implementation prior to processing instances, or may
                        be noted within a schema document as it is processed, producing associations
                        as shown in appendix A.¶\nA schema MAY (and likely will) have multiple URIs, but there is no way for a
                        URI to identify more than one schema. When multiple schemas try to identify
                        as the same URI, validators SHOULD raise an error condition.¶\n9.1.3. Detecting a Meta-Schema\nDetecting a Meta-Schema\nImplementations MUST recognize a schema as a meta-schema if it
                        is being examined because it was identified as such by another
                        schema's "$schema" keyword.  This means that a single schema
                        document might sometimes be considered a regular schema, and
                        other times be considered a meta-schema.¶\nIn the case of examining a schema which is its own meta-schema,
                        when an implementation begins processing it as a regular schema,
                        it is processed under those rules.  However, when loaded a second
                        time as a result of checking its own "$schema" value, it is treated
                        as a meta-schema.  So the same document is processed both ways in
                        the course of one session.¶\nImplementations MAY allow a schema to be explicitly passed as a meta-schema,
                        for implementation-specific purposes, such as pre-loading a commonly
                        used meta-schema and checking its vocabulary support requirements
                        up front.  Meta-schema authors MUST NOT expect such features to be
                        interoperable across implementations.¶\nSchemas can be identified by any URI that has been given to them, including
                    a JSON Pointer or their URI given directly by "$id".  In all cases,
                    dereferencing a "$ref" reference involves first resolving its value as a
                    URI reference against the current base URI per
                    RFC 3986 [RFC3986].¶\nIf the resulting URI identifies a schema within the current document, or
                    within another schema document that has been made available to the implementation,
                    then that schema SHOULD be used automatically.¶\nFor example, consider this schema:¶\n{
    "$id": "https://example.net/root.json",
    "items": {
        "type": "array",
        "items": { "$ref": "#item" }
    },
    "$defs": {
        "single": {
            "$anchor": "item",
            "type": "object",
            "additionalProperties": { "$ref": "other.json" }
        }
    }
}

¶\nWhen an implementation encounters the <#/$defs/single> schema,
                    it resolves the "$anchor" value as a fragment name against the current
                    base URI to form <https://example.net/root.json#item>.¶\nWhen an implementation then looks inside the <#/items> schema, it
                    encounters the <#item> reference, and resolves this to
                    <https://example.net/root.json#item>, which it has seen defined in
                    this same document and can therefore use automatically.¶\nWhen an implementation encounters the reference to "other.json", it resolves
                    this to <https://example.net/other.json>, which is not defined in this
                    document.  If a schema with that identifier has otherwise been supplied to
                    the implementation, it can also be used automatically.
                    
                        What should implementations do when the referenced schema is not known?
                        Are there circumstances in which automatic network dereferencing is
                        allowed?  A same origin policy?  A user-configurable option?  In the
                        case of an evolving API described by Hyper-Schema, it is expected that
                        new schemas will be added to the system dynamically, so placing an
                        absolute requirement of pre-loading schema documents is not feasible.
          ¶\nWhat should implementations do when the referenced schema is not known?
                        Are there circumstances in which automatic network dereferencing is
                        allowed?  A same origin policy?  A user-configurable option?  In the
                        case of an evolving API described by Hyper-Schema, it is expected that
                        new schemas will be added to the system dynamically, so placing an
                        absolute requirement of pre-loading schema documents is not feasible.\n9.2.1. JSON Pointer fragments and embedded schema resources
          

                        Since JSON Pointer URI fragments are constructed based on the structure
                        of the schema document, an embedded schema resource and its subschemas
                        can be identified by JSON Pointer fragments relative to either its own
                        canonical URI, or relative to any containing resource's URI.¶

                        Conceptually, a set of linked schema resources should behave
                        identically whether each resource is a separate document connected with
                        schema references (Section 8.2.3), or is structured as
                        a single document with one or more schema resources embedded as
                        subschemas.¶

                        Since URIs involving JSON Pointer fragments relative to the parent
                        schema resource's URI cease to be valid when the embedded schema
                        is moved to a separate document and referenced, applications and schemas
                        SHOULD NOT use such URIs to identify embedded schema resources or
                        locations within them.¶

                            Consider the following schema document that contains another
                            schema resource embedded within it:¶


{
    "$id": "https://example.com/foo",
    "items": {
        "$id": "https://example.com/bar",
        "additionalProperties": { }
    }
}

¶


                        The URI "https://example.com/foo#/items" points to the "items" schema,
                        which is an embedded resource.  The canonical URI of that schema
                        resource, however, is "https://example.com/bar".¶

                        For the "additionalProperties" schema within that embedded resource,
                        the URI "https://example.com/foo#/items/additionalProperties" points
                        to the correct object, but that object's URI relative to its resource's
                        canonical URI is "https://example.com/bar#/additionalProperties".¶

                            Now consider the following two schema resources linked by reference
                            using a URI value for "$ref":¶


{
    "$id": "https://example.com/foo",
    "items": {
        "$ref": "bar"
    }
}

{
    "$id": "https://example.com/bar",
    "additionalProperties": { }
}

¶


                            Here we see that "https://example.com/bar#/additionalProperties",
                            using a JSON Pointer fragment appended to the canonical URI of
                            the "bar" schema resource, is still valid, while
                            "https://example.com/foo#/items/additionalProperties", which relied
                            on a JSON Pointer fragment appended to the canonical URI of the
                            "foo" schema resource, no longer resolves to anything.¶

                        Note also that "https://example.com/foo#/items" is valid in both
                        arrangements, but resolves to a different value.  This URI ends up
                        functioning similarly to a retrieval URI for a resource.  While this URI
                        is valid, it is more robust to use the "$id" of the embedded or referenced
                        resource unless it is specifically desired to identify the object containing
                        the "$ref" in the second (non-embedded) arrangement.¶

                        An implementation MAY choose not to support addressing schema resource
                        contents by URIs using a base other than the resource's canonical URI,
                        plus a JSON Pointer fragment relative to that base.  Therefore, schema
                        authors SHOULD NOT rely on such URIs, as using them may reduce interoperability.
                        
                            This is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)
            ¶

                        Further examples of such non-canonical URI construction, as well as
                        the appropriate canonical URI-based fragments to use instead,
                        are provided in appendix A.¶\n9.2.1. JSON Pointer fragments and embedded schema resources\nJSON Pointer fragments and embedded schema resources\nSince JSON Pointer URI fragments are constructed based on the structure
                        of the schema document, an embedded schema resource and its subschemas
                        can be identified by JSON Pointer fragments relative to either its own
                        canonical URI, or relative to any containing resource's URI.¶\nConceptually, a set of linked schema resources should behave
                        identically whether each resource is a separate document connected with
                        schema references (Section 8.2.3), or is structured as
                        a single document with one or more schema resources embedded as
                        subschemas.¶\nschema references (Section 8.2.3)\nSince URIs involving JSON Pointer fragments relative to the parent
                        schema resource's URI cease to be valid when the embedded schema
                        is moved to a separate document and referenced, applications and schemas
                        SHOULD NOT use such URIs to identify embedded schema resources or
                        locations within them.¶\nConsider the following schema document that contains another
                            schema resource embedded within it:¶\n{
    "$id": "https://example.com/foo",
    "items": {
        "$id": "https://example.com/bar",
        "additionalProperties": { }
    }
}

¶\nThe URI "https://example.com/foo#/items" points to the "items" schema,
                        which is an embedded resource.  The canonical URI of that schema
                        resource, however, is "https://example.com/bar".¶\nFor the "additionalProperties" schema within that embedded resource,
                        the URI "https://example.com/foo#/items/additionalProperties" points
                        to the correct object, but that object's URI relative to its resource's
                        canonical URI is "https://example.com/bar#/additionalProperties".¶\nNow consider the following two schema resources linked by reference
                            using a URI value for "$ref":¶\n{
    "$id": "https://example.com/foo",
    "items": {
        "$ref": "bar"
    }
}

{
    "$id": "https://example.com/bar",
    "additionalProperties": { }
}

¶\nHere we see that "https://example.com/bar#/additionalProperties",
                            using a JSON Pointer fragment appended to the canonical URI of
                            the "bar" schema resource, is still valid, while
                            "https://example.com/foo#/items/additionalProperties", which relied
                            on a JSON Pointer fragment appended to the canonical URI of the
                            "foo" schema resource, no longer resolves to anything.¶\nNote also that "https://example.com/foo#/items" is valid in both
                        arrangements, but resolves to a different value.  This URI ends up
                        functioning similarly to a retrieval URI for a resource.  While this URI
                        is valid, it is more robust to use the "$id" of the embedded or referenced
                        resource unless it is specifically desired to identify the object containing
                        the "$ref" in the second (non-embedded) arrangement.¶\nAn implementation MAY choose not to support addressing schema resource
                        contents by URIs using a base other than the resource's canonical URI,
                        plus a JSON Pointer fragment relative to that base.  Therefore, schema
                        authors SHOULD NOT rely on such URIs, as using them may reduce interoperability.
                        
                            This is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)
            ¶\nThis is to avoid requiring implementations to keep track of a whole
                            stack of possible base URIs and JSON Pointer fragments for each,
                            given that all but one will be fragile if the schema resources
                            are reorganized.  Some
                            have argued that this is easy so there is
                            no point in forbidding it, while others have argued that it complicates
                            schema identification and should be forbidden.  Feedback on this
                            topic is encouraged.
                            After some discussion, we feel that we need to remove the use of
                            "canonical" in favour of talking about JSON Pointers which reference
                            across schema resource boundaries as undefined or even forbidden behavior
                            (https://github.com/json-schema-org/json-schema-spec/issues/937,
                            https://github.com/json-schema-org/json-schema-spec/issues/1183)\nFurther examples of such non-canonical URI construction, as well as
                        the appropriate canonical URI-based fragments to use instead,
                        are provided in appendix A.¶\n9.3. Compound Documents\nA Compound Schema Document is defined as a JSON document (sometimes called a "bundled" schema)
                    which has multiple embedded JSON Schema Resources bundled into the same document to
                    ease transportation.¶\nEach embedded Schema Resource MUST be treated as an individual Schema Resource, following standard
                    schema loading and processing requirements, including determining vocabulary support.¶\nThe bundling process for creating a Compound Schema Document is defined as taking
                        references (such as "$ref") to an external Schema Resource and embedding the referenced
                        Schema Resources within the referring document. Bundling SHOULD be done in such a way that
                        all URIs (used for referencing) in the base document and any referenced/embedded
                        documents do not require altering.¶\nEach embedded JSON Schema Resource MUST identify itself with a URI using the "$id" keyword,
                        and SHOULD make use of the "$schema" keyword to identify the dialect it is using, in the root of the
                        schema resource. It is RECOMMENDED that the URI identifier value of "$id" be an Absolute URI.¶\nWhen the Schema Resource referenced by a by-reference applicator is bundled, it is RECOMMENDED that
                        the Schema Resource be located as a value of a "$defs" object at the containing schema's root.
                        The key of the "$defs" for the now embedded Schema Resource MAY be the "$id" of the bundled schema
                        or some other form of application defined unique identifier (such as a UUID). This key is not
                        intended to be referenced in JSON Schema, but may be used by an application to aid the
                        bundling process.¶\nA Schema Resource MAY be embedded in a location other than "$defs" where the location is defined
                        as a schema value.¶\nA Bundled Schema Resource MUST NOT be bundled by replacing the schema object from which it was
                        referenced, or by wrapping the Schema Resource in other applicator keywords.¶\nIn order to produce identical output, references in the containing schema document to the
                        previously external Schema Resources MUST NOT be changed, and now resolve to a schema using the
                        "$id" of an embedded Schema Resource. Such identical output includes validation evaluation and URIs
                        or paths used in resulting annotations or errors.¶\nWhile the bundling process will often be the main method for creating a Compound Schema Document,
                        it is also possible and expected that some will be created by hand, potentially without individual
                        Schema Resources existing on their own previously.¶\n9.3.2. Differing and Default Dialects\nDiffering and Default Dialects\nWhen multiple schema resources are present in a single document,
                        schema resources which do not define with which dialect they should be processed
                        MUST be processed with the same dialect as the enclosing resource.¶\nSince any schema that can be referenced can also be embedded, embedded schema resources MAY
                        specify different processing dialects using the "$schema" values from their enclosing resource.¶\nGiven that a Compound Schema Document may have embedded resources which identify as using different
                        dialects, these documents SHOULD NOT be validated by applying a meta-schema
                        to the Compound Schema Document as an instance. It is RECOMMENDED that an alternate
                        validation process be provided in order to validate Schema Documents. Each Schema Resource
                        SHOULD be separately validated against its associated meta-schema.
                        
                            If you know a schema is what's being validated, you can identify if the schemas
                            is a Compound Schema Document or not, by way of use of "$id", which identifies an
                            embedded resource when used not at the document's root.
            ¶\nIf you know a schema is what's being validated, you can identify if the schemas
                            is a Compound Schema Document or not, by way of use of "$id", which identifies an
                            embedded resource when used not at the document's root.\nA Compound Schema Document in which all embedded resources identify as using the same
                        dialect, or in which "$schema" is omitted and therefore defaults to that of the enclosing resource,
                        MAY be validated by applying the appropriate meta-schema.¶\n9.4.1. Guarding Against Infinite Recursion\nGuarding Against Infinite Recursion\nA schema MUST NOT be run into an infinite loop against an instance. For
                        example, if two schemas "#alice" and "#bob" both have an "allOf" property
                        that refers to the other, a naive validator might get stuck in an infinite
                        recursive loop trying to validate the instance.  Schemas SHOULD NOT make
                        use of infinite recursive nesting like this; the behavior is undefined.¶\n9.4.2. References to Possible Non-Schemas
          

                        Subschema objects (or booleans) are recognized by their use with known
                        applicator keywords or with location-reserving keywords such as
                        "$defs" (Section 8.2.4) that take one or more subschemas
                        as a value.  These keywords may be "$defs" and the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.¶

                        Multi-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
            ¶

                        Note that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.¶\n9.4.2. References to Possible Non-Schemas\nReferences to Possible Non-Schemas\nSubschema objects (or booleans) are recognized by their use with known
                        applicator keywords or with location-reserving keywords such as
                        "$defs" (Section 8.2.4) that take one or more subschemas
                        as a value.  These keywords may be "$defs" and the standard applicators
                        from this document, or extension keywords from a known vocabulary, or
                        implementation-specific custom keywords.¶\n"$defs" (Section 8.2.4)\nMulti-level structures of unknown keywords are capable of introducing
                        nested subschemas, which would be subject to the processing rules for
                        "$id".  Therefore, having a reference target in such an unrecognized
                        structure cannot be reliably implemented, and the resulting behavior
                        is undefined.  Similarly, a reference target under a known keyword,
                        for which the value is known not to be a schema, results in undefined
                        behavior in order to avoid burdening implementations with the need
                        to detect such targets.
                        
                            These scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.
            ¶\nThese scenarios are analogous to fetching a schema over HTTP
                            but receiving a response with a Content-Type other than
                            application/schema+json.  An implementation can certainly
                            try to interpret it as a schema, but the origin server
                            offered no guarantee that it actually is any such thing.
                            Therefore, interpreting it as such has security implications
                            and may produce unpredictable results.\nNote that single-level custom keywords with identical syntax and
                        semantics to "$defs" do not allow for any intervening "$id" keywords,
                        and therefore will behave correctly under implementations that attempt
                        to use any reference target as a schema.  However, this behavior is
                        implementation-specific and MUST NOT be relied upon for interoperability.¶\n9.5. Associating Instances and Schemas\nAssociating Instances and Schemas\n9.5.1. Usage for Hypermedia
          

                        JSON has been adopted widely by HTTP servers for automated APIs and robots. This
                        section describes how to enhance processing of JSON documents in a more RESTful
                        manner when used with protocols that support media types and
                        Web linking [RFC8288].¶

            
9.5.1.1. Linking to a Schema
            

                            It is RECOMMENDED that instances described by a schema provide a link to
                            a downloadable JSON Schema using the link relation "describedby", as defined by
                            Linked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226].¶

                            In HTTP, such links can be attached to any response using the
                            Link header [RFC8288]. An example of such a header would be:¶


        Link: <https://example.com/my-hyper-schema>; rel="describedby"

¶



            
9.5.1.2. Usage Over HTTP
            

                            When used for hypermedia systems over a network,
                            HTTP [RFC7231] is frequently the protocol of choice for
                            distributing schemas. Misbehaving clients can pose problems for server
                            maintainers if they pull a schema over the network more frequently than
                            necessary, when it's instead possible to cache a schema for a long period of
                            time.¶

                            HTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                            HTTP clients SHOULD observe caching headers and not re-request documents within
                            their freshness period.
                            Distributed systems SHOULD make use of a shared cache and/or caching proxy.¶

                            Clients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                            implementation or software product. Since symbols are listed in decreasing order
                            of significance, the JSON Schema library name/version should precede the more
                            generic HTTP library name (if any). For example:¶


        User-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

¶


                            Clients SHOULD be able to make requests with a "From" header so that server
                            operators can contact the owner of a potentially misbehaving script.¶\n9.5.1. Usage for Hypermedia\nJSON has been adopted widely by HTTP servers for automated APIs and robots. This
                        section describes how to enhance processing of JSON documents in a more RESTful
                        manner when used with protocols that support media types and
                        Web linking [RFC8288].¶\nWeb linking [RFC8288]\n9.5.1.1. Linking to a Schema\nIt is RECOMMENDED that instances described by a schema provide a link to
                            a downloadable JSON Schema using the link relation "describedby", as defined by
                            Linked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226].¶\nLinked Data Protocol 1.0, section 8.1 [W3C.REC-ldp-20150226]\nLinked Data Protocol 1.0, section 8.1\nIn HTTP, such links can be attached to any response using the
                            Link header [RFC8288]. An example of such a header would be:¶\nLink header [RFC8288]\nLink: <https://example.com/my-hyper-schema>; rel="describedby"

¶\n9.5.1.2. Usage Over HTTP\nWhen used for hypermedia systems over a network,
                            HTTP [RFC7231] is frequently the protocol of choice for
                            distributing schemas. Misbehaving clients can pose problems for server
                            maintainers if they pull a schema over the network more frequently than
                            necessary, when it's instead possible to cache a schema for a long period of
                            time.¶\nHTTP servers SHOULD set long-lived caching headers on JSON Schemas.
                            HTTP clients SHOULD observe caching headers and not re-request documents within
                            their freshness period.
                            Distributed systems SHOULD make use of a shared cache and/or caching proxy.¶\nClients SHOULD set or prepend a User-Agent header specific to the JSON Schema
                            implementation or software product. Since symbols are listed in decreasing order
                            of significance, the JSON Schema library name/version should precede the more
                            generic HTTP library name (if any). For example:¶\nUser-Agent: product-name/5.4.1 so-cool-json-schema/1.0.2 curl/7.43.0

¶\nClients SHOULD be able to make requests with a "From" header so that server
                            operators can contact the owner of a potentially misbehaving script.¶\n10. A Vocabulary for Applying Subschemas\nA Vocabulary for Applying Subschemas\nThis section defines a vocabulary of applicator keywords that
                are RECOMMENDED for use as the basis of other vocabularies.¶\nMeta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.¶\nThe current URI for this vocabulary, known as the Applicator vocabulary, is:
                <https://json-schema.org/draft/2020-12/vocab/applicator>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/applicator.¶\nhttps://json-schema.org/draft/2020-12/meta/applicator\nhttps://json-schema.org/draft/2020-12/meta/applicator\n10.1. Keyword Independence\nSchema keywords typically operate independently, without
                    affecting each other's outcomes.¶\nFor schema author convenience, there are some exceptions among the
                    keywords in this vocabulary:¶\n"additionalProperties", whose behavior is defined in terms of
                            "properties" and "patternProperties"¶\n"items", whose behavior is defined in terms of "prefixItems"¶\n"contains", whose behavior is affected by the presence and value of
                            "minContains", in the Validation vocabulary¶\n10.2. Keywords for Applying Subschemas in Place
        

                    These keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.¶

                    Subschemas of these keywords evaluate the instance completely independently
                    such that the results of one such subschema MUST NOT impact the results of sibling
                    subschemas.  Therefore subschemas may be applied in
                    any order.¶


          
10.2.1. Keywords for Applying Subschemas With Logic
          

                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶


            
10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶



            
10.2.1.2. anyOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶


            
10.2.1.3. oneOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶



            
10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶






          
10.2.2. Keywords for Applying Subschemas Conditionally
          

                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶

                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶

                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶

            
10.2.2.1. if
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶

                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶

                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶

                            If annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶


            
10.2.2.2. then
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.3. else
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.4. dependentSchemas
            

                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶

                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶

                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶

                            Omitting this keyword has the same behavior as an empty object.¶\n10.2. Keywords for Applying Subschemas in Place\nKeywords for Applying Subschemas in Place\nThese keywords apply subschemas to the same location in the instance
                    as the parent schema is being applied.  They allow combining
                    or modifying the subschema results in various ways.¶\nSubschemas of these keywords evaluate the instance completely independently
                    such that the results of one such subschema MUST NOT impact the results of sibling
                    subschemas.  Therefore subschemas may be applied in
                    any order.¶\n10.2.1. Keywords for Applying Subschemas With Logic
          

                        These keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶


            
10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶



            
10.2.1.2. anyOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶


            
10.2.1.3. oneOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶



            
10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\n10.2.1. Keywords for Applying Subschemas With Logic\nKeywords for Applying Subschemas With Logic\nThese keywords correspond to logical operators for combining or modifying
                        the boolean assertion results of the subschemas.  They have no direct
                        impact on annotation collection, although they enable the same annotation
                        keyword to be applied to an instance location with different values.
                        Annotation keywords define their own rules for combining such values.¶\n10.2.1.1. allOf
            

                            This keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶

                            An instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against all schemas defined by this keyword's value.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against at least one schema defined by this keyword's value.
                            Note that when annotations are being collected, all subschemas MUST
                            be examined so that annotations are collected from each subschema
                            that validates successfully.¶\nThis keyword's value MUST be a non-empty array.
                            Each item of the array MUST be a valid JSON Schema.¶\nAn instance validates successfully against this keyword if it validates
                            successfully against exactly one schema defined by this keyword's value.¶\n10.2.1.4. not
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            An instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nAn instance is valid against this keyword if it fails to validate
                            successfully against the schema defined by this keyword.¶\n10.2.2. Keywords for Applying Subschemas Conditionally
          

                        Three of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶

                        "if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶

                        There is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶

            
10.2.2.1. if
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            This validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶

                            Instances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶

                            Instances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶

                            If annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶


            
10.2.2.2. then
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.3. else
            

                            This keyword's value MUST be a valid JSON Schema.¶

                            When "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶

                            This keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶


            
10.2.2.4. dependentSchemas
            

                            This keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶

                            This keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶

                            If the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶

                            Omitting this keyword has the same behavior as an empty object.¶\n10.2.2. Keywords for Applying Subschemas Conditionally\nKeywords for Applying Subschemas Conditionally\nThree of these keywords work together to implement conditional
                        application of a subschema based on the outcome of another subschema.
                        The fourth is a shortcut for a specific conditional case.¶\n"if", "then", and "else" MUST NOT interact with each other across
                        subschema boundaries.  In other words, an "if" in one
                        branch of an "allOf" MUST NOT have an impact on a "then"
                        or "else" in another branch.¶\nThere is no default behavior for "if", "then", or "else"
                        when they are not present.  In particular, they MUST NOT
                        be treated as if present with an empty schema, and when
                        "if" is not present, both "then" and "else" MUST be
                        entirely ignored.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nThis validation outcome of this keyword's subschema
                            has no direct effect on the overall validation
                            result.  Rather, it controls which of the "then"
                            or "else" keywords are evaluated.¶\nInstances that successfully validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "then" keyword, if
                            present.¶\nInstances that fail to validate against this
                            keyword's subschema MUST also be valid against
                            the subschema value of the "else" keyword, if
                            present.¶\nIf annotations (Section 7.7)
                            are being collected, they are collected from this
                            keyword's subschema in the usual way, including when
                            the keyword is present without either "then" or "else".¶\nannotations (Section 7.7)\nThis keyword's value MUST be a valid JSON Schema.¶\nWhen "if" is present, and the instance successfully
                            validates against its subschema, then validation
                            succeeds against this keyword if the instance also
                            successfully validates against this keyword's subschema.¶\nThis keyword has no effect when "if" is absent, or
                            when the instance fails to validate against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶\nThis keyword's value MUST be a valid JSON Schema.¶\nWhen "if" is present, and the instance fails to
                            validate against its subschema, then validation
                            succeeds against this keyword if the instance
                            successfully validates against this keyword's subschema.¶\nThis keyword has no effect when "if" is absent, or
                            when the instance successfully validates against its
                            subschema.  Implementations MUST NOT evaluate
                            the instance against this keyword, for either validation
                            or annotation collection purposes, in such cases.¶\n10.2.2.4. dependentSchemas\nThis keyword specifies subschemas that are evaluated if the instance
                            is an object and contains a certain property.¶\nThis keyword's value MUST be an object.
                            Each value in the object MUST be a valid JSON Schema.¶\nIf the object key is a property in the instance, the entire
                            instance must validate against the subschema.  Its use is
                            dependent on the presence of the property.¶\nOmitting this keyword has the same behavior as an empty object.¶\n10.3. Keywords for Applying Subschemas to Child Instances\nKeywords for Applying Subschemas to Child Instances\nEach of these keywords defines a rule for applying its
                    subschema(s) to child instances, specifically object
                    properties and array items, and combining their results.¶\n10.3.1. Keywords for Applying Subschemas to Arrays\nKeywords for Applying Subschemas to Arrays\n10.3.1.1. prefixItems\nThe value of "prefixItems" MUST be a non-empty array of valid JSON Schemas.¶\nValidation succeeds if each element of the instance validates
                            against the schema at the same position, if any.  This keyword
                            does not constrain the length of the array.  If the array is longer
                            than this keyword's value, this keyword validates only the
                            prefix of matching length.¶\nThis keyword produces an annotation value which is the largest
                            index to which this keyword applied a subschema.  The value
                            MAY be a boolean true if a subschema was applied to every
                            index of the instance, such as is produced by the "items" keyword.
                            This annotation affects the behavior of "items" and "unevaluatedItems".¶\nOmitting this keyword has the same assertion behavior as
                            an empty array.¶\n10.3.1.2. items
            

                            The value of "items" MUST be a valid JSON Schema.¶

                            This keyword applies its subschema to all instance elements
                            at indexes greater than the length of the "prefixItems" array
                            in the same schema object, as reported by the annotation result
                            of that "prefixItems" keyword.  If no such annotation
                            result exists, "items" applies its subschema to all instance
                            array elements.
                            
                                Note that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.
              ¶

                            If the "items" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, indicating that all remaining array
                            elements have been evaluated against this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary.¶

                            Omitting this keyword has the same assertion behavior as
                            an empty schema.¶

                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of a "prefixItems" array.
                            Implementations that do not support annotation collection MUST do so.¶\nThe value of "items" MUST be a valid JSON Schema.¶\nThis keyword applies its subschema to all instance elements
                            at indexes greater than the length of the "prefixItems" array
                            in the same schema object, as reported by the annotation result
                            of that "prefixItems" keyword.  If no such annotation
                            result exists, "items" applies its subschema to all instance
                            array elements.
                            
                                Note that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.
              ¶\nNote that the behavior of "items" without "prefixItems" is
                                identical to that of the schema form of "items" in prior drafts.
                                When "prefixItems" is present, the behavior of "items" is
                                identical to the former "additionalItems" keyword.\nIf the "items" subschema is applied to any
                            positions within the instance array, it produces an
                            annotation result of boolean true, indicating that all remaining array
                            elements have been evaluated against this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty schema.¶\nImplementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking for the presence and size of a "prefixItems" array.
                            Implementations that do not support annotation collection MUST do so.¶\nThe value of this keyword MUST be a valid JSON Schema.¶\nAn array instance is valid against "contains" if at least one of
                            its elements is valid against the given schema,
                            except when "minContains" is present and has a value of 0, in which
                            case an array instance MUST be considered valid against the "contains" keyword,
                            even if none of its elements is valid against the given schema.¶\nThis keyword produces an annotation value which is an array of
                            the indexes to which this keyword validates successfully when applying
                            its subschema, in ascending order. The value MAY be a boolean "true" if
                            the subschema validates successfully when applied to every index of the
                            instance. The annotation MUST be present if the instance array to which
                            this keyword's schema applies is empty.¶\nThis annotation affects the behavior of "unevaluatedItems" in the
                            Unevaluated vocabulary, and MAY also be used to implement the
                            "minContains" and "maxContains" keywords in the Validation vocabulary.¶\nThe subschema MUST be applied to every array element even after the first
                            match has been found, in order to collect annotations for use by other
                            keywords. This is to ensure that all possible annotations are collected.¶\n10.3.2. Keywords for Applying Subschemas to Objects\nKeywords for Applying Subschemas to Objects\nThe value of "properties" MUST be an object.
                            Each value of this object MUST be a valid JSON Schema.¶\nValidation succeeds if, for each name that appears in both
                            the instance and as a name within this keyword's value, the child
                            instance for that name successfully validates against the
                            corresponding schema.¶\nThe annotation result of this keyword is the set of instance
                            property names matched by this keyword.
                            This annotation affects the behavior of "additionalProperties" (in
                            this vocabulary) and "unevaluatedProperties" in the Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty object.¶\n10.3.2.2. patternProperties\nThe value of "patternProperties" MUST be an object. Each property name
                            of this object SHOULD be a valid regular expression, according to the
                            ECMA-262 regular expression dialect. Each property value of this object
                            MUST be a valid JSON Schema.¶\nValidation succeeds if, for each instance name that matches any
                            regular expressions that appear as a property name in this keyword's value,
                            the child instance for that name successfully validates against each
                            schema that corresponds to a matching regular expression.¶\nThe annotation result of this keyword is the set of instance
                            property names matched by this keyword.
                            This annotation affects the behavior of "additionalProperties" (in this
                            vocabulary) and "unevaluatedProperties" (in the Unevaluated vocabulary).¶\nOmitting this keyword has the same assertion behavior as
                            an empty object.¶\n10.3.2.3. additionalProperties
            

                            The value of "additionalProperties" MUST be a valid JSON Schema.¶

                            The behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".¶

                            For all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.¶

                            The annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedProperties"
                            in the Unevaluated vocabulary.¶

                            Omitting this keyword has the same assertion behavior as
                            an empty schema.¶

                            Implementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                            
                                In defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.
              ¶\n10.3.2.3. additionalProperties\nThe value of "additionalProperties" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the presence and
                            annotation results of "properties" and "patternProperties"
                            within the same schema object.
                            Validation with "additionalProperties" applies only to the child
                            values of instance names that do not appear in the annotation
                            results of either "properties" or "patternProperties".¶\nFor all such properties, validation succeeds if the child instance
                            validates against the "additionalProperties" schema.¶\nThe annotation result of this keyword is the set of instance
                            property names validated by this keyword's subschema.
                            This annotation affects the behavior of "unevaluatedProperties"
                            in the Unevaluated vocabulary.¶\nOmitting this keyword has the same assertion behavior as
                            an empty schema.¶\nImplementations MAY choose to implement or optimize this keyword
                            in another way that produces the same effect, such as by directly
                            checking the names in "properties" and the patterns in
                            "patternProperties" against the instance property set.
                            Implementations that do not support annotation collection MUST do so.
                            
                                In defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.
              ¶\nIn defining this option, it seems there is the potential for
                                ambiguity in the output format. The ambiguity does not affect validation results,
                                but it does affect the resulting output format.
                                The ambiguity allows for multiple valid output results depending on whether annotations
                                are used or a solution that "produces the same effect" as draft-07. It is understood
                                that annotations from failing schemas are dropped.
                                See our
                                [Decision Record](https://github.com/json-schema-org/json-schema-spec/tree/HEAD/adr/2022-04-08-cref-for-ambiguity-and-fix-later-gh-spec-issue-1172.md)
                                for further details.\n10.3.2.4. propertyNames\nThe value of "propertyNames" MUST be a valid JSON Schema.¶\nIf the instance is an object, this keyword validates if every property name in
                            the instance validates against the provided schema.
                            Note the property name that the schema is testing will always be a string.¶\nOmitting this keyword has the same behavior as an empty schema.¶\n11. A Vocabulary for Unevaluated Locations\nA Vocabulary for Unevaluated Locations\nThe purpose of these keywords is to enable schema authors to apply
                subschemas to array items or object properties that have not been
                successfully evaluated against any dynamic-scope subschema of any
                adjacent keywords.¶\nThese instance items or properties may have been unsuccessfully evaluated
                against one or more adjacent keyword subschemas, such as when an assertion
                in a branch of an "anyOf" fails.  Such failed evaluations are not considered
                to contribute to whether or not the item or property has been evaluated.
                Only successful evaluations are considered.¶\nIf an item in an array or an object property is "successfully evaluated", it
                is logically considered to be valid in terms of the representation of the
                object or array that's expected. For example if a subschema represents a car,
                which requires between 2-4 wheels, and the value of "wheels" is 6, the instance
                object is not "evaluated" to be a car, and the "wheels" property is considered
                "unevaluated (successfully as a known thing)", and does not retain any annotations.¶\nRecall that adjacent keywords are keywords within the same schema object,
                and that the dynamic-scope subschemas include reference targets as well as
                lexical subschemas.¶\nThe behavior of these keywords depend on the annotation results of
                adjacent keywords that apply to the instance location being validated.¶\nMeta-schemas that do not use "$vocabulary" SHOULD be considered to
                require this vocabulary as if its URI were present with a value of true.¶\nThe current URI for this vocabulary, known as the Unevaluated Applicator
                vocabulary, is:
                <https://json-schema.org/draft/2020-12/vocab/unevaluated>.¶\nThe current URI for the corresponding meta-schema is:
                https://json-schema.org/draft/2020-12/meta/unevaluated.¶\nhttps://json-schema.org/draft/2020-12/meta/unevaluated\nhttps://json-schema.org/draft/2020-12/meta/unevaluated\n11.1. Keyword Independence\nSchema keywords typically operate independently, without
                    affecting each other's outcomes. However, the keywords in this
                    vocabulary are notable exceptions:¶\n"unevaluatedItems", whose behavior is defined in terms of annotations
                            from "prefixItems", "items", "contains", and itself¶\n"unevaluatedProperties", whose behavior is defined in terms of
                            annotations from "properties", "patternProperties",
                            "additionalProperties" and itself¶\n11.2. unevaluatedItems
        

                    The value of "unevaluatedItems" MUST be a valid JSON Schema.¶

                    The behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "prefixItems", "items", and "contains",
                    which can come from those keywords when they are adjacent to the
                    "unevaluatedItems" keyword. Those three annotations, as well as
                    "unevaluatedItems", can also result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶

                    If no relevant annotations are present, the "unevaluatedItems"
                    subschema MUST be applied to all locations in the array.
                    If a boolean true value is present from any of the relevant annotations,
                    "unevaluatedItems" MUST be ignored.  Otherwise, the subschema
                    MUST be applied to any index greater than the largest annotation
                    value for "prefixItems", which does not appear in any annotation
                    value for "contains".¶

                    This means that "prefixItems", "items", "contains", and all in-place
                    applicators MUST be evaluated before this keyword can be evaluated.
                    Authors of extension keywords MUST NOT define an in-place applicator
                    that would need to be evaluated after this keyword.¶

                    If the "unevaluatedItems" subschema is applied to any
                    positions within the instance array, it produces an
                    annotation result of boolean true, analogous to the
                    behavior of "items".
                    This annotation affects the behavior of "unevaluatedItems" in parent schemas.¶

                    Omitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.2. unevaluatedItems\nThe value of "unevaluatedItems" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "prefixItems", "items", and "contains",
                    which can come from those keywords when they are adjacent to the
                    "unevaluatedItems" keyword. Those three annotations, as well as
                    "unevaluatedItems", can also result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶\nin-place applicator (Section 10.2)\nIf no relevant annotations are present, the "unevaluatedItems"
                    subschema MUST be applied to all locations in the array.
                    If a boolean true value is present from any of the relevant annotations,
                    "unevaluatedItems" MUST be ignored.  Otherwise, the subschema
                    MUST be applied to any index greater than the largest annotation
                    value for "prefixItems", which does not appear in any annotation
                    value for "contains".¶\nThis means that "prefixItems", "items", "contains", and all in-place
                    applicators MUST be evaluated before this keyword can be evaluated.
                    Authors of extension keywords MUST NOT define an in-place applicator
                    that would need to be evaluated after this keyword.¶\nIf the "unevaluatedItems" subschema is applied to any
                    positions within the instance array, it produces an
                    annotation result of boolean true, analogous to the
                    behavior of "items".
                    This annotation affects the behavior of "unevaluatedItems" in parent schemas.¶\nOmitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.3. unevaluatedProperties
        

                    The value of "unevaluatedProperties" MUST be a valid JSON Schema.¶

                    The behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "properties", "patternProperties",
                    and "additionalProperties", which can come from those keywords when
                    they are adjacent to the "unevaluatedProperties" keyword.  Those
                    three annotations, as well as "unevaluatedProperties", can also
                    result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶

                    Validation with "unevaluatedProperties" applies only to the child
                    values of instance names that do not appear in the "properties",
                    "patternProperties", "additionalProperties", or
                    "unevaluatedProperties" annotation results that apply to the
                    instance location being validated.¶

                    For all such properties, validation succeeds if the child instance
                    validates against the "unevaluatedProperties" schema.¶

                    This means that "properties", "patternProperties", "additionalProperties",
                    and all in-place applicators MUST be evaluated before this keyword can
                    be evaluated.  Authors of extension keywords MUST NOT define an in-place
                    applicator that would need to be evaluated after this keyword.¶

                    The annotation result of this keyword is the set of instance
                    property names validated by this keyword's subschema.
                    This annotation affects the behavior of "unevaluatedProperties" in parent schemas.¶

                    Omitting this keyword has the same assertion behavior as
                    an empty schema.¶\n11.3. unevaluatedProperties\nunevaluatedProperties\nThe value of "unevaluatedProperties" MUST be a valid JSON Schema.¶\nThe behavior of this keyword depends on the annotation results of
                    adjacent keywords that apply to the instance location being validated.
                    Specifically, the annotations from "properties", "patternProperties",
                    and "additionalProperties", which can come from those keywords when
                    they are adjacent to the "unevaluatedProperties" keyword.  Those
                    three annotations, as well as "unevaluatedProperties", can also
                    result from any and all adjacent
                    in-place applicator (Section 10.2) keywords.
                    This includes but is not limited to the in-place applicators
                    defined in this document.¶\nin-place applicator (Section 10.2)\nValidation with "unevaluatedProperties" applies only to the child
                    values of instance names that do not appear in the "properties",
                    "patternProperties", "additionalProperties", or
                    "unevaluatedProperties" annotation results that apply to the
                    instance location being validated.¶\nFor all such properties, validation succeeds if the child instance
                    validates against the "unevaluatedProperties" schema.¶\nThis means that "properties", "patternProperties", "additionalProperties",
                    and all in-place applicators MUST be evaluated before this keyword can
                    be evaluated.  Authors of extension keywords MUST NOT define an in-place
                    applicator that would need to be evaluated after this keyword.¶\nThe annotation result of this keyword is the set of instance
                    property names validated by this keyword's subschema.
                    This annotation affects the behavior of "unevaluatedProperties" in parent schemas.¶\nOmitting this keyword has the same assertion behavior as
                    an empty schema.¶\n12. Output Formatting
      

                JSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.¶

        
12.1. Format
        

                    JSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.¶


        
12.2. Output Formats
        

                    This specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.¶


                            Flag - A boolean which simply indicates the overall validation result
                            with no further details.¶

          
                            Basic - Provides validation information in a flat list structure.¶

          
                            Detailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.¶

          
                            Verbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.¶

        

                    An implementation SHOULD provide at least one of the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    "detailed" or "verbose" formats, it MUST also provide the "flag" format.
                    Implementations SHOULD specify in their documentation which formats they support.¶


        
12.3. Minimum Information
        

                    Beyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.¶

                    A single object that contains all of these components is considered an
                    output unit.¶

                    Implementations MAY elect to provide additional information.¶

          
12.3.1. Keyword Relative Location
          

                        The relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$dynamicRef".¶


/properties/width/$ref/minimum

¶


                    Note that this pointer may not be resolvable by the normal JSON Pointer process
                    due to the inclusion of these by-reference applicator keywords.¶

                        The JSON key for this information is "keywordLocation".¶


          
12.3.2. Keyword Absolute Location
          

                        The absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as a full URI using the canonical URI of the relevant schema resource
                        with a JSON Pointer fragment, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$dynamicRef" as non-terminal path components.
                        It MAY end in such keywords if the error or annotation is for that
                        keyword, such as an unresolvable reference.
                        
                            Note that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.
            ¶


https://example.com/schemas/common#/$defs/count/minimum

¶


                        This information MAY be omitted only if either the dynamic scope did not pass
                        over a reference or if the schema does not declare an absolute URI as its "$id".¶

                        The JSON key for this information is "absoluteKeywordLocation".¶


          
12.3.3. Instance Location
          

                        The location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.¶

                        The JSON key for this information is "instanceLocation".¶


          
12.3.4. Error or Annotation
          

                        The error or annotation that is produced by the validation.¶

                        For errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.¶

                        For annotations, each keyword that produces an annotation specifies its
                        format.  By default, it is the keyword's value.¶

                        The JSON key for failed validations is "error"; for successful validations
                        it is "annotation".¶


          
12.3.5. Nested Results
          

                        For the two hierarchical structures, this property will hold nested errors
                        and annotations.¶

                        The JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".  Note the plural forms, as
                        a keyword with nested results can also have a local error or annotation.¶



        
12.4. Output Structure
        

                    The output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.¶


                            "valid" - a boolean value indicating the overall validation success or
                            failure¶

          
                            "errors" - the collection of errors or annotations produced by a failed
                            validation¶

          
                            "annotations" - the collection of errors or annotations produced by a
                            successful validation¶

        

                    For these examples, the following schema and instance will be used.¶


{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3
  },
  {
    "x": 1,
    "z": 6.7
  }
]

¶


                    This instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.¶

                    Specifically, the errors it will produce are:¶


                            The second object is missing a "y" property.¶

          
                            The second object has a disallowed "z" property.¶

          
                            There are only two objects, but three are required.¶

        

                    Note that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.¶

          
12.4.1. Flag
          

                        In the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.¶


{
  "valid": false
}

¶


                        Because no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.¶


          
12.4.2. Basic
          

                        The "Basic" structure is a flat list of output units.¶


{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "",
      "instanceLocation": "",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref/required",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/required",
      "instanceLocation": "/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/additionalProperties",
      "instanceLocation": "/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶



          
12.4.3. Detailed
          

                        The "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correlation is more easily identified.¶

                        The following rules govern the construction of the results object:¶


                                All applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.¶

            
                                Nodes that have no children are removed.¶

            
                                Nodes that have a single child are replaced by the child.¶

          

                        Branch nodes do not require an error message or an annotation.¶


{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/items/$ref/required",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/required",
          "instanceLocation": "/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/additionalProperties",
          "instanceLocation": "/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶



          
12.4.4. Verbose
          

                        The "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.¶

                        The primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.¶

                        Because this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        https://json-schema.org/draft/2020-12/output/verbose-example.¶


// schema
{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "/type",
      "instanceLocation": ""
    },
    {
      "valid": true,
      "keywordLocation": "/properties",
      "instanceLocation": ""
    },
    {
      "valid": false,
      "keywordLocation": "/additionalProperties",
      "instanceLocation": "",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/additionalProperties",
          "instanceLocation": "/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}

¶



          
12.4.5. Output validation schemas
          

                        For convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        https://json-schema.org/draft/2020-12/output/schema.¶\n12. Output Formatting\nJSON Schema is defined to be platform-independent.  As such, to increase compatibility
                across platforms, implementations SHOULD conform to a standard validation output
                format.  This section describes the minimum requirements that consumers will need to
                properly interpret validation results.¶\nJSON Schema output is defined using the JSON Schema data instance model as described
                    in section 4.2.1.  Implementations MAY deviate from this as supported by their
                    specific languages and platforms, however it is RECOMMENDED that the output be
                    convertible to the JSON format defined herein via serialization or other means.¶\nThis specification defines four output formats.  See the "Output Structure"
                    section for the requirements of each format.¶\nFlag - A boolean which simply indicates the overall validation result
                            with no further details.¶\nBasic - Provides validation information in a flat list structure.¶\nDetailed - Provides validation information in a condensed hierarchical
                            structure based on the structure of the schema.¶\nVerbose - Provides validation information in an uncondensed hierarchical
                            structure that matches the exact structure of the schema.¶\nAn implementation SHOULD provide at least one of the "flag", "basic", or "detailed"
                    format and MAY provide the "verbose" format.  If it provides one or more of the
                    "detailed" or "verbose" formats, it MUST also provide the "flag" format.
                    Implementations SHOULD specify in their documentation which formats they support.¶\n12.3. Minimum Information\nBeyond the simplistic "flag" output, additional information is useful to aid in
                    debugging a schema or instance.  Each sub-result SHOULD contain the information
                    contained within this section at a minimum.¶\nA single object that contains all of these components is considered an
                    output unit.¶\nImplementations MAY elect to provide additional information.¶\n12.3.1. Keyword Relative Location\nKeyword Relative Location\nThe relative location of the validating keyword that follows the validation
                        path.  The value MUST be expressed as a JSON Pointer, and it MUST include
                        any by-reference applicators such as "$ref" or "$dynamicRef".¶\n/properties/width/$ref/minimum

¶\nNote that this pointer may not be resolvable by the normal JSON Pointer process
                    due to the inclusion of these by-reference applicator keywords.¶\nThe JSON key for this information is "keywordLocation".¶\n12.3.2. Keyword Absolute Location\nKeyword Absolute Location\nThe absolute, dereferenced location of the validating keyword.  The value MUST
                        be expressed as a full URI using the canonical URI of the relevant schema resource
                        with a JSON Pointer fragment, and it MUST NOT include by-reference applicators
                        such as "$ref" or "$dynamicRef" as non-terminal path components.
                        It MAY end in such keywords if the error or annotation is for that
                        keyword, such as an unresolvable reference.
                        
                            Note that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.
            ¶\nNote that "absolute" here is in the sense of "absolute filesystem path"
                            (meaning the complete location) rather than the "absolute-URI"
                            terminology from RFC 3986 (meaning with scheme but without fragment).
                            Keyword absolute locations will have a fragment in order to
                            identify the keyword.\nhttps://example.com/schemas/common#/$defs/count/minimum

¶\nThis information MAY be omitted only if either the dynamic scope did not pass
                        over a reference or if the schema does not declare an absolute URI as its "$id".¶\nThe JSON key for this information is "absoluteKeywordLocation".¶\n12.3.3. Instance Location\nThe location of the JSON value within the instance being validated.  The
                        value MUST be expressed as a JSON Pointer.¶\nThe JSON key for this information is "instanceLocation".¶\n12.3.4. Error or Annotation\nThe error or annotation that is produced by the validation.¶\nFor errors, the specific wording for the message is not defined by this
                        specification.  Implementations will need to provide this.¶\nFor annotations, each keyword that produces an annotation specifies its
                        format.  By default, it is the keyword's value.¶\nThe JSON key for failed validations is "error"; for successful validations
                        it is "annotation".¶\n12.3.5. Nested Results\nFor the two hierarchical structures, this property will hold nested errors
                        and annotations.¶\nThe JSON key for nested results in failed validations is "errors"; for
                        successful validations it is "annotations".  Note the plural forms, as
                        a keyword with nested results can also have a local error or annotation.¶\n12.4. Output Structure\nThe output MUST be an object containing a boolean property named "valid".  When
                    additional information about the result is required, the output MUST also contain
                    "errors" or "annotations" as described below.¶\n"valid" - a boolean value indicating the overall validation success or
                            failure¶\n"errors" - the collection of errors or annotations produced by a failed
                            validation¶\n"annotations" - the collection of errors or annotations produced by a
                            successful validation¶\nFor these examples, the following schema and instance will be used.¶\n{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "point": {
      "type": "object",
      "properties": {
        "x": { "type": "number" },
        "y": { "type": "number" }
      },
      "additionalProperties": false,
      "required": [ "x", "y" ]
    }
  },
  "type": "array",
  "items": { "$ref": "#/$defs/point" },
  "minItems": 3
}

[
  {
    "x": 2.5,
    "y": 1.3
  },
  {
    "x": 1,
    "z": 6.7
  }
]

¶\nThis instance will fail validation and produce errors, but it's trivial to deduce
                    examples for passing schemas that produce annotations.¶\nSpecifically, the errors it will produce are:¶\nThe second object is missing a "y" property.¶\nThe second object has a disallowed "z" property.¶\nThere are only two objects, but three are required.¶\nNote that the error message wording as depicted in these examples is not a
                    requirement of this specification.  Implementations SHOULD craft error messages
                    tailored for their audience or provide a templating mechanism that allows their
                    users to craft their own messages.¶\nIn the simplest case, merely the boolean result for the "valid" valid property
                        needs to be fulfilled.¶\n{
  "valid": false
}

¶\nBecause no errors or annotations are returned with this format, it is
                        RECOMMENDED that implementations use short-circuiting logic to return
                        failure or success as soon as the outcome can be determined.  For example,
                        if an "anyOf" keyword contains five sub-schemas, and the second one
                        passes, there is no need to check the other three.  The logic can simply
                        return with success.¶\nThe "Basic" structure is a flat list of output units.¶\n{
  "valid": false,
  "errors": [
    {
      "keywordLocation": "",
      "instanceLocation": "",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "error": "A subschema had errors."
    },
    {
      "keywordLocation": "/items/$ref/required",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/required",
      "instanceLocation": "/1",
      "error": "Required property 'y' not found."
    },
    {
      "keywordLocation": "/items/$ref/additionalProperties",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point/additionalProperties",
      "instanceLocation": "/1/z",
      "error": "Additional property 'z' found but was invalid."
    },
    {
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶\nThe "Detailed" structure is based on the schema and can be more readable
                        for both humans and machines.  Having the structure organized this way makes
                        associations between the errors more apparent.  For example, the fact that
                        the missing "y" property and the extra "z" property both stem from the same
                        location in the instance is not immediately obvious in the "Basic" structure.
                        In a hierarchy, the correlation is more easily identified.¶\nThe following rules govern the construction of the results object:¶\nAll applicator keywords ("*Of", "$ref", "if"/"then"/"else", etc.) require
                                a node.¶\nNodes that have no children are removed.¶\nNodes that have a single child are replaced by the child.¶\nBranch nodes do not require an error message or an annotation.¶\n{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": false,
      "keywordLocation": "/items/$ref",
      "absoluteKeywordLocation":
        "https://example.com/polygon#/$defs/point",
      "instanceLocation": "/1",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/items/$ref/required",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/required",
          "instanceLocation": "/1",
          "error": "Required property 'y' not found."
        },
        {
          "valid": false,
          "keywordLocation": "/items/$ref/additionalProperties",
          "absoluteKeywordLocation":
            "https://example.com/polygon#/$defs/point/additionalProperties",
          "instanceLocation": "/1/z",
          "error": "Additional property 'z' found but was invalid."
        }
      ]
    },
    {
      "valid": false,
      "keywordLocation": "/minItems",
      "instanceLocation": "",
      "error": "Expected at least 3 items but found 2"
    }
  ]
}

¶\nThe "Verbose" structure is a fully realized hierarchy that exactly matches
                        that of the schema.  This structure has applications in form generation and
                        validation where the error's location is important.¶\nThe primary difference between this and the "Detailed" structure is that
                        all results are returned.  This includes sub-schema validation results that
                        would otherwise be removed (e.g. annotations for failed validations,
                        successful validations inside a `not` keyword, etc.).  Because of this, it
                        is RECOMMENDED that each node also carry a `valid` property to indicate the
                        validation result for that node.¶\nBecause this output structure can be quite large, a smaller example is given
                        here for brevity.  The URI of the full output structure of the example above is:
                        https://json-schema.org/draft/2020-12/output/verbose-example.¶\nhttps://json-schema.org/draft/2020-12/output/verbose-example\nhttps://json-schema.org/draft/2020-12/output/verbose-example\n// schema
{
  "$id": "https://example.com/polygon",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "validProp": true,
  },
  "additionalProperties": false
}

// instance
{
  "validProp": 5,
  "disallowedProp": "value"
}

// result
{
  "valid": false,
  "keywordLocation": "",
  "instanceLocation": "",
  "errors": [
    {
      "valid": true,
      "keywordLocation": "/type",
      "instanceLocation": ""
    },
    {
      "valid": true,
      "keywordLocation": "/properties",
      "instanceLocation": ""
    },
    {
      "valid": false,
      "keywordLocation": "/additionalProperties",
      "instanceLocation": "",
      "errors": [
        {
          "valid": false,
          "keywordLocation": "/additionalProperties",
          "instanceLocation": "/disallowedProp",
          "error": "Additional property 'disallowedProp' found but was invalid."
        }
      ]
    }
  ]
}

¶\n12.4.5. Output validation schemas\nOutput validation schemas\nFor convenience, JSON Schema has been provided to validate output generated
                        by implementations.  Its URI is:
                        https://json-schema.org/draft/2020-12/output/schema.¶\nhttps://json-schema.org/draft/2020-12/output/schema\nhttps://json-schema.org/draft/2020-12/output/schema\n13. Security Considerations
      

                Both schemas and instances are JSON values. As such, all security considerations
                defined in RFC 8259 [RFC8259] apply.¶

                Instances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas does not consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.¶

                A malicious party could cause an implementation to repeatedly collect a copy
                of a very large value as an annotation.  Implementations SHOULD guard against
                excessive consumption of system resources in such a scenario.¶

                Servers MUST ensure that malicious parties cannot change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".¶

                Individual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.¶

                Schema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.¶

                A malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.¶\n13. Security Considerations\nSecurity Considerations\nBoth schemas and instances are JSON values. As such, all security considerations
                defined in RFC 8259 [RFC8259] apply.¶\nInstances and schemas are both frequently written by untrusted third parties, to be
                deployed on public Internet servers.
                Validators should take care that the parsing and validating against schemas does not consume excessive
                system resources.
                Validators MUST NOT fall into an infinite loop.¶\nA malicious party could cause an implementation to repeatedly collect a copy
                of a very large value as an annotation.  Implementations SHOULD guard against
                excessive consumption of system resources in such a scenario.¶\nServers MUST ensure that malicious parties cannot change the functionality of
                existing schemas by uploading a schema with a pre-existing or very similar "$id".¶\nIndividual JSON Schema vocabularies are liable to also have their own security
                considerations. Consult the respective specifications for more information.¶\nSchema authors should take care with "$comment" contents, as a malicious
                implementation can display them to end-users in violation of a spec, or
                fail to strip them if such behavior is expected.¶\nA malicious schema author could place executable code or other dangerous
                material within a "$comment".  Implementations MUST NOT parse or otherwise
                take action based on "$comment" contents.¶\n14. IANA Considerations\n14.1. application/schema+json\napplication/schema+json\nThe proposed MIME media type for JSON Schema is defined as follows:¶\nType name: application¶\nSubtype name: schema+json¶\nRequired parameters: N/A¶\nEncoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See JSON [RFC8259].¶\nSecurity considerations: See Section
                            13 above.¶\nInteroperability considerations: See Sections
                            6.2,
                            6.3, and
                            6.4 above.¶\nFragment identifier considerations: See Section
                            5¶\n14.2. application/schema-instance+json\napplication/schema-instance+json\nThe proposed MIME media type for JSON Schema Instances that require
                    a JSON Schema-specific media type is defined as follows:¶\nType name: application¶\nSubtype name: schema-instance+json¶\nRequired parameters: N/A¶\nEncoding considerations: Encoding considerations are
                            identical to those specified for the "application/json"
                            media type.  See JSON [RFC8259].¶\nSecurity considerations: See Section
                            13 above.¶\nInteroperability considerations: See Sections
                            6.2,
                            6.3, and
                            6.4 above.¶\nFragment identifier considerations: See Section
                            5¶\n15.1. Normative References\n"Key words for use in RFCs to Indicate Requirement Levels"\n<https://www.rfc-editor.org/info/rfc2119>\nhttps://www.rfc-editor.org/info/rfc2119\n"Uniform Resource Identifier (URI): Generic Syntax"\n<https://www.rfc-editor.org/info/rfc3986>\nhttps://www.rfc-editor.org/info/rfc3986\n"Additional Media Type Structured Syntax Suffixes"\n<https://www.rfc-editor.org/info/rfc6839>\nhttps://www.rfc-editor.org/info/rfc6839\n"JavaScript Object Notation (JSON) Pointer"\n<https://www.rfc-editor.org/info/rfc6901>\nhttps://www.rfc-editor.org/info/rfc6901\n"The JavaScript Object Notation (JSON) Data Interchange Format"\n<https://www.rfc-editor.org/info/rfc8259>\nhttps://www.rfc-editor.org/info/rfc8259\n"Linked Data Platform 1.0"\nWorld Wide Web Consortium Recommendation REC-ldp-20150226\n<https://www.w3.org/TR/2015/REC-ldp-20150226>\nhttps://www.w3.org/TR/2015/REC-ldp-20150226\n"ECMA-262, 11th edition specification"\n<https://www.ecma-international.org/ecma-262/11.0/index.html>\nhttps://www.ecma-international.org/ecma-262/11.0/index.html\n15.2. Informative References\nInformative References\n"The Canonical Link Relation"\n<https://www.rfc-editor.org/info/rfc6596>\nhttps://www.rfc-editor.org/info/rfc6596\n"Concise Binary Object Representation (CBOR)"\n<https://www.rfc-editor.org/info/rfc7049>\nhttps://www.rfc-editor.org/info/rfc7049\n"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content"\n<https://www.rfc-editor.org/info/rfc7231>\nhttps://www.rfc-editor.org/info/rfc7231\n<https://www.rfc-editor.org/info/rfc8288>\nhttps://www.rfc-editor.org/info/rfc8288\n"Best Practices for Fragment Identifiers and Media Type Definitions"\nWorld Wide Web Consortium WD WD-fragid-best-practices-20121025\n<https://www.w3.org/TR/2012/WD-fragid-best-practices-20121025>\nhttps://www.w3.org/TR/2012/WD-fragid-best-practices-20121025\n"JSON Schema Validation: A Vocabulary for Structural Validation of JSON"\nInternet-Draft, draft-bhutton-json-schema-validation-01\n<https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01>\nhttps://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-validation-01\n"JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON"\nInternet-Draft, draft-handrews-json-schema-hyperschema-02\n<https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-02>\nhttps://datatracker.ietf.org/doc/html/draft-handrews-json-schema-hyperschema-02\n"Namespaces in XML 1.1 (Second Edition)"\n<http://www.w3.org/TR/2006/REC-xml-names11-20060816>\nhttp://www.w3.org/TR/2006/REC-xml-names11-20060816\nAppendix A. Schema identification examples
      

                    Consider the following schema, which shows "$id" being used to identify
                    both the root schema and various subschemas, and "$anchor" being used
                    to define plain name fragment identifiers.¶


{
    "$id": "https://example.com/root.json",
    "$defs": {
        "A": { "$anchor": "foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$anchor": "bar" },
                "Y": {
                    "$id": "t/inner.json",
                    "$anchor": "bar"
                }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

¶


                The schemas at the following URI-encoded JSON
                Pointers [RFC6901] (relative to the root schema) have the following
                base URIs, and are identifiable by any listed URI in accordance with
                sections 5 and
                9.2.1 above.¶

        # (document root)
        
          
            canonical (and base) URI
            
                                https://example.com/root.json¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/root.json#¶

          


        
#/$defs/A
        
          
            base URI
            https://example.com/root.json¶

            
canonical resource URI plus plain fragment
            
                                https://example.com/root.json#foo¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/root.json#/$defs/A¶

          


        
#/$defs/B
        
          
            canonical (and base) URI
            https://example.com/other.json¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/other.json#¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B¶

          


        
#/$defs/B/$defs/X
        
          
            base URI
            https://example.com/other.json¶

            
canonical resource URI plus plain fragment
            
                                https://example.com/other.json#bar¶

            
canonical resource URI plus pointer fragment
            
                                https://example.com/other.json#/$defs/X¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B/$defs/X¶

          


        
#/$defs/B/$defs/Y
        
          
            canonical (and base) URI
            https://example.com/t/inner.json¶

            
canonical URI plus plain fragment
            
                                https://example.com/t/inner.json#bar¶

            
canonical URI plus pointer fragment
            
                                https://example.com/t/inner.json#¶

            
base URI of enclosing (other.json) resource plus fragment
            
                                https://example.com/other.json#/$defs/Y¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/B/$defs/Y¶

          


        
#/$defs/C
        
          
            canonical (and base) URI
            
                                urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f¶

            
canonical URI plus pointer fragment
            
                                urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f#¶

            
base URI of enclosing (root.json) resource plus fragment
            
                                https://example.com/root.json#/$defs/C¶

          


      


                Note: The fragment part of the URI does not make it canonical or non-canonical,
                rather, the base URI used (as part of the full URI with any fragment) is what
                determines the canonical nature of the resulting full URI.
                
                    Multiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.
        ¶\nAppendix A. Schema identification examples\nSchema identification examples\nConsider the following schema, which shows "$id" being used to identify
                    both the root schema and various subschemas, and "$anchor" being used
                    to define plain name fragment identifiers.¶\n{
    "$id": "https://example.com/root.json",
    "$defs": {
        "A": { "$anchor": "foo" },
        "B": {
            "$id": "other.json",
            "$defs": {
                "X": { "$anchor": "bar" },
                "Y": {
                    "$id": "t/inner.json",
                    "$anchor": "bar"
                }
            }
        },
        "C": {
            "$id": "urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f"
        }
    }
}

¶\nThe schemas at the following URI-encoded JSON
                Pointers [RFC6901] (relative to the root schema) have the following
                base URIs, and are identifiable by any listed URI in accordance with
                sections 5 and
                9.2.1 above.¶\nJSON
                Pointers [RFC6901]\nJSON
                Pointers\nNote: The fragment part of the URI does not make it canonical or non-canonical,
                rather, the base URI used (as part of the full URI with any fragment) is what
                determines the canonical nature of the resulting full URI.
                
                    Multiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.
        ¶\nMultiple "canonical" URIs? We Acknowledge this is potentially confusing, and
                    direct you to read the CREF located in the
                    JSON Pointer fragments and embedded schema resources (Section 9.2.1)
                    section for futher comments.\nJSON Pointer fragments and embedded schema resources (Section 9.2.1)\nJSON Pointer fragments and embedded schema resources\nAppendix B. Manipulating schema documents and references\nManipulating schema documents and references\nVarious tools have been created to rearrange schema documents
                based on how and where references ("$ref") appear.  This appendix discusses
                which use cases and actions are compliant with this specification.¶\nB.1. Bundling schema resources into a single document\nBundling schema resources into a single document\nA set of schema resources intended for use together can be organized
                    with each in its own schema document, all in the same schema document,
                    or any granularity of document grouping in between.¶\nNumerous tools exist to perform various sorts of reference removal.
                    A common case of this is producing a single file where all references
                    can be resolved within that file.  This is typically done to simplify
                    distribution, or to simplify coding so that various invocations
                    of JSON Schema libraries do not have to keep track of and load
                    a large number of resources.¶\nThis transformation can be safely and reversibly done as long as
                    all static references (e.g. "$ref") use URI-references that resolve
                    to URIs using the canonical resource URI as the base, and all schema
                    resources have an absolute-URI as the "$id" in their root schema.¶\nWith these conditions met, each external resource can be copied
                    under "$defs", without breaking any references among the resources'
                    schema objects, and without changing any aspect of validation or
                    annotation results.  The names of the schemas under "$defs" do
                    not affect behavior, assuming they are each unique, as they
                    do not appear in the canonical URIs for the embedded resources.¶\nB.2. Reference removal is not always safe\nReference removal is not always safe\nAttempting to remove all references and produce a single schema document does not,
                    in all cases, produce a schema with identical behavior to the original form.¶\nSince "$ref" is now treated like any other keyword, with other keywords allowed
                    in the same schema objects, fully supporting non-recursive "$ref" removal in
                    all cases can require relatively complex schema manipulations.  It is beyond
                    the scope of this specification to determine or provide a set of safe "$ref"
                    removal transformations, as they depend not only on the schema structure
                    but also on the intended usage.¶\nAppendix C. Example of recursive schema extension
      

                    Consider the following two schemas describing a simple
                    recursive tree structure, where each node in the tree
                    can have a "data" field of any type.  The first schema
                    allows and ignores other instance properties.  The second is
                    more strict and only allows the "data" and "children" properties.
                    An example instance with "data" misspelled as "daat" is also shown.¶


// tree schema, extensible
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/tree",
    "$dynamicAnchor": "node",

    "type": "object",
    "properties": {
        "data": true,
        "children": {
            "type": "array",
            "items": {
                "$dynamicRef": "#node"
            }
        }
    }
}

// strict-tree schema, guards against misspelled properties
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/strict-tree",
    "$dynamicAnchor": "node",

    "$ref": "tree",
    "unevaluatedProperties": false
}

// instance with misspelled field
{
    "children": [ { "daat": 1 } ]
}

¶


                When we load these two schemas, we will notice the "$dynamicAnchor"
                named "node" (note the lack of "#" as this is just the name)
                present in each, resulting in the following full schema URIs:¶

"https://example.com/tree#node"¶

        "https://example.com/strict-tree#node"¶

      

                In addition, JSON Schema implementations keep track of the fact
                that these fragments were created with "$dynamicAnchor".¶

                If we apply the "strict-tree" schema to the instance, we will follow
                the "$ref" to the "tree" schema, examine its "children" subschema,
                and find the "$dynamicRef": to "#node" (note the "#" for URI fragment syntax)
                in its "items" subschema.  That reference resolves to
                "https://example.com/tree#node", which is a URI with a fragment
                created by "$dynamicAnchor".  Therefore we must examine the dynamic
                scope before following the reference.¶

                At this point, the dynamic path is
                "#/$ref/properties/children/items/$dynamicRef", with a dynamic scope
                containing (from the outermost scope to the innermost):¶

"https://example.com/strict-tree#"¶

        "https://example.com/tree#"¶

        "https://example.com/tree#/properties/children"¶

        "https://example.com/tree#/properties/children/items"¶

      

                Since we are looking for a plain name fragment, which can be
                defined anywhere within a schema resource, the JSON Pointer fragments
                are irrelevant to this check.  That means that we can remove those
                fragments and eliminate consecutive duplicates, producing:¶

"https://example.com/strict-tree"¶

        "https://example.com/tree"¶

      

                In this case, the outermost resource also has a "node" fragment
                defined by "$dynamicAnchor".  Therefore instead of resolving the
                "$dynamicRef" to "https://example.com/tree#node", we resolve it to
                "https://example.com/strict-tree#node".¶

                This way, the recursion in the "tree" schema recurses to the root
                of "strict-tree", instead of only applying "strict-tree" to the
                instance root, but applying "tree" to instance children.¶

                This example shows both "$dynamicAnchor"s in the same place
                in each schema, specifically the resource root schema.
                Since plain-name fragments are independent of the JSON structure,
                this would work just as well if one or both of the node schema objects
                were moved under "$defs".  It is the matching "$dynamicAnchor" values
                which tell us how to resolve the dynamic reference, not any sort of
                correlation in JSON structure.¶\nAppendix C. Example of recursive schema extension\nExample of recursive schema extension\nConsider the following two schemas describing a simple
                    recursive tree structure, where each node in the tree
                    can have a "data" field of any type.  The first schema
                    allows and ignores other instance properties.  The second is
                    more strict and only allows the "data" and "children" properties.
                    An example instance with "data" misspelled as "daat" is also shown.¶\n// tree schema, extensible
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/tree",
    "$dynamicAnchor": "node",

    "type": "object",
    "properties": {
        "data": true,
        "children": {
            "type": "array",
            "items": {
                "$dynamicRef": "#node"
            }
        }
    }
}

// strict-tree schema, guards against misspelled properties
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "https://example.com/strict-tree",
    "$dynamicAnchor": "node",

    "$ref": "tree",
    "unevaluatedProperties": false
}

// instance with misspelled field
{
    "children": [ { "daat": 1 } ]
}

¶\nWhen we load these two schemas, we will notice the "$dynamicAnchor"
                named "node" (note the lack of "#" as this is just the name)
                present in each, resulting in the following full schema URIs:¶\n"https://example.com/tree#node"¶\n"https://example.com/strict-tree#node"¶\nIn addition, JSON Schema implementations keep track of the fact
                that these fragments were created with "$dynamicAnchor".¶\nIf we apply the "strict-tree" schema to the instance, we will follow
                the "$ref" to the "tree" schema, examine its "children" subschema,
                and find the "$dynamicRef": to "#node" (note the "#" for URI fragment syntax)
                in its "items" subschema.  That reference resolves to
                "https://example.com/tree#node", which is a URI with a fragment
                created by "$dynamicAnchor".  Therefore we must examine the dynamic
                scope before following the reference.¶\nAt this point, the dynamic path is
                "#/$ref/properties/children/items/$dynamicRef", with a dynamic scope
                containing (from the outermost scope to the innermost):¶\n"https://example.com/strict-tree#"¶\n"https://example.com/tree#"¶\n"https://example.com/tree#/properties/children"¶\n"https://example.com/tree#/properties/children/items"¶\nSince we are looking for a plain name fragment, which can be
                defined anywhere within a schema resource, the JSON Pointer fragments
                are irrelevant to this check.  That means that we can remove those
                fragments and eliminate consecutive duplicates, producing:¶\n"https://example.com/strict-tree"¶\n"https://example.com/tree"¶\nIn this case, the outermost resource also has a "node" fragment
                defined by "$dynamicAnchor".  Therefore instead of resolving the
                "$dynamicRef" to "https://example.com/tree#node", we resolve it to
                "https://example.com/strict-tree#node".¶\nThis way, the recursion in the "tree" schema recurses to the root
                of "strict-tree", instead of only applying "strict-tree" to the
                instance root, but applying "tree" to instance children.¶\nThis example shows both "$dynamicAnchor"s in the same place
                in each schema, specifically the resource root schema.
                Since plain-name fragments are independent of the JSON structure,
                this would work just as well if one or both of the node schema objects
                were moved under "$defs".  It is the matching "$dynamicAnchor" values
                which tell us how to resolve the dynamic reference, not any sort of
                correlation in JSON structure.¶\nAppendix D. Working with vocabularies\nWorking with vocabularies\nD.1. Best practices for vocabulary and meta-schema authors\nBest practices for vocabulary and meta-schema authors\nVocabulary authors should
                    take care to avoid keyword name collisions if the vocabulary is intended
                    for broad use, and potentially combined with other vocabularies.  JSON
                    Schema does not provide any formal namespacing system, but also does
                    not constrain keyword names, allowing for any number of namespacing
                    approaches.¶\nVocabularies may build on each other, such as by defining the behavior
                    of their keywords with respect to the behavior of keywords from another
                    vocabulary, or by using a keyword from another vocabulary with
                    a restricted or expanded set of acceptable values.  Not all such
                    vocabulary re-use will result in a new vocabulary that is compatible
                    with the vocabulary on which it is built.  Vocabulary authors should
                    clearly document what level of compatibility, if any, is expected.¶\nMeta-schema authors should not use "$vocabulary" to combine multiple
                    vocabularies that define conflicting syntax or semantics for the same
                    keyword.  As semantic conflicts are not generally detectable through
                    schema validation, implementations are not expected to detect such
                    conflicts.  If conflicting vocabularies are declared, the resulting
                    behavior is undefined.¶\nVocabulary authors SHOULD provide a meta-schema that validates the
                    expected usage of the vocabulary's keywords on their own.  Such meta-schemas
                    SHOULD not forbid additional keywords, and MUST not forbid any
                    keywords from the Core vocabulary.¶\nIt is recommended that meta-schema authors reference each vocabulary's
                    meta-schema using the "allOf" (Section 10.2.1.1) keyword,
                    although other mechanisms for constructing the meta-schema may be
                    appropriate for certain use cases.¶\n"allOf" (Section 10.2.1.1)\nThe recursive nature of meta-schemas makes the "$dynamicAnchor"
                    and "$dynamicRef" keywords particularly useful for extending
                    existing meta-schemas, as can be seen in the JSON Hyper-Schema meta-schema
                    which extends the Validation meta-schema.¶\nMeta-schemas may impose additional constraints, including describing
                    keywords not present in any vocabulary, beyond what the meta-schemas
                    associated with the declared vocabularies describe.  This allows for
                    restricting usage to a subset of a vocabulary, and for validating
                    locally defined keywords not intended for re-use.¶\nHowever, meta-schemas should not contradict any vocabularies that
                    they declare, such as by requiring a different JSON type than
                    the vocabulary expects.  The resulting behavior is undefined.¶\nMeta-schemas intended for local use, with no need to test for
                    vocabulary support in arbitrary implementations, can safely omit
                    "$vocabulary" entirely.¶\nD.2. Example meta-schema with vocabulary declarations
        

                    This meta-schema explicitly declares both the Core and Applicator vocabularies,
                    together with an extension vocabulary, and combines their meta-schemas with
                    an "allOf".  The extension vocabulary's meta-schema, which describes only the
                    keywords in that vocabulary, is shown after the main example meta-schema.¶

                    The main example meta-schema also restricts the usage of the Unevaluated
                    vocabulary by forbidding the keywords prefixed with "unevaluated", which
                    are particularly complex to implement.  This does not change the semantics
                    or set of keywords defined by the other vocabularies. It just ensures
                    that schemas using this meta-schema that attempt to use the keywords
                    prefixed with "unevaluated" will fail validation against this meta-schema.¶

                    Finally, this meta-schema describes the syntax of a keyword, "localKeyword",
                    that is not part of any vocabulary.  Presumably, the implementors and users
                    of this meta-schema will understand the semantics of "localKeyword".
                    JSON Schema does not define any mechanism for expressing keyword semantics
                    outside of vocabularies, making them unsuitable for use except in a
                    specific environment in which they are understood.¶

                        This meta-schema combines several vocabularies for general use.¶


{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/general-use-example",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://example.com/vocab/example-vocab": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2020-12/meta/core"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/applicator"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/validation"},
    {"$ref": "https://example.com/meta/example-vocab"}
  ],
  "patternProperties": {
    "^unevaluated": false
  },
  "properties": {
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}

¶


                        This meta-schema describes only a single extension vocabulary.¶


{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/example-vocab",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://example.com/vocab/example-vocab": true,
  },
  "type": ["object", "boolean"],
  "properties": {
    "minDate": {
      "type": "string",
      "pattern": "\d\d\d\d-\d\d-\d\d",
      "format": "date",
    }
  }
}

¶


                    As shown above, even though each of the single-vocabulary meta-schemas
                    referenced in the general-use meta-schema's "allOf" declares its
                    corresponding vocabulary, this new meta-schema must re-declare them.¶

                    The standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.¶

                    While the general-use meta-schema can validate the syntax of "minDate",
                    it is the vocabulary that defines the logic behind the semantic meaning
                    of "minDate".  Without an understanding of the semantics (in this example,
                    that the instance value must be a date equal to or after the date
                    provided as the keyword's value in the schema), an implementation can
                    only validate the syntactic usage.  In this case, that means validating
                    that it is a date-formatted string (using "pattern" to ensure that it is
                    validated even when "format" functions purely as an annotation, as explained
                    in the Validation specification [json-schema-validation].¶\nD.2. Example meta-schema with vocabulary declarations\nExample meta-schema with vocabulary declarations\nThis meta-schema explicitly declares both the Core and Applicator vocabularies,
                    together with an extension vocabulary, and combines their meta-schemas with
                    an "allOf".  The extension vocabulary's meta-schema, which describes only the
                    keywords in that vocabulary, is shown after the main example meta-schema.¶\nThe main example meta-schema also restricts the usage of the Unevaluated
                    vocabulary by forbidding the keywords prefixed with "unevaluated", which
                    are particularly complex to implement.  This does not change the semantics
                    or set of keywords defined by the other vocabularies. It just ensures
                    that schemas using this meta-schema that attempt to use the keywords
                    prefixed with "unevaluated" will fail validation against this meta-schema.¶\nFinally, this meta-schema describes the syntax of a keyword, "localKeyword",
                    that is not part of any vocabulary.  Presumably, the implementors and users
                    of this meta-schema will understand the semantics of "localKeyword".
                    JSON Schema does not define any mechanism for expressing keyword semantics
                    outside of vocabularies, making them unsuitable for use except in a
                    specific environment in which they are understood.¶\nThis meta-schema combines several vocabularies for general use.¶\n{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/general-use-example",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://example.com/vocab/example-vocab": true
  },
  "allOf": [
    {"$ref": "https://json-schema.org/draft/2020-12/meta/core"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/applicator"},
    {"$ref": "https://json-schema.org/draft/2020-12/meta/validation"},
    {"$ref": "https://example.com/meta/example-vocab"}
  ],
  "patternProperties": {
    "^unevaluated": false
  },
  "properties": {
    "localKeyword": {
      "$comment": "Not in vocabulary, but validated if used",
      "type": "string"
    }
  }
}

¶\nThis meta-schema describes only a single extension vocabulary.¶\n{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/meta/example-vocab",
  "$dynamicAnchor": "meta",
  "$vocabulary": {
    "https://example.com/vocab/example-vocab": true,
  },
  "type": ["object", "boolean"],
  "properties": {
    "minDate": {
      "type": "string",
      "pattern": "\d\d\d\d-\d\d-\d\d",
      "format": "date",
    }
  }
}

¶\nAs shown above, even though each of the single-vocabulary meta-schemas
                    referenced in the general-use meta-schema's "allOf" declares its
                    corresponding vocabulary, this new meta-schema must re-declare them.¶\nThe standard meta-schemas that combine all vocabularies defined by
                    the Core and Validation specification, and that combine all vocabularies
                    defined by those specifications as well as the Hyper-Schema specification,
                    demonstrate additional complex combinations.  These URIs for these
                    meta-schemas may be found in the Validation and Hyper-Schema specifications,
                    respectively.¶\nWhile the general-use meta-schema can validate the syntax of "minDate",
                    it is the vocabulary that defines the logic behind the semantic meaning
                    of "minDate".  Without an understanding of the semantics (in this example,
                    that the instance value must be a date equal to or after the date
                    provided as the keyword's value in the schema), an implementation can
                    only validate the syntactic usage.  In this case, that means validating
                    that it is a date-formatted string (using "pattern" to ensure that it is
                    validated even when "format" functions purely as an annotation, as explained
                    in the Validation specification [json-schema-validation].¶\nValidation specification [json-schema-validation]\nValidation specification\njson-schema-validation\nAppendix E. References and generative use cases\nReferences and generative use cases\nWhile the presence of references is expected to be transparent
                to validation results, generative use cases such as code generators
                and UI renderers often consider references to be semantically significant.¶\nTo make such use case-specific semantics explicit, the best practice
                is to create an annotation keyword for use in the same
                schema object alongside of a reference keyword such as "$ref".¶\nFor example, here is a hypothetical keyword for determining
                    whether a code generator should consider the reference
                    target to be a distinct class, and how those classes are related.
                    Note that this example is solely for illustrative purposes, and is
                    not intended to propose a functional code generation keyword.¶\n{
    "allOf": [
        {
            "classRelation": "is-a",
            "$ref": "classes/base.json"
        },
        {
            "$ref": "fields/common.json"
        }
    ],
    "properties": {
        "foo": {
            "classRelation": "has-a",
            "$ref": "classes/foo.json"
        },
        "date": {
            "$ref": "types/dateStruct.json",
        }
    }
}

¶\nHere, this schema represents some sort of object-oriented class.
                The first reference in the "allOf" is noted as the base class.
                The second is not assigned a class relationship, meaning that the
                code generator should combine the target's definition with this
                one as if no reference were involved.¶\nLooking at the properties, "foo" is flagged as object composition,
                while the "date" property is not.  It is simply a field with
                sub-fields, rather than an instance of a distinct class.¶\nThis style of usage requires the annotation to be in the same object
                as the reference, which must be recognizable as a reference.¶\nAppendix F. Acknowledgments\nThanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.¶\nThanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Evgeny Poberezkin,
                Brad Bowman,
                Gowry Sankar,
                Donald Pipowitch,
                Dave Finlay,
                Denis Laxalde,
                Phil Sturgeon,
                Shawn Silverman,
                and Karen Etheridge
                for their submissions and patches to the document.¶\nAppendix G. ChangeLog\nThis section to be removed before leaving Internet-Draft status.¶\nThis section to be removed before leaving Internet-Draft status.\nImprove and clarify the "type", "contains", "unevaluatedProperties", and "unevaluatedItems" keyword explanations¶\nClarify various aspects of "canonical URIs"¶\nComment on ambiguity around annotations and "additionalProperties"¶\nClarify Vocabularies need not be formally defined¶\nRemove references to remaining media-type parameters¶\nFix multiple examples¶\n"$schema" MAY change for embedded resources¶\nArray-value "items" functionality is now "prefixItems"¶\n"items" subsumes the old function of "additionalItems"¶\n"contains" annotation behavior, and "contains" and "unevaluatedItems" interactions now specified¶\nRename $recursive* to $dynamic*, with behavior modification¶\n$dynamicAnchor defines a fragment like $anchor¶\n$dynamic* (previously $recursive) no longer use runtime base URI determination¶\nDefine Compound Schema Documents (bundle) and processing¶\nReference ECMA-262, 11th edition for regular expression support¶\nRegular expression should support unicode¶\nRemove media type parameters¶\nSpecify Unknown keywords are collected as annotations¶\nMoved "unevaluatedItems" and "unevaluatedProperties" from core into their own vocabulary¶\nUpdate to RFC 8259 for JSON specification¶\nMoved "definitions" from the Validation specification here as "$defs"¶\nMoved applicator keywords from the Validation specification as their own vocabulary¶\nMoved the schema form of "dependencies" from the Validation specification as "dependentSchemas"¶\nFormalized annotation collection¶\nSpecified recommended output formats¶\nDefined keyword interactions in terms of annotation and assertion results¶\nAdded "unevaluatedProperties" and "unevaluatedItems"¶\nDefine "$ref" behavior in terms of the assertion, applicator, and annotation model¶\nAllow keywords adjacent to "$ref"¶\nNote undefined behavior for "$ref" targets involving unknown keywords¶\nAdd recursive referencing, primarily for meta-schema extension¶\nAdd the concept of formal vocabularies, and how they can be recognized through meta-schemas¶\nAdditional guidance on initial base URIs beyond network retrieval¶\nAllow "schema" media type parameter for "application/schema+json"¶\nBetter explanation of media type parameters and the HTTP Accept header¶\nUse "$id" to establish canonical and base absolute-URIs only, no fragments¶\nReplace plain-name-fragment-only form of "$id" with "$anchor"¶\nClarified that the behavior of JSON Pointers across "$id" boundary is unreliable¶\nThis draft is purely a clarification with no functional changes¶\nEmphasized annotations as a primary usage of JSON Schema¶\nClarified $id by use cases¶\nExhaustive schema identification examples¶\nReplaced "external referencing" with how and when an implementation might know of a schema from another document¶\nReplaced "internal referencing" with how an implementation should recognized schema identifiers during parsing¶\nDereferencing the former "internal" or "external" references is always the same process¶\nMinor formatting improvements¶\nMake the concept of a schema keyword vocabulary more clear¶\nNote that the concept of "integer" is from a vocabulary, not the data model¶\nClassify keywords as assertions or annotations and describe their general behavior¶\nExplain the boolean schemas in terms of generalized assertions¶\nReserve "$comment" for non-user-visible notes about the schema¶\nWording improvements around "$id" and fragments¶\nNote the challenges of extending meta-schemas with recursive references¶\nAdd "application/schema-instance+json" media type¶\nRecommend a "schema" link relation / parameter instead of "profile"¶\nAllowed for any schema to be a boolean¶\n"$schema" SHOULD NOT appear in subschemas, although that may change¶\nChanged "id" to "$id"; all core keywords prefixed with "$"¶\nClarify and formalize fragments for application/schema+json¶\nNote applicability to formats such as CBOR that can be represented in the JSON data model¶\nUpdated references to JSON¶\nUpdated references to HTTP¶\nUpdated references to JSON Pointer¶\nBehavior for "id" is now specified in terms of RFC3986¶\nAligned vocabulary usage for URIs with RFC3986¶\nRemoved reference to draft-pbryan-zyp-json-ref-03¶\nLimited use of "$ref" to wherever a schema is expected¶\nAdded definition of the "JSON Schema data model"¶\nAdded additional security considerations¶\nDefined use of subschema identifiers for "id"¶\nRewrote section on usage with HTTP¶\nRewrote section on usage with rel="describedBy" and rel="profile"¶\nFixed numerous invalid examples¶\nSalvaged from draft v3.¶\nSplit validation keywords into separate document.¶\nSplit hypermedia keywords into separate document.¶\nInitial post-split draft.¶\nMandate the use of JSON Reference, JSON Pointer.¶\nDefine the role of "id". Define URI resolution scope.¶\nAdd interoperability considerations.¶\nAuthors' Addresses
      

        Austin Wright (editor)

Email:
[email protected]



        Henry Andrews (editor)

Email:
[email protected]



        Ben Hutton (editor)
Postman

Email:
[email protected]


URI:
https://jsonschema.dev



        Greg Dennis

Email:
[email protected]


URI:
https://github.com/gregsdennis\nAustin Wright (editor)\nAustin Wright (editor)\nEmail:
[email protected]\nHenry Andrews (editor)\nHenry Andrews (editor)\nEmail:
[email protected]\nEmail:
[email protected]\nURI:
https://jsonschema.dev\nhttps://jsonschema.dev\nEmail:
[email protected]\nURI:
https://github.com/gregsdennis\nhttps://github.com/gregsdennis\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHub195 Tools195ToolsLanguage.NETCC#C++ClojureCoffeeScriptCommon LispDartDelphiElixirElmErlangGoHaskellHelmJavaJavaScriptJuliaKotlinLua/LuaJITObjective-COpenAPIOrderlyPerlPHPPostgreSQLProtocol BuffersPythonRAMLRubyRustScalaSwiftTypeScriptXSDTooling TypeAnnotationsBenchmarksBundlerCode To SchemaData To SchemaDocumentationEditorEditor PluginsHyper SchemaLDO UtilityLinterLinter PluginsModel To SchemaSchema RepositorySchema To CodeSchema To DataSchema To TypesSchema To Web UIUtil Draft MigrationUtil Format ConversionUtil General ProcessingUtil Schema To SchemaUtil TestingValidatorEnvironmentCOM/ActiveXCommand LineEmbedded platformGithub ActionsiOSLinuxmacOSMicrosoft WindowstvOSvisionOSwatchOSWeb (Online)WindowsDialect2020-122019-097654License(MIT AND Apache-2.0)AFL-2.1 OR BSD-3-ClauseAGPL-3.0AGPL-3.0 and CommercialAGPL-3.0-onlyApache License 2.0Apache-2.0Artistic-2.0BSD-2-ClauseBSD-3-ClauseBSL-1.0CC0-1.0EPL-1.0GPL-1.0+ OR Artistic-1.0GPL-2.0GPL-3.0GPL-3.0-onlyISCLGPL 2.1 or laterLGPL-2.1LGPL-2.1-onlyLGPL-3.0MITMPL-2.0Ms-PLPostgreSQLProprietaryProprietary and FreewareShow obsoleteApply FiltersClear FiltersJSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.JSON Schema ToolingToolings below are written in different languages, and support part, or all, of at least one recent version of the specification.Listing does not signify a recommendation or endorsement of any kind.Raise an issue to get your tool added or updated in the tooling table.Bowtie is a meta-validator for JSON Schema implementations and it provides compliance reports.GROUP BY:NoneTooling TypeLanguageValidatorNameLanguagesDialectsLicenseBowtie@cfworker/json-schemaJavaScript472019-092020-12MIT@exodus/schemasafeJavaScript4672019-092020-12MIT@hyperjump/json-schemaJavaScript4672019-092020-12MIT@imhonglu/json-schemaTypeScript2020-12MITajvJavaScript4672019-092020-12MITajv-cli4672019-092020-12MITBlazeC++4672019-092020-12AGPL-3.0 and CommercialboonRust4672019-092020-12Apache-2.0Corvus.JsonSchema.NET672019-092020-12Apache-2.0cypress-ajv-schema-validatorJavaScript4672019-092020-12MITdjvJavaScript46MITDSJSONSchemaValidationObjective-C467MITerosb/json-sKemaJava2020-12MITeverit-org/json-schemaJava467Apache-2.0ExonerateElixir467MITExtendsClass's JSON Schema Validator7Proprietaryf5-json-schemaC++7BSL-1.0fastjsonschemaPython467BSD-3-ClausegojsonschemaGo467Apache-2.0JaronuingaJava4672019-092020-12LGPL 2.1 or laterjema.jsJavaScript2020-12MITJeSSEErlang346Apache-2.0jinxClojure7MITjschonPython2019-092020-12MITjschon.dev2019-092020-12MITJSIRuby467AGPL-3.0-onlyJSON Essentials for COM/ActiveX7ProprietaryJSON Schema LibraryJavaScript4672019-09MITJSON Schema Lint123467MITJSON schema validation for JSON for Modern C++C++7MITJSON Schema Validator34672019-092020-12AGPL-3.0-onlyjson-everything672019-092020-12MITjson-kotlin-schemaKotlin72019-09MITjson-schemaRuby12346MITjson-schema (dev.harrel)Java72019-092020-12MITjson-schema (fisxoj)Common Lisp4672019-09LGPL-2.1-onlyjson-schema-validatorKotlin4672019-092020-12MITjson-schema.hyperjump.io4672019-092020-12MITJSON::Schema::ModernPerl4672019-092020-12GPL-1.0+ OR Artistic-1.0JSON::Schema::TinyPerl72019-092020-12GPL-1.0+ OR Artistic-1.0JSON::ValidatorPerl4672019-09Artistic-2.0Json.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonconsC++4672019-092020-12BSL-1.0jsonschemaGo2020-12MITjsonschemaPython34672019-092020-12MITjsonschema-rsRust4672019-092020-12MITjsonschema-rs (Python)Python467MITJSONSchema::ValidatorPerl467MITjsonschema.dev7MITJSONSchema.jlJulia467MITJsonSchema.Net.NET672019-092020-12MITjsonschemafriendJava34672019-092020-12Apache-2.0JSONSchemerRuby4672019-092020-12MITJsonXemaElixir467MITJSVElixir, Erlang72020-12MITJustifyJava467Apache-2.0justinrainbow/json-schemaPHP34MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and Freewarelua-resty-jsonschemaLua/LuaJIT467MITluposlip/json-schemaClojure467Apache-2.0Medeia-validatorKotlin, Java467Apache-2.0networknet/json-schema-validatorJava4672019-092020-12Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Opis Json SchemaPHP672019-092020-12Apache-2.0Polyglottal JSON Schema Validator46MITqri-io/jsonschemaGo72019-09MITReactive Core Circe JSON ValidatorScala2019-092020-12Apache-2.0santhosh-tekuri/jsonschemaGo4672019-092020-12Apache-2.0SnowJava672019-09AGPL-3.0-onlySourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Swaggest Json SchemaPHP467MITswift-json-schemaSwift2020-12MITv8r467MITvalbuddy467ProprietaryValidate JSON Action2019-092020-12MITValijsonC++7BSD-2-ClauseVert.x Json SchemaJava472019-092020-12Apache-2.0vue-vuelidate-jsonschemaJavaScript6MITyajsv467MITZuunr JSONJava2020-12Apache-2.0AnnotationsNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITBundlerNameLanguagesDialectsLicenseBowtie@hyperjump/json-schemaJavaScript4672019-092020-12MITJsonSchema.Net.NET672019-092020-12MITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Hyper SchemaNameLanguagesDialectsLicenseBowtieCore API Hyper-Schema codecPython4BSD-2-Clausemokkabonna/json-hyper-schemaJavaScript7MITBenchmarksNameLanguagesDialectsLicenseBowtiejson-schema-validation-comparisonJava, Kotlin, Scala34672019-092020-12MITphp-json-schema-benchPHP467MITDocumentationNameLanguagesDialectsLicenseBowtie@adobe/jsonschema2mdJavaScript2019-09Apache-2.0@cloudflare/docaJavaScript467Apache-2.0docson4Apache-2.0docusaurus-json-schema-plugin72019-092020-12AGPL-3.0-onlyFastAPIPythonMITjson-schema-for-humansPython7Apache-2.0json-schema-static-docs7GPL-3.0-onlyjsonschema-markdownMITjsonschematic7MITLiquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0Oxygen XSL JSON ToolsXSDwetzel3472020-12Apache-2.0LDO UtilityNameLanguagesDialectsLicenseBowtie@cloudflare/json-hyper-schemaJavaScript467BSD-3-ClauseCode To SchemaNameLanguagesDialectsLicenseBowtiedrf-jsonschema-serializerPythonBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJson.NET Schema.NET34672019-092020-12AGPL-3.0-onlyjsonschemaGo2020-12MITjsonschema-generatorJava672019-092020-12Apache-2.0JsonSchema.Net.NET672019-092020-12MITLateApexEarlySpeed.Json.Schema.NET2020-12BSD-3-ClauseLiformPHPMITmashumaroPythonApache-2.0Micronaut JSON SchemaJava2020-12Apache-2.0msgspecPythonBSD-3-ClauseNJsonSchema.NET4672019-092020-12Ms-PLOpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0PydanticPythonMITscala-jsonschemaScala4672019-092020-12Apache-2.0SchemarsRust7MITShaleRuby2020-12MITswift-json-schemaSwift2020-12MITtypescript-json-schemaTypeScriptBSD-3-ClauseData To SchemaNameLanguagesDialectsLicenseBowtiedadav/helm-schemaHelm7MITjson-schema-inferrerJava4672019-092020-12Apache-2.0JSONoidScala2020-12MITjsonschema.net4672019-09ProprietaryLiquid Online Tools4Proprietaryluposlip/json-schemaClojure467Apache-2.0MetaConfiguratorTypeScript2020-12MITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietarySchema GuruScala672019-092020-12Apache-2.0Model To SchemaNameLanguagesDialectsLicenseBowtieDataspecer2020-12Proprietaryprotoc-gen-jsonschemaProtocol Buffers4672019-092020-12Apache-2.0swift-json-schemaSwift2020-12MITSchema To TypesNameLanguagesDialectsLicenseBowtiejson-2-joiJavaScriptApache License 2.0json-schema-to-tsTypeScriptMITjson-schema-to-typescriptTypeScriptMITSchema To CodeNameLanguagesDialectsLicenseBowtieCorvus.JsonSchema.NET672019-092020-12Apache-2.0go-jsonschemaGo2020-12MITjson-kotlin-schema-codegenKotlinMITjson-schema-to-case-classScala34672019-09MITjson-schema-to-elmElm7MITjsonCodeGenJavaMITjsonschema2pojoJava7Apache-2.0jsonschematypesJava, TypeScript34672019-09Apache-2.0OpenAPI JSON Schema GeneratorJava, Kotlin, Python52020-12Apache-2.0php-code-builderPHP7MITprotoc-gen-jsonschemaGoMITquicktype.ioTypeScript, C++, Go, Java, C#, Swift, JavaScript6ProprietaryschemafyRust4MITShaleRuby2020-12MITstathamPythonMITyacgPythonMITSchema To Web UINameLanguagesDialectsLicenseBowtieAJSF (Angular JSON Schema Form)JavaScriptMITAlpaca FormsJavaScriptApache-2.0Angular Schema FormJavaScriptMITDashjoin JSON Schema FormJavaScript6Apache-2.0JSON EditorJavaScript34MITJSON Form (joshfire)JavaScriptMITJson Forms (brutusin)JavaScriptMITJSON Schema Form ElementJavaScriptISCjson-schema-form (Remote.com)JavaScriptMITJSONForms (jsonforms.io)JavaScriptMITLiform-ReactJavaScriptMITMetaConfiguratorTypeScript2020-12MITNgx Schema FormJavaScriptMITReact Json Schema Form (Mui)JavaScriptMITReact JSON Schema Form (RJSF-Team)JavaScriptApache-2.0React Schema Form (networknt)JavaScriptMITRestspace Schema FormJavaScriptMITStoplight JSON Schema TreeTypeScript4Apache-2.0Stoplight JSON Schema ViewerTypeScript4Apache-2.0Svelte JSON Schema FormTypeScript7(MIT AND Apache-2.0)UI Schema for ReactJavaScript4672019-09MITvazco/uniformsJavaScriptMITSchema To DataNameLanguagesDialectsLicenseBowtiehypothesis-jsonschemaPython467MPL-2.0jsongeneratorJava34672019-09Apache-2.0JsonSchema.Net.NET672019-092020-12MITMetaConfiguratorTypeScript2020-12MITUtil General ProcessingNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-walkerJavaScript467BSD-3-Clause@hyperjump/json-schemaJavaScript4672019-092020-12MITjoi-to-jsonJavaScript4672019-092020-12MITJSON ToolkitC++01234672019-092020-12AGPL-3.0 and Commercialjson-schema-libraryJavaScriptMITjson-schema-ref-parserJavaScriptMITSourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Util Schema To SchemaNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-transformJavaScriptBSD-3-Clausejson-schema-compareJavaScriptMITJSON-Schema-InstantiatorJavaScriptMITjson-schema-merge-allofJavaScriptMITjson-schema-resolve-allofJavaScriptUtil Draft MigrationNameLanguagesDialectsLicenseBowtieAlterSchemaJavaScript4672019-092020-12Apache-2.0Util Format ConversionNameLanguagesDialectsLicenseBowtie@cloudflare/json-schema-apidoc-loaderJavaScript467BSD-3-Clause@cloudflare/json-schema-ref-loaderJavaScriptBSD-3-Clausejoi-to-jsonJavaScript4672019-092020-12MITJSON Schema to OpenAPI SchemaOpenAPI467MITjson-2-joiJavaScriptApache License 2.0OpenAPI specification to JSON SchemaOpenAPI7MITOrderlyOrderlyBSD-3-ClauseOxygen XSL JSON ToolsXSDramldt2jsonschemaRAML46Apache-2.0XSD to JSON Schema IntelliJ PluginXSDUtil TestingNameLanguagesDialectsLicenseBowtiecypress-ajv-schema-validatorJavaScript4672019-092020-12MIThypothesis-jsonschemaPython467MPL-2.0Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0EditorNameLanguagesDialectsLicenseBowtieAltova XMLSpy 2019r367Dashjoin JSON Schema editor6Eclipse IDEHackolade Studio4672019-092020-12JSON Schema Editor2020-12MITJSONBuddy4672019-092020-12JSONEditor Online467Liquid JSON Schema Editor4672019-09Liquid JSON Schema EditorC#, .NET4672019-092020-12Proprietary and FreewareMetaConfiguratorTypeScript2020-12MITOxygen JSON Schema Editor4672019-092020-12Perseid Modeler4672019-092020-12Stoplight Studio467Visual Studio CodeWebStorm, IntelliJ IDEA, and other JetBrains IDEs467Schema RepositoryNameLanguagesDialectsLicenseBowtieSchemaStore.orgApache-2.0LinterNameLanguagesDialectsLicenseBowtiejson-schema-linter467Sourcemeta JSON Schema CLI01234672019-092020-12AGPL-3.0Stoplight Spectral467Apache-2.0Linter PluginsNameLanguagesDialectsLicenseBowtieeslint-plugin-json-schema-validatorMITremark-lint-frontmatter-schemaISCNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on Slack\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubGet startedIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaJSON Schema GlossaryThis document collects short explanations of terminology one may encounter within the JSON Schema community.Whilst many of the entries below have precise technical definitions, preference is given to explanations of their conversational use, with additional references linked for further information.
This page is not meant to be normative, nor is it meant to contain fully original research or explanation.
It is meant to aid the understanding of those less familiar with formal language used within JSON Schema, or within specifications more broadly.
(In fact, entries below make effort to avoid terminology like "normative" itself for reasons just mentioned.)If you encounter a term you wish were defined here, please feel free to file an issue requesting it.The entries on this page can be linked to via anchor links (e.g. https://json-schema.org/learn/glossary.html#vocabulary) when sharing a definition with others.dialectA cohesive collection of keywords available for use within a schema, often representing a use-case specific single release of the JSON Schema specification.Dialects, particularly the 2019-09 and 2020-12 dialects, are often defined via a collection of vocabularies.Each dialect is identified by a URI, its dialect identifier, which schemas may then reference in their $schema keyword.
Doing so identifies the schema as being written in the dialect, and thereby indicates which keywords are usable within it, along with their intended meaning.The JSON Schema specification defines a number of dialects, each of which enable vocabularies suitable for the dialect's specific use case.
These vocabularies are described in meta-schemas.draftAn individual release of the JSON Schema specification.JSON Schema drafts are not intended to be provisional documents, as the layman's use of the word "draft" might indicate.While future drafts may introduce new behavior or changes to existing behavior, each draft is a completed, released document, batching together changes to the specification, and intended for implementation and use.The current list of drafts can be found here.JSONA pervasive data interchange format used for representing and transmitting data as human readable text.
JSON is extremely widely used, and parsers which can read and write it exist for essentially every commonly-used programming language.JSON Schema, distinctly, is built on top of JSON, in that JSON schemas are themselves JSON objects which describe JSON values.
The two are, however, entirely different pieces of the conceptual puzzle, with JSON being a concrete format for representing data, and JSON Schema being a way to schematize data which is written in a JSON-compatible format.The JSON format is an open format, with its own homepage, and specifications published in the ECMA-404 and RFC-8259 documents from ECMA and the IETF respectively.
In particular, it is not managed or developed by the JSON Schema team, who simply make use of the format.JSON Hyper-SchemaJSON Hyper-Schema extends JSON Schema, offering a vocabulary to annotate JSON documents with hypermedia controls. This extension facilitates the description of links and actions that can be executed on JSON data, making it a powerful tool for developing hypermedia-driven APIs.The essence of JSON Hyper-Schema lies in its ability to define links and actions that can be executed on JSON data. This is achieved through the use of the links keyword, which allows for the creation of dynamic, interactive data representations. For example, a JSON document representing a blog post might include an "author" property. The JSON Hyper-Schema that describes this document could include a template for a hypermedia control that uses the author's identifier in the instance to construct a link to the author's profile. The developer doesn't need to construct the URL manually, which enhances the developer experience by offering a seamless navigation experience.In other words, JSON Hyper-Schema extends JSON Schema by introducing features for creating hypermedia controls. This facilitates the creation of interactive APIs and ensures compatibility with existing JSON HTTP APIs, maintaining a seamless integration. It adds a layer of interactivity to JSON documents, making it easier to interact with remote JSON resources.JSON pointerJSON Pointer is a string syntax for identifying a value at a specified location within a JSON document. It serves to precisely reference specific parts of the document for retrieval or manipulation. A subschema is often identified using a JSON Pointer, specifying its location within the containing resource.keywordA property appearing within a schema object.The JSON Schema specification defines behavior for a large library of keywords which can be used to describe instances.implementationHistorically, the word "implementation" has been used to describe both specifically validators/annotators (the scope of the spec) and also various other kinds of JSON Schema tooling.  However, due to this ambiguity, we have decided that the preferred conversational term should be "tooling".instanceA piece of JSON data which is to be described by a schema.JSON Schema can be used to describe JSON values of any type (as well as values from many JSON-like formats which can be reasonably represented as JSON).The JSON Schema specification makes no broad assumptions about the structure of instances themselves beyond those of the JSON specification itself.
In particular it does not reserve any properties within a JSON object for its own use, or require parsers of JSON to support features beyond those already mandated of JSON implementations.meta-schemaA schema which is itself intended to describe other schemas.JSON Schema defines a language for describing any instance using a schema written in JSON.
Since schemas are themselves JSON values, they may be also be treated as instances, and therefore described by other schemas.We refer to the schema-of-a-schema as a "meta-schema" to express this use.normativeIn the context of JSON Schema, and formal specifications more broadly, a document which outlines standardized behavior.
This is as distinct from non-normative or informational documents, meant to explain, simplify or offer opinions.Distinguishing between whether a document is normative or not is intended to clarify to those using the document whether its contents are allowed to contradict or augment behavior described in other normative documents.
JSON Schema's normative documents notably include its specification.
This page for instance, not being a normative document, is not able to proscribe new JSON Schema behavior not already covered by the specification.See alsonormative and non-normative in the Mozilla Glossary, and its linksschemaA document, written according to the proscribed structure of the JSON Schema specification, which can be used to describe instances.The rules constituting which schemas are conformant, as well as the rules governing their behavior when validating instances, are defined by the JSON Schema specification.Strictly speaking, according to the specification, schemas are themselves JSON documents, though it is somewhat common for them to be authored or maintained in other languages which are easily translated to JSON, such as YAML.In recent drafts of the specification, a schema is either a JSON object or a JSON boolean value.subschemaA schema which is itself contained within a surrounding parent schema.
Like schemas themselves, in recent drafts of JSON Schema, subschemas are either JSON objects or JSON boolean values.Within the JSON Schema specification and its dialects, a number of keywords take subschemas as part of their values.
For example, the not keyword takes a subschema value and inverts its result, succeeding whenever the subschema does not succeed, such that the instance 12 is invalid under {"type": "string"} but valid under {"not": {"type": "string"}}, where {"type": "string"} is a subschema contained in the full schema.Some subschemas may appear in more complex nested locations within a parent schema.
The allOf keyword, for instance, takes an array of multiple subschemas and succeeds whenever all of the subschemas do individually.Whether something that otherwise appears to be a schema (based on its contents) actually is a subschema can be misleading at first glance without context or knowledge about its location within the parent schema.
Specifically, in our above example, {"type": "string"} was a subschema of a larger schema, but in the schema {"const": {"type": "string"}}, it is not a subschema.
Even though as a value it looks the same, the const keyword, which compares instances against a specific expected value, does not take a subschema as its value, its value is an opaque value with no particular meaning (such that in this schema, the number 12 would be invalid, but the precise instance {"type": "string"} is valid).
Said more plainly, whether a particular value is a subschema or not depends on its precise location within a parent schema, as interpretation of the value depends on the defined behavior of the keyword(s) it lives under.Subschemas may themselves contain sub-subschemas, though colloquially one generally uses the term "subschema" regardless of the level of nesting, further clarifying which larger schema is the parent schema whenever needed.toolingA JSON Schema tool (or colloquially "tooling") is any software application or library for working with or evaluating schemas in some way.The following are considered tools:a validator librarya CLI validatora schema or code generatora UI form generatorApplications which use JSON Schema internally without exposing that functionality in some way, for example, validating configuration files or web requests, are not considered tooling.validation resultThe validation result in the context of JSON Schema refers to the outcome of applying the entire JSON Schema to the entire instance document. This outcome can encompass more than just a boolean assertion and may include various output formats, such as error messages, error codes, or detailed validation reports. It signifies whether the instance document adheres to the rules and constraints specified in the schema. The validation result signifies whether the instance document passes or fails validation against the schema.vocabularyA tightly related collection of keywords, grouped to facilitate re-use.A vocabulary is specified by a prose document or specification which explains the semantics of its keywords in a way suitable for implementers and users of the vocabulary.
It often also includes a meta-schema (or multiple metaschemas) which define the syntax of its keywords.Anyone can create and publish a vocabulary, and implementations generally will include facilities for extending themselves with support for additional vocabularies and their keywords.
The JSON Schema specification includes a number of vocabularies which cover each of the keywords it defines.In some dialects of JSON Schema, the $vocabulary keyword can be used to include the keywords defined by a vocabulary into the dialect, as well as to indicate whether implementations must specifically recognize the vocabulary in order to be able to process schemas written in the dialect or not.See alsojson-schema-vocabularies, a repository which collects known third-party JSON Schema vocabulariesGo BackOther ExamplesUp NextJSON Schema KeywordsNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\nSpecificationDocsToolsBlogCommunitySearchSystemLightDarkStar on GitHubSpecificationIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaIntroductionOverviewWhat is JSON Schema?RoadmapSponsorsUse casesCase studiesFAQPro HelpSimilar technologiesLandscapeCode of conduct Get StartedOverviewWhat is a schema?The basicsCreate your first schemaTour of JSON SchemaJSON Schema glossaryExamplesMiscellaneous examplesModelling a file systemOther examples GuidesOverviewFor implementersCommon interfaces across implementations ReferenceOverviewJSON Schema keywordsJSON data types arraybooleannullnumeric typesobjectregular expressionsstring Dialect and vocabulary declarationEnumerated and constant values Enumerated valuesConstant values Schema annotations and commentsAnnotationsComments Conditional schema validationSchema composition Boolean JSON Schema combinationModular JSON Schema combination Media: string-encoding non-JSON dataLearn JSON Schema SpecificationOverviewVersions2020-122019-09draft-07draft-06draft-05Specification linksMigrationRelease notesJSON Hyper-SchemaSpecification The current version is 2020-12!
The previous version was 2019-09.Specification documentsSee also the release notes / change log (Work in progress).The specification is split into two parts, Core and Validation. We also publish
the Relative JSON Pointers spec although it's not currently used by Core or
Validation in any significant way.           JSON Schema Core    defines the basic foundation of JSON Schema    JSON Schema Validation    defines the validation keywords of JSON Schema     Relative JSON Pointers    extends the JSON Pointer syntax for relative pointers   Meta-schemasThe meta-schemas are schemas against which other schemas can be validated. It is self-descriptive: the JSON Schema meta-schema validates itself.The latest meta-schema is 2020-12.  For an explanation of the change to date-based identifiers, see the Specification Links page.If you are accessing these JSON document links from a web browser, you will need to save the file then open it as a JSON document.  This is due to limitations with GitHub Pages.General-purpose meta-schemaPlease note, additional vocabulary specific schema files are needed to fully construct and use the Core/Validation Dialect meta-schema.                                                                                                                                                                         Core/Validation Dialect meta-schema     Used for schemas written for pure validation.                                   Hyper-Schema Dialect meta-schema  Used for schemas written for validation (2020-12) and hyper-linking (2019-09).  Recommended Output meta-schema   Recommended output structure of the application process.                       Single-vocabulary meta-schemasThese are relevant primarily to people who want to write their own meta-schemas that build on specific parts of the existing specification.Core Vocabulary meta-schemaApplicator Vocabulary meta-schemaValidation Vocabulary meta-schemaUnevaluated Vocabulary meta-schemaFormat Annotation Vocabulary meta-schemaFormat Assertion Vocabulary meta-schemaContent Vocabulary meta-schemaMeta-Data Vocabulary meta-schemaOutput schemas and examplesJSON Schema recommended output schemaJSON Schema verbose output exampleMigrating from older draftsThe release notes discuss the changes impacting users and implementers:JSON Schema Core and Validation
  Draft 2019-09 to Draft 2020-12Draft-07 to Draft 2019-09Draft-06 to Draft-07Draft-04 to Draft-06JSON Hyper-Schema
  There was no JSON Hyper-Schema draft for 2020-12 releases.Draft-07 to 2019-09Draft-04 to Draft-07Draft-04 to Draft-06Older draftsPlease see Specification Links for older drafts and the latest unreleased version of the specification.Go BackJSON Schema referenceUp NextSpecification LinksNeed Help?Did you find these docs helpful?Help us make our docs great!At JSON Schema, we value docs contributions as much as every other type of contribution!Edit this page on GithubLearn how to contributeStill Need Help?Learning JSON Schema is often confusing, but don't worry, we are here to help!.Ask the community on GitHubAsk the community on SlackOpen CollectiveCode of ConductSlack XLinkedInYoutubeGitHubCopyright © 2025 JSON Schema. All rights reserved.\n\n\n\n