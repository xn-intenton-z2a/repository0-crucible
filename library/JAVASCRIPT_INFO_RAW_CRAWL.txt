Part 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTranslation of the Modern JavaScript TutorialThere are following translations (in the alphabetical order):LanguageTranslated (%)Last CommitPublishedAlbanian 11%23 Jun 2023Arabic 57%28 May 2023https://ar.javascript.infoArmenian 11%4 May 2024Azerbaijani 19%19 Jan 2025Bengali 34%15 Oct 2023Bosnian 18%15 Dec 2021Bulgarian 24%2 Oct 2023Burmese 5%20 Aug 2023Catalan 32%15 Dec 2021Central Khmer 30%15 Dec 2021Chinese 91%12 Mar 2025https://zh.javascript.infoChinese Traditional 33%15 Dec 2021Croatian 1%22 Aug 2022Czech 14%31 Mar 2025Danish 5%17 Sep 2024Dutch 13%15 Dec 2021Finnish 5%19 Apr 2022French 84%19 Mar 2025https://fr.javascript.infoGeorgian 6%15 Dec 2021German 16%31 Mar 2025Greek 13%31 Mar 2025Hebrew 11%15 Dec 2021Hindi 9%15 Dec 2021Hungarian 7%15 Dec 2021Indonesian 64%25 Sep 2023https://id.javascript.infoItalian 87%5 Nov 2023https://it.javascript.infoJapanese 90%13 Nov 2024https://ja.javascript.infoKazakh 4%4 Sep 2024Korean 75%29 Dec 2024https://ko.javascript.infoKurdish 1%31 Mar 2025Kyrgyz 10%6 Feb 2024Lithuanian 17%21 Aug 2022Malay 1%14 Apr 2025Malayalam 6%26 Dec 2023Montenegrin 26%15 Dec 2021Norvegian 32%15 Dec 2021Persian (Farsi) 66%21 Feb 2025https://fa.javascript.infoPolish 25%22 Oct 2022Portuguese 28%2 Nov 2024Punjabi 17%15 Dec 2021Romanian 26%6 Sep 2023Russian 91%17 Apr 2025https://learn.javascript.ruSerbian 5%15 Dec 2021Sinhala 11%15 Dec 2021Slovak 11%15 Dec 2021Slovenian 5%15 Dec 2021Spanish 91%2 Apr 2025https://es.javascript.infoTamil 7%15 Dec 2021Telugu 0%13 Apr 2025Thai 20%29 Sep 2024Turkish 64%27 Oct 2024https://tr.javascript.infoTurkmen 11%15 Dec 2021Ukrainian 89%13 Apr 2025https://uk.javascript.infoUrdu 5%20 Feb 2023Uyghur 1%14 Apr 2025Uzbek 51%15 Dec 2021Vietnamese 16%15 Jul 2024Help us to translate: click the language name link above, it leads to the repo. Then read the instruction. That's simple, join in!
Help to translate
To participate in a translation, simply choose the language in the list above.
Then you’ll get to the language page and see instructions. Maybe even in that language, if the readme is translated :)
Becoming a maintainer
Anyone can contribute to a translation. But maintainers are the ones who also watch over its quality.
Maintainers have the power to review and merge pull requests of others.
Please file an issue, if:

You’re already a maintainer of a translation, and would like to add another one.
You’re interested in becoming a maintainer for a translation, and other maintainers agree to add you.
An existing translation is stalled, previous maintainers don’t respond, and you want to take it over.

Starting a new translation
Your language is not in the list?
If you’d like to create a new translation, file an issue with the following information:

Language code
List of maintainers (one or more): github nick and email

As a maintainer, you should know JavaScript well enough to translate and review pull requests of others.
We will:

Create a new repository for you at javascript-tutorial/{lang-code}.javascript.info.
Add/invite all maintainers to the team translate-{lang-code} in the javascript-tutorial organization.
Create an special issue in the new repository to track your translation progress.

You’ll get an email invite to join (unless you’re a member already). Please accept this invite, so you can get admin access to your repository!
You’ll find more translation tips in Readme when the repository is created.
Happy translating!
Publishing
When the translation is at least half-finished, please create an issue with a request to publish. Your name and contributions will show up at the About page.\n\nThere are following translations (in the alphabetical order):LanguageTranslated (%)Last CommitPublishedAlbanian 11%23 Jun 2023Arabic 57%28 May 2023https://ar.javascript.infoArmenian 11%4 May 2024Azerbaijani 19%19 Jan 2025Bengali 34%15 Oct 2023Bosnian 18%15 Dec 2021Bulgarian 24%2 Oct 2023Burmese 5%20 Aug 2023Catalan 32%15 Dec 2021Central Khmer 30%15 Dec 2021Chinese 91%12 Mar 2025https://zh.javascript.infoChinese Traditional 33%15 Dec 2021Croatian 1%22 Aug 2022Czech 14%31 Mar 2025Danish 5%17 Sep 2024Dutch 13%15 Dec 2021Finnish 5%19 Apr 2022French 84%19 Mar 2025https://fr.javascript.infoGeorgian 6%15 Dec 2021German 16%31 Mar 2025Greek 13%31 Mar 2025Hebrew 11%15 Dec 2021Hindi 9%15 Dec 2021Hungarian 7%15 Dec 2021Indonesian 64%25 Sep 2023https://id.javascript.infoItalian 87%5 Nov 2023https://it.javascript.infoJapanese 90%13 Nov 2024https://ja.javascript.infoKazakh 4%4 Sep 2024Korean 75%29 Dec 2024https://ko.javascript.infoKurdish 1%31 Mar 2025Kyrgyz 10%6 Feb 2024Lithuanian 17%21 Aug 2022Malay 1%14 Apr 2025Malayalam 6%26 Dec 2023Montenegrin 26%15 Dec 2021Norvegian 32%15 Dec 2021Persian (Farsi) 66%21 Feb 2025https://fa.javascript.infoPolish 25%22 Oct 2022Portuguese 28%2 Nov 2024Punjabi 17%15 Dec 2021Romanian 26%6 Sep 2023Russian 91%17 Apr 2025https://learn.javascript.ruSerbian 5%15 Dec 2021Sinhala 11%15 Dec 2021Slovak 11%15 Dec 2021Slovenian 5%15 Dec 2021Spanish 91%2 Apr 2025https://es.javascript.infoTamil 7%15 Dec 2021Telugu 0%13 Apr 2025Thai 20%29 Sep 2024Turkish 64%27 Oct 2024https://tr.javascript.infoTurkmen 11%15 Dec 2021Ukrainian 89%13 Apr 2025https://uk.javascript.infoUrdu 5%20 Feb 2023Uyghur 1%14 Apr 2025Uzbek 51%15 Dec 2021Vietnamese 16%15 Jul 2024Help us to translate: click the language name link above, it leads to the repo. Then read the instruction. That's simple, join in!
Help to translate
To participate in a translation, simply choose the language in the list above.
Then you’ll get to the language page and see instructions. Maybe even in that language, if the readme is translated :)
Becoming a maintainer
Anyone can contribute to a translation. But maintainers are the ones who also watch over its quality.
Maintainers have the power to review and merge pull requests of others.
Please file an issue, if:

You’re already a maintainer of a translation, and would like to add another one.
You’re interested in becoming a maintainer for a translation, and other maintainers agree to add you.
An existing translation is stalled, previous maintainers don’t respond, and you want to take it over.

Starting a new translation
Your language is not in the list?
If you’d like to create a new translation, file an issue with the following information:

Language code
List of maintainers (one or more): github nick and email

As a maintainer, you should know JavaScript well enough to translate and review pull requests of others.
We will:

Create a new repository for you at javascript-tutorial/{lang-code}.javascript.info.
Add/invite all maintainers to the team translate-{lang-code} in the javascript-tutorial organization.
Create an special issue in the new repository to track your translation progress.

You’ll get an email invite to join (unless you’re a member already). Please accept this invite, so you can get admin access to your repository!
You’ll find more translation tips in Readme when the repository is created.
Happy translating!
Publishing
When the translation is at least half-finished, please create an issue with a request to publish. Your name and contributions will show up at the About page.\n\nTranslation of the Modern JavaScript TutorialThere are following translations (in the alphabetical order):LanguageTranslated (%)Last CommitPublishedAlbanian 11%23 Jun 2023Arabic 57%28 May 2023https://ar.javascript.infoArmenian 11%4 May 2024Azerbaijani 19%19 Jan 2025Bengali 34%15 Oct 2023Bosnian 18%15 Dec 2021Bulgarian 24%2 Oct 2023Burmese 5%20 Aug 2023Catalan 32%15 Dec 2021Central Khmer 30%15 Dec 2021Chinese 91%12 Mar 2025https://zh.javascript.infoChinese Traditional 33%15 Dec 2021Croatian 1%22 Aug 2022Czech 14%31 Mar 2025Danish 5%17 Sep 2024Dutch 13%15 Dec 2021Finnish 5%19 Apr 2022French 84%19 Mar 2025https://fr.javascript.infoGeorgian 6%15 Dec 2021German 16%31 Mar 2025Greek 13%31 Mar 2025Hebrew 11%15 Dec 2021Hindi 9%15 Dec 2021Hungarian 7%15 Dec 2021Indonesian 64%25 Sep 2023https://id.javascript.infoItalian 87%5 Nov 2023https://it.javascript.infoJapanese 90%13 Nov 2024https://ja.javascript.infoKazakh 4%4 Sep 2024Korean 75%29 Dec 2024https://ko.javascript.infoKurdish 1%31 Mar 2025Kyrgyz 10%6 Feb 2024Lithuanian 17%21 Aug 2022Malay 1%14 Apr 2025Malayalam 6%26 Dec 2023Montenegrin 26%15 Dec 2021Norvegian 32%15 Dec 2021Persian (Farsi) 66%21 Feb 2025https://fa.javascript.infoPolish 25%22 Oct 2022Portuguese 28%2 Nov 2024Punjabi 17%15 Dec 2021Romanian 26%6 Sep 2023Russian 91%17 Apr 2025https://learn.javascript.ruSerbian 5%15 Dec 2021Sinhala 11%15 Dec 2021Slovak 11%15 Dec 2021Slovenian 5%15 Dec 2021Spanish 91%2 Apr 2025https://es.javascript.infoTamil 7%15 Dec 2021Telugu 0%13 Apr 2025Thai 20%29 Sep 2024Turkish 64%27 Oct 2024https://tr.javascript.infoTurkmen 11%15 Dec 2021Ukrainian 89%13 Apr 2025https://uk.javascript.infoUrdu 5%20 Feb 2023Uyghur 1%14 Apr 2025Uzbek 51%15 Dec 2021Vietnamese 16%15 Jul 2024Help us to translate: click the language name link above, it leads to the repo. Then read the instruction. That's simple, join in!
Help to translate
To participate in a translation, simply choose the language in the list above.
Then you’ll get to the language page and see instructions. Maybe even in that language, if the readme is translated :)
Becoming a maintainer
Anyone can contribute to a translation. But maintainers are the ones who also watch over its quality.
Maintainers have the power to review and merge pull requests of others.
Please file an issue, if:

You’re already a maintainer of a translation, and would like to add another one.
You’re interested in becoming a maintainer for a translation, and other maintainers agree to add you.
An existing translation is stalled, previous maintainers don’t respond, and you want to take it over.

Starting a new translation
Your language is not in the list?
If you’d like to create a new translation, file an issue with the following information:

Language code
List of maintainers (one or more): github nick and email

As a maintainer, you should know JavaScript well enough to translate and review pull requests of others.
We will:

Create a new repository for you at javascript-tutorial/{lang-code}.javascript.info.
Add/invite all maintainers to the team translate-{lang-code} in the javascript-tutorial organization.
Create an special issue in the new repository to track your translation progress.

You’ll get an email invite to join (unless you’re a member already). Please accept this invite, so you can get admin access to your repository!
You’ll find more translation tips in Readme when the repository is created.
Happy translating!
Publishing
When the translation is at least half-finished, please create an issue with a request to publish. Your name and contributions will show up at the About page.\n\n\n\nBuy EPUB/PDF for offline readingPDF/EPUB book is an offline version of the tutorial. Buying this book, you support the project and become able to read the tutorial as e-book. You get the whole content as of now, plus 1 year of free updates.
Download sampleWhich parts of the tutorial you want?Part I. The JavaScript Language710+ pages, PDF + EPUBPart II. Browser: Document, Events, Interfaces300+ pages, PDF + EPUBPart III. Various topics: Network, Regexps, etc.330+ pages, PDF + EPUBParts I && II together2xPDF + 2xEPUB (1000+ pages)Full Tutorial (all 3 parts)3xEPUB + 3xPDF (1300+ pages)Specify your emailThe download link will be sent to this address after payment.In case of any difficulty please contact orders@javascript.info.Proceed with payment\n\nBuy EPUB/PDF for offline readingPDF/EPUB book is an offline version of the tutorial. Buying this book, you support the project and become able to read the tutorial as e-book. You get the whole content as of now, plus 1 year of free updates.
Download sampleWhich parts of the tutorial you want?Part I. The JavaScript Language710+ pages, PDF + EPUBPart II. Browser: Document, Events, Interfaces300+ pages, PDF + EPUBPart III. Various topics: Network, Regexps, etc.330+ pages, PDF + EPUBParts I && II together2xPDF + 2xEPUB (1000+ pages)Full Tutorial (all 3 parts)3xEPUB + 3xPDF (1300+ pages)Specify your emailThe download link will be sent to this address after payment.In case of any difficulty please contact orders@javascript.info.Proceed with payment\n\nBuy EPUB/PDF for offline readingPDF/EPUB book is an offline version of the tutorial. Buying this book, you support the project and become able to read the tutorial as e-book. You get the whole content as of now, plus 1 year of free updates.
Download sampleWhich parts of the tutorial you want?Part I. The JavaScript Language710+ pages, PDF + EPUBPart II. Browser: Document, Events, Interfaces300+ pages, PDF + EPUBPart III. Various topics: Network, Regexps, etc.330+ pages, PDF + EPUBParts I && II together2xPDF + 2xEPUB (1000+ pages)Full Tutorial (all 3 parts)3xEPUB + 3xPDF (1300+ pages)Specify your emailThe download link will be sent to this address after payment.In case of any difficulty please contact orders@javascript.info.Proceed with payment\n\n\n\nShow tasksThe JavaScript languageAn introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Show an alertShow an alert with an external scriptCode structureThe modern mode, "use strict"VariablesWorking with variablesGiving the right nameUppercase const?Data typesString quotesInteraction: alert, prompt, confirmA simple pageType ConversionsBasic operators, mathsThe postfix and prefix formsAssignment resultType conversionsFix the additionComparisonsComparisonsConditional branching: if, '?'if (a string with zero)The name of JavaScriptShow the signRewrite 'if' into '?'Rewrite 'if..else' into '?'Logical operatorsWhat's the result of OR?What's the result of OR'ed alerts?What is the result of AND?What is the result of AND'ed alerts?The result of OR AND ORCheck the range betweenCheck the range outsideA question about "if"Check the loginNullish coalescing operator '??'Loops: while and forLast loop valueWhich values does the while loop show?Which values get shown by the "for" loop?Output even numbers in the loopReplace "for" with "while"Repeat until the input is correctOutput prime numbersThe "switch" statementRewrite the "switch" into an "if"Rewrite "if" into "switch"FunctionsIs "else" required?Rewrite the function using '?' or '||'Function min(a, b)Function pow(x,n)Function expressionsArrow functions, the basicsRewrite with arrow functionsJavaScript specialsCode qualityDebugging in the browserCoding StyleBad styleCommentsNinja codeAutomated testing with MochaWhat's wrong in the test?Polyfills and transpilersObjects: the basicsObjectsHello, objectCheck for emptinessSum object propertiesMultiply numeric property values by 2Object references and copyingGarbage collectionObject methods, "this"Using "this" in object literalCreate a calculatorChainingConstructor, operator "new"Two functions – one objectCreate new CalculatorCreate new AccumulatorOptional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesCan I add a string property?NumbersSum numbers from the visitorWhy 6.35.toFixed(1) == 6.3?Repeat until the input is a numberAn occasional infinite loopA random number from min to maxA random integer from min to maxStringsUppercase the first characterCheck for spamTruncate the textExtract the moneyArraysIs array copied?Array operations.Calling in an array contextSum input numbersA maximal subarrayArray methodsTranslate border-left-width to borderLeftWidthFilter rangeFilter range "in place"Sort in decreasing orderCopy and sort arrayCreate an extendable calculatorMap to namesMap to objectsSort users by ageShuffle an arrayGet average ageFilter unique array membersCreate keyed object from arrayIterablesMap and SetFilter unique array membersFilter anagramsIterable keysWeakMap and WeakSetStore "unread" flagsStore read datesObject.keys, values, entriesSum the propertiesCount propertiesDestructuring assignmentDestructuring assignmentThe maximal salaryDate and timeCreate a dateShow a weekdayEuropean weekdayWhich day of month was many days ago?Last day of month?How many seconds have passed today?How many seconds till tomorrow?Format the relative dateJSON methods, toJSONTurn the object into JSON and backExclude backreferencesAdvanced working with functionsRecursion and stackSum all numbers till the given oneCalculate factorialFibonacci numbersOutput a single-linked listOutput a single-linked list in the reverse orderRest parameters and spread syntaxVariable scope, closureDoes a function pickup latest changes?Which variables are available?Are counters independent?Counter objectFunction in ifSum with closuresIs variable visible?Filter through functionSort by fieldArmy of functionsThe old "var"Global objectFunction object, NFESet and decrease for counterSum with an arbitrary amount of bracketsThe "new Function" syntaxScheduling: setTimeout and setIntervalOutput every secondWhat will setTimeout show?Decorators and forwarding, call/applySpy decoratorDelaying decoratorDebounce decoratorThrottle decoratorFunction bindingBound function as a methodSecond bindFunction property after bindFix a function that loses "this"Partial application for loginArrow functions revisitedObject properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceWorking with prototypeSearching algorithmWhere does it write?Why are both hamsters full?F.prototypeChanging "prototype"Create an object with the same constructorNative prototypesAdd method "f.defer(ms)" to functionsAdd the decorating "defer()" to functionsPrototype methods, objects without __proto__Add toString to the dictionaryThe difference between callsClassesClass basic syntaxRewrite to classClass inheritanceError creating an instanceExtended clockStatic properties and methodsClass extends Object?Private and protected properties and methodsExtending built-in classesClass checking: "instanceof"Strange instanceofMixinsError handlingError handling, "try...catch"Finally or just the code?Custom errors, extending ErrorInherit from SyntaxErrorPromises, async/awaitIntroduction: callbacksPromiseRe-resolve a promise?Delay with a promiseAnimated circle with promisePromises chainingPromise: then versus catchError handling with promisesError in setTimeoutPromise APIPromisificationMicrotasksAsync/awaitRewrite using async/awaitRewrite "rethrow" with async/awaitCall async from non-asyncDangerous Promise.allGenerators, advanced iterationGeneratorsPseudo-random generatorAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectError on reading non-existent propertyAccessing array[-1]ObservableEval: run a code stringEval-calculatorCurryingReference TypeSyntax checkExplain the value of "this"BigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesDocumentBrowser environment, specsDOM treeWalking the DOMDOM childrenThe sibling questionSelect all diagonal cellsSearching: getElement*, querySelector*Search for elementsNode properties: type, tag and contentsCount descendantsWhat's in the nodeType?Tag in commentWhere's the "document" in the hierarchy?Attributes and propertiesGet the attributeMake external links orangeModifying the documentcreateTextNode vs innerHTML vs textContentClear the elementWhy does "aaa" remain?Create a listCreate a tree from the objectShow descendants in a treeCreate a calendarColored clock with setIntervalInsert the HTML in the listSort the tableStyles and classesCreate a notificationElement size and scrollingWhat's the scroll from the bottom?What is the scrollbar width?Place the ball in the field centerThe difference: CSS width versus clientWidthWindow sizes and scrollingCoordinatesFind window coordinates of the fieldShow a note near the elementShow a note near the element (absolute)Position the note inside (absolute)Introduction to EventsIntroduction to browser eventsHide on clickHide selfWhich handlers run?Move the ball across the fieldCreate a sliding menuAdd a closing buttonCarouselBubbling and capturingEvent delegationHide messages with delegationTree menuSortable tableTooltip behaviorBrowser default actionsWhy "return false" doesn't work?Catch links in the elementImage galleryDispatching custom eventsUI EventsMouse eventsSelectable listMoving the mouse: mouseover/out, mouseenter/leaveImproved tooltip behavior"Smart" tooltipDrag'n'Drop with mouse eventsSliderDrag superheroes around the fieldPointer eventsKeyboard: keydown and keyupExtended hotkeysScrollingEndless pageUp/down buttonLoad visible imagesForms, controlsForm properties and methodsAdd an option to selectFocusing: focus/blurEditable divEdit TD on clickKeyboard-driven mouseEvents: change, input, cut, copy, pasteDeposit calculatorForms: event and method submitModal formDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorLoad images with a callbackMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksWhat will be the output of this code?Additional articlesFrames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysConcatenate typed arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFetch users from GitHubFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsWhy do we need Origin?Fetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsStoring data in the browserCookies, document.cookieLocalStorage, sessionStorageAutosave a form fieldIndexedDBAnimationBezier curveCSS-animationsAnimate a plane (CSS)Animate the flying plane (CSS)Animated circleAnimated circle with callbackJavaScript animationsAnimate the bouncing ballAnimate the ball bouncing to the rightWeb componentsFrom the orbital heightCustom elementsLive timer elementShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Regexp ^$Multiline mode of anchors ^ $, flag "m"Word boundary: \bFind the timeEscaping, special charactersSets and ranges [...]Java[^script]Find the time as hh:mm or hh-mmQuantifiers +, *, ? and {n}How to find an ellipsis "..." ?Regexp for HTML colorsGreedy and lazy quantifiersA match for /d+? d+?/Find HTML commentsFind HTML tagsCapturing groupsCheck MAC-addressFind color in the format #abc or #abcdefFind all numbersParse an expressionBackreferences in pattern: \N and \k<name>Alternation (OR) |Find programming languagesFind bbtag pairsFind quoted stringsFind the full tagLookahead and lookbehindFind non-negative integersInsert After HeadCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and String\nThe JavaScript languageAn introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Show an alertShow an alert with an external scriptCode structureThe modern mode, "use strict"VariablesWorking with variablesGiving the right nameUppercase const?Data typesString quotesInteraction: alert, prompt, confirmA simple pageType ConversionsBasic operators, mathsThe postfix and prefix formsAssignment resultType conversionsFix the additionComparisonsComparisonsConditional branching: if, '?'if (a string with zero)The name of JavaScriptShow the signRewrite 'if' into '?'Rewrite 'if..else' into '?'Logical operatorsWhat's the result of OR?What's the result of OR'ed alerts?What is the result of AND?What is the result of AND'ed alerts?The result of OR AND ORCheck the range betweenCheck the range outsideA question about "if"Check the loginNullish coalescing operator '??'Loops: while and forLast loop valueWhich values does the while loop show?Which values get shown by the "for" loop?Output even numbers in the loopReplace "for" with "while"Repeat until the input is correctOutput prime numbersThe "switch" statementRewrite the "switch" into an "if"Rewrite "if" into "switch"FunctionsIs "else" required?Rewrite the function using '?' or '||'Function min(a, b)Function pow(x,n)Function expressionsArrow functions, the basicsRewrite with arrow functionsJavaScript specialsCode qualityDebugging in the browserCoding StyleBad styleCommentsNinja codeAutomated testing with MochaWhat's wrong in the test?Polyfills and transpilersObjects: the basicsObjectsHello, objectCheck for emptinessSum object propertiesMultiply numeric property values by 2Object references and copyingGarbage collectionObject methods, "this"Using "this" in object literalCreate a calculatorChainingConstructor, operator "new"Two functions – one objectCreate new CalculatorCreate new AccumulatorOptional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesCan I add a string property?NumbersSum numbers from the visitorWhy 6.35.toFixed(1) == 6.3?Repeat until the input is a numberAn occasional infinite loopA random number from min to maxA random integer from min to maxStringsUppercase the first characterCheck for spamTruncate the textExtract the moneyArraysIs array copied?Array operations.Calling in an array contextSum input numbersA maximal subarrayArray methodsTranslate border-left-width to borderLeftWidthFilter rangeFilter range "in place"Sort in decreasing orderCopy and sort arrayCreate an extendable calculatorMap to namesMap to objectsSort users by ageShuffle an arrayGet average ageFilter unique array membersCreate keyed object from arrayIterablesMap and SetFilter unique array membersFilter anagramsIterable keysWeakMap and WeakSetStore "unread" flagsStore read datesObject.keys, values, entriesSum the propertiesCount propertiesDestructuring assignmentDestructuring assignmentThe maximal salaryDate and timeCreate a dateShow a weekdayEuropean weekdayWhich day of month was many days ago?Last day of month?How many seconds have passed today?How many seconds till tomorrow?Format the relative dateJSON methods, toJSONTurn the object into JSON and backExclude backreferencesAdvanced working with functionsRecursion and stackSum all numbers till the given oneCalculate factorialFibonacci numbersOutput a single-linked listOutput a single-linked list in the reverse orderRest parameters and spread syntaxVariable scope, closureDoes a function pickup latest changes?Which variables are available?Are counters independent?Counter objectFunction in ifSum with closuresIs variable visible?Filter through functionSort by fieldArmy of functionsThe old "var"Global objectFunction object, NFESet and decrease for counterSum with an arbitrary amount of bracketsThe "new Function" syntaxScheduling: setTimeout and setIntervalOutput every secondWhat will setTimeout show?Decorators and forwarding, call/applySpy decoratorDelaying decoratorDebounce decoratorThrottle decoratorFunction bindingBound function as a methodSecond bindFunction property after bindFix a function that loses "this"Partial application for loginArrow functions revisitedObject properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceWorking with prototypeSearching algorithmWhere does it write?Why are both hamsters full?F.prototypeChanging "prototype"Create an object with the same constructorNative prototypesAdd method "f.defer(ms)" to functionsAdd the decorating "defer()" to functionsPrototype methods, objects without __proto__Add toString to the dictionaryThe difference between callsClassesClass basic syntaxRewrite to classClass inheritanceError creating an instanceExtended clockStatic properties and methodsClass extends Object?Private and protected properties and methodsExtending built-in classesClass checking: "instanceof"Strange instanceofMixinsError handlingError handling, "try...catch"Finally or just the code?Custom errors, extending ErrorInherit from SyntaxErrorPromises, async/awaitIntroduction: callbacksPromiseRe-resolve a promise?Delay with a promiseAnimated circle with promisePromises chainingPromise: then versus catchError handling with promisesError in setTimeoutPromise APIPromisificationMicrotasksAsync/awaitRewrite using async/awaitRewrite "rethrow" with async/awaitCall async from non-asyncDangerous Promise.allGenerators, advanced iterationGeneratorsPseudo-random generatorAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectError on reading non-existent propertyAccessing array[-1]ObservableEval: run a code stringEval-calculatorCurryingReference TypeSyntax checkExplain the value of "this"BigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesDocumentBrowser environment, specsDOM treeWalking the DOMDOM childrenThe sibling questionSelect all diagonal cellsSearching: getElement*, querySelector*Search for elementsNode properties: type, tag and contentsCount descendantsWhat's in the nodeType?Tag in commentWhere's the "document" in the hierarchy?Attributes and propertiesGet the attributeMake external links orangeModifying the documentcreateTextNode vs innerHTML vs textContentClear the elementWhy does "aaa" remain?Create a listCreate a tree from the objectShow descendants in a treeCreate a calendarColored clock with setIntervalInsert the HTML in the listSort the tableStyles and classesCreate a notificationElement size and scrollingWhat's the scroll from the bottom?What is the scrollbar width?Place the ball in the field centerThe difference: CSS width versus clientWidthWindow sizes and scrollingCoordinatesFind window coordinates of the fieldShow a note near the elementShow a note near the element (absolute)Position the note inside (absolute)Introduction to EventsIntroduction to browser eventsHide on clickHide selfWhich handlers run?Move the ball across the fieldCreate a sliding menuAdd a closing buttonCarouselBubbling and capturingEvent delegationHide messages with delegationTree menuSortable tableTooltip behaviorBrowser default actionsWhy "return false" doesn't work?Catch links in the elementImage galleryDispatching custom eventsUI EventsMouse eventsSelectable listMoving the mouse: mouseover/out, mouseenter/leaveImproved tooltip behavior"Smart" tooltipDrag'n'Drop with mouse eventsSliderDrag superheroes around the fieldPointer eventsKeyboard: keydown and keyupExtended hotkeysScrollingEndless pageUp/down buttonLoad visible imagesForms, controlsForm properties and methodsAdd an option to selectFocusing: focus/blurEditable divEdit TD on clickKeyboard-driven mouseEvents: change, input, cut, copy, pasteDeposit calculatorForms: event and method submitModal formDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorLoad images with a callbackMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksWhat will be the output of this code?Additional articlesFrames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysConcatenate typed arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFetch users from GitHubFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsWhy do we need Origin?Fetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsStoring data in the browserCookies, document.cookieLocalStorage, sessionStorageAutosave a form fieldIndexedDBAnimationBezier curveCSS-animationsAnimate a plane (CSS)Animate the flying plane (CSS)Animated circleAnimated circle with callbackJavaScript animationsAnimate the bouncing ballAnimate the ball bouncing to the rightWeb componentsFrom the orbital heightCustom elementsLive timer elementShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Regexp ^$Multiline mode of anchors ^ $, flag "m"Word boundary: \bFind the timeEscaping, special charactersSets and ranges [...]Java[^script]Find the time as hh:mm or hh-mmQuantifiers +, *, ? and {n}How to find an ellipsis "..." ?Regexp for HTML colorsGreedy and lazy quantifiersA match for /d+? d+?/Find HTML commentsFind HTML tagsCapturing groupsCheck MAC-addressFind color in the format #abc or #abcdefFind all numbersParse an expressionBackreferences in pattern: \N and \k<name>Alternation (OR) |Find programming languagesFind bbtag pairsFind quoted stringsFind the full tagLookahead and lookbehindFind non-negative integersInsert After HeadCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and String\nThe JavaScript languageAn introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Show an alertShow an alert with an external scriptCode structureThe modern mode, "use strict"VariablesWorking with variablesGiving the right nameUppercase const?Data typesString quotesInteraction: alert, prompt, confirmA simple pageType ConversionsBasic operators, mathsThe postfix and prefix formsAssignment resultType conversionsFix the additionComparisonsComparisonsConditional branching: if, '?'if (a string with zero)The name of JavaScriptShow the signRewrite 'if' into '?'Rewrite 'if..else' into '?'Logical operatorsWhat's the result of OR?What's the result of OR'ed alerts?What is the result of AND?What is the result of AND'ed alerts?The result of OR AND ORCheck the range betweenCheck the range outsideA question about "if"Check the loginNullish coalescing operator '??'Loops: while and forLast loop valueWhich values does the while loop show?Which values get shown by the "for" loop?Output even numbers in the loopReplace "for" with "while"Repeat until the input is correctOutput prime numbersThe "switch" statementRewrite the "switch" into an "if"Rewrite "if" into "switch"FunctionsIs "else" required?Rewrite the function using '?' or '||'Function min(a, b)Function pow(x,n)Function expressionsArrow functions, the basicsRewrite with arrow functionsJavaScript specialsCode qualityDebugging in the browserCoding StyleBad styleCommentsNinja codeAutomated testing with MochaWhat's wrong in the test?Polyfills and transpilersObjects: the basicsObjectsHello, objectCheck for emptinessSum object propertiesMultiply numeric property values by 2Object references and copyingGarbage collectionObject methods, "this"Using "this" in object literalCreate a calculatorChainingConstructor, operator "new"Two functions – one objectCreate new CalculatorCreate new AccumulatorOptional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesCan I add a string property?NumbersSum numbers from the visitorWhy 6.35.toFixed(1) == 6.3?Repeat until the input is a numberAn occasional infinite loopA random number from min to maxA random integer from min to maxStringsUppercase the first characterCheck for spamTruncate the textExtract the moneyArraysIs array copied?Array operations.Calling in an array contextSum input numbersA maximal subarrayArray methodsTranslate border-left-width to borderLeftWidthFilter rangeFilter range "in place"Sort in decreasing orderCopy and sort arrayCreate an extendable calculatorMap to namesMap to objectsSort users by ageShuffle an arrayGet average ageFilter unique array membersCreate keyed object from arrayIterablesMap and SetFilter unique array membersFilter anagramsIterable keysWeakMap and WeakSetStore "unread" flagsStore read datesObject.keys, values, entriesSum the propertiesCount propertiesDestructuring assignmentDestructuring assignmentThe maximal salaryDate and timeCreate a dateShow a weekdayEuropean weekdayWhich day of month was many days ago?Last day of month?How many seconds have passed today?How many seconds till tomorrow?Format the relative dateJSON methods, toJSONTurn the object into JSON and backExclude backreferencesAdvanced working with functionsRecursion and stackSum all numbers till the given oneCalculate factorialFibonacci numbersOutput a single-linked listOutput a single-linked list in the reverse orderRest parameters and spread syntaxVariable scope, closureDoes a function pickup latest changes?Which variables are available?Are counters independent?Counter objectFunction in ifSum with closuresIs variable visible?Filter through functionSort by fieldArmy of functionsThe old "var"Global objectFunction object, NFESet and decrease for counterSum with an arbitrary amount of bracketsThe "new Function" syntaxScheduling: setTimeout and setIntervalOutput every secondWhat will setTimeout show?Decorators and forwarding, call/applySpy decoratorDelaying decoratorDebounce decoratorThrottle decoratorFunction bindingBound function as a methodSecond bindFunction property after bindFix a function that loses "this"Partial application for loginArrow functions revisitedObject properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceWorking with prototypeSearching algorithmWhere does it write?Why are both hamsters full?F.prototypeChanging "prototype"Create an object with the same constructorNative prototypesAdd method "f.defer(ms)" to functionsAdd the decorating "defer()" to functionsPrototype methods, objects without __proto__Add toString to the dictionaryThe difference between callsClassesClass basic syntaxRewrite to classClass inheritanceError creating an instanceExtended clockStatic properties and methodsClass extends Object?Private and protected properties and methodsExtending built-in classesClass checking: "instanceof"Strange instanceofMixinsError handlingError handling, "try...catch"Finally or just the code?Custom errors, extending ErrorInherit from SyntaxErrorPromises, async/awaitIntroduction: callbacksPromiseRe-resolve a promise?Delay with a promiseAnimated circle with promisePromises chainingPromise: then versus catchError handling with promisesError in setTimeoutPromise APIPromisificationMicrotasksAsync/awaitRewrite using async/awaitRewrite "rethrow" with async/awaitCall async from non-asyncDangerous Promise.allGenerators, advanced iterationGeneratorsPseudo-random generatorAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectError on reading non-existent propertyAccessing array[-1]ObservableEval: run a code stringEval-calculatorCurryingReference TypeSyntax checkExplain the value of "this"BigIntUnicode, String internalsWeakRef and FinalizationRegistry\nThe JavaScript language\nAn introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper console\nAn Introduction to JavaScript\nAn Introduction to JavaScript\nAn Introduction to JavaScript\nManuals and specifications\nManuals and specifications\nManuals and specifications\nJavaScript FundamentalsHello, world!Show an alertShow an alert with an external scriptCode structureThe modern mode, "use strict"VariablesWorking with variablesGiving the right nameUppercase const?Data typesString quotesInteraction: alert, prompt, confirmA simple pageType ConversionsBasic operators, mathsThe postfix and prefix formsAssignment resultType conversionsFix the additionComparisonsComparisonsConditional branching: if, '?'if (a string with zero)The name of JavaScriptShow the signRewrite 'if' into '?'Rewrite 'if..else' into '?'Logical operatorsWhat's the result of OR?What's the result of OR'ed alerts?What is the result of AND?What is the result of AND'ed alerts?The result of OR AND ORCheck the range betweenCheck the range outsideA question about "if"Check the loginNullish coalescing operator '??'Loops: while and forLast loop valueWhich values does the while loop show?Which values get shown by the "for" loop?Output even numbers in the loopReplace "for" with "while"Repeat until the input is correctOutput prime numbersThe "switch" statementRewrite the "switch" into an "if"Rewrite "if" into "switch"FunctionsIs "else" required?Rewrite the function using '?' or '||'Function min(a, b)Function pow(x,n)Function expressionsArrow functions, the basicsRewrite with arrow functionsJavaScript specials\nJavaScript Fundamentals\nJavaScript Fundamentals\nHello, world!Show an alertShow an alert with an external script\nShow an alert with an external script\nShow an alert with an external script\nShow an alert with an external script\nThe modern mode, "use strict"\nThe modern mode, "use strict"\nThe modern mode, "use strict"\nVariablesWorking with variablesGiving the right nameUppercase const?\nWorking with variables\nWorking with variables\nWorking with variables\nGiving the right name\nGiving the right name\nGiving the right name\nData typesString quotes\nInteraction: alert, prompt, confirmA simple page\nInteraction: alert, prompt, confirm\nInteraction: alert, prompt, confirm\nBasic operators, mathsThe postfix and prefix formsAssignment resultType conversionsFix the addition\nBasic operators, maths\nBasic operators, maths\nThe postfix and prefix forms\nThe postfix and prefix forms\nThe postfix and prefix forms\nComparisonsComparisons\nConditional branching: if, '?'if (a string with zero)The name of JavaScriptShow the signRewrite 'if' into '?'Rewrite 'if..else' into '?'\nConditional branching: if, '?'\nConditional branching: if, '?'\nif (a string with zero)\nif (a string with zero)\nif (a string with zero)\nThe name of JavaScript\nThe name of JavaScript\nThe name of JavaScript\nRewrite 'if' into '?'\nRewrite 'if' into '?'\nRewrite 'if' into '?'\nRewrite 'if..else' into '?'\nRewrite 'if..else' into '?'\nRewrite 'if..else' into '?'\nLogical operatorsWhat's the result of OR?What's the result of OR'ed alerts?What is the result of AND?What is the result of AND'ed alerts?The result of OR AND ORCheck the range betweenCheck the range outsideA question about "if"Check the login\nWhat's the result of OR?\nWhat's the result of OR?\nWhat's the result of OR?\nWhat's the result of OR'ed alerts?\nWhat's the result of OR'ed alerts?\nWhat's the result of OR'ed alerts?\nWhat is the result of AND?\nWhat is the result of AND?\nWhat is the result of AND?\nWhat is the result of AND'ed alerts?\nWhat is the result of AND'ed alerts?\nWhat is the result of AND'ed alerts?\nThe result of OR AND OR\nThe result of OR AND OR\nThe result of OR AND OR\nCheck the range between\nCheck the range between\nCheck the range between\nCheck the range outside\nCheck the range outside\nCheck the range outside\nA question about "if"\nA question about "if"\nA question about "if"\nNullish coalescing operator '??'\nNullish coalescing operator '??'\nNullish coalescing operator '??'\nLoops: while and forLast loop valueWhich values does the while loop show?Which values get shown by the "for" loop?Output even numbers in the loopReplace "for" with "while"Repeat until the input is correctOutput prime numbers\nWhich values does the while loop show?\nWhich values does the while loop show?\nWhich values does the while loop show?\nWhich values get shown by the "for" loop?\nWhich values get shown by the "for" loop?\nWhich values get shown by the "for" loop?\nOutput even numbers in the loop\nOutput even numbers in the loop\nOutput even numbers in the loop\nReplace "for" with "while"\nReplace "for" with "while"\nReplace "for" with "while"\nRepeat until the input is correct\nRepeat until the input is correct\nRepeat until the input is correct\nThe "switch" statementRewrite the "switch" into an "if"Rewrite "if" into "switch"\nThe "switch" statement\nThe "switch" statement\nRewrite the "switch" into an "if"\nRewrite the "switch" into an "if"\nRewrite the "switch" into an "if"\nRewrite "if" into "switch"\nRewrite "if" into "switch"\nRewrite "if" into "switch"\nFunctionsIs "else" required?Rewrite the function using '?' or '||'Function min(a, b)Function pow(x,n)\nRewrite the function using '?' or '||'\nRewrite the function using '?' or '||'\nRewrite the function using '?' or '||'\nArrow functions, the basicsRewrite with arrow functions\nArrow functions, the basics\nArrow functions, the basics\nRewrite with arrow functions\nRewrite with arrow functions\nRewrite with arrow functions\nCode qualityDebugging in the browserCoding StyleBad styleCommentsNinja codeAutomated testing with MochaWhat's wrong in the test?Polyfills and transpilers\nDebugging in the browser\nDebugging in the browser\nDebugging in the browser\nCoding StyleBad style\nAutomated testing with MochaWhat's wrong in the test?\nAutomated testing with Mocha\nAutomated testing with Mocha\nWhat's wrong in the test?\nWhat's wrong in the test?\nWhat's wrong in the test?\nPolyfills and transpilers\nPolyfills and transpilers\nPolyfills and transpilers\nObjects: the basicsObjectsHello, objectCheck for emptinessSum object propertiesMultiply numeric property values by 2Object references and copyingGarbage collectionObject methods, "this"Using "this" in object literalCreate a calculatorChainingConstructor, operator "new"Two functions – one objectCreate new CalculatorCreate new AccumulatorOptional chaining '?.'Symbol typeObject to primitive conversion\nObjectsHello, objectCheck for emptinessSum object propertiesMultiply numeric property values by 2\nSum object properties\nSum object properties\nSum object properties\nMultiply numeric property values by 2\nMultiply numeric property values by 2\nMultiply numeric property values by 2\nObject references and copying\nObject references and copying\nObject references and copying\nObject methods, "this"Using "this" in object literalCreate a calculatorChaining\nObject methods, "this"\nObject methods, "this"\nUsing "this" in object literal\nUsing "this" in object literal\nUsing "this" in object literal\nConstructor, operator "new"Two functions – one objectCreate new CalculatorCreate new Accumulator\nConstructor, operator "new"\nConstructor, operator "new"\nTwo functions – one object\nTwo functions – one object\nTwo functions – one object\nCreate new Calculator\nCreate new Calculator\nCreate new Calculator\nCreate new Accumulator\nCreate new Accumulator\nCreate new Accumulator\nOptional chaining '?.'\nOptional chaining '?.'\nOptional chaining '?.'\nObject to primitive conversion\nObject to primitive conversion\nObject to primitive conversion\nData typesMethods of primitivesCan I add a string property?NumbersSum numbers from the visitorWhy 6.35.toFixed(1) == 6.3?Repeat until the input is a numberAn occasional infinite loopA random number from min to maxA random integer from min to maxStringsUppercase the first characterCheck for spamTruncate the textExtract the moneyArraysIs array copied?Array operations.Calling in an array contextSum input numbersA maximal subarrayArray methodsTranslate border-left-width to borderLeftWidthFilter rangeFilter range "in place"Sort in decreasing orderCopy and sort arrayCreate an extendable calculatorMap to namesMap to objectsSort users by ageShuffle an arrayGet average ageFilter unique array membersCreate keyed object from arrayIterablesMap and SetFilter unique array membersFilter anagramsIterable keysWeakMap and WeakSetStore "unread" flagsStore read datesObject.keys, values, entriesSum the propertiesCount propertiesDestructuring assignmentDestructuring assignmentThe maximal salaryDate and timeCreate a dateShow a weekdayEuropean weekdayWhich day of month was many days ago?Last day of month?How many seconds have passed today?How many seconds till tomorrow?Format the relative dateJSON methods, toJSONTurn the object into JSON and backExclude backreferences\nMethods of primitivesCan I add a string property?\nMethods of primitives\nMethods of primitives\nCan I add a string property?\nCan I add a string property?\nCan I add a string property?\nNumbersSum numbers from the visitorWhy 6.35.toFixed(1) == 6.3?Repeat until the input is a numberAn occasional infinite loopA random number from min to maxA random integer from min to max\nSum numbers from the visitor\nSum numbers from the visitor\nSum numbers from the visitor\nWhy 6.35.toFixed(1) == 6.3?\nWhy 6.35.toFixed(1) == 6.3?\nWhy 6.35.toFixed(1) == 6.3?\nRepeat until the input is a number\nRepeat until the input is a number\nRepeat until the input is a number\nAn occasional infinite loop\nAn occasional infinite loop\nAn occasional infinite loop\nA random number from min to max\nA random number from min to max\nA random number from min to max\nA random integer from min to max\nA random integer from min to max\nA random integer from min to max\nStringsUppercase the first characterCheck for spamTruncate the textExtract the money\nUppercase the first character\nUppercase the first character\nUppercase the first character\nArraysIs array copied?Array operations.Calling in an array contextSum input numbersA maximal subarray\nCalling in an array context\nCalling in an array context\nCalling in an array context\nArray methodsTranslate border-left-width to borderLeftWidthFilter rangeFilter range "in place"Sort in decreasing orderCopy and sort arrayCreate an extendable calculatorMap to namesMap to objectsSort users by ageShuffle an arrayGet average ageFilter unique array membersCreate keyed object from array\nTranslate border-left-width to borderLeftWidth\nTranslate border-left-width to borderLeftWidth\nTranslate border-left-width to borderLeftWidth\nFilter range "in place"\nFilter range "in place"\nFilter range "in place"\nSort in decreasing order\nSort in decreasing order\nSort in decreasing order\nCreate an extendable calculator\nCreate an extendable calculator\nCreate an extendable calculator\nFilter unique array members\nFilter unique array members\nFilter unique array members\nCreate keyed object from array\nCreate keyed object from array\nCreate keyed object from array\nMap and SetFilter unique array membersFilter anagramsIterable keys\nFilter unique array members\nFilter unique array members\nFilter unique array members\nWeakMap and WeakSetStore "unread" flagsStore read dates\nObject.keys, values, entriesSum the propertiesCount properties\nObject.keys, values, entries\nObject.keys, values, entries\nDestructuring assignmentDestructuring assignmentThe maximal salary\nDestructuring assignment\nDestructuring assignment\nDestructuring assignment\nDestructuring assignment\nDestructuring assignment\nDate and timeCreate a dateShow a weekdayEuropean weekdayWhich day of month was many days ago?Last day of month?How many seconds have passed today?How many seconds till tomorrow?Format the relative date\nWhich day of month was many days ago?\nWhich day of month was many days ago?\nWhich day of month was many days ago?\nHow many seconds have passed today?\nHow many seconds have passed today?\nHow many seconds have passed today?\nHow many seconds till tomorrow?\nHow many seconds till tomorrow?\nHow many seconds till tomorrow?\nFormat the relative date\nFormat the relative date\nFormat the relative date\nJSON methods, toJSONTurn the object into JSON and backExclude backreferences\nTurn the object into JSON and back\nTurn the object into JSON and back\nTurn the object into JSON and back\nExclude backreferences\nExclude backreferences\nExclude backreferences\nAdvanced working with functionsRecursion and stackSum all numbers till the given oneCalculate factorialFibonacci numbersOutput a single-linked listOutput a single-linked list in the reverse orderRest parameters and spread syntaxVariable scope, closureDoes a function pickup latest changes?Which variables are available?Are counters independent?Counter objectFunction in ifSum with closuresIs variable visible?Filter through functionSort by fieldArmy of functionsThe old "var"Global objectFunction object, NFESet and decrease for counterSum with an arbitrary amount of bracketsThe "new Function" syntaxScheduling: setTimeout and setIntervalOutput every secondWhat will setTimeout show?Decorators and forwarding, call/applySpy decoratorDelaying decoratorDebounce decoratorThrottle decoratorFunction bindingBound function as a methodSecond bindFunction property after bindFix a function that loses "this"Partial application for loginArrow functions revisited\nAdvanced working with functions\nAdvanced working with functions\nRecursion and stackSum all numbers till the given oneCalculate factorialFibonacci numbersOutput a single-linked listOutput a single-linked list in the reverse order\nSum all numbers till the given one\nSum all numbers till the given one\nSum all numbers till the given one\nOutput a single-linked list\nOutput a single-linked list\nOutput a single-linked list\nOutput a single-linked list in the reverse order\nOutput a single-linked list in the reverse order\nOutput a single-linked list in the reverse order\nRest parameters and spread syntax\nRest parameters and spread syntax\nRest parameters and spread syntax\nVariable scope, closureDoes a function pickup latest changes?Which variables are available?Are counters independent?Counter objectFunction in ifSum with closuresIs variable visible?Filter through functionSort by fieldArmy of functions\nVariable scope, closure\nVariable scope, closure\nDoes a function pickup latest changes?\nDoes a function pickup latest changes?\nDoes a function pickup latest changes?\nWhich variables are available?\nWhich variables are available?\nWhich variables are available?\nAre counters independent?\nAre counters independent?\nAre counters independent?\nFilter through function\nFilter through function\nFilter through function\nFunction object, NFESet and decrease for counterSum with an arbitrary amount of brackets\nSet and decrease for counter\nSet and decrease for counter\nSet and decrease for counter\nSum with an arbitrary amount of brackets\nSum with an arbitrary amount of brackets\nSum with an arbitrary amount of brackets\nThe "new Function" syntax\nThe "new Function" syntax\nThe "new Function" syntax\nScheduling: setTimeout and setIntervalOutput every secondWhat will setTimeout show?\nScheduling: setTimeout and setInterval\nScheduling: setTimeout and setInterval\nWhat will setTimeout show?\nWhat will setTimeout show?\nWhat will setTimeout show?\nDecorators and forwarding, call/applySpy decoratorDelaying decoratorDebounce decoratorThrottle decorator\nDecorators and forwarding, call/apply\nDecorators and forwarding, call/apply\nFunction bindingBound function as a methodSecond bindFunction property after bindFix a function that loses "this"Partial application for login\nBound function as a method\nBound function as a method\nBound function as a method\nFunction property after bind\nFunction property after bind\nFunction property after bind\nFix a function that loses "this"\nFix a function that loses "this"\nFix a function that loses "this"\nPartial application for login\nPartial application for login\nPartial application for login\nArrow functions revisited\nArrow functions revisited\nArrow functions revisited\nObject properties configurationProperty flags and descriptorsProperty getters and setters\nObject properties configuration\nObject properties configuration\nProperty flags and descriptors\nProperty flags and descriptors\nProperty flags and descriptors\nProperty getters and setters\nProperty getters and setters\nProperty getters and setters\nPrototypes, inheritancePrototypal inheritanceWorking with prototypeSearching algorithmWhere does it write?Why are both hamsters full?F.prototypeChanging "prototype"Create an object with the same constructorNative prototypesAdd method "f.defer(ms)" to functionsAdd the decorating "defer()" to functionsPrototype methods, objects without __proto__Add toString to the dictionaryThe difference between calls\nPrototypes, inheritance\nPrototypes, inheritance\nPrototypal inheritanceWorking with prototypeSearching algorithmWhere does it write?Why are both hamsters full?\nPrototypal inheritance\nPrototypal inheritance\nWorking with prototype\nWorking with prototype\nWorking with prototype\nWhy are both hamsters full?\nWhy are both hamsters full?\nWhy are both hamsters full?\nF.prototypeChanging "prototype"Create an object with the same constructor\nCreate an object with the same constructor\nCreate an object with the same constructor\nCreate an object with the same constructor\nNative prototypesAdd method "f.defer(ms)" to functionsAdd the decorating "defer()" to functions\nAdd method "f.defer(ms)" to functions\nAdd method "f.defer(ms)" to functions\nAdd method "f.defer(ms)" to functions\nAdd the decorating "defer()" to functions\nAdd the decorating "defer()" to functions\nAdd the decorating "defer()" to functions\nPrototype methods, objects without __proto__Add toString to the dictionaryThe difference between calls\nPrototype methods, objects without __proto__\nPrototype methods, objects without __proto__\nAdd toString to the dictionary\nAdd toString to the dictionary\nAdd toString to the dictionary\nThe difference between calls\nThe difference between calls\nThe difference between calls\nClassesClass basic syntaxRewrite to classClass inheritanceError creating an instanceExtended clockStatic properties and methodsClass extends Object?Private and protected properties and methodsExtending built-in classesClass checking: "instanceof"Strange instanceofMixins\nClass basic syntaxRewrite to class\nClass inheritanceError creating an instanceExtended clock\nError creating an instance\nError creating an instance\nError creating an instance\nStatic properties and methodsClass extends Object?\nStatic properties and methods\nStatic properties and methods\nClass extends Object?\nClass extends Object?\nClass extends Object?\nPrivate and protected properties and methods\nPrivate and protected properties and methods\nPrivate and protected properties and methods\nExtending built-in classes\nExtending built-in classes\nExtending built-in classes\nClass checking: "instanceof"Strange instanceof\nClass checking: "instanceof"\nClass checking: "instanceof"\nError handlingError handling, "try...catch"Finally or just the code?Custom errors, extending ErrorInherit from SyntaxError\nError handling, "try...catch"Finally or just the code?\nError handling, "try...catch"\nError handling, "try...catch"\nFinally or just the code?\nFinally or just the code?\nFinally or just the code?\nCustom errors, extending ErrorInherit from SyntaxError\nCustom errors, extending Error\nCustom errors, extending Error\nInherit from SyntaxError\nInherit from SyntaxError\nInherit from SyntaxError\nPromises, async/awaitIntroduction: callbacksPromiseRe-resolve a promise?Delay with a promiseAnimated circle with promisePromises chainingPromise: then versus catchError handling with promisesError in setTimeoutPromise APIPromisificationMicrotasksAsync/awaitRewrite using async/awaitRewrite "rethrow" with async/awaitCall async from non-asyncDangerous Promise.all\nPromises, async/await\nPromises, async/await\nIntroduction: callbacks\nIntroduction: callbacks\nIntroduction: callbacks\nPromiseRe-resolve a promise?Delay with a promiseAnimated circle with promise\nRe-resolve a promise?\nRe-resolve a promise?\nRe-resolve a promise?\nAnimated circle with promise\nAnimated circle with promise\nAnimated circle with promise\nPromises chainingPromise: then versus catch\nPromise: then versus catch\nPromise: then versus catch\nPromise: then versus catch\nError handling with promisesError in setTimeout\nError handling with promises\nError handling with promises\nAsync/awaitRewrite using async/awaitRewrite "rethrow" with async/awaitCall async from non-asyncDangerous Promise.all\nRewrite using async/await\nRewrite using async/await\nRewrite using async/await\nRewrite "rethrow" with async/await\nRewrite "rethrow" with async/await\nRewrite "rethrow" with async/await\nCall async from non-async\nCall async from non-async\nCall async from non-async\nDangerous Promise.all\nDangerous Promise.all\nDangerous Promise.all\nGenerators, advanced iterationGeneratorsPseudo-random generatorAsync iteration and generators\nGenerators, advanced iteration\nGenerators, advanced iteration\nGeneratorsPseudo-random generator\nPseudo-random generator\nPseudo-random generator\nPseudo-random generator\nAsync iteration and generators\nAsync iteration and generators\nAsync iteration and generators\nModulesModules, introductionExport and ImportDynamic imports\nModules, introduction\nModules, introduction\nModules, introduction\nMiscellaneousProxy and ReflectError on reading non-existent propertyAccessing array[-1]ObservableEval: run a code stringEval-calculatorCurryingReference TypeSyntax checkExplain the value of "this"BigIntUnicode, String internalsWeakRef and FinalizationRegistry\nProxy and ReflectError on reading non-existent propertyAccessing array[-1]Observable\nError on reading non-existent property\nError on reading non-existent property\nError on reading non-existent property\nEval: run a code stringEval-calculator\nEval: run a code string\nEval: run a code string\nReference TypeSyntax checkExplain the value of "this"\nExplain the value of "this"\nExplain the value of "this"\nExplain the value of "this"\nUnicode, String internals\nUnicode, String internals\nUnicode, String internals\nWeakRef and FinalizationRegistry\nWeakRef and FinalizationRegistry\nWeakRef and FinalizationRegistry\nBrowser: Document, Events, InterfacesDocumentBrowser environment, specsDOM treeWalking the DOMDOM childrenThe sibling questionSelect all diagonal cellsSearching: getElement*, querySelector*Search for elementsNode properties: type, tag and contentsCount descendantsWhat's in the nodeType?Tag in commentWhere's the "document" in the hierarchy?Attributes and propertiesGet the attributeMake external links orangeModifying the documentcreateTextNode vs innerHTML vs textContentClear the elementWhy does "aaa" remain?Create a listCreate a tree from the objectShow descendants in a treeCreate a calendarColored clock with setIntervalInsert the HTML in the listSort the tableStyles and classesCreate a notificationElement size and scrollingWhat's the scroll from the bottom?What is the scrollbar width?Place the ball in the field centerThe difference: CSS width versus clientWidthWindow sizes and scrollingCoordinatesFind window coordinates of the fieldShow a note near the elementShow a note near the element (absolute)Position the note inside (absolute)Introduction to EventsIntroduction to browser eventsHide on clickHide selfWhich handlers run?Move the ball across the fieldCreate a sliding menuAdd a closing buttonCarouselBubbling and capturingEvent delegationHide messages with delegationTree menuSortable tableTooltip behaviorBrowser default actionsWhy "return false" doesn't work?Catch links in the elementImage galleryDispatching custom eventsUI EventsMouse eventsSelectable listMoving the mouse: mouseover/out, mouseenter/leaveImproved tooltip behavior"Smart" tooltipDrag'n'Drop with mouse eventsSliderDrag superheroes around the fieldPointer eventsKeyboard: keydown and keyupExtended hotkeysScrollingEndless pageUp/down buttonLoad visible imagesForms, controlsForm properties and methodsAdd an option to selectFocusing: focus/blurEditable divEdit TD on clickKeyboard-driven mouseEvents: change, input, cut, copy, pasteDeposit calculatorForms: event and method submitModal formDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorLoad images with a callbackMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksWhat will be the output of this code?\nBrowser: Document, Events, Interfaces\nDocumentBrowser environment, specsDOM treeWalking the DOMDOM childrenThe sibling questionSelect all diagonal cellsSearching: getElement*, querySelector*Search for elementsNode properties: type, tag and contentsCount descendantsWhat's in the nodeType?Tag in commentWhere's the "document" in the hierarchy?Attributes and propertiesGet the attributeMake external links orangeModifying the documentcreateTextNode vs innerHTML vs textContentClear the elementWhy does "aaa" remain?Create a listCreate a tree from the objectShow descendants in a treeCreate a calendarColored clock with setIntervalInsert the HTML in the listSort the tableStyles and classesCreate a notificationElement size and scrollingWhat's the scroll from the bottom?What is the scrollbar width?Place the ball in the field centerThe difference: CSS width versus clientWidthWindow sizes and scrollingCoordinatesFind window coordinates of the fieldShow a note near the elementShow a note near the element (absolute)Position the note inside (absolute)\nBrowser environment, specs\nBrowser environment, specs\nBrowser environment, specs\nWalking the DOMDOM childrenThe sibling questionSelect all diagonal cells\nSelect all diagonal cells\nSelect all diagonal cells\nSelect all diagonal cells\nSearching: getElement*, querySelector*Search for elements\nSearching: getElement*, querySelector*\nSearching: getElement*, querySelector*\nNode properties: type, tag and contentsCount descendantsWhat's in the nodeType?Tag in commentWhere's the "document" in the hierarchy?\nNode properties: type, tag and contents\nNode properties: type, tag and contents\nWhat's in the nodeType?\nWhat's in the nodeType?\nWhat's in the nodeType?\nWhere's the "document" in the hierarchy?\nWhere's the "document" in the hierarchy?\nWhere's the "document" in the hierarchy?\nAttributes and propertiesGet the attributeMake external links orange\nAttributes and properties\nAttributes and properties\nMake external links orange\nMake external links orange\nMake external links orange\nModifying the documentcreateTextNode vs innerHTML vs textContentClear the elementWhy does "aaa" remain?Create a listCreate a tree from the objectShow descendants in a treeCreate a calendarColored clock with setIntervalInsert the HTML in the listSort the table\nModifying the document\nModifying the document\ncreateTextNode vs innerHTML vs textContent\ncreateTextNode vs innerHTML vs textContent\ncreateTextNode vs innerHTML vs textContent\nWhy does "aaa" remain?\nWhy does "aaa" remain?\nWhy does "aaa" remain?\nCreate a tree from the object\nCreate a tree from the object\nCreate a tree from the object\nShow descendants in a tree\nShow descendants in a tree\nShow descendants in a tree\nColored clock with setInterval\nColored clock with setInterval\nColored clock with setInterval\nInsert the HTML in the list\nInsert the HTML in the list\nInsert the HTML in the list\nStyles and classesCreate a notification\nCreate a notification\nCreate a notification\nCreate a notification\nElement size and scrollingWhat's the scroll from the bottom?What is the scrollbar width?Place the ball in the field centerThe difference: CSS width versus clientWidth\nElement size and scrolling\nElement size and scrolling\nWhat's the scroll from the bottom?\nWhat's the scroll from the bottom?\nWhat's the scroll from the bottom?\nWhat is the scrollbar width?\nWhat is the scrollbar width?\nWhat is the scrollbar width?\nPlace the ball in the field center\nPlace the ball in the field center\nPlace the ball in the field center\nThe difference: CSS width versus clientWidth\nThe difference: CSS width versus clientWidth\nThe difference: CSS width versus clientWidth\nWindow sizes and scrolling\nWindow sizes and scrolling\nWindow sizes and scrolling\nCoordinatesFind window coordinates of the fieldShow a note near the elementShow a note near the element (absolute)Position the note inside (absolute)\nFind window coordinates of the field\nFind window coordinates of the field\nFind window coordinates of the field\nShow a note near the element\nShow a note near the element\nShow a note near the element\nShow a note near the element (absolute)\nShow a note near the element (absolute)\nShow a note near the element (absolute)\nPosition the note inside (absolute)\nPosition the note inside (absolute)\nPosition the note inside (absolute)\nIntroduction to EventsIntroduction to browser eventsHide on clickHide selfWhich handlers run?Move the ball across the fieldCreate a sliding menuAdd a closing buttonCarouselBubbling and capturingEvent delegationHide messages with delegationTree menuSortable tableTooltip behaviorBrowser default actionsWhy "return false" doesn't work?Catch links in the elementImage galleryDispatching custom events\nIntroduction to Events\nIntroduction to Events\nIntroduction to browser eventsHide on clickHide selfWhich handlers run?Move the ball across the fieldCreate a sliding menuAdd a closing buttonCarousel\nIntroduction to browser events\nIntroduction to browser events\nMove the ball across the field\nMove the ball across the field\nMove the ball across the field\nCreate a sliding menu\nCreate a sliding menu\nCreate a sliding menu\nBubbling and capturing\nBubbling and capturing\nBubbling and capturing\nEvent delegationHide messages with delegationTree menuSortable tableTooltip behavior\nHide messages with delegation\nHide messages with delegation\nHide messages with delegation\nBrowser default actionsWhy "return false" doesn't work?Catch links in the elementImage gallery\nBrowser default actions\nBrowser default actions\nWhy "return false" doesn't work?\nWhy "return false" doesn't work?\nWhy "return false" doesn't work?\nCatch links in the element\nCatch links in the element\nCatch links in the element\nDispatching custom events\nDispatching custom events\nDispatching custom events\nUI EventsMouse eventsSelectable listMoving the mouse: mouseover/out, mouseenter/leaveImproved tooltip behavior"Smart" tooltipDrag'n'Drop with mouse eventsSliderDrag superheroes around the fieldPointer eventsKeyboard: keydown and keyupExtended hotkeysScrollingEndless pageUp/down buttonLoad visible images\nMouse eventsSelectable list\nMoving the mouse: mouseover/out, mouseenter/leaveImproved tooltip behavior"Smart" tooltip\nMoving the mouse: mouseover/out, mouseenter/leave\nMoving the mouse: mouseover/out, mouseenter/leave\nImproved tooltip behavior\nImproved tooltip behavior\nImproved tooltip behavior\nDrag'n'Drop with mouse eventsSliderDrag superheroes around the field\nDrag'n'Drop with mouse events\nDrag'n'Drop with mouse events\nDrag superheroes around the field\nDrag superheroes around the field\nDrag superheroes around the field\nKeyboard: keydown and keyupExtended hotkeys\nKeyboard: keydown and keyup\nKeyboard: keydown and keyup\nScrollingEndless pageUp/down buttonLoad visible images\nForms, controlsForm properties and methodsAdd an option to selectFocusing: focus/blurEditable divEdit TD on clickKeyboard-driven mouseEvents: change, input, cut, copy, pasteDeposit calculatorForms: event and method submitModal form\nForm properties and methodsAdd an option to select\nForm properties and methods\nForm properties and methods\nAdd an option to select\nAdd an option to select\nAdd an option to select\nFocusing: focus/blurEditable divEdit TD on clickKeyboard-driven mouse\nKeyboard-driven mouse\nKeyboard-driven mouse\nKeyboard-driven mouse\nEvents: change, input, cut, copy, pasteDeposit calculator\nEvents: change, input, cut, copy, paste\nEvents: change, input, cut, copy, paste\nForms: event and method submitModal form\nForms: event and method submit\nForms: event and method submit\nDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorLoad images with a callback\nDocument and resource loading\nDocument and resource loading\nPage: DOMContentLoaded, load, beforeunload, unload\nPage: DOMContentLoaded, load, beforeunload, unload\nPage: DOMContentLoaded, load, beforeunload, unload\nScripts: async, defer\nScripts: async, defer\nScripts: async, defer\nResource loading: onload and onerrorLoad images with a callback\nResource loading: onload and onerror\nResource loading: onload and onerror\nLoad images with a callback\nLoad images with a callback\nLoad images with a callback\nMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksWhat will be the output of this code?\nEvent loop: microtasks and macrotasksWhat will be the output of this code?\nEvent loop: microtasks and macrotasks\nEvent loop: microtasks and macrotasks\nWhat will be the output of this code?\nWhat will be the output of this code?\nWhat will be the output of this code?\nAdditional articlesFrames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysConcatenate typed arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFetch users from GitHubFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsWhy do we need Origin?Fetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsStoring data in the browserCookies, document.cookieLocalStorage, sessionStorageAutosave a form fieldIndexedDBAnimationBezier curveCSS-animationsAnimate a plane (CSS)Animate the flying plane (CSS)Animated circleAnimated circle with callbackJavaScript animationsAnimate the bouncing ballAnimate the ball bouncing to the rightWeb componentsFrom the orbital heightCustom elementsLive timer elementShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Regexp ^$Multiline mode of anchors ^ $, flag "m"Word boundary: \bFind the timeEscaping, special charactersSets and ranges [...]Java[^script]Find the time as hh:mm or hh-mmQuantifiers +, *, ? and {n}How to find an ellipsis "..." ?Regexp for HTML colorsGreedy and lazy quantifiersA match for /d+? d+?/Find HTML commentsFind HTML tagsCapturing groupsCheck MAC-addressFind color in the format #abc or #abcdefFind all numbersParse an expressionBackreferences in pattern: \N and \k<name>Alternation (OR) |Find programming languagesFind bbtag pairsFind quoted stringsFind the full tagLookahead and lookbehindFind non-negative integersInsert After HeadCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and String\nFrames and windowsPopups and window methodsCross-window communicationThe clickjacking attack\nPopups and window methods\nPopups and window methods\nPopups and window methods\nCross-window communication\nCross-window communication\nCross-window communication\nThe clickjacking attack\nThe clickjacking attack\nThe clickjacking attack\nBinary data, filesArrayBuffer, binary arraysConcatenate typed arraysTextDecoder and TextEncoderBlobFile and FileReader\nArrayBuffer, binary arraysConcatenate typed arrays\nArrayBuffer, binary arrays\nArrayBuffer, binary arrays\nConcatenate typed arrays\nConcatenate typed arrays\nConcatenate typed arrays\nTextDecoder and TextEncoder\nTextDecoder and TextEncoder\nTextDecoder and TextEncoder\nNetwork requestsFetchFetch users from GitHubFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsWhy do we need Origin?Fetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent Events\nFetchFetch users from GitHub\nFetch users from GitHub\nFetch users from GitHub\nFetch users from GitHub\nFetch: Download progress\nFetch: Download progress\nFetch: Download progress\nFetch: Cross-Origin RequestsWhy do we need Origin?\nFetch: Cross-Origin Requests\nFetch: Cross-Origin Requests\nWhy do we need Origin?\nWhy do we need Origin?\nWhy do we need Origin?\nResumable file upload\nResumable file upload\nResumable file upload\nStoring data in the browserCookies, document.cookieLocalStorage, sessionStorageAutosave a form fieldIndexedDB\nStoring data in the browser\nStoring data in the browser\nCookies, document.cookie\nCookies, document.cookie\nCookies, document.cookie\nLocalStorage, sessionStorageAutosave a form field\nLocalStorage, sessionStorage\nLocalStorage, sessionStorage\nAutosave a form field\nAutosave a form field\nAutosave a form field\nAnimationBezier curveCSS-animationsAnimate a plane (CSS)Animate the flying plane (CSS)Animated circleAnimated circle with callbackJavaScript animationsAnimate the bouncing ballAnimate the ball bouncing to the right\nCSS-animationsAnimate a plane (CSS)Animate the flying plane (CSS)Animated circleAnimated circle with callback\nAnimate a plane (CSS)\nAnimate a plane (CSS)\nAnimate a plane (CSS)\nAnimate the flying plane (CSS)\nAnimate the flying plane (CSS)\nAnimate the flying plane (CSS)\nAnimated circle with callback\nAnimated circle with callback\nAnimated circle with callback\nJavaScript animationsAnimate the bouncing ballAnimate the ball bouncing to the right\nJavaScript animations\nJavaScript animations\nAnimate the bouncing ball\nAnimate the bouncing ball\nAnimate the bouncing ball\nAnimate the ball bouncing to the right\nAnimate the ball bouncing to the right\nAnimate the ball bouncing to the right\nWeb componentsFrom the orbital heightCustom elementsLive timer elementShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and events\nFrom the orbital height\nFrom the orbital height\nFrom the orbital height\nCustom elementsLive timer element\nShadow DOM slots, composition\nShadow DOM slots, composition\nShadow DOM slots, composition\nShadow DOM and events\nShadow DOM and events\nShadow DOM and events\nRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Regexp ^$Multiline mode of anchors ^ $, flag "m"Word boundary: \bFind the timeEscaping, special charactersSets and ranges [...]Java[^script]Find the time as hh:mm or hh-mmQuantifiers +, *, ? and {n}How to find an ellipsis "..." ?Regexp for HTML colorsGreedy and lazy quantifiersA match for /d+? d+?/Find HTML commentsFind HTML tagsCapturing groupsCheck MAC-addressFind color in the format #abc or #abcdefFind all numbersParse an expressionBackreferences in pattern: \N and \k<name>Alternation (OR) |Find programming languagesFind bbtag pairsFind quoted stringsFind the full tagLookahead and lookbehindFind non-negative integersInsert After HeadCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and String\nUnicode: flag "u" and class \p{...}\nUnicode: flag "u" and class \p{...}\nUnicode: flag "u" and class \p{...}\nAnchors: string start ^ and end $Regexp ^$\nAnchors: string start ^ and end $\nAnchors: string start ^ and end $\nMultiline mode of anchors ^ $, flag "m"\nMultiline mode of anchors ^ $, flag "m"\nMultiline mode of anchors ^ $, flag "m"\nWord boundary: \bFind the time\nEscaping, special characters\nEscaping, special characters\nEscaping, special characters\nSets and ranges [...]Java[^script]Find the time as hh:mm or hh-mm\nSets and ranges [...]\nSets and ranges [...]\nFind the time as hh:mm or hh-mm\nFind the time as hh:mm or hh-mm\nFind the time as hh:mm or hh-mm\nQuantifiers +, *, ? and {n}How to find an ellipsis "..." ?Regexp for HTML colors\nQuantifiers +, *, ? and {n}\nQuantifiers +, *, ? and {n}\nHow to find an ellipsis "..." ?\nHow to find an ellipsis "..." ?\nHow to find an ellipsis "..." ?\nRegexp for HTML colors\nRegexp for HTML colors\nRegexp for HTML colors\nGreedy and lazy quantifiersA match for /d+? d+?/Find HTML commentsFind HTML tags\nGreedy and lazy quantifiers\nGreedy and lazy quantifiers\nA match for /d+? d+?/\nA match for /d+? d+?/\nA match for /d+? d+?/\nCapturing groupsCheck MAC-addressFind color in the format #abc or #abcdefFind all numbersParse an expression\nFind color in the format #abc or #abcdef\nFind color in the format #abc or #abcdef\nFind color in the format #abc or #abcdef\nBackreferences in pattern: \N and \k<name>\nBackreferences in pattern: \N and \k<name>\nBackreferences in pattern: \N and \k<name>\nAlternation (OR) |Find programming languagesFind bbtag pairsFind quoted stringsFind the full tag\nFind programming languages\nFind programming languages\nFind programming languages\nLookahead and lookbehindFind non-negative integersInsert After Head\nLookahead and lookbehind\nLookahead and lookbehind\nFind non-negative integers\nFind non-negative integers\nFind non-negative integers\nCatastrophic backtracking\nCatastrophic backtracking\nCatastrophic backtracking\nSticky flag "y", searching at position\nSticky flag "y", searching at position\nSticky flag "y", searching at position\nMethods of RegExp and String\nMethods of RegExp and String\nMethods of RegExp and String\n\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTutorialThe JavaScript languageAn introductionAbout the JavaScript language and the environment to develop with it.
An Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consolePrevious lessonNext lessonShareTutorial map\n\nAbout the JavaScript language and the environment to develop with it.
An Introduction to JavaScriptManuals and specificationsCode editorsDeveloper console\n\nTutorialThe JavaScript languageAn introductionAbout the JavaScript language and the environment to develop with it.
An Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consolePrevious lessonNext lessonShareTutorial map\n\n\n\nLet’s see what’s so special about JavaScript, what we can achieve with it, and what other technologies play well with it.
What is JavaScript?JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Scripts are provided and executed as plain text. They don’t need special preparation or compilation to run.
In this aspect, JavaScript is very different from another language called Java.

            Why is it called JavaScript?
            When JavaScript was created, it initially had another name: “LiveScript”. But Java was very popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help.
But as it evolved, JavaScript became a fully independent language with its own specification called ECMAScript, and now it has no relation to Java at all.

Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.
Different engines have different “codenames”. For example:

V8 – in Chrome, Opera and Edge.
SpiderMonkey – in Firefox.
…There are other codenames like “Chakra” for IE, “JavaScriptCore”, “Nitro” and “SquirrelFish” for Safari, etc.

The terms above are good to remember because they are used in developer articles on the internet. We’ll use them too. For instance, if “a feature X is supported by V8”, then it probably works in Chrome, Opera and Edge.

            How do engines work?
            Engines are complicated. But the basics are easy.

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to machine code.
And then the machine code runs, pretty fast.

The engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.

What can in-browser JavaScript do?Modern JavaScript is a “safe” programming language. It does not provide low-level access to memory or the CPU, because it was initially created for browsers which do not require it.
JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.
For instance, in-browser JavaScript is able to:

Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

What CAN’T in-browser JavaScript do?JavaScript’s abilities in the browser are limited to protect the user’s safety. The aim is to prevent an evil webpage from accessing private information or harming the user’s data.
Examples of such restrictions include:


JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.
There are ways to interact with the camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.


Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other page if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and must contain special JavaScript code that handles it. We’ll cover that in the tutorial.
This limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com, for example, and steal information from there.


JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.



      
      
        
      
      Such limitations do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugins/extensions which may ask for extended permissions.
What makes JavaScript unique?There are at least three great things about JavaScript:
Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.
JavaScript is the only browser technology that combines these three things.
That’s what makes JavaScript unique. That’s why it’s the most widespread tool for creating browser interfaces.
That said, JavaScript can be used to create servers, mobile applications, etc.
Languages “over” JavaScriptThe syntax of JavaScript does not suit everyone’s needs. Different people want different features.
That’s to be expected, because projects and requirements are different for everyone.
So, recently a plethora of new languages appeared, which are transpiled (converted) to JavaScript before they run in the browser.
Modern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and auto-converting it “under the hood”.
Examples of such languages:

CoffeeScript is “syntactic sugar” for JavaScript. It introduces shorter syntax, allowing us to write clearer and more precise code. Usually, Ruby devs like it.
TypeScript is concentrated on adding “strict data typing” to simplify the development and support of complex systems. It is developed by Microsoft.
Flow also adds data typing, but in a different way. Developed by Facebook.
Dart is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.
Brython is a Python transpiler to JavaScript that enables the writing of applications in pure Python without JavaScript.
Kotlin is a modern, concise and safe programming language that can target the browser or Node.

There are more. Of course, even if we use one of these transpiled languages, we should also know JavaScript to really understand what we’re doing.
Summary
JavaScript was initially created as a browser-only language, but it is now used in many other environments as well.
Today, JavaScript has a unique position as the most widely-adopted browser language, fully integrated with HTML/CSS.
There are many languages that get “transpiled” to JavaScript and provide certain features. It is recommended to take a look at them, at least briefly, after mastering JavaScript.\n\nTutorialThe JavaScript languageAn introductionAugust 8, 2022An Introduction to JavaScriptLet’s see what’s so special about JavaScript, what we can achieve with it, and what other technologies play well with it.
What is JavaScript?JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Scripts are provided and executed as plain text. They don’t need special preparation or compilation to run.
In this aspect, JavaScript is very different from another language called Java.

            Why is it called JavaScript?
            When JavaScript was created, it initially had another name: “LiveScript”. But Java was very popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help.
But as it evolved, JavaScript became a fully independent language with its own specification called ECMAScript, and now it has no relation to Java at all.

Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.
Different engines have different “codenames”. For example:

V8 – in Chrome, Opera and Edge.
SpiderMonkey – in Firefox.
…There are other codenames like “Chakra” for IE, “JavaScriptCore”, “Nitro” and “SquirrelFish” for Safari, etc.

The terms above are good to remember because they are used in developer articles on the internet. We’ll use them too. For instance, if “a feature X is supported by V8”, then it probably works in Chrome, Opera and Edge.

            How do engines work?
            Engines are complicated. But the basics are easy.

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to machine code.
And then the machine code runs, pretty fast.

The engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.

What can in-browser JavaScript do?Modern JavaScript is a “safe” programming language. It does not provide low-level access to memory or the CPU, because it was initially created for browsers which do not require it.
JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.
For instance, in-browser JavaScript is able to:

Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

What CAN’T in-browser JavaScript do?JavaScript’s abilities in the browser are limited to protect the user’s safety. The aim is to prevent an evil webpage from accessing private information or harming the user’s data.
Examples of such restrictions include:


JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.
There are ways to interact with the camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.


Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other page if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and must contain special JavaScript code that handles it. We’ll cover that in the tutorial.
This limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com, for example, and steal information from there.


JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.



      
      
        
      
      Such limitations do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugins/extensions which may ask for extended permissions.
What makes JavaScript unique?There are at least three great things about JavaScript:
Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.
JavaScript is the only browser technology that combines these three things.
That’s what makes JavaScript unique. That’s why it’s the most widespread tool for creating browser interfaces.
That said, JavaScript can be used to create servers, mobile applications, etc.
Languages “over” JavaScriptThe syntax of JavaScript does not suit everyone’s needs. Different people want different features.
That’s to be expected, because projects and requirements are different for everyone.
So, recently a plethora of new languages appeared, which are transpiled (converted) to JavaScript before they run in the browser.
Modern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and auto-converting it “under the hood”.
Examples of such languages:

CoffeeScript is “syntactic sugar” for JavaScript. It introduces shorter syntax, allowing us to write clearer and more precise code. Usually, Ruby devs like it.
TypeScript is concentrated on adding “strict data typing” to simplify the development and support of complex systems. It is developed by Microsoft.
Flow also adds data typing, but in a different way. Developed by Facebook.
Dart is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.
Brython is a Python transpiler to JavaScript that enables the writing of applications in pure Python without JavaScript.
Kotlin is a modern, concise and safe programming language that can target the browser or Node.

There are more. Of course, even if we use one of these transpiled languages, we should also know JavaScript to really understand what we’re doing.
Summary
JavaScript was initially created as a browser-only language, but it is now used in many other environments as well.
Today, JavaScript has a unique position as the most widely-adopted browser language, fully integrated with HTML/CSS.
There are many languages that get “transpiled” to JavaScript and provide certain features. It is recommended to take a look at them, at least briefly, after mastering JavaScript.

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nLet’s see what’s so special about JavaScript, what we can achieve with it, and what other technologies play well with it.
What is JavaScript?JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Scripts are provided and executed as plain text. They don’t need special preparation or compilation to run.
In this aspect, JavaScript is very different from another language called Java.

            Why is it called JavaScript?
            When JavaScript was created, it initially had another name: “LiveScript”. But Java was very popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help.
But as it evolved, JavaScript became a fully independent language with its own specification called ECMAScript, and now it has no relation to Java at all.

Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.
Different engines have different “codenames”. For example:

V8 – in Chrome, Opera and Edge.
SpiderMonkey – in Firefox.
…There are other codenames like “Chakra” for IE, “JavaScriptCore”, “Nitro” and “SquirrelFish” for Safari, etc.

The terms above are good to remember because they are used in developer articles on the internet. We’ll use them too. For instance, if “a feature X is supported by V8”, then it probably works in Chrome, Opera and Edge.

            How do engines work?
            Engines are complicated. But the basics are easy.

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to machine code.
And then the machine code runs, pretty fast.

The engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.

What can in-browser JavaScript do?Modern JavaScript is a “safe” programming language. It does not provide low-level access to memory or the CPU, because it was initially created for browsers which do not require it.
JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.
For instance, in-browser JavaScript is able to:

Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

What CAN’T in-browser JavaScript do?JavaScript’s abilities in the browser are limited to protect the user’s safety. The aim is to prevent an evil webpage from accessing private information or harming the user’s data.
Examples of such restrictions include:


JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.
There are ways to interact with the camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.


Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other page if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and must contain special JavaScript code that handles it. We’ll cover that in the tutorial.
This limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com, for example, and steal information from there.


JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.



      
      
        
      
      Such limitations do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugins/extensions which may ask for extended permissions.
What makes JavaScript unique?There are at least three great things about JavaScript:
Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.
JavaScript is the only browser technology that combines these three things.
That’s what makes JavaScript unique. That’s why it’s the most widespread tool for creating browser interfaces.
That said, JavaScript can be used to create servers, mobile applications, etc.
Languages “over” JavaScriptThe syntax of JavaScript does not suit everyone’s needs. Different people want different features.
That’s to be expected, because projects and requirements are different for everyone.
So, recently a plethora of new languages appeared, which are transpiled (converted) to JavaScript before they run in the browser.
Modern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and auto-converting it “under the hood”.
Examples of such languages:

CoffeeScript is “syntactic sugar” for JavaScript. It introduces shorter syntax, allowing us to write clearer and more precise code. Usually, Ruby devs like it.
TypeScript is concentrated on adding “strict data typing” to simplify the development and support of complex systems. It is developed by Microsoft.
Flow also adds data typing, but in a different way. Developed by Facebook.
Dart is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.
Brython is a Python transpiler to JavaScript that enables the writing of applications in pure Python without JavaScript.
Kotlin is a modern, concise and safe programming language that can target the browser or Node.

There are more. Of course, even if we use one of these transpiled languages, we should also know JavaScript to really understand what we’re doing.
Summary
JavaScript was initially created as a browser-only language, but it is now used in many other environments as well.
Today, JavaScript has a unique position as the most widely-adopted browser language, fully integrated with HTML/CSS.
There are many languages that get “transpiled” to JavaScript and provide certain features. It is recommended to take a look at them, at least briefly, after mastering JavaScript.\n\nTutorialThe JavaScript languageAn introductionAugust 8, 2022An Introduction to JavaScriptLet’s see what’s so special about JavaScript, what we can achieve with it, and what other technologies play well with it.
What is JavaScript?JavaScript was initially created to “make web pages alive”.
The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
Scripts are provided and executed as plain text. They don’t need special preparation or compilation to run.
In this aspect, JavaScript is very different from another language called Java.

            Why is it called JavaScript?
            When JavaScript was created, it initially had another name: “LiveScript”. But Java was very popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help.
But as it evolved, JavaScript became a fully independent language with its own specification called ECMAScript, and now it has no relation to Java at all.

Today, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.
Different engines have different “codenames”. For example:

V8 – in Chrome, Opera and Edge.
SpiderMonkey – in Firefox.
…There are other codenames like “Chakra” for IE, “JavaScriptCore”, “Nitro” and “SquirrelFish” for Safari, etc.

The terms above are good to remember because they are used in developer articles on the internet. We’ll use them too. For instance, if “a feature X is supported by V8”, then it probably works in Chrome, Opera and Edge.

            How do engines work?
            Engines are complicated. But the basics are easy.

The engine (embedded if it’s a browser) reads (“parses”) the script.
Then it converts (“compiles”) the script to machine code.
And then the machine code runs, pretty fast.

The engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.

What can in-browser JavaScript do?Modern JavaScript is a “safe” programming language. It does not provide low-level access to memory or the CPU, because it was initially created for browsers which do not require it.
JavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.
In-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.
For instance, in-browser JavaScript is able to:

Add new HTML to the page, change the existing content, modify styles.
React to user actions, run on mouse clicks, pointer movements, key presses.
Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
Get and set cookies, ask questions to the visitor, show messages.
Remember the data on the client-side (“local storage”).

What CAN’T in-browser JavaScript do?JavaScript’s abilities in the browser are limited to protect the user’s safety. The aim is to prevent an evil webpage from accessing private information or harming the user’s data.
Examples of such restrictions include:


JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.
Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.
There are ways to interact with the camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.


Different tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other page if they come from different sites (from a different domain, protocol or port).
This is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and must contain special JavaScript code that handles it. We’ll cover that in the tutorial.
This limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com, for example, and steal information from there.


JavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.



      
      
        
      
      Such limitations do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugins/extensions which may ask for extended permissions.
What makes JavaScript unique?There are at least three great things about JavaScript:
Full integration with HTML/CSS.
Simple things are done simply.
Supported by all major browsers and enabled by default.
JavaScript is the only browser technology that combines these three things.
That’s what makes JavaScript unique. That’s why it’s the most widespread tool for creating browser interfaces.
That said, JavaScript can be used to create servers, mobile applications, etc.
Languages “over” JavaScriptThe syntax of JavaScript does not suit everyone’s needs. Different people want different features.
That’s to be expected, because projects and requirements are different for everyone.
So, recently a plethora of new languages appeared, which are transpiled (converted) to JavaScript before they run in the browser.
Modern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and auto-converting it “under the hood”.
Examples of such languages:

CoffeeScript is “syntactic sugar” for JavaScript. It introduces shorter syntax, allowing us to write clearer and more precise code. Usually, Ruby devs like it.
TypeScript is concentrated on adding “strict data typing” to simplify the development and support of complex systems. It is developed by Microsoft.
Flow also adds data typing, but in a different way. Developed by Facebook.
Dart is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.
Brython is a Python transpiler to JavaScript that enables the writing of applications in pure Python without JavaScript.
Kotlin is a modern, concise and safe programming language that can target the browser or Node.

There are more. Of course, even if we use one of these transpiled languages, we should also know JavaScript to really understand what we’re doing.
Summary
JavaScript was initially created as a browser-only language, but it is now used in many other environments as well.
Today, JavaScript has a unique position as the most widely-adopted browser language, fully integrated with HTML/CSS.
There are many languages that get “transpiled” to JavaScript and provide certain features. It is recommended to take a look at them, at least briefly, after mastering JavaScript.

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThis book is a tutorial. It aims to help you gradually learn the language. But once you’re familiar with the basics, you’ll need other resources.
SpecificationThe ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.
But being that formalized, it’s difficult to understand at first. So if you need the most trustworthy source of information about the language details, the specification is the right place. But it’s not for everyday use.
A new specification version is released every year. Between these releases, the latest specification draft is at https://tc39.es/ecma262/.
To read about new bleeding-edge features, including those that are “almost standard” (so-called “stage 3”), see proposals at https://github.com/tc39/proposals.
Also, if you’re developing for the browser, then there are other specifications covered in the second part of the tutorial.
Manuals

MDN (Mozilla) JavaScript Reference is the main manual with examples and other information. It’s great to get in-depth information about individual language functions, methods etc.
You can find it at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference.


Although, it’s often best to use an internet search instead. Just use “MDN [term]” in the query, e.g. https://google.com/search?q=MDN+parseInt to search for the parseInt function.
Compatibility tablesJavaScript is a developing language, new features get added regularly.
To see their support among browser-based and other engines, see:

https://caniuse.com – per-feature tables of support, e.g. to see which engines support modern cryptography functions: https://caniuse.com/#feat=cryptography.
https://kangax.github.io/compat-table – a table with language features and engines that support those or don’t support.

All these resources are useful in real-life development, as they contain valuable information about language details, their support, etc.
Please remember them (or this page) for the cases when you need in-depth information about a particular feature.\n\nTutorialThe JavaScript languageAn introductionJuly 10, 2022Manuals and specificationsThis book is a tutorial. It aims to help you gradually learn the language. But once you’re familiar with the basics, you’ll need other resources.
SpecificationThe ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.
But being that formalized, it’s difficult to understand at first. So if you need the most trustworthy source of information about the language details, the specification is the right place. But it’s not for everyday use.
A new specification version is released every year. Between these releases, the latest specification draft is at https://tc39.es/ecma262/.
To read about new bleeding-edge features, including those that are “almost standard” (so-called “stage 3”), see proposals at https://github.com/tc39/proposals.
Also, if you’re developing for the browser, then there are other specifications covered in the second part of the tutorial.
Manuals

MDN (Mozilla) JavaScript Reference is the main manual with examples and other information. It’s great to get in-depth information about individual language functions, methods etc.
You can find it at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference.


Although, it’s often best to use an internet search instead. Just use “MDN [term]” in the query, e.g. https://google.com/search?q=MDN+parseInt to search for the parseInt function.
Compatibility tablesJavaScript is a developing language, new features get added regularly.
To see their support among browser-based and other engines, see:

https://caniuse.com – per-feature tables of support, e.g. to see which engines support modern cryptography functions: https://caniuse.com/#feat=cryptography.
https://kangax.github.io/compat-table – a table with language features and engines that support those or don’t support.

All these resources are useful in real-life development, as they contain valuable information about language details, their support, etc.
Please remember them (or this page) for the cases when you need in-depth information about a particular feature.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThis book is a tutorial. It aims to help you gradually learn the language. But once you’re familiar with the basics, you’ll need other resources.
SpecificationThe ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.
But being that formalized, it’s difficult to understand at first. So if you need the most trustworthy source of information about the language details, the specification is the right place. But it’s not for everyday use.
A new specification version is released every year. Between these releases, the latest specification draft is at https://tc39.es/ecma262/.
To read about new bleeding-edge features, including those that are “almost standard” (so-called “stage 3”), see proposals at https://github.com/tc39/proposals.
Also, if you’re developing for the browser, then there are other specifications covered in the second part of the tutorial.
Manuals

MDN (Mozilla) JavaScript Reference is the main manual with examples and other information. It’s great to get in-depth information about individual language functions, methods etc.
You can find it at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference.


Although, it’s often best to use an internet search instead. Just use “MDN [term]” in the query, e.g. https://google.com/search?q=MDN+parseInt to search for the parseInt function.
Compatibility tablesJavaScript is a developing language, new features get added regularly.
To see their support among browser-based and other engines, see:

https://caniuse.com – per-feature tables of support, e.g. to see which engines support modern cryptography functions: https://caniuse.com/#feat=cryptography.
https://kangax.github.io/compat-table – a table with language features and engines that support those or don’t support.

All these resources are useful in real-life development, as they contain valuable information about language details, their support, etc.
Please remember them (or this page) for the cases when you need in-depth information about a particular feature.\n\nTutorialThe JavaScript languageAn introductionJuly 10, 2022Manuals and specificationsThis book is a tutorial. It aims to help you gradually learn the language. But once you’re familiar with the basics, you’ll need other resources.
SpecificationThe ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.
But being that formalized, it’s difficult to understand at first. So if you need the most trustworthy source of information about the language details, the specification is the right place. But it’s not for everyday use.
A new specification version is released every year. Between these releases, the latest specification draft is at https://tc39.es/ecma262/.
To read about new bleeding-edge features, including those that are “almost standard” (so-called “stage 3”), see proposals at https://github.com/tc39/proposals.
Also, if you’re developing for the browser, then there are other specifications covered in the second part of the tutorial.
Manuals

MDN (Mozilla) JavaScript Reference is the main manual with examples and other information. It’s great to get in-depth information about individual language functions, methods etc.
You can find it at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference.


Although, it’s often best to use an internet search instead. Just use “MDN [term]” in the query, e.g. https://google.com/search?q=MDN+parseInt to search for the parseInt function.
Compatibility tablesJavaScript is a developing language, new features get added regularly.
To see their support among browser-based and other engines, see:

https://caniuse.com – per-feature tables of support, e.g. to see which engines support modern cryptography functions: https://caniuse.com/#feat=cryptography.
https://kangax.github.io/compat-table – a table with language features and engines that support those or don’t support.

All these resources are useful in real-life development, as they contain valuable information about language details, their support, etc.
Please remember them (or this page) for the cases when you need in-depth information about a particular feature.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nA code editor is the place where programmers spend most of their time.
There are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.
IDEThe term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” As the name suggests, it’s not just an editor, but a full-scale “development environment.”
An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.
If you haven’t selected an IDE yet, consider the following options:

Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).

For Windows, there’s also “Visual Studio”, not to be confused with “Visual Studio Code”. “Visual Studio” is a paid and mighty Windows-only editor, well-suited for the .NET platform. It’s also good at JavaScript. There’s also a free version Visual Studio Community.
Many IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.
Lightweight editors“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.
There are many options, for instance:

Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.

Let’s not argueThe editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.
There are other great editors in our big world. Please choose the one you like the most.
The choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences.
The author’s personal opinion:

I’d use Visual Studio Code if I develop mostly frontend.
Otherwise, if it’s mostly another language/platform and partially frontend, then consider other editors, such as XCode (Mac), Visual Studio (Windows) or Jetbrains family (Webstorm, PHPStorm, RubyMine etc, depending on the language).\n\nTutorialThe JavaScript languageAn introductionOctober 18, 2022Code editorsA code editor is the place where programmers spend most of their time.
There are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.
IDEThe term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” As the name suggests, it’s not just an editor, but a full-scale “development environment.”
An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.
If you haven’t selected an IDE yet, consider the following options:

Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).

For Windows, there’s also “Visual Studio”, not to be confused with “Visual Studio Code”. “Visual Studio” is a paid and mighty Windows-only editor, well-suited for the .NET platform. It’s also good at JavaScript. There’s also a free version Visual Studio Community.
Many IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.
Lightweight editors“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.
There are many options, for instance:

Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.

Let’s not argueThe editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.
There are other great editors in our big world. Please choose the one you like the most.
The choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences.
The author’s personal opinion:

I’d use Visual Studio Code if I develop mostly frontend.
Otherwise, if it’s mostly another language/platform and partially frontend, then consider other editors, such as XCode (Mac), Visual Studio (Windows) or Jetbrains family (Webstorm, PHPStorm, RubyMine etc, depending on the language).

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nA code editor is the place where programmers spend most of their time.
There are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.
IDEThe term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” As the name suggests, it’s not just an editor, but a full-scale “development environment.”
An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.
If you haven’t selected an IDE yet, consider the following options:

Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).

For Windows, there’s also “Visual Studio”, not to be confused with “Visual Studio Code”. “Visual Studio” is a paid and mighty Windows-only editor, well-suited for the .NET platform. It’s also good at JavaScript. There’s also a free version Visual Studio Community.
Many IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.
Lightweight editors“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.
There are many options, for instance:

Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.

Let’s not argueThe editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.
There are other great editors in our big world. Please choose the one you like the most.
The choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences.
The author’s personal opinion:

I’d use Visual Studio Code if I develop mostly frontend.
Otherwise, if it’s mostly another language/platform and partially frontend, then consider other editors, such as XCode (Mac), Visual Studio (Windows) or Jetbrains family (Webstorm, PHPStorm, RubyMine etc, depending on the language).\n\nTutorialThe JavaScript languageAn introductionOctober 18, 2022Code editorsA code editor is the place where programmers spend most of their time.
There are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.
IDEThe term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” As the name suggests, it’s not just an editor, but a full-scale “development environment.”
An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.
If you haven’t selected an IDE yet, consider the following options:

Visual Studio Code (cross-platform, free).
WebStorm (cross-platform, paid).

For Windows, there’s also “Visual Studio”, not to be confused with “Visual Studio Code”. “Visual Studio” is a paid and mighty Windows-only editor, well-suited for the .NET platform. It’s also good at JavaScript. There’s also a free version Visual Studio Community.
Many IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.
Lightweight editors“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.
They are mainly used to open and edit a file instantly.
The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.
In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.
There are many options, for instance:

Sublime Text (cross-platform, shareware).
Notepad++ (Windows, free).
Vim and Emacs are also cool if you know how to use them.

Let’s not argueThe editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.
There are other great editors in our big world. Please choose the one you like the most.
The choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences.
The author’s personal opinion:

I’d use Visual Studio Code if I develop mostly frontend.
Otherwise, if it’s mostly another language/platform and partially frontend, then consider other editors, such as XCode (Mac), Visual Studio (Windows) or Jetbrains family (Webstorm, PHPStorm, RubyMine etc, depending on the language).

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nCode is prone to errors. You will quite likely make errors… Oh, what am I talking about? You are absolutely going to make errors, at least if you’re a human, not a robot.
But in the browser, users don’t see errors by default. So, if something goes wrong in the script, we won’t see what’s broken and can’t fix it.
To see errors and get a lot of other useful information about scripts, “developer tools” have been embedded in browsers.
Most developers lean towards Chrome or Firefox for development because those browsers have the best developer tools. Other browsers also provide developer tools, sometimes with special features, but are usually playing “catch-up” to Chrome or Firefox. So most developers have a “favorite” browser and switch to others if a problem is browser-specific.
Developer tools are potent; they have many features. To start, we’ll learn how to open them, look at errors, and run JavaScript commands.
Google ChromeOpen the page bug.html.
There’s an error in the JavaScript code on it. It’s hidden from a regular visitor’s eyes, so let’s open developer tools to see it.
Press F12 or, if you’re on Mac, then Cmd+Opt+J.
The developer tools will open on the Console tab by default.
It looks somewhat like this:

      
      
      The exact look of developer tools depends on your version of Chrome. It changes from time to time but should be similar.

Here we can see the red-colored error message. In this case, the script contains an unknown “lalala” command.
On the right, there is a clickable link to the source bug.html:12 with the line number where the error has occurred.

Below the error message, there is a blue > symbol. It marks a “command line” where we can type JavaScript commands. Press Enter to run them.
Now we can see errors, and that’s enough for a start. We’ll come back to developer tools later and cover debugging more in-depth in the chapter Debugging in the browser.

            Multi-line input
            Usually, when we put a line of code into the console, and then press Enter, it executes.
To insert multiple lines, press Shift+Enter. This way one can enter long fragments of JavaScript code.

Firefox, Edge, and othersMost other browsers use F12 to open developer tools.
The look & feel of them is quite similar. Once you know how to use one of these tools (you can start with Chrome), you can easily switch to another.
SafariSafari (Mac browser, not supported by Windows/Linux) is a little bit special here. We need to enable the “Develop menu” first.
Open Settings and go to the “Advanced” pane. There’s a checkbox at the bottom:

      
      
      Now Cmd+Opt+C can toggle the console. Also, note that the new top menu item named “Develop” has appeared. It has many commands and options.
Summary
Developer tools allow us to see errors, run commands, examine variables, and much more.
They can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).

Now we have the environment ready. In the next section, we’ll get down to JavaScript.\n\nTutorialThe JavaScript languageAn introductionApril 13, 2025Developer consoleCode is prone to errors. You will quite likely make errors… Oh, what am I talking about? You are absolutely going to make errors, at least if you’re a human, not a robot.
But in the browser, users don’t see errors by default. So, if something goes wrong in the script, we won’t see what’s broken and can’t fix it.
To see errors and get a lot of other useful information about scripts, “developer tools” have been embedded in browsers.
Most developers lean towards Chrome or Firefox for development because those browsers have the best developer tools. Other browsers also provide developer tools, sometimes with special features, but are usually playing “catch-up” to Chrome or Firefox. So most developers have a “favorite” browser and switch to others if a problem is browser-specific.
Developer tools are potent; they have many features. To start, we’ll learn how to open them, look at errors, and run JavaScript commands.
Google ChromeOpen the page bug.html.
There’s an error in the JavaScript code on it. It’s hidden from a regular visitor’s eyes, so let’s open developer tools to see it.
Press F12 or, if you’re on Mac, then Cmd+Opt+J.
The developer tools will open on the Console tab by default.
It looks somewhat like this:

      
      
      The exact look of developer tools depends on your version of Chrome. It changes from time to time but should be similar.

Here we can see the red-colored error message. In this case, the script contains an unknown “lalala” command.
On the right, there is a clickable link to the source bug.html:12 with the line number where the error has occurred.

Below the error message, there is a blue > symbol. It marks a “command line” where we can type JavaScript commands. Press Enter to run them.
Now we can see errors, and that’s enough for a start. We’ll come back to developer tools later and cover debugging more in-depth in the chapter Debugging in the browser.

            Multi-line input
            Usually, when we put a line of code into the console, and then press Enter, it executes.
To insert multiple lines, press Shift+Enter. This way one can enter long fragments of JavaScript code.

Firefox, Edge, and othersMost other browsers use F12 to open developer tools.
The look & feel of them is quite similar. Once you know how to use one of these tools (you can start with Chrome), you can easily switch to another.
SafariSafari (Mac browser, not supported by Windows/Linux) is a little bit special here. We need to enable the “Develop menu” first.
Open Settings and go to the “Advanced” pane. There’s a checkbox at the bottom:

      
      
      Now Cmd+Opt+C can toggle the console. Also, note that the new top menu item named “Develop” has appeared. It has many commands and options.
Summary
Developer tools allow us to see errors, run commands, examine variables, and much more.
They can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).

Now we have the environment ready. In the next section, we’ll get down to JavaScript.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nCode is prone to errors. You will quite likely make errors… Oh, what am I talking about? You are absolutely going to make errors, at least if you’re a human, not a robot.
But in the browser, users don’t see errors by default. So, if something goes wrong in the script, we won’t see what’s broken and can’t fix it.
To see errors and get a lot of other useful information about scripts, “developer tools” have been embedded in browsers.
Most developers lean towards Chrome or Firefox for development because those browsers have the best developer tools. Other browsers also provide developer tools, sometimes with special features, but are usually playing “catch-up” to Chrome or Firefox. So most developers have a “favorite” browser and switch to others if a problem is browser-specific.
Developer tools are potent; they have many features. To start, we’ll learn how to open them, look at errors, and run JavaScript commands.
Google ChromeOpen the page bug.html.
There’s an error in the JavaScript code on it. It’s hidden from a regular visitor’s eyes, so let’s open developer tools to see it.
Press F12 or, if you’re on Mac, then Cmd+Opt+J.
The developer tools will open on the Console tab by default.
It looks somewhat like this:

      
      
      The exact look of developer tools depends on your version of Chrome. It changes from time to time but should be similar.

Here we can see the red-colored error message. In this case, the script contains an unknown “lalala” command.
On the right, there is a clickable link to the source bug.html:12 with the line number where the error has occurred.

Below the error message, there is a blue > symbol. It marks a “command line” where we can type JavaScript commands. Press Enter to run them.
Now we can see errors, and that’s enough for a start. We’ll come back to developer tools later and cover debugging more in-depth in the chapter Debugging in the browser.

            Multi-line input
            Usually, when we put a line of code into the console, and then press Enter, it executes.
To insert multiple lines, press Shift+Enter. This way one can enter long fragments of JavaScript code.

Firefox, Edge, and othersMost other browsers use F12 to open developer tools.
The look & feel of them is quite similar. Once you know how to use one of these tools (you can start with Chrome), you can easily switch to another.
SafariSafari (Mac browser, not supported by Windows/Linux) is a little bit special here. We need to enable the “Develop menu” first.
Open Settings and go to the “Advanced” pane. There’s a checkbox at the bottom:

      
      
      Now Cmd+Opt+C can toggle the console. Also, note that the new top menu item named “Develop” has appeared. It has many commands and options.
Summary
Developer tools allow us to see errors, run commands, examine variables, and much more.
They can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).

Now we have the environment ready. In the next section, we’ll get down to JavaScript.\n\nTutorialThe JavaScript languageAn introductionApril 13, 2025Developer consoleCode is prone to errors. You will quite likely make errors… Oh, what am I talking about? You are absolutely going to make errors, at least if you’re a human, not a robot.
But in the browser, users don’t see errors by default. So, if something goes wrong in the script, we won’t see what’s broken and can’t fix it.
To see errors and get a lot of other useful information about scripts, “developer tools” have been embedded in browsers.
Most developers lean towards Chrome or Firefox for development because those browsers have the best developer tools. Other browsers also provide developer tools, sometimes with special features, but are usually playing “catch-up” to Chrome or Firefox. So most developers have a “favorite” browser and switch to others if a problem is browser-specific.
Developer tools are potent; they have many features. To start, we’ll learn how to open them, look at errors, and run JavaScript commands.
Google ChromeOpen the page bug.html.
There’s an error in the JavaScript code on it. It’s hidden from a regular visitor’s eyes, so let’s open developer tools to see it.
Press F12 or, if you’re on Mac, then Cmd+Opt+J.
The developer tools will open on the Console tab by default.
It looks somewhat like this:

      
      
      The exact look of developer tools depends on your version of Chrome. It changes from time to time but should be similar.

Here we can see the red-colored error message. In this case, the script contains an unknown “lalala” command.
On the right, there is a clickable link to the source bug.html:12 with the line number where the error has occurred.

Below the error message, there is a blue > symbol. It marks a “command line” where we can type JavaScript commands. Press Enter to run them.
Now we can see errors, and that’s enough for a start. We’ll come back to developer tools later and cover debugging more in-depth in the chapter Debugging in the browser.

            Multi-line input
            Usually, when we put a line of code into the console, and then press Enter, it executes.
To insert multiple lines, press Shift+Enter. This way one can enter long fragments of JavaScript code.

Firefox, Edge, and othersMost other browsers use F12 to open developer tools.
The look & feel of them is quite similar. Once you know how to use one of these tools (you can start with Chrome), you can easily switch to another.
SafariSafari (Mac browser, not supported by Windows/Linux) is a little bit special here. We need to enable the “Develop menu” first.
Open Settings and go to the “Advanced” pane. There’s a checkbox at the bottom:

      
      
      Now Cmd+Opt+C can toggle the console. Also, note that the new top menu item named “Develop” has appeared. It has many commands and options.
Summary
Developer tools allow us to see errors, run commands, examine variables, and much more.
They can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).

Now we have the environment ready. In the next section, we’ll get down to JavaScript.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTutorialThe JavaScript languageJavaScript FundamentalsLet’s learn the fundamentals of script building.
Hello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsPrevious lessonNext lessonShareTutorial map\n\nLet’s learn the fundamentals of script building.
Hello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specials\n\nTutorialThe JavaScript languageJavaScript FundamentalsLet’s learn the fundamentals of script building.
Hello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsPrevious lessonNext lessonShareTutorial map\n\n\n\nThis part of the tutorial is about core JavaScript, the language itself.
But we need a working environment to run our scripts and, since this book is online, the browser is a good choice. We’ll keep the amount of browser-specific commands (like alert) to a minimum so that you don’t spend time on them if you plan to concentrate on another environment (like Node.js). We’ll focus on JavaScript in the browser in the next part of the tutorial.
So first, let’s see how we attach a script to a webpage. For server-side environments (like Node.js), you can execute the script with a command like "node my.js".
The “script” tagJavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE HTML>
<html>

<body>

  <p>Before the script...</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>...After the script.</p>

</body>

</html>
        
      
      
      You can run the example by clicking the “Play” button in the right-top corner of the box above.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.
Modern markupThe <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:

The type attribute: <script type=…>

The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore. Also, the modern HTML standard totally changed the meaning of this attribute. Now, it can be used for JavaScript modules. But that’s an advanced topic, we’ll talk about modules in another part of the tutorial.

The language attribute: <script language=…>

This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

Comments before and after scripts.

In really ancient books and guides, you may find comments inside <script> tags, like this:

      
        
        
          <script type="text/javascript"><!--
    ...
//--></script>
        
      
      
      This trick isn’t used in modern JavaScript. These comments hide JavaScript code from old browsers that didn’t know how to process the <script> tag. Since browsers released in the last 15 years don’t have this issue, this kind of comment can help you identify really old code.


External scriptsIf we have a lot of JavaScript code, we can put it into a separate file.
Script files are attached to HTML with the src attribute:

      
        
        
          <script src="/path/to/script.js"></script>
        
      
      
      Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.
We can give a full URL as well. For instance:

      
        
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
        
      
      
      To attach several scripts, use multiple tags:

      
        
        
          <script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
        
      
      
      
            Please note:
            As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files.
The benefit of a separate file is that the browser will download it and store it in its cache.
Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once.
That reduces traffic and makes pages faster.


            If src is set, the script content is ignored.
            A single <script> tag can’t have both the src attribute and code inside.
This won’t work:

      
        
        
          <script src="file.js">
  alert(1); // the content is ignored, because src is set
</script>
        
      
      
      We must choose either an external <script src="…"> or a regular <script> with code.
The example above can be split into two scripts to work:

      
        
        
          <script src="file.js"></script>
<script>
  alert(1);
</script>
        
      
      
      
Summary
We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.

There is much more to learn about browser scripts and their interaction with the webpage. But let’s keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn’t distract ourselves with browser-specific implementations of it. We’ll be using the browser as a way to run JavaScript, which is very convenient for online reading, but only one of many.\n\nTutorialThe JavaScript languageJavaScript FundamentalsNovember 1, 2021Hello, world!This part of the tutorial is about core JavaScript, the language itself.
But we need a working environment to run our scripts and, since this book is online, the browser is a good choice. We’ll keep the amount of browser-specific commands (like alert) to a minimum so that you don’t spend time on them if you plan to concentrate on another environment (like Node.js). We’ll focus on JavaScript in the browser in the next part of the tutorial.
So first, let’s see how we attach a script to a webpage. For server-side environments (like Node.js), you can execute the script with a command like "node my.js".
The “script” tagJavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE HTML>
<html>

<body>

  <p>Before the script...</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>...After the script.</p>

</body>

</html>
        
      
      
      You can run the example by clicking the “Play” button in the right-top corner of the box above.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.
Modern markupThe <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:

The type attribute: <script type=…>

The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore. Also, the modern HTML standard totally changed the meaning of this attribute. Now, it can be used for JavaScript modules. But that’s an advanced topic, we’ll talk about modules in another part of the tutorial.

The language attribute: <script language=…>

This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

Comments before and after scripts.

In really ancient books and guides, you may find comments inside <script> tags, like this:

      
        
        
          <script type="text/javascript"><!--
    ...
//--></script>
        
      
      
      This trick isn’t used in modern JavaScript. These comments hide JavaScript code from old browsers that didn’t know how to process the <script> tag. Since browsers released in the last 15 years don’t have this issue, this kind of comment can help you identify really old code.


External scriptsIf we have a lot of JavaScript code, we can put it into a separate file.
Script files are attached to HTML with the src attribute:

      
        
        
          <script src="/path/to/script.js"></script>
        
      
      
      Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.
We can give a full URL as well. For instance:

      
        
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
        
      
      
      To attach several scripts, use multiple tags:

      
        
        
          <script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
        
      
      
      
            Please note:
            As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files.
The benefit of a separate file is that the browser will download it and store it in its cache.
Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once.
That reduces traffic and makes pages faster.


            If src is set, the script content is ignored.
            A single <script> tag can’t have both the src attribute and code inside.
This won’t work:

      
        
        
          <script src="file.js">
  alert(1); // the content is ignored, because src is set
</script>
        
      
      
      We must choose either an external <script src="…"> or a regular <script> with code.
The example above can be split into two scripts to work:

      
        
        
          <script src="file.js"></script>
<script>
  alert(1);
</script>
        
      
      
      
Summary
We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.

There is much more to learn about browser scripts and their interaction with the webpage. But let’s keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn’t distract ourselves with browser-specific implementations of it. We’ll be using the browser as a way to run JavaScript, which is very convenient for online reading, but only one of many.
TasksShow an alertimportance: 5Create a page that shows a message “I’m JavaScript!”.
Do it in a sandbox, or on your hard drive, doesn’t matter, just ensure that it works.
Demo in new windowsolution
      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script>
    alert( "I'm JavaScript!" );
  </script>

</body>

</html>
        
      
      
      Open the solution in a sandbox.Show an alert with an external scriptimportance: 5Take the solution of the previous task Show an alert. Modify it by extracting the script content into an external file alert.js, residing in the same folder.
Open the page, ensure that the alert works.
solutionThe HTML code:

      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script src="alert.js"></script>

</body>

</html>
        
      
      
      For the file alert.js in the same folder:

      
        
        
          alert("I'm JavaScript!");
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThis part of the tutorial is about core JavaScript, the language itself.
But we need a working environment to run our scripts and, since this book is online, the browser is a good choice. We’ll keep the amount of browser-specific commands (like alert) to a minimum so that you don’t spend time on them if you plan to concentrate on another environment (like Node.js). We’ll focus on JavaScript in the browser in the next part of the tutorial.
So first, let’s see how we attach a script to a webpage. For server-side environments (like Node.js), you can execute the script with a command like "node my.js".
The “script” tagJavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE HTML>
<html>

<body>

  <p>Before the script...</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>...After the script.</p>

</body>

</html>
        
      
      
      You can run the example by clicking the “Play” button in the right-top corner of the box above.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.
Modern markupThe <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:

The type attribute: <script type=…>

The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore. Also, the modern HTML standard totally changed the meaning of this attribute. Now, it can be used for JavaScript modules. But that’s an advanced topic, we’ll talk about modules in another part of the tutorial.

The language attribute: <script language=…>

This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

Comments before and after scripts.

In really ancient books and guides, you may find comments inside <script> tags, like this:

      
        
        
          <script type="text/javascript"><!--
    ...
//--></script>
        
      
      
      This trick isn’t used in modern JavaScript. These comments hide JavaScript code from old browsers that didn’t know how to process the <script> tag. Since browsers released in the last 15 years don’t have this issue, this kind of comment can help you identify really old code.


External scriptsIf we have a lot of JavaScript code, we can put it into a separate file.
Script files are attached to HTML with the src attribute:

      
        
        
          <script src="/path/to/script.js"></script>
        
      
      
      Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.
We can give a full URL as well. For instance:

      
        
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
        
      
      
      To attach several scripts, use multiple tags:

      
        
        
          <script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
        
      
      
      
            Please note:
            As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files.
The benefit of a separate file is that the browser will download it and store it in its cache.
Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once.
That reduces traffic and makes pages faster.


            If src is set, the script content is ignored.
            A single <script> tag can’t have both the src attribute and code inside.
This won’t work:

      
        
        
          <script src="file.js">
  alert(1); // the content is ignored, because src is set
</script>
        
      
      
      We must choose either an external <script src="…"> or a regular <script> with code.
The example above can be split into two scripts to work:

      
        
        
          <script src="file.js"></script>
<script>
  alert(1);
</script>
        
      
      
      
Summary
We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.

There is much more to learn about browser scripts and their interaction with the webpage. But let’s keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn’t distract ourselves with browser-specific implementations of it. We’ll be using the browser as a way to run JavaScript, which is very convenient for online reading, but only one of many.
TasksShow an alertimportance: 5Create a page that shows a message “I’m JavaScript!”.
Do it in a sandbox, or on your hard drive, doesn’t matter, just ensure that it works.
Demo in new windowsolution
      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script>
    alert( "I'm JavaScript!" );
  </script>

</body>

</html>
        
      
      
      Open the solution in a sandbox.Show an alert with an external scriptimportance: 5Take the solution of the previous task Show an alert. Modify it by extracting the script content into an external file alert.js, residing in the same folder.
Open the page, ensure that the alert works.
solutionThe HTML code:

      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script src="alert.js"></script>

</body>

</html>
        
      
      
      For the file alert.js in the same folder:

      
        
        
          alert("I'm JavaScript!");\n\nTutorialThe JavaScript languageJavaScript FundamentalsNovember 1, 2021Hello, world!This part of the tutorial is about core JavaScript, the language itself.
But we need a working environment to run our scripts and, since this book is online, the browser is a good choice. We’ll keep the amount of browser-specific commands (like alert) to a minimum so that you don’t spend time on them if you plan to concentrate on another environment (like Node.js). We’ll focus on JavaScript in the browser in the next part of the tutorial.
So first, let’s see how we attach a script to a webpage. For server-side environments (like Node.js), you can execute the script with a command like "node my.js".
The “script” tagJavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE HTML>
<html>

<body>

  <p>Before the script...</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>...After the script.</p>

</body>

</html>
        
      
      
      You can run the example by clicking the “Play” button in the right-top corner of the box above.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.
Modern markupThe <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:

The type attribute: <script type=…>

The old HTML standard, HTML4, required a script to have a type. Usually it was type="text/javascript". It’s not required anymore. Also, the modern HTML standard totally changed the meaning of this attribute. Now, it can be used for JavaScript modules. But that’s an advanced topic, we’ll talk about modules in another part of the tutorial.

The language attribute: <script language=…>

This attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.

Comments before and after scripts.

In really ancient books and guides, you may find comments inside <script> tags, like this:

      
        
        
          <script type="text/javascript"><!--
    ...
//--></script>
        
      
      
      This trick isn’t used in modern JavaScript. These comments hide JavaScript code from old browsers that didn’t know how to process the <script> tag. Since browsers released in the last 15 years don’t have this issue, this kind of comment can help you identify really old code.


External scriptsIf we have a lot of JavaScript code, we can put it into a separate file.
Script files are attached to HTML with the src attribute:

      
        
        
          <script src="/path/to/script.js"></script>
        
      
      
      Here, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. For instance, src="script.js", just like src="./script.js", would mean a file "script.js" in the current folder.
We can give a full URL as well. For instance:

      
        
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
        
      
      
      To attach several scripts, use multiple tags:

      
        
        
          <script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
        
      
      
      
            Please note:
            As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files.
The benefit of a separate file is that the browser will download it and store it in its cache.
Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once.
That reduces traffic and makes pages faster.


            If src is set, the script content is ignored.
            A single <script> tag can’t have both the src attribute and code inside.
This won’t work:

      
        
        
          <script src="file.js">
  alert(1); // the content is ignored, because src is set
</script>
        
      
      
      We must choose either an external <script src="…"> or a regular <script> with code.
The example above can be split into two scripts to work:

      
        
        
          <script src="file.js"></script>
<script>
  alert(1);
</script>
        
      
      
      
Summary
We can use a <script> tag to add JavaScript code to a page.
The type and language attributes are not required.
A script in an external file can be inserted with <script src="path/to/script.js"></script>.

There is much more to learn about browser scripts and their interaction with the webpage. But let’s keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn’t distract ourselves with browser-specific implementations of it. We’ll be using the browser as a way to run JavaScript, which is very convenient for online reading, but only one of many.
TasksShow an alertimportance: 5Create a page that shows a message “I’m JavaScript!”.
Do it in a sandbox, or on your hard drive, doesn’t matter, just ensure that it works.
Demo in new windowsolution
      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script>
    alert( "I'm JavaScript!" );
  </script>

</body>

</html>
        
      
      
      Open the solution in a sandbox.Show an alert with an external scriptimportance: 5Take the solution of the previous task Show an alert. Modify it by extracting the script content into an external file alert.js, residing in the same folder.
Open the page, ensure that the alert works.
solutionThe HTML code:

      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script src="alert.js"></script>

</body>

</html>
        
      
      
      For the file alert.js in the same folder:

      
        
        
          alert("I'm JavaScript!");
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThe first thing we’ll study is the building blocks of code.
StatementsStatements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.
For example, here we split “Hello World” into two alerts:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, statements are written on separate lines to make the code more readable:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello');
alert('World');
        
      
      
      SemicolonsA semicolon may be omitted in most cases when a line break exists.
This would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.
In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!
There are cases when a newline does not mean a semicolon. For example:

      
        
        
          
            
          
          
            
          
        
        
          alert(3 +
1
+ 2);
        
      
      
      The code outputs 6 because JavaScript does not insert semicolons here. It is intuitively obvious that if the line ends with a plus "+", then it is an “incomplete expression”, so a semicolon there would be incorrect. And in this case, that works as intended.
But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
Errors which occur in such cases are quite hard to find and fix.

            An example of an error
            If you’re curious to see a concrete example of such an error, check this code out:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");

[1, 2].forEach(alert);
        
      
      
      No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.
Now let’s remove the semicolon after the alert:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")

[1, 2].forEach(alert);
        
      
      
      The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.
Here’s how the engine sees it:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")[1, 2].forEach(alert);
        
      
      
      Looks weird, right? Such merging in this case is just wrong. We need to put a semicolon after alert for the code to work correctly.
This can happen in other situations also.

We recommend putting semicolons between statements even if they are separated by newlines. This rule is widely adopted by the community. Let’s note once again – it is possible to leave out semicolons most of the time. But it’s safer – especially for a beginner – to use them.
CommentsAs time goes on, programs become more and more complex. It becomes necessary to add comments which describe what the code does and why.
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.
One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          // This comment occupies a line of its own
alert('Hello');

alert('World'); // This comment follows the statement
        
      
      
      Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          /* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');
        
      
      
      The content of comments is ignored, so if we put code inside /* … */, it won’t execute.
Sometimes it can be handy to temporarily disable a part of code:

      
        
        
          
            
          
          
            
          
        
        
          /* Commenting out the code
alert('Hello');
*/
alert('World');
        
      
      
      
            Use hotkeys!
            In most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey). For Mac, try Cmd instead of Ctrl and Option instead of Shift.


            Nested comments are not supported!
            There may not be /*...*/ inside another /*...*/.
Such code will die with an error:

      
        
        
          
            
          
          
            
          
        
        
          /*
  /* nested comment ?!? */
*/
alert( 'World' );
        
      
      
      
Please, don’t hesitate to comment your code.
Comments increase the overall code footprint, but that’s not a problem at all. There are many tools which minify code before publishing to a production server. They remove comments, so they don’t appear in the working scripts. Therefore, comments do not have negative effects on production at all.
Later in the tutorial there will be a chapter Code quality that also explains how to write better comments.\n\nTutorialThe JavaScript languageJavaScript FundamentalsMay 29, 2021Code structureThe first thing we’ll study is the building blocks of code.
StatementsStatements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.
For example, here we split “Hello World” into two alerts:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, statements are written on separate lines to make the code more readable:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello');
alert('World');
        
      
      
      SemicolonsA semicolon may be omitted in most cases when a line break exists.
This would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.
In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!
There are cases when a newline does not mean a semicolon. For example:

      
        
        
          
            
          
          
            
          
        
        
          alert(3 +
1
+ 2);
        
      
      
      The code outputs 6 because JavaScript does not insert semicolons here. It is intuitively obvious that if the line ends with a plus "+", then it is an “incomplete expression”, so a semicolon there would be incorrect. And in this case, that works as intended.
But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
Errors which occur in such cases are quite hard to find and fix.

            An example of an error
            If you’re curious to see a concrete example of such an error, check this code out:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");

[1, 2].forEach(alert);
        
      
      
      No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.
Now let’s remove the semicolon after the alert:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")

[1, 2].forEach(alert);
        
      
      
      The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.
Here’s how the engine sees it:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")[1, 2].forEach(alert);
        
      
      
      Looks weird, right? Such merging in this case is just wrong. We need to put a semicolon after alert for the code to work correctly.
This can happen in other situations also.

We recommend putting semicolons between statements even if they are separated by newlines. This rule is widely adopted by the community. Let’s note once again – it is possible to leave out semicolons most of the time. But it’s safer – especially for a beginner – to use them.
CommentsAs time goes on, programs become more and more complex. It becomes necessary to add comments which describe what the code does and why.
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.
One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          // This comment occupies a line of its own
alert('Hello');

alert('World'); // This comment follows the statement
        
      
      
      Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          /* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');
        
      
      
      The content of comments is ignored, so if we put code inside /* … */, it won’t execute.
Sometimes it can be handy to temporarily disable a part of code:

      
        
        
          
            
          
          
            
          
        
        
          /* Commenting out the code
alert('Hello');
*/
alert('World');
        
      
      
      
            Use hotkeys!
            In most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey). For Mac, try Cmd instead of Ctrl and Option instead of Shift.


            Nested comments are not supported!
            There may not be /*...*/ inside another /*...*/.
Such code will die with an error:

      
        
        
          
            
          
          
            
          
        
        
          /*
  /* nested comment ?!? */
*/
alert( 'World' );
        
      
      
      
Please, don’t hesitate to comment your code.
Comments increase the overall code footprint, but that’s not a problem at all. There are many tools which minify code before publishing to a production server. They remove comments, so they don’t appear in the working scripts. Therefore, comments do not have negative effects on production at all.
Later in the tutorial there will be a chapter Code quality that also explains how to write better comments.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThe first thing we’ll study is the building blocks of code.
StatementsStatements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.
For example, here we split “Hello World” into two alerts:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, statements are written on separate lines to make the code more readable:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello');
alert('World');
        
      
      
      SemicolonsA semicolon may be omitted in most cases when a line break exists.
This would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.
In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!
There are cases when a newline does not mean a semicolon. For example:

      
        
        
          
            
          
          
            
          
        
        
          alert(3 +
1
+ 2);
        
      
      
      The code outputs 6 because JavaScript does not insert semicolons here. It is intuitively obvious that if the line ends with a plus "+", then it is an “incomplete expression”, so a semicolon there would be incorrect. And in this case, that works as intended.
But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
Errors which occur in such cases are quite hard to find and fix.

            An example of an error
            If you’re curious to see a concrete example of such an error, check this code out:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");

[1, 2].forEach(alert);
        
      
      
      No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.
Now let’s remove the semicolon after the alert:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")

[1, 2].forEach(alert);
        
      
      
      The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.
Here’s how the engine sees it:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")[1, 2].forEach(alert);
        
      
      
      Looks weird, right? Such merging in this case is just wrong. We need to put a semicolon after alert for the code to work correctly.
This can happen in other situations also.

We recommend putting semicolons between statements even if they are separated by newlines. This rule is widely adopted by the community. Let’s note once again – it is possible to leave out semicolons most of the time. But it’s safer – especially for a beginner – to use them.
CommentsAs time goes on, programs become more and more complex. It becomes necessary to add comments which describe what the code does and why.
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.
One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          // This comment occupies a line of its own
alert('Hello');

alert('World'); // This comment follows the statement
        
      
      
      Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          /* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');
        
      
      
      The content of comments is ignored, so if we put code inside /* … */, it won’t execute.
Sometimes it can be handy to temporarily disable a part of code:

      
        
        
          
            
          
          
            
          
        
        
          /* Commenting out the code
alert('Hello');
*/
alert('World');
        
      
      
      
            Use hotkeys!
            In most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey). For Mac, try Cmd instead of Ctrl and Option instead of Shift.


            Nested comments are not supported!
            There may not be /*...*/ inside another /*...*/.
Such code will die with an error:

      
        
        
          
            
          
          
            
          
        
        
          /*
  /* nested comment ?!? */
*/
alert( 'World' );
        
      
      
      
Please, don’t hesitate to comment your code.
Comments increase the overall code footprint, but that’s not a problem at all. There are many tools which minify code before publishing to a production server. They remove comments, so they don’t appear in the working scripts. Therefore, comments do not have negative effects on production at all.
Later in the tutorial there will be a chapter Code quality that also explains how to write better comments.\n\nTutorialThe JavaScript languageJavaScript FundamentalsMay 29, 2021Code structureThe first thing we’ll study is the building blocks of code.
StatementsStatements are syntax constructs and commands that perform actions.
We’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.
We can have as many statements in our code as we want. Statements can be separated with a semicolon.
For example, here we split “Hello World” into two alerts:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, statements are written on separate lines to make the code more readable:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello');
alert('World');
        
      
      
      SemicolonsA semicolon may be omitted in most cases when a line break exists.
This would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      Here, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.
In most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!
There are cases when a newline does not mean a semicolon. For example:

      
        
        
          
            
          
          
            
          
        
        
          alert(3 +
1
+ 2);
        
      
      
      The code outputs 6 because JavaScript does not insert semicolons here. It is intuitively obvious that if the line ends with a plus "+", then it is an “incomplete expression”, so a semicolon there would be incorrect. And in this case, that works as intended.
But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.
Errors which occur in such cases are quite hard to find and fix.

            An example of an error
            If you’re curious to see a concrete example of such an error, check this code out:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");

[1, 2].forEach(alert);
        
      
      
      No need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.
Now let’s remove the semicolon after the alert:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")

[1, 2].forEach(alert);
        
      
      
      The difference compared to the code above is only one character: the semicolon at the end of the first line is gone.
If we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.
That’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.
Here’s how the engine sees it:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")[1, 2].forEach(alert);
        
      
      
      Looks weird, right? Such merging in this case is just wrong. We need to put a semicolon after alert for the code to work correctly.
This can happen in other situations also.

We recommend putting semicolons between statements even if they are separated by newlines. This rule is widely adopted by the community. Let’s note once again – it is possible to leave out semicolons most of the time. But it’s safer – especially for a beginner – to use them.
CommentsAs time goes on, programs become more and more complex. It becomes necessary to add comments which describe what the code does and why.
Comments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.
One-line comments start with two forward slash characters //.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          // This comment occupies a line of its own
alert('Hello');

alert('World'); // This comment follows the statement
        
      
      
      Multiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          /* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');
        
      
      
      The content of comments is ignored, so if we put code inside /* … */, it won’t execute.
Sometimes it can be handy to temporarily disable a part of code:

      
        
        
          
            
          
          
            
          
        
        
          /* Commenting out the code
alert('Hello');
*/
alert('World');
        
      
      
      
            Use hotkeys!
            In most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey). For Mac, try Cmd instead of Ctrl and Option instead of Shift.


            Nested comments are not supported!
            There may not be /*...*/ inside another /*...*/.
Such code will die with an error:

      
        
        
          
            
          
          
            
          
        
        
          /*
  /* nested comment ?!? */
*/
alert( 'World' );
        
      
      
      
Please, don’t hesitate to comment your code.
Comments increase the overall code footprint, but that’s not a problem at all. There are many tools which minify code before publishing to a production server. They remove comments, so they don’t appear in the working scripts. Therefore, comments do not have negative effects on production at all.
Later in the tutorial there will be a chapter Code quality that also explains how to write better comments.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nFor a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.
That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.
This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".
“use strict”The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.
For example:

      
        
        
          "use strict";

// this code works the modern way
...
        
      
      
      Quite soon we’re going to learn functions (a way to group commands), so let’s note in advance that "use strict" can be put at the beginning of a function. Doing that enables strict mode in that function only. But usually people use it for the whole script.

            Ensure that “use strict” is at the top
            Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
Strict mode isn’t enabled here:

      
        
        
          alert("some code");
// "use strict" below is ignored--it must be at the top

"use strict";

// strict mode is not activated
        
      
      
      Only comments may appear above "use strict".


            There’s no way to cancel use strict
            There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Browser consoleWhen you use a developer console to run code, please note that it doesn’t use strict by default.
Sometimes, when use strict makes a difference, you’ll get incorrect results.
So, how to actually use strict in the console?
First, you can try to press Shift+Enter to input multiple lines, and put use strict on top, like this:

      
        
        
          'use strict'; <Shift+Enter for a newline>
//  ...your code
<Enter to run>
        
      
      
      It works in most browsers, namely Firefox and Chrome.
If it doesn’t, e.g. in an old browser, there’s an ugly, but reliable way to ensure use strict. Put it inside this kind of wrapper:

      
        
        
          (function() {
  'use strict';

  // ...your code here...
})()
        
      
      
      Should we “use strict”?The question may sound obvious, but it’s not so.
One could recommend to start scripts with "use strict"… But you know what’s cool?
Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.
So, for now "use strict"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.
As of now, we’ve got to know about use strict in general.
In the next chapters, as we learn language features, we’ll see the differences between the strict and old modes. Luckily, there aren’t many and they actually make our lives better.
All examples in this tutorial assume strict mode unless (very rarely) specified otherwise.\n\nTutorialThe JavaScript languageJavaScript FundamentalsMay 19, 2020The modern mode, "use strict"For a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.
That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.
This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".
“use strict”The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.
For example:

      
        
        
          "use strict";

// this code works the modern way
...
        
      
      
      Quite soon we’re going to learn functions (a way to group commands), so let’s note in advance that "use strict" can be put at the beginning of a function. Doing that enables strict mode in that function only. But usually people use it for the whole script.

            Ensure that “use strict” is at the top
            Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
Strict mode isn’t enabled here:

      
        
        
          alert("some code");
// "use strict" below is ignored--it must be at the top

"use strict";

// strict mode is not activated
        
      
      
      Only comments may appear above "use strict".


            There’s no way to cancel use strict
            There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Browser consoleWhen you use a developer console to run code, please note that it doesn’t use strict by default.
Sometimes, when use strict makes a difference, you’ll get incorrect results.
So, how to actually use strict in the console?
First, you can try to press Shift+Enter to input multiple lines, and put use strict on top, like this:

      
        
        
          'use strict'; <Shift+Enter for a newline>
//  ...your code
<Enter to run>
        
      
      
      It works in most browsers, namely Firefox and Chrome.
If it doesn’t, e.g. in an old browser, there’s an ugly, but reliable way to ensure use strict. Put it inside this kind of wrapper:

      
        
        
          (function() {
  'use strict';

  // ...your code here...
})()
        
      
      
      Should we “use strict”?The question may sound obvious, but it’s not so.
One could recommend to start scripts with "use strict"… But you know what’s cool?
Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.
So, for now "use strict"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.
As of now, we’ve got to know about use strict in general.
In the next chapters, as we learn language features, we’ll see the differences between the strict and old modes. Luckily, there aren’t many and they actually make our lives better.
All examples in this tutorial assume strict mode unless (very rarely) specified otherwise.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nFor a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.
That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.
This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".
“use strict”The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.
For example:

      
        
        
          "use strict";

// this code works the modern way
...
        
      
      
      Quite soon we’re going to learn functions (a way to group commands), so let’s note in advance that "use strict" can be put at the beginning of a function. Doing that enables strict mode in that function only. But usually people use it for the whole script.

            Ensure that “use strict” is at the top
            Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
Strict mode isn’t enabled here:

      
        
        
          alert("some code");
// "use strict" below is ignored--it must be at the top

"use strict";

// strict mode is not activated
        
      
      
      Only comments may appear above "use strict".


            There’s no way to cancel use strict
            There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Browser consoleWhen you use a developer console to run code, please note that it doesn’t use strict by default.
Sometimes, when use strict makes a difference, you’ll get incorrect results.
So, how to actually use strict in the console?
First, you can try to press Shift+Enter to input multiple lines, and put use strict on top, like this:

      
        
        
          'use strict'; <Shift+Enter for a newline>
//  ...your code
<Enter to run>
        
      
      
      It works in most browsers, namely Firefox and Chrome.
If it doesn’t, e.g. in an old browser, there’s an ugly, but reliable way to ensure use strict. Put it inside this kind of wrapper:

      
        
        
          (function() {
  'use strict';

  // ...your code here...
})()
        
      
      
      Should we “use strict”?The question may sound obvious, but it’s not so.
One could recommend to start scripts with "use strict"… But you know what’s cool?
Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.
So, for now "use strict"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.
As of now, we’ve got to know about use strict in general.
In the next chapters, as we learn language features, we’ll see the differences between the strict and old modes. Luckily, there aren’t many and they actually make our lives better.
All examples in this tutorial assume strict mode unless (very rarely) specified otherwise.\n\nTutorialThe JavaScript languageJavaScript FundamentalsMay 19, 2020The modern mode, "use strict"For a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.
That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.
This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: "use strict".
“use strict”The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.
For example:

      
        
        
          "use strict";

// this code works the modern way
...
        
      
      
      Quite soon we’re going to learn functions (a way to group commands), so let’s note in advance that "use strict" can be put at the beginning of a function. Doing that enables strict mode in that function only. But usually people use it for the whole script.

            Ensure that “use strict” is at the top
            Please make sure that "use strict" is at the top of your scripts, otherwise strict mode may not be enabled.
Strict mode isn’t enabled here:

      
        
        
          alert("some code");
// "use strict" below is ignored--it must be at the top

"use strict";

// strict mode is not activated
        
      
      
      Only comments may appear above "use strict".


            There’s no way to cancel use strict
            There is no directive like "no use strict" that reverts the engine to old behavior.
Once we enter strict mode, there’s no going back.

Browser consoleWhen you use a developer console to run code, please note that it doesn’t use strict by default.
Sometimes, when use strict makes a difference, you’ll get incorrect results.
So, how to actually use strict in the console?
First, you can try to press Shift+Enter to input multiple lines, and put use strict on top, like this:

      
        
        
          'use strict'; <Shift+Enter for a newline>
//  ...your code
<Enter to run>
        
      
      
      It works in most browsers, namely Firefox and Chrome.
If it doesn’t, e.g. in an old browser, there’s an ugly, but reliable way to ensure use strict. Put it inside this kind of wrapper:

      
        
        
          (function() {
  'use strict';

  // ...your code here...
})()
        
      
      
      Should we “use strict”?The question may sound obvious, but it’s not so.
One could recommend to start scripts with "use strict"… But you know what’s cool?
Modern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the "use strict" directive, if we use them.
So, for now "use strict"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.
As of now, we’ve got to know about use strict in general.
In the next chapters, as we learn language features, we’ll see the differences between the strict and old modes. Luckily, there aren’t many and they actually make our lives better.
All examples in this tutorial assume strict mode unless (very rarely) specified otherwise.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nMost of the time, a JavaScript application needs to work with information. Here are two examples:

An online shop – the information might include goods being sold and a shopping cart.
A chat application – the information might include users, messages, and much more.

Variables are used to store this information.
A variableA variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.
The statement below creates (in other words: declares) a variable with the name “message”:

      
        
        
          let message;
        
      
      
      Now, we can put some data into it by using the assignment operator =:

      
        
        
          let message;

message = 'Hello'; // store the string 'Hello' in the variable named message
        
      
      
      The string is now saved into the memory area associated with the variable. We can access it using the variable name:

      
        
        
          
            
          
          
            
          
        
        
          let message;
message = 'Hello!';

alert(message); // shows the variable content
        
      
      
      To be concise, we can combine the variable declaration and assignment into a single line:

      
        
        
          
            
          
          
            
          
        
        
          let message = 'Hello!'; // define the variable and assign the value

alert(message); // Hello!
        
      
      
      We can also declare multiple variables in one line:

      
        
        
          let user = 'John', age = 25, message = 'Hello';
        
      
      
      That might seem shorter, but we don’t recommend it. For the sake of better readability, please use a single line per variable.
The multiline variant is a bit longer, but easier to read:

      
        
        
          let user = 'John';
let age = 25;
let message = 'Hello';
        
      
      
      Some people also define multiple variables in this multiline style:

      
        
        
          let user = 'John',
  age = 25,
  message = 'Hello';
        
      
      
      …Or even in the “comma-first” style:

      
        
        
          let user = 'John'
  , age = 25
  , message = 'Hello';
        
      
      
      Technically, all these variants do the same thing. So, it’s a matter of personal taste and aesthetics.

            var instead of let
            In older scripts, you may also find another keyword: var instead of let:

      
        
        
          var message = 'Hello';
        
      
      
      The var keyword is almost the same as let. It also declares a variable but in a slightly different, “old-school” way.
There are subtle differences between let and var, but they do not matter to us yet. We’ll cover them in detail in the chapter The old "var".

A real-life analogyWe can easily grasp the concept of a “variable” if we imagine it as a “box” for data, with a uniquely-named sticker on it.
For instance, the variable message can be imagined as a box labelled "message" with the value "Hello!" in it:

      
      
        
      
      We can put any value in the box.
We can also change it as many times as we want:

      
        
        
          
            
          
          
            
          
        
        
          let message;

message = 'Hello!';

message = 'World!'; // value changed

alert(message);
        
      
      
      When the value is changed, the old data is removed from the variable:

      
      
        
      
      We can also declare two variables and copy data from one into the other.

      
        
        
          
            
          
          
            
          
        
        
          let hello = 'Hello world!';

let message;

// copy 'Hello world' from hello into message
message = hello;

// now two variables hold the same data
alert(hello); // Hello world!
alert(message); // Hello world!
        
      
      
      
            Declaring twice triggers an error
            A variable should be declared only once.
A repeated declaration of the same variable is an error:

      
        
        
          
            
          
          
            
          
        
        
          let message = "This";

// repeated 'let' leads to an error
let message = "That"; // SyntaxError: 'message' has already been declared
        
      
      
      So, we should declare a variable once and then refer to it without let.


            Functional languages
            It’s interesting to note that there exist so-called pure functional programming languages, such as Haskell, that forbid changing variable values.
In such languages, once the value is stored “in the box”, it’s there forever. If we need to store something else, the language forces us to create a new box (declare a new variable). We can’t reuse the old one.
Though it may seem a little odd at first sight, these languages are quite capable of serious development. More than that, there are areas like parallel computations where this limitation confers certain benefits.

Variable namingThere are two limitations on variable names in JavaScript:

The name must contain only letters, digits, or the symbols $ and _.
The first character must not be a digit.

Examples of valid names:

      
        
        
          let userName;
let test123;
        
      
      
      When the name contains multiple words, camelCase is commonly used. That is: words go one after another, each word except first starting with a capital letter: myVeryLongName.
What’s interesting – the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
These names are valid:

      
        
        
          
            
          
          
            
          
        
        
          let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"

alert($ + _); // 3
        
      
      
      Examples of incorrect variable names:

      
        
        
          let 1a; // cannot start with a digit

let my-name; // hyphens '-' aren't allowed in the name
        
      
      
      
            Case matters
            Variables named apple and APPLE are two different variables.


            Non-Latin letters are allowed, but not recommended
            It is possible to use any language, including Cyrillic letters, Chinese logograms and so on, like this:

      
        
        
          let имя = '...';
let 我 = '...';
        
      
      
      Technically, there is no error here. Such names are allowed, but there is an international convention to use English in variable names. Even if we’re writing a small script, it may have a long life ahead. People from other countries may need to read it sometime.


            Reserved names
            There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.
The code below gives a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!
        
      
      
      

            An assignment without use strict
            Normally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using let. This still works now if we don’t put use strict in our scripts to maintain compatibility with old scripts.

      
        
        
          
            
          
          
            
          
        
        
          // note: no "use strict" in this example

num = 5; // the variable "num" is created if it didn't exist

alert(num); // 5
        
      
      
      This is a bad practice and would cause an error in strict mode:

      
        
        
          "use strict";

num = 5; // error: num is not defined
        
      
      
      
ConstantsTo declare a constant (unchanging) variable, use const instead of let:

      
        
        
          const myBirthday = '18.04.1982';
        
      
      
      Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:

      
        
        
          
            
          
          
            
          
        
        
          const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, can't reassign the constant!
        
      
      
      When a programmer is sure that a variable will never change, they can declare it with const to guarantee and communicate that fact to everyone.
Uppercase constantsThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known before execution.
Such constants are named using capital letters and underscores.
For instance, let’s make constants for colors in so-called “web” (hexadecimal) format:

      
        
        
          
            
          
          
            
          
        
        
          const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
        
      
      
      Benefits:

COLOR_ORANGE is much easier to remember than "#FF7F00".
It is much easier to mistype "#FF7F00" than COLOR_ORANGE.
When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00.

When should we use capitals for a constant and when should we name it normally? Let’s make that clear.
Being a “constant” just means that a variable’s value never changes. But some constants are known before execution (like a hexadecimal value for red) and some constants are calculated in run-time, during the execution, but do not change after their initial assignment.
For instance:

      
        
        
          const pageLoadTime = /* time taken by a webpage to load */;
        
      
      
      The value of pageLoadTime is not known before the page load, so it’s named normally. But it’s still a constant because it doesn’t change after the assignment.
In other words, capital-named constants are only used as aliases for “hard-coded” values.
Name things rightTalking about variables, there’s one more extremely important thing.
A variable name should have a clean, obvious meaning, describing the data that it stores.
Variable naming is one of the most important and complex skills in programming. A glance at variable names can reveal which code was written by a beginner versus an experienced developer.
In a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it’s much easier to find information that is well-labelled. Or, in other words, when the variables have good names.
Please spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.
Some good-to-follow rules are:

Use human-readable names like userName or shoppingCart.
Stay away from abbreviations or short names like a, b, and c, unless you know what you’re doing.
Make names maximally descriptive and concise. Examples of bad names are data and value. Such names say nothing. It’s only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.
Agree on terms within your team and in your mind. If a site visitor is called a “user” then we should name related variables currentUser or newUser instead of currentVisitor or newManInTown.

Sounds simple? Indeed it is, but creating descriptive and concise variable names in practice is not. Go for it.

            Reuse or create?
            And the last note. There are some lazy programmers who, instead of declaring new variables, tend to reuse existing ones.
As a result, their variables are like boxes into which people throw different things without changing their stickers. What’s inside the box now? Who knows? We need to come closer and check.
Such programmers save a little bit on variable declaration but lose ten times more on debugging.
An extra variable is good, not evil.
Modern JavaScript minifiers and browsers optimize code well enough, so it won’t create performance issues. Using different variables for different values can even help the engine optimize your code.

SummaryWe can declare variables to store data by using the var, let, or const keywords.

let – is a modern variable declaration.
var – is an old-school variable declaration. Normally we don’t use it at all, but we’ll cover subtle differences from let in the chapter The old "var", just in case you need them.
const – is like let, but the value of the variable can’t be changed.

Variables should be named in a way that allows us to easily understand what’s inside them.\n\nTutorialThe JavaScript languageJavaScript FundamentalsFebruary 14, 2024VariablesMost of the time, a JavaScript application needs to work with information. Here are two examples:

An online shop – the information might include goods being sold and a shopping cart.
A chat application – the information might include users, messages, and much more.

Variables are used to store this information.
A variableA variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.
The statement below creates (in other words: declares) a variable with the name “message”:

      
        
        
          let message;
        
      
      
      Now, we can put some data into it by using the assignment operator =:

      
        
        
          let message;

message = 'Hello'; // store the string 'Hello' in the variable named message
        
      
      
      The string is now saved into the memory area associated with the variable. We can access it using the variable name:

      
        
        
          
            
          
          
            
          
        
        
          let message;
message = 'Hello!';

alert(message); // shows the variable content
        
      
      
      To be concise, we can combine the variable declaration and assignment into a single line:

      
        
        
          
            
          
          
            
          
        
        
          let message = 'Hello!'; // define the variable and assign the value

alert(message); // Hello!
        
      
      
      We can also declare multiple variables in one line:

      
        
        
          let user = 'John', age = 25, message = 'Hello';
        
      
      
      That might seem shorter, but we don’t recommend it. For the sake of better readability, please use a single line per variable.
The multiline variant is a bit longer, but easier to read:

      
        
        
          let user = 'John';
let age = 25;
let message = 'Hello';
        
      
      
      Some people also define multiple variables in this multiline style:

      
        
        
          let user = 'John',
  age = 25,
  message = 'Hello';
        
      
      
      …Or even in the “comma-first” style:

      
        
        
          let user = 'John'
  , age = 25
  , message = 'Hello';
        
      
      
      Technically, all these variants do the same thing. So, it’s a matter of personal taste and aesthetics.

            var instead of let
            In older scripts, you may also find another keyword: var instead of let:

      
        
        
          var message = 'Hello';
        
      
      
      The var keyword is almost the same as let. It also declares a variable but in a slightly different, “old-school” way.
There are subtle differences between let and var, but they do not matter to us yet. We’ll cover them in detail in the chapter The old "var".

A real-life analogyWe can easily grasp the concept of a “variable” if we imagine it as a “box” for data, with a uniquely-named sticker on it.
For instance, the variable message can be imagined as a box labelled "message" with the value "Hello!" in it:

      
      
        
      
      We can put any value in the box.
We can also change it as many times as we want:

      
        
        
          
            
          
          
            
          
        
        
          let message;

message = 'Hello!';

message = 'World!'; // value changed

alert(message);
        
      
      
      When the value is changed, the old data is removed from the variable:

      
      
        
      
      We can also declare two variables and copy data from one into the other.

      
        
        
          
            
          
          
            
          
        
        
          let hello = 'Hello world!';

let message;

// copy 'Hello world' from hello into message
message = hello;

// now two variables hold the same data
alert(hello); // Hello world!
alert(message); // Hello world!
        
      
      
      
            Declaring twice triggers an error
            A variable should be declared only once.
A repeated declaration of the same variable is an error:

      
        
        
          
            
          
          
            
          
        
        
          let message = "This";

// repeated 'let' leads to an error
let message = "That"; // SyntaxError: 'message' has already been declared
        
      
      
      So, we should declare a variable once and then refer to it without let.


            Functional languages
            It’s interesting to note that there exist so-called pure functional programming languages, such as Haskell, that forbid changing variable values.
In such languages, once the value is stored “in the box”, it’s there forever. If we need to store something else, the language forces us to create a new box (declare a new variable). We can’t reuse the old one.
Though it may seem a little odd at first sight, these languages are quite capable of serious development. More than that, there are areas like parallel computations where this limitation confers certain benefits.

Variable namingThere are two limitations on variable names in JavaScript:

The name must contain only letters, digits, or the symbols $ and _.
The first character must not be a digit.

Examples of valid names:

      
        
        
          let userName;
let test123;
        
      
      
      When the name contains multiple words, camelCase is commonly used. That is: words go one after another, each word except first starting with a capital letter: myVeryLongName.
What’s interesting – the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
These names are valid:

      
        
        
          
            
          
          
            
          
        
        
          let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"

alert($ + _); // 3
        
      
      
      Examples of incorrect variable names:

      
        
        
          let 1a; // cannot start with a digit

let my-name; // hyphens '-' aren't allowed in the name
        
      
      
      
            Case matters
            Variables named apple and APPLE are two different variables.


            Non-Latin letters are allowed, but not recommended
            It is possible to use any language, including Cyrillic letters, Chinese logograms and so on, like this:

      
        
        
          let имя = '...';
let 我 = '...';
        
      
      
      Technically, there is no error here. Such names are allowed, but there is an international convention to use English in variable names. Even if we’re writing a small script, it may have a long life ahead. People from other countries may need to read it sometime.


            Reserved names
            There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.
The code below gives a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!
        
      
      
      

            An assignment without use strict
            Normally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using let. This still works now if we don’t put use strict in our scripts to maintain compatibility with old scripts.

      
        
        
          
            
          
          
            
          
        
        
          // note: no "use strict" in this example

num = 5; // the variable "num" is created if it didn't exist

alert(num); // 5
        
      
      
      This is a bad practice and would cause an error in strict mode:

      
        
        
          "use strict";

num = 5; // error: num is not defined
        
      
      
      
ConstantsTo declare a constant (unchanging) variable, use const instead of let:

      
        
        
          const myBirthday = '18.04.1982';
        
      
      
      Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:

      
        
        
          
            
          
          
            
          
        
        
          const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, can't reassign the constant!
        
      
      
      When a programmer is sure that a variable will never change, they can declare it with const to guarantee and communicate that fact to everyone.
Uppercase constantsThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known before execution.
Such constants are named using capital letters and underscores.
For instance, let’s make constants for colors in so-called “web” (hexadecimal) format:

      
        
        
          
            
          
          
            
          
        
        
          const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
        
      
      
      Benefits:

COLOR_ORANGE is much easier to remember than "#FF7F00".
It is much easier to mistype "#FF7F00" than COLOR_ORANGE.
When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00.

When should we use capitals for a constant and when should we name it normally? Let’s make that clear.
Being a “constant” just means that a variable’s value never changes. But some constants are known before execution (like a hexadecimal value for red) and some constants are calculated in run-time, during the execution, but do not change after their initial assignment.
For instance:

      
        
        
          const pageLoadTime = /* time taken by a webpage to load */;
        
      
      
      The value of pageLoadTime is not known before the page load, so it’s named normally. But it’s still a constant because it doesn’t change after the assignment.
In other words, capital-named constants are only used as aliases for “hard-coded” values.
Name things rightTalking about variables, there’s one more extremely important thing.
A variable name should have a clean, obvious meaning, describing the data that it stores.
Variable naming is one of the most important and complex skills in programming. A glance at variable names can reveal which code was written by a beginner versus an experienced developer.
In a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it’s much easier to find information that is well-labelled. Or, in other words, when the variables have good names.
Please spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.
Some good-to-follow rules are:

Use human-readable names like userName or shoppingCart.
Stay away from abbreviations or short names like a, b, and c, unless you know what you’re doing.
Make names maximally descriptive and concise. Examples of bad names are data and value. Such names say nothing. It’s only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.
Agree on terms within your team and in your mind. If a site visitor is called a “user” then we should name related variables currentUser or newUser instead of currentVisitor or newManInTown.

Sounds simple? Indeed it is, but creating descriptive and concise variable names in practice is not. Go for it.

            Reuse or create?
            And the last note. There are some lazy programmers who, instead of declaring new variables, tend to reuse existing ones.
As a result, their variables are like boxes into which people throw different things without changing their stickers. What’s inside the box now? Who knows? We need to come closer and check.
Such programmers save a little bit on variable declaration but lose ten times more on debugging.
An extra variable is good, not evil.
Modern JavaScript minifiers and browsers optimize code well enough, so it won’t create performance issues. Using different variables for different values can even help the engine optimize your code.

SummaryWe can declare variables to store data by using the var, let, or const keywords.

let – is a modern variable declaration.
var – is an old-school variable declaration. Normally we don’t use it at all, but we’ll cover subtle differences from let in the chapter The old "var", just in case you need them.
const – is like let, but the value of the variable can’t be changed.

Variables should be named in a way that allows us to easily understand what’s inside them.
TasksWorking with variablesimportance: 2
Declare two variables: admin and name.
Assign the value "John" to name.
Copy the value from name to admin.
Show the value of admin using alert (must output “John”).

solutionIn the code below, each line corresponds to the item in the task list.

      
        
        
          
            
          
          
            
          
        
        
          let admin, name; // can declare two variables at once

name = "John";

admin = name;

alert( admin ); // "John"
        
      
      
      Giving the right nameimportance: 3
Create a variable with the name of our planet. How would you name such a variable?
Create a variable to store the name of a current visitor to a website. How would you name that variable?

solutionThe variable for our planetThe variable for our planetThat’s simple:

      
        
        
          let ourPlanetName = "Earth";
        
      
      
      Note, we could use a shorter name planet, but it might not be obvious what planet it refers to. It’s nice to be more verbose. At least until the variable isNotTooLong.
The name of the current visitorThe name of the current visitor
      
        
        
          let currentUserName = "John";
        
      
      
      Again, we could shorten that to userName if we know for sure that the user is current.
Modern editors and autocomplete make long variable names easy to write. Don’t save on them. A name with 3 words in it is fine.
And if your editor does not have proper autocompletion, get a new one.
Uppercase const?importance: 4Examine the following code:

      
        
        
          const birthday = '18.04.1982';

const age = someCode(birthday);
        
      
      
      Here we have a constant birthday for the date, and also the age constant.
The age is calculated from birthday using someCode(), which means a function call that we didn’t explain yet (we will soon!), but the details don’t matter here, the point is that age is calculated somehow based on the birthday.
Would it be right to use upper case for birthday? For age? Or even for both?

      
        
        
          const BIRTHDAY = '18.04.1982'; // make birthday uppercase?

const AGE = someCode(BIRTHDAY); // make age uppercase?
        
      
      
      solutionWe generally use upper case for constants that are “hard-coded”. Or, in other words, when the value is known prior to execution and directly written into the code.
In this code, birthday is exactly like that. So we could use the upper case for it.
In contrast, age is evaluated in run-time. Today we have one age, a year after we’ll have another one. It is constant in a sense that it does not change through the code execution. But it is a bit “less of a constant” than birthday: it is calculated, so we should keep the lower case for it.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nMost of the time, a JavaScript application needs to work with information. Here are two examples:

An online shop – the information might include goods being sold and a shopping cart.
A chat application – the information might include users, messages, and much more.

Variables are used to store this information.
A variableA variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.
The statement below creates (in other words: declares) a variable with the name “message”:

      
        
        
          let message;
        
      
      
      Now, we can put some data into it by using the assignment operator =:

      
        
        
          let message;

message = 'Hello'; // store the string 'Hello' in the variable named message
        
      
      
      The string is now saved into the memory area associated with the variable. We can access it using the variable name:

      
        
        
          
            
          
          
            
          
        
        
          let message;
message = 'Hello!';

alert(message); // shows the variable content
        
      
      
      To be concise, we can combine the variable declaration and assignment into a single line:

      
        
        
          
            
          
          
            
          
        
        
          let message = 'Hello!'; // define the variable and assign the value

alert(message); // Hello!
        
      
      
      We can also declare multiple variables in one line:

      
        
        
          let user = 'John', age = 25, message = 'Hello';
        
      
      
      That might seem shorter, but we don’t recommend it. For the sake of better readability, please use a single line per variable.
The multiline variant is a bit longer, but easier to read:

      
        
        
          let user = 'John';
let age = 25;
let message = 'Hello';
        
      
      
      Some people also define multiple variables in this multiline style:

      
        
        
          let user = 'John',
  age = 25,
  message = 'Hello';
        
      
      
      …Or even in the “comma-first” style:

      
        
        
          let user = 'John'
  , age = 25
  , message = 'Hello';
        
      
      
      Technically, all these variants do the same thing. So, it’s a matter of personal taste and aesthetics.

            var instead of let
            In older scripts, you may also find another keyword: var instead of let:

      
        
        
          var message = 'Hello';
        
      
      
      The var keyword is almost the same as let. It also declares a variable but in a slightly different, “old-school” way.
There are subtle differences between let and var, but they do not matter to us yet. We’ll cover them in detail in the chapter The old "var".

A real-life analogyWe can easily grasp the concept of a “variable” if we imagine it as a “box” for data, with a uniquely-named sticker on it.
For instance, the variable message can be imagined as a box labelled "message" with the value "Hello!" in it:

      
      
        
      
      We can put any value in the box.
We can also change it as many times as we want:

      
        
        
          
            
          
          
            
          
        
        
          let message;

message = 'Hello!';

message = 'World!'; // value changed

alert(message);
        
      
      
      When the value is changed, the old data is removed from the variable:

      
      
        
      
      We can also declare two variables and copy data from one into the other.

      
        
        
          
            
          
          
            
          
        
        
          let hello = 'Hello world!';

let message;

// copy 'Hello world' from hello into message
message = hello;

// now two variables hold the same data
alert(hello); // Hello world!
alert(message); // Hello world!
        
      
      
      
            Declaring twice triggers an error
            A variable should be declared only once.
A repeated declaration of the same variable is an error:

      
        
        
          
            
          
          
            
          
        
        
          let message = "This";

// repeated 'let' leads to an error
let message = "That"; // SyntaxError: 'message' has already been declared
        
      
      
      So, we should declare a variable once and then refer to it without let.


            Functional languages
            It’s interesting to note that there exist so-called pure functional programming languages, such as Haskell, that forbid changing variable values.
In such languages, once the value is stored “in the box”, it’s there forever. If we need to store something else, the language forces us to create a new box (declare a new variable). We can’t reuse the old one.
Though it may seem a little odd at first sight, these languages are quite capable of serious development. More than that, there are areas like parallel computations where this limitation confers certain benefits.

Variable namingThere are two limitations on variable names in JavaScript:

The name must contain only letters, digits, or the symbols $ and _.
The first character must not be a digit.

Examples of valid names:

      
        
        
          let userName;
let test123;
        
      
      
      When the name contains multiple words, camelCase is commonly used. That is: words go one after another, each word except first starting with a capital letter: myVeryLongName.
What’s interesting – the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
These names are valid:

      
        
        
          
            
          
          
            
          
        
        
          let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"

alert($ + _); // 3
        
      
      
      Examples of incorrect variable names:

      
        
        
          let 1a; // cannot start with a digit

let my-name; // hyphens '-' aren't allowed in the name
        
      
      
      
            Case matters
            Variables named apple and APPLE are two different variables.


            Non-Latin letters are allowed, but not recommended
            It is possible to use any language, including Cyrillic letters, Chinese logograms and so on, like this:

      
        
        
          let имя = '...';
let 我 = '...';
        
      
      
      Technically, there is no error here. Such names are allowed, but there is an international convention to use English in variable names. Even if we’re writing a small script, it may have a long life ahead. People from other countries may need to read it sometime.


            Reserved names
            There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.
The code below gives a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!
        
      
      
      

            An assignment without use strict
            Normally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using let. This still works now if we don’t put use strict in our scripts to maintain compatibility with old scripts.

      
        
        
          
            
          
          
            
          
        
        
          // note: no "use strict" in this example

num = 5; // the variable "num" is created if it didn't exist

alert(num); // 5
        
      
      
      This is a bad practice and would cause an error in strict mode:

      
        
        
          "use strict";

num = 5; // error: num is not defined
        
      
      
      
ConstantsTo declare a constant (unchanging) variable, use const instead of let:

      
        
        
          const myBirthday = '18.04.1982';
        
      
      
      Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:

      
        
        
          
            
          
          
            
          
        
        
          const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, can't reassign the constant!
        
      
      
      When a programmer is sure that a variable will never change, they can declare it with const to guarantee and communicate that fact to everyone.
Uppercase constantsThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known before execution.
Such constants are named using capital letters and underscores.
For instance, let’s make constants for colors in so-called “web” (hexadecimal) format:

      
        
        
          
            
          
          
            
          
        
        
          const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
        
      
      
      Benefits:

COLOR_ORANGE is much easier to remember than "#FF7F00".
It is much easier to mistype "#FF7F00" than COLOR_ORANGE.
When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00.

When should we use capitals for a constant and when should we name it normally? Let’s make that clear.
Being a “constant” just means that a variable’s value never changes. But some constants are known before execution (like a hexadecimal value for red) and some constants are calculated in run-time, during the execution, but do not change after their initial assignment.
For instance:

      
        
        
          const pageLoadTime = /* time taken by a webpage to load */;
        
      
      
      The value of pageLoadTime is not known before the page load, so it’s named normally. But it’s still a constant because it doesn’t change after the assignment.
In other words, capital-named constants are only used as aliases for “hard-coded” values.
Name things rightTalking about variables, there’s one more extremely important thing.
A variable name should have a clean, obvious meaning, describing the data that it stores.
Variable naming is one of the most important and complex skills in programming. A glance at variable names can reveal which code was written by a beginner versus an experienced developer.
In a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it’s much easier to find information that is well-labelled. Or, in other words, when the variables have good names.
Please spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.
Some good-to-follow rules are:

Use human-readable names like userName or shoppingCart.
Stay away from abbreviations or short names like a, b, and c, unless you know what you’re doing.
Make names maximally descriptive and concise. Examples of bad names are data and value. Such names say nothing. It’s only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.
Agree on terms within your team and in your mind. If a site visitor is called a “user” then we should name related variables currentUser or newUser instead of currentVisitor or newManInTown.

Sounds simple? Indeed it is, but creating descriptive and concise variable names in practice is not. Go for it.

            Reuse or create?
            And the last note. There are some lazy programmers who, instead of declaring new variables, tend to reuse existing ones.
As a result, their variables are like boxes into which people throw different things without changing their stickers. What’s inside the box now? Who knows? We need to come closer and check.
Such programmers save a little bit on variable declaration but lose ten times more on debugging.
An extra variable is good, not evil.
Modern JavaScript minifiers and browsers optimize code well enough, so it won’t create performance issues. Using different variables for different values can even help the engine optimize your code.

SummaryWe can declare variables to store data by using the var, let, or const keywords.

let – is a modern variable declaration.
var – is an old-school variable declaration. Normally we don’t use it at all, but we’ll cover subtle differences from let in the chapter The old "var", just in case you need them.
const – is like let, but the value of the variable can’t be changed.

Variables should be named in a way that allows us to easily understand what’s inside them.
TasksWorking with variablesimportance: 2
Declare two variables: admin and name.
Assign the value "John" to name.
Copy the value from name to admin.
Show the value of admin using alert (must output “John”).

solutionIn the code below, each line corresponds to the item in the task list.

      
        
        
          
            
          
          
            
          
        
        
          let admin, name; // can declare two variables at once

name = "John";

admin = name;

alert( admin ); // "John"
        
      
      
      Giving the right nameimportance: 3
Create a variable with the name of our planet. How would you name such a variable?
Create a variable to store the name of a current visitor to a website. How would you name that variable?

solutionThe variable for our planetThe variable for our planetThat’s simple:

      
        
        
          let ourPlanetName = "Earth";
        
      
      
      Note, we could use a shorter name planet, but it might not be obvious what planet it refers to. It’s nice to be more verbose. At least until the variable isNotTooLong.
The name of the current visitorThe name of the current visitor
      
        
        
          let currentUserName = "John";
        
      
      
      Again, we could shorten that to userName if we know for sure that the user is current.
Modern editors and autocomplete make long variable names easy to write. Don’t save on them. A name with 3 words in it is fine.
And if your editor does not have proper autocompletion, get a new one.
Uppercase const?importance: 4Examine the following code:

      
        
        
          const birthday = '18.04.1982';

const age = someCode(birthday);
        
      
      
      Here we have a constant birthday for the date, and also the age constant.
The age is calculated from birthday using someCode(), which means a function call that we didn’t explain yet (we will soon!), but the details don’t matter here, the point is that age is calculated somehow based on the birthday.
Would it be right to use upper case for birthday? For age? Or even for both?

      
        
        
          const BIRTHDAY = '18.04.1982'; // make birthday uppercase?

const AGE = someCode(BIRTHDAY); // make age uppercase?
        
      
      
      solutionWe generally use upper case for constants that are “hard-coded”. Or, in other words, when the value is known prior to execution and directly written into the code.
In this code, birthday is exactly like that. So we could use the upper case for it.
In contrast, age is evaluated in run-time. Today we have one age, a year after we’ll have another one. It is constant in a sense that it does not change through the code execution. But it is a bit “less of a constant” than birthday: it is calculated, so we should keep the lower case for it.\n\nTutorialThe JavaScript languageJavaScript FundamentalsFebruary 14, 2024VariablesMost of the time, a JavaScript application needs to work with information. Here are two examples:

An online shop – the information might include goods being sold and a shopping cart.
A chat application – the information might include users, messages, and much more.

Variables are used to store this information.
A variableA variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.
To create a variable in JavaScript, use the let keyword.
The statement below creates (in other words: declares) a variable with the name “message”:

      
        
        
          let message;
        
      
      
      Now, we can put some data into it by using the assignment operator =:

      
        
        
          let message;

message = 'Hello'; // store the string 'Hello' in the variable named message
        
      
      
      The string is now saved into the memory area associated with the variable. We can access it using the variable name:

      
        
        
          
            
          
          
            
          
        
        
          let message;
message = 'Hello!';

alert(message); // shows the variable content
        
      
      
      To be concise, we can combine the variable declaration and assignment into a single line:

      
        
        
          
            
          
          
            
          
        
        
          let message = 'Hello!'; // define the variable and assign the value

alert(message); // Hello!
        
      
      
      We can also declare multiple variables in one line:

      
        
        
          let user = 'John', age = 25, message = 'Hello';
        
      
      
      That might seem shorter, but we don’t recommend it. For the sake of better readability, please use a single line per variable.
The multiline variant is a bit longer, but easier to read:

      
        
        
          let user = 'John';
let age = 25;
let message = 'Hello';
        
      
      
      Some people also define multiple variables in this multiline style:

      
        
        
          let user = 'John',
  age = 25,
  message = 'Hello';
        
      
      
      …Or even in the “comma-first” style:

      
        
        
          let user = 'John'
  , age = 25
  , message = 'Hello';
        
      
      
      Technically, all these variants do the same thing. So, it’s a matter of personal taste and aesthetics.

            var instead of let
            In older scripts, you may also find another keyword: var instead of let:

      
        
        
          var message = 'Hello';
        
      
      
      The var keyword is almost the same as let. It also declares a variable but in a slightly different, “old-school” way.
There are subtle differences between let and var, but they do not matter to us yet. We’ll cover them in detail in the chapter The old "var".

A real-life analogyWe can easily grasp the concept of a “variable” if we imagine it as a “box” for data, with a uniquely-named sticker on it.
For instance, the variable message can be imagined as a box labelled "message" with the value "Hello!" in it:

      
      
        
      
      We can put any value in the box.
We can also change it as many times as we want:

      
        
        
          
            
          
          
            
          
        
        
          let message;

message = 'Hello!';

message = 'World!'; // value changed

alert(message);
        
      
      
      When the value is changed, the old data is removed from the variable:

      
      
        
      
      We can also declare two variables and copy data from one into the other.

      
        
        
          
            
          
          
            
          
        
        
          let hello = 'Hello world!';

let message;

// copy 'Hello world' from hello into message
message = hello;

// now two variables hold the same data
alert(hello); // Hello world!
alert(message); // Hello world!
        
      
      
      
            Declaring twice triggers an error
            A variable should be declared only once.
A repeated declaration of the same variable is an error:

      
        
        
          
            
          
          
            
          
        
        
          let message = "This";

// repeated 'let' leads to an error
let message = "That"; // SyntaxError: 'message' has already been declared
        
      
      
      So, we should declare a variable once and then refer to it without let.


            Functional languages
            It’s interesting to note that there exist so-called pure functional programming languages, such as Haskell, that forbid changing variable values.
In such languages, once the value is stored “in the box”, it’s there forever. If we need to store something else, the language forces us to create a new box (declare a new variable). We can’t reuse the old one.
Though it may seem a little odd at first sight, these languages are quite capable of serious development. More than that, there are areas like parallel computations where this limitation confers certain benefits.

Variable namingThere are two limitations on variable names in JavaScript:

The name must contain only letters, digits, or the symbols $ and _.
The first character must not be a digit.

Examples of valid names:

      
        
        
          let userName;
let test123;
        
      
      
      When the name contains multiple words, camelCase is commonly used. That is: words go one after another, each word except first starting with a capital letter: myVeryLongName.
What’s interesting – the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.
These names are valid:

      
        
        
          
            
          
          
            
          
        
        
          let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"

alert($ + _); // 3
        
      
      
      Examples of incorrect variable names:

      
        
        
          let 1a; // cannot start with a digit

let my-name; // hyphens '-' aren't allowed in the name
        
      
      
      
            Case matters
            Variables named apple and APPLE are two different variables.


            Non-Latin letters are allowed, but not recommended
            It is possible to use any language, including Cyrillic letters, Chinese logograms and so on, like this:

      
        
        
          let имя = '...';
let 我 = '...';
        
      
      
      Technically, there is no error here. Such names are allowed, but there is an international convention to use English in variable names. Even if we’re writing a small script, it may have a long life ahead. People from other countries may need to read it sometime.


            Reserved names
            There is a list of reserved words, which cannot be used as variable names because they are used by the language itself.
For example: let, class, return, and function are reserved.
The code below gives a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let let = 5; // can't name a variable "let", error!
let return = 5; // also can't name it "return", error!
        
      
      
      

            An assignment without use strict
            Normally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using let. This still works now if we don’t put use strict in our scripts to maintain compatibility with old scripts.

      
        
        
          
            
          
          
            
          
        
        
          // note: no "use strict" in this example

num = 5; // the variable "num" is created if it didn't exist

alert(num); // 5
        
      
      
      This is a bad practice and would cause an error in strict mode:

      
        
        
          "use strict";

num = 5; // error: num is not defined
        
      
      
      
ConstantsTo declare a constant (unchanging) variable, use const instead of let:

      
        
        
          const myBirthday = '18.04.1982';
        
      
      
      Variables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:

      
        
        
          
            
          
          
            
          
        
        
          const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, can't reassign the constant!
        
      
      
      When a programmer is sure that a variable will never change, they can declare it with const to guarantee and communicate that fact to everyone.
Uppercase constantsThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known before execution.
Such constants are named using capital letters and underscores.
For instance, let’s make constants for colors in so-called “web” (hexadecimal) format:

      
        
        
          
            
          
          
            
          
        
        
          const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
        
      
      
      Benefits:

COLOR_ORANGE is much easier to remember than "#FF7F00".
It is much easier to mistype "#FF7F00" than COLOR_ORANGE.
When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00.

When should we use capitals for a constant and when should we name it normally? Let’s make that clear.
Being a “constant” just means that a variable’s value never changes. But some constants are known before execution (like a hexadecimal value for red) and some constants are calculated in run-time, during the execution, but do not change after their initial assignment.
For instance:

      
        
        
          const pageLoadTime = /* time taken by a webpage to load */;
        
      
      
      The value of pageLoadTime is not known before the page load, so it’s named normally. But it’s still a constant because it doesn’t change after the assignment.
In other words, capital-named constants are only used as aliases for “hard-coded” values.
Name things rightTalking about variables, there’s one more extremely important thing.
A variable name should have a clean, obvious meaning, describing the data that it stores.
Variable naming is one of the most important and complex skills in programming. A glance at variable names can reveal which code was written by a beginner versus an experienced developer.
In a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it’s much easier to find information that is well-labelled. Or, in other words, when the variables have good names.
Please spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.
Some good-to-follow rules are:

Use human-readable names like userName or shoppingCart.
Stay away from abbreviations or short names like a, b, and c, unless you know what you’re doing.
Make names maximally descriptive and concise. Examples of bad names are data and value. Such names say nothing. It’s only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.
Agree on terms within your team and in your mind. If a site visitor is called a “user” then we should name related variables currentUser or newUser instead of currentVisitor or newManInTown.

Sounds simple? Indeed it is, but creating descriptive and concise variable names in practice is not. Go for it.

            Reuse or create?
            And the last note. There are some lazy programmers who, instead of declaring new variables, tend to reuse existing ones.
As a result, their variables are like boxes into which people throw different things without changing their stickers. What’s inside the box now? Who knows? We need to come closer and check.
Such programmers save a little bit on variable declaration but lose ten times more on debugging.
An extra variable is good, not evil.
Modern JavaScript minifiers and browsers optimize code well enough, so it won’t create performance issues. Using different variables for different values can even help the engine optimize your code.

SummaryWe can declare variables to store data by using the var, let, or const keywords.

let – is a modern variable declaration.
var – is an old-school variable declaration. Normally we don’t use it at all, but we’ll cover subtle differences from let in the chapter The old "var", just in case you need them.
const – is like let, but the value of the variable can’t be changed.

Variables should be named in a way that allows us to easily understand what’s inside them.
TasksWorking with variablesimportance: 2
Declare two variables: admin and name.
Assign the value "John" to name.
Copy the value from name to admin.
Show the value of admin using alert (must output “John”).

solutionIn the code below, each line corresponds to the item in the task list.

      
        
        
          
            
          
          
            
          
        
        
          let admin, name; // can declare two variables at once

name = "John";

admin = name;

alert( admin ); // "John"
        
      
      
      Giving the right nameimportance: 3
Create a variable with the name of our planet. How would you name such a variable?
Create a variable to store the name of a current visitor to a website. How would you name that variable?

solutionThe variable for our planetThe variable for our planetThat’s simple:

      
        
        
          let ourPlanetName = "Earth";
        
      
      
      Note, we could use a shorter name planet, but it might not be obvious what planet it refers to. It’s nice to be more verbose. At least until the variable isNotTooLong.
The name of the current visitorThe name of the current visitor
      
        
        
          let currentUserName = "John";
        
      
      
      Again, we could shorten that to userName if we know for sure that the user is current.
Modern editors and autocomplete make long variable names easy to write. Don’t save on them. A name with 3 words in it is fine.
And if your editor does not have proper autocompletion, get a new one.
Uppercase const?importance: 4Examine the following code:

      
        
        
          const birthday = '18.04.1982';

const age = someCode(birthday);
        
      
      
      Here we have a constant birthday for the date, and also the age constant.
The age is calculated from birthday using someCode(), which means a function call that we didn’t explain yet (we will soon!), but the details don’t matter here, the point is that age is calculated somehow based on the birthday.
Would it be right to use upper case for birthday? For age? Or even for both?

      
        
        
          const BIRTHDAY = '18.04.1982'; // make birthday uppercase?

const AGE = someCode(BIRTHDAY); // make age uppercase?
        
      
      
      solutionWe generally use upper case for constants that are “hard-coded”. Or, in other words, when the value is known prior to execution and directly written into the code.
In this code, birthday is exactly like that. So we could use the upper case for it.
In contrast, age is evaluated in run-time. Today we have one age, a year after we’ll have another one. It is constant in a sense that it does not change through the code execution. But it is a bit “less of a constant” than birthday: it is calculated, so we should keep the lower case for it.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nA value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. Here, we’ll cover them in general and in the next chapters we’ll talk about each of them in detail.
We can put any type in a variable. For example, a variable can at one moment be a string and then store a number:

      
        
        
          // no error
let message = "hello";
message = 123456;
        
      
      
      Programming languages that allow such things, such as JavaScript, are called “dynamically typed”, meaning that there exist data types, but variables are not bound to any of them.
Number
      
        
        
          let n = 123;
n = 12.345;
        
      
      
      The number type represents both integer and floating point numbers.
There are many operations for numbers, e.g. multiplication *, division /, addition +, subtraction -, and so on.
Besides regular numbers, there are so-called “special numeric values” which also belong to this data type: Infinity, -Infinity and NaN.


Infinity represents the mathematical Infinity ∞. It is a special value that’s greater than any number.
We can get it as a result of division by zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 / 0 ); // Infinity
        
      
      
      Or just reference it directly:

      
        
        
          
            
          
          
            
          
        
        
          alert( Infinity ); // Infinity
        
      
      
      

NaN represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( "not a number" / 2 ); // NaN, such division is erroneous
        
      
      
      NaN is sticky. Any further mathematical operation on NaN returns NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "not a number" / 2 - 1 ); // NaN
        
      
      
      So, if there’s a NaN somewhere in a mathematical expression, it propagates to the whole result (there’s only one exception to that: NaN ** 0 is 1).



            Mathematical operations are safe
            Doing maths is “safe” in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc.
The script will never stop with a fatal error (“die”). At worst, we’ll get NaN as the result.

Special numeric values formally belong to the “number” type. Of course they are not numbers in the common sense of this word.
We’ll see more about working with numbers in the chapter Numbers.
BigIntIn JavaScript, the “number” type cannot safely represent integer values larger than (253-1) (that’s 9007199254740991), or less than -(253-1) for negatives.
To be really precise, the “number” type can store larger integers (up to 1.7976931348623157 * 10308), but outside of the safe integer range ±(253-1) there’ll be a precision error, because not all digits fit into the fixed 64-bit storage. So an “approximate” value may be stored.
For example, these two numbers (right above the safe range) are the same:

      
        
        
          console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
        
      
      
      So to say, all odd integers greater than (253-1) can’t be stored at all in the “number” type.
For most purposes ±(253-1) range is quite enough, but sometimes we need the entire range of really big integers, e.g. for cryptography or microsecond-precision timestamps.
BigInt type was recently added to the language to represent integers of arbitrary length.
A BigInt value is created by appending n to the end of an integer:

      
        
        
          // the "n" at the end means it's a BigInt
const bigInt = 1234567890123456789012345678901234567890n;
        
      
      
      As BigInt numbers are rarely needed, we don’t cover them here, but devoted them a separate chapter BigInt. Read it when you need such big numbers.
StringA string in JavaScript must be surrounded by quotes.

      
        
        
          let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
        
      
      
      In JavaScript, there are 3 types of quotes.

Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello`.

Double and single quotes are “simple” quotes. There’s practically no difference between them in JavaScript.
Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:

      
        
        
          
            
          
          
            
          
        
        
          let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
        
      
      
      The expression inside ${…} is evaluated and the result becomes a part of the string. We can put anything in there: a variable like name or an arithmetical expression like 1 + 2 or something more complex.
Please note that this can only be done in backticks. Other quotes don’t have this embedding functionality!

      
        
        
          
            
          
          
            
          
        
        
          alert( "the result is ${1 + 2}" ); // the result is ${1 + 2} (double quotes do nothing)
        
      
      
      We’ll cover strings more thoroughly in the chapter Strings.

            There is no character type.
            In some languages, there is a special “character” type for a single character. For example, in the C language and in Java it is called “char”.
In JavaScript, there is no such type. There’s only one type: string. A string may consist of zero characters (be empty), one character or many of them.

Boolean (logical type)The boolean type has only two values: true and false.
This type is commonly used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.
For instance:

      
        
        
          let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
        
      
      
      Boolean values also come as a result of comparisons:

      
        
        
          
            
          
          
            
          
        
        
          let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
        
      
      
      We’ll cover booleans more deeply in the chapter Logical operators.
The “null” valueThe special null value does not belong to any of the types described above.
It forms a separate type of its own which contains only the null value:

      
        
        
          let age = null;
        
      
      
      In JavaScript, null is not a “reference to a non-existing object” or a “null pointer” like in some other languages.
It’s just a special value which represents “nothing”, “empty” or “value unknown”.
The code above states that age is unknown.
The “undefined” valueThe special value undefined also stands apart. It makes a type of its own, just like null.
The meaning of undefined is “value is not assigned”.
If a variable is declared, but not assigned, then its value is undefined:

      
        
        
          
            
          
          
            
          
        
        
          let age;

alert(age); // shows "undefined"
        
      
      
      Technically, it is possible to explicitly assign undefined to a variable:

      
        
        
          
            
          
          
            
          
        
        
          let age = 100;

// change the value to undefined
age = undefined;

alert(age); // "undefined"
        
      
      
      …But we don’t recommend doing that. Normally, one uses null to assign an “empty” or “unknown” value to a variable, while undefined is reserved as a default initial value for unassigned things.
Objects and SymbolsThe object type is special.
All other types are called “primitive” because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.
Being that important, objects deserve a special treatment. We’ll deal with them later in the chapter Objects, after we learn more about primitives.
The symbol type is used to create unique identifiers for objects. We have to mention it here for the sake of completeness, but also postpone the details till we know objects.
The typeof operatorThe typeof operator returns the type of the operand. It’s useful when we want to process values of different types differently or just want to do a quick check.
A call to typeof x returns a string with the type name:

      
        
        
          typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
        
      
      
      The last three lines may need additional explanation:

Math is a built-in object that provides mathematical operations. We will learn it in the chapter Numbers. Here, it serves just as an example of an object.
The result of typeof null is "object". That’s an officially recognized error in typeof, coming from very early days of JavaScript and kept for compatibility. Definitely, null is not an object. It is a special value with a separate type of its own. The behavior of typeof is wrong here.
The result of typeof alert is "function", because alert is a function. We’ll study functions in the next chapters where we’ll also see that there’s no special “function” type in JavaScript. Functions belong to the object type. But typeof treats them differently, returning "function". That also comes from the early days of JavaScript. Technically, such behavior isn’t correct, but can be convenient in practice.


            The typeof(x) syntax
            You may also come across another syntax: typeof(x). It’s the same as typeof x.
To put it clear: typeof is an operator, not a function. The parentheses here aren’t a part of typeof. It’s the kind of parentheses used for mathematical grouping.
Usually, such parentheses contain a mathematical expression, such as (2 + 2), but here they contain only one argument (x). Syntactically, they allow to avoid a space between the typeof operator and its argument, and some people like it.
Some people prefer typeof(x), although the typeof x syntax is much more common.

SummaryThere are 8 basic data types in JavaScript.

Seven primitive data types:

number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.


And one non-primitive data type:

object for more complex data structures.



The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.

In the next chapters, we’ll concentrate on primitive values and once we’re familiar with them, we’ll move on to objects.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJuly 9, 2024Data typesA value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. Here, we’ll cover them in general and in the next chapters we’ll talk about each of them in detail.
We can put any type in a variable. For example, a variable can at one moment be a string and then store a number:

      
        
        
          // no error
let message = "hello";
message = 123456;
        
      
      
      Programming languages that allow such things, such as JavaScript, are called “dynamically typed”, meaning that there exist data types, but variables are not bound to any of them.
Number
      
        
        
          let n = 123;
n = 12.345;
        
      
      
      The number type represents both integer and floating point numbers.
There are many operations for numbers, e.g. multiplication *, division /, addition +, subtraction -, and so on.
Besides regular numbers, there are so-called “special numeric values” which also belong to this data type: Infinity, -Infinity and NaN.


Infinity represents the mathematical Infinity ∞. It is a special value that’s greater than any number.
We can get it as a result of division by zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 / 0 ); // Infinity
        
      
      
      Or just reference it directly:

      
        
        
          
            
          
          
            
          
        
        
          alert( Infinity ); // Infinity
        
      
      
      

NaN represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( "not a number" / 2 ); // NaN, such division is erroneous
        
      
      
      NaN is sticky. Any further mathematical operation on NaN returns NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "not a number" / 2 - 1 ); // NaN
        
      
      
      So, if there’s a NaN somewhere in a mathematical expression, it propagates to the whole result (there’s only one exception to that: NaN ** 0 is 1).



            Mathematical operations are safe
            Doing maths is “safe” in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc.
The script will never stop with a fatal error (“die”). At worst, we’ll get NaN as the result.

Special numeric values formally belong to the “number” type. Of course they are not numbers in the common sense of this word.
We’ll see more about working with numbers in the chapter Numbers.
BigIntIn JavaScript, the “number” type cannot safely represent integer values larger than (253-1) (that’s 9007199254740991), or less than -(253-1) for negatives.
To be really precise, the “number” type can store larger integers (up to 1.7976931348623157 * 10308), but outside of the safe integer range ±(253-1) there’ll be a precision error, because not all digits fit into the fixed 64-bit storage. So an “approximate” value may be stored.
For example, these two numbers (right above the safe range) are the same:

      
        
        
          console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
        
      
      
      So to say, all odd integers greater than (253-1) can’t be stored at all in the “number” type.
For most purposes ±(253-1) range is quite enough, but sometimes we need the entire range of really big integers, e.g. for cryptography or microsecond-precision timestamps.
BigInt type was recently added to the language to represent integers of arbitrary length.
A BigInt value is created by appending n to the end of an integer:

      
        
        
          // the "n" at the end means it's a BigInt
const bigInt = 1234567890123456789012345678901234567890n;
        
      
      
      As BigInt numbers are rarely needed, we don’t cover them here, but devoted them a separate chapter BigInt. Read it when you need such big numbers.
StringA string in JavaScript must be surrounded by quotes.

      
        
        
          let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
        
      
      
      In JavaScript, there are 3 types of quotes.

Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello`.

Double and single quotes are “simple” quotes. There’s practically no difference between them in JavaScript.
Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:

      
        
        
          
            
          
          
            
          
        
        
          let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
        
      
      
      The expression inside ${…} is evaluated and the result becomes a part of the string. We can put anything in there: a variable like name or an arithmetical expression like 1 + 2 or something more complex.
Please note that this can only be done in backticks. Other quotes don’t have this embedding functionality!

      
        
        
          
            
          
          
            
          
        
        
          alert( "the result is ${1 + 2}" ); // the result is ${1 + 2} (double quotes do nothing)
        
      
      
      We’ll cover strings more thoroughly in the chapter Strings.

            There is no character type.
            In some languages, there is a special “character” type for a single character. For example, in the C language and in Java it is called “char”.
In JavaScript, there is no such type. There’s only one type: string. A string may consist of zero characters (be empty), one character or many of them.

Boolean (logical type)The boolean type has only two values: true and false.
This type is commonly used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.
For instance:

      
        
        
          let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
        
      
      
      Boolean values also come as a result of comparisons:

      
        
        
          
            
          
          
            
          
        
        
          let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
        
      
      
      We’ll cover booleans more deeply in the chapter Logical operators.
The “null” valueThe special null value does not belong to any of the types described above.
It forms a separate type of its own which contains only the null value:

      
        
        
          let age = null;
        
      
      
      In JavaScript, null is not a “reference to a non-existing object” or a “null pointer” like in some other languages.
It’s just a special value which represents “nothing”, “empty” or “value unknown”.
The code above states that age is unknown.
The “undefined” valueThe special value undefined also stands apart. It makes a type of its own, just like null.
The meaning of undefined is “value is not assigned”.
If a variable is declared, but not assigned, then its value is undefined:

      
        
        
          
            
          
          
            
          
        
        
          let age;

alert(age); // shows "undefined"
        
      
      
      Technically, it is possible to explicitly assign undefined to a variable:

      
        
        
          
            
          
          
            
          
        
        
          let age = 100;

// change the value to undefined
age = undefined;

alert(age); // "undefined"
        
      
      
      …But we don’t recommend doing that. Normally, one uses null to assign an “empty” or “unknown” value to a variable, while undefined is reserved as a default initial value for unassigned things.
Objects and SymbolsThe object type is special.
All other types are called “primitive” because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.
Being that important, objects deserve a special treatment. We’ll deal with them later in the chapter Objects, after we learn more about primitives.
The symbol type is used to create unique identifiers for objects. We have to mention it here for the sake of completeness, but also postpone the details till we know objects.
The typeof operatorThe typeof operator returns the type of the operand. It’s useful when we want to process values of different types differently or just want to do a quick check.
A call to typeof x returns a string with the type name:

      
        
        
          typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
        
      
      
      The last three lines may need additional explanation:

Math is a built-in object that provides mathematical operations. We will learn it in the chapter Numbers. Here, it serves just as an example of an object.
The result of typeof null is "object". That’s an officially recognized error in typeof, coming from very early days of JavaScript and kept for compatibility. Definitely, null is not an object. It is a special value with a separate type of its own. The behavior of typeof is wrong here.
The result of typeof alert is "function", because alert is a function. We’ll study functions in the next chapters where we’ll also see that there’s no special “function” type in JavaScript. Functions belong to the object type. But typeof treats them differently, returning "function". That also comes from the early days of JavaScript. Technically, such behavior isn’t correct, but can be convenient in practice.


            The typeof(x) syntax
            You may also come across another syntax: typeof(x). It’s the same as typeof x.
To put it clear: typeof is an operator, not a function. The parentheses here aren’t a part of typeof. It’s the kind of parentheses used for mathematical grouping.
Usually, such parentheses contain a mathematical expression, such as (2 + 2), but here they contain only one argument (x). Syntactically, they allow to avoid a space between the typeof operator and its argument, and some people like it.
Some people prefer typeof(x), although the typeof x syntax is much more common.

SummaryThere are 8 basic data types in JavaScript.

Seven primitive data types:

number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.


And one non-primitive data type:

object for more complex data structures.



The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.

In the next chapters, we’ll concentrate on primitive values and once we’re familiar with them, we’ll move on to objects.
TasksString quotesimportance: 5What is the output of the script?

      
        
        
          let name = "Ilya";

alert( `hello ${1}` ); // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?
        
      
      
      solutionBackticks embed the expression inside ${...} into the string.

      
        
        
          
            
          
          
            
          
        
        
          let name = "Ilya";

// the expression is a number 1
alert( `hello ${1}` ); // hello 1

// the expression is a string "name"
alert( `hello ${"name"}` ); // hello name

// the expression is a variable, embed it
alert( `hello ${name}` ); // hello Ilya
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nA value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. Here, we’ll cover them in general and in the next chapters we’ll talk about each of them in detail.
We can put any type in a variable. For example, a variable can at one moment be a string and then store a number:

      
        
        
          // no error
let message = "hello";
message = 123456;
        
      
      
      Programming languages that allow such things, such as JavaScript, are called “dynamically typed”, meaning that there exist data types, but variables are not bound to any of them.
Number
      
        
        
          let n = 123;
n = 12.345;
        
      
      
      The number type represents both integer and floating point numbers.
There are many operations for numbers, e.g. multiplication *, division /, addition +, subtraction -, and so on.
Besides regular numbers, there are so-called “special numeric values” which also belong to this data type: Infinity, -Infinity and NaN.


Infinity represents the mathematical Infinity ∞. It is a special value that’s greater than any number.
We can get it as a result of division by zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 / 0 ); // Infinity
        
      
      
      Or just reference it directly:

      
        
        
          
            
          
          
            
          
        
        
          alert( Infinity ); // Infinity
        
      
      
      

NaN represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( "not a number" / 2 ); // NaN, such division is erroneous
        
      
      
      NaN is sticky. Any further mathematical operation on NaN returns NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "not a number" / 2 - 1 ); // NaN
        
      
      
      So, if there’s a NaN somewhere in a mathematical expression, it propagates to the whole result (there’s only one exception to that: NaN ** 0 is 1).



            Mathematical operations are safe
            Doing maths is “safe” in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc.
The script will never stop with a fatal error (“die”). At worst, we’ll get NaN as the result.

Special numeric values formally belong to the “number” type. Of course they are not numbers in the common sense of this word.
We’ll see more about working with numbers in the chapter Numbers.
BigIntIn JavaScript, the “number” type cannot safely represent integer values larger than (253-1) (that’s 9007199254740991), or less than -(253-1) for negatives.
To be really precise, the “number” type can store larger integers (up to 1.7976931348623157 * 10308), but outside of the safe integer range ±(253-1) there’ll be a precision error, because not all digits fit into the fixed 64-bit storage. So an “approximate” value may be stored.
For example, these two numbers (right above the safe range) are the same:

      
        
        
          console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
        
      
      
      So to say, all odd integers greater than (253-1) can’t be stored at all in the “number” type.
For most purposes ±(253-1) range is quite enough, but sometimes we need the entire range of really big integers, e.g. for cryptography or microsecond-precision timestamps.
BigInt type was recently added to the language to represent integers of arbitrary length.
A BigInt value is created by appending n to the end of an integer:

      
        
        
          // the "n" at the end means it's a BigInt
const bigInt = 1234567890123456789012345678901234567890n;
        
      
      
      As BigInt numbers are rarely needed, we don’t cover them here, but devoted them a separate chapter BigInt. Read it when you need such big numbers.
StringA string in JavaScript must be surrounded by quotes.

      
        
        
          let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
        
      
      
      In JavaScript, there are 3 types of quotes.

Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello`.

Double and single quotes are “simple” quotes. There’s practically no difference between them in JavaScript.
Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:

      
        
        
          
            
          
          
            
          
        
        
          let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
        
      
      
      The expression inside ${…} is evaluated and the result becomes a part of the string. We can put anything in there: a variable like name or an arithmetical expression like 1 + 2 or something more complex.
Please note that this can only be done in backticks. Other quotes don’t have this embedding functionality!

      
        
        
          
            
          
          
            
          
        
        
          alert( "the result is ${1 + 2}" ); // the result is ${1 + 2} (double quotes do nothing)
        
      
      
      We’ll cover strings more thoroughly in the chapter Strings.

            There is no character type.
            In some languages, there is a special “character” type for a single character. For example, in the C language and in Java it is called “char”.
In JavaScript, there is no such type. There’s only one type: string. A string may consist of zero characters (be empty), one character or many of them.

Boolean (logical type)The boolean type has only two values: true and false.
This type is commonly used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.
For instance:

      
        
        
          let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
        
      
      
      Boolean values also come as a result of comparisons:

      
        
        
          
            
          
          
            
          
        
        
          let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
        
      
      
      We’ll cover booleans more deeply in the chapter Logical operators.
The “null” valueThe special null value does not belong to any of the types described above.
It forms a separate type of its own which contains only the null value:

      
        
        
          let age = null;
        
      
      
      In JavaScript, null is not a “reference to a non-existing object” or a “null pointer” like in some other languages.
It’s just a special value which represents “nothing”, “empty” or “value unknown”.
The code above states that age is unknown.
The “undefined” valueThe special value undefined also stands apart. It makes a type of its own, just like null.
The meaning of undefined is “value is not assigned”.
If a variable is declared, but not assigned, then its value is undefined:

      
        
        
          
            
          
          
            
          
        
        
          let age;

alert(age); // shows "undefined"
        
      
      
      Technically, it is possible to explicitly assign undefined to a variable:

      
        
        
          
            
          
          
            
          
        
        
          let age = 100;

// change the value to undefined
age = undefined;

alert(age); // "undefined"
        
      
      
      …But we don’t recommend doing that. Normally, one uses null to assign an “empty” or “unknown” value to a variable, while undefined is reserved as a default initial value for unassigned things.
Objects and SymbolsThe object type is special.
All other types are called “primitive” because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.
Being that important, objects deserve a special treatment. We’ll deal with them later in the chapter Objects, after we learn more about primitives.
The symbol type is used to create unique identifiers for objects. We have to mention it here for the sake of completeness, but also postpone the details till we know objects.
The typeof operatorThe typeof operator returns the type of the operand. It’s useful when we want to process values of different types differently or just want to do a quick check.
A call to typeof x returns a string with the type name:

      
        
        
          typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
        
      
      
      The last three lines may need additional explanation:

Math is a built-in object that provides mathematical operations. We will learn it in the chapter Numbers. Here, it serves just as an example of an object.
The result of typeof null is "object". That’s an officially recognized error in typeof, coming from very early days of JavaScript and kept for compatibility. Definitely, null is not an object. It is a special value with a separate type of its own. The behavior of typeof is wrong here.
The result of typeof alert is "function", because alert is a function. We’ll study functions in the next chapters where we’ll also see that there’s no special “function” type in JavaScript. Functions belong to the object type. But typeof treats them differently, returning "function". That also comes from the early days of JavaScript. Technically, such behavior isn’t correct, but can be convenient in practice.


            The typeof(x) syntax
            You may also come across another syntax: typeof(x). It’s the same as typeof x.
To put it clear: typeof is an operator, not a function. The parentheses here aren’t a part of typeof. It’s the kind of parentheses used for mathematical grouping.
Usually, such parentheses contain a mathematical expression, such as (2 + 2), but here they contain only one argument (x). Syntactically, they allow to avoid a space between the typeof operator and its argument, and some people like it.
Some people prefer typeof(x), although the typeof x syntax is much more common.

SummaryThere are 8 basic data types in JavaScript.

Seven primitive data types:

number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.


And one non-primitive data type:

object for more complex data structures.



The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.

In the next chapters, we’ll concentrate on primitive values and once we’re familiar with them, we’ll move on to objects.
TasksString quotesimportance: 5What is the output of the script?

      
        
        
          let name = "Ilya";

alert( `hello ${1}` ); // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?
        
      
      
      solutionBackticks embed the expression inside ${...} into the string.

      
        
        
          
            
          
          
            
          
        
        
          let name = "Ilya";

// the expression is a number 1
alert( `hello ${1}` ); // hello 1

// the expression is a string "name"
alert( `hello ${"name"}` ); // hello name

// the expression is a variable, embed it
alert( `hello ${name}` ); // hello Ilya\n\nTutorialThe JavaScript languageJavaScript FundamentalsJuly 9, 2024Data typesA value in JavaScript is always of a certain type. For example, a string or a number.
There are eight basic data types in JavaScript. Here, we’ll cover them in general and in the next chapters we’ll talk about each of them in detail.
We can put any type in a variable. For example, a variable can at one moment be a string and then store a number:

      
        
        
          // no error
let message = "hello";
message = 123456;
        
      
      
      Programming languages that allow such things, such as JavaScript, are called “dynamically typed”, meaning that there exist data types, but variables are not bound to any of them.
Number
      
        
        
          let n = 123;
n = 12.345;
        
      
      
      The number type represents both integer and floating point numbers.
There are many operations for numbers, e.g. multiplication *, division /, addition +, subtraction -, and so on.
Besides regular numbers, there are so-called “special numeric values” which also belong to this data type: Infinity, -Infinity and NaN.


Infinity represents the mathematical Infinity ∞. It is a special value that’s greater than any number.
We can get it as a result of division by zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 / 0 ); // Infinity
        
      
      
      Or just reference it directly:

      
        
        
          
            
          
          
            
          
        
        
          alert( Infinity ); // Infinity
        
      
      
      

NaN represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( "not a number" / 2 ); // NaN, such division is erroneous
        
      
      
      NaN is sticky. Any further mathematical operation on NaN returns NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "not a number" / 2 - 1 ); // NaN
        
      
      
      So, if there’s a NaN somewhere in a mathematical expression, it propagates to the whole result (there’s only one exception to that: NaN ** 0 is 1).



            Mathematical operations are safe
            Doing maths is “safe” in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc.
The script will never stop with a fatal error (“die”). At worst, we’ll get NaN as the result.

Special numeric values formally belong to the “number” type. Of course they are not numbers in the common sense of this word.
We’ll see more about working with numbers in the chapter Numbers.
BigIntIn JavaScript, the “number” type cannot safely represent integer values larger than (253-1) (that’s 9007199254740991), or less than -(253-1) for negatives.
To be really precise, the “number” type can store larger integers (up to 1.7976931348623157 * 10308), but outside of the safe integer range ±(253-1) there’ll be a precision error, because not all digits fit into the fixed 64-bit storage. So an “approximate” value may be stored.
For example, these two numbers (right above the safe range) are the same:

      
        
        
          console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
        
      
      
      So to say, all odd integers greater than (253-1) can’t be stored at all in the “number” type.
For most purposes ±(253-1) range is quite enough, but sometimes we need the entire range of really big integers, e.g. for cryptography or microsecond-precision timestamps.
BigInt type was recently added to the language to represent integers of arbitrary length.
A BigInt value is created by appending n to the end of an integer:

      
        
        
          // the "n" at the end means it's a BigInt
const bigInt = 1234567890123456789012345678901234567890n;
        
      
      
      As BigInt numbers are rarely needed, we don’t cover them here, but devoted them a separate chapter BigInt. Read it when you need such big numbers.
StringA string in JavaScript must be surrounded by quotes.

      
        
        
          let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
        
      
      
      In JavaScript, there are 3 types of quotes.

Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello`.

Double and single quotes are “simple” quotes. There’s practically no difference between them in JavaScript.
Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:

      
        
        
          
            
          
          
            
          
        
        
          let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
        
      
      
      The expression inside ${…} is evaluated and the result becomes a part of the string. We can put anything in there: a variable like name or an arithmetical expression like 1 + 2 or something more complex.
Please note that this can only be done in backticks. Other quotes don’t have this embedding functionality!

      
        
        
          
            
          
          
            
          
        
        
          alert( "the result is ${1 + 2}" ); // the result is ${1 + 2} (double quotes do nothing)
        
      
      
      We’ll cover strings more thoroughly in the chapter Strings.

            There is no character type.
            In some languages, there is a special “character” type for a single character. For example, in the C language and in Java it is called “char”.
In JavaScript, there is no such type. There’s only one type: string. A string may consist of zero characters (be empty), one character or many of them.

Boolean (logical type)The boolean type has only two values: true and false.
This type is commonly used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.
For instance:

      
        
        
          let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
        
      
      
      Boolean values also come as a result of comparisons:

      
        
        
          
            
          
          
            
          
        
        
          let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
        
      
      
      We’ll cover booleans more deeply in the chapter Logical operators.
The “null” valueThe special null value does not belong to any of the types described above.
It forms a separate type of its own which contains only the null value:

      
        
        
          let age = null;
        
      
      
      In JavaScript, null is not a “reference to a non-existing object” or a “null pointer” like in some other languages.
It’s just a special value which represents “nothing”, “empty” or “value unknown”.
The code above states that age is unknown.
The “undefined” valueThe special value undefined also stands apart. It makes a type of its own, just like null.
The meaning of undefined is “value is not assigned”.
If a variable is declared, but not assigned, then its value is undefined:

      
        
        
          
            
          
          
            
          
        
        
          let age;

alert(age); // shows "undefined"
        
      
      
      Technically, it is possible to explicitly assign undefined to a variable:

      
        
        
          
            
          
          
            
          
        
        
          let age = 100;

// change the value to undefined
age = undefined;

alert(age); // "undefined"
        
      
      
      …But we don’t recommend doing that. Normally, one uses null to assign an “empty” or “unknown” value to a variable, while undefined is reserved as a default initial value for unassigned things.
Objects and SymbolsThe object type is special.
All other types are called “primitive” because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.
Being that important, objects deserve a special treatment. We’ll deal with them later in the chapter Objects, after we learn more about primitives.
The symbol type is used to create unique identifiers for objects. We have to mention it here for the sake of completeness, but also postpone the details till we know objects.
The typeof operatorThe typeof operator returns the type of the operand. It’s useful when we want to process values of different types differently or just want to do a quick check.
A call to typeof x returns a string with the type name:

      
        
        
          typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
        
      
      
      The last three lines may need additional explanation:

Math is a built-in object that provides mathematical operations. We will learn it in the chapter Numbers. Here, it serves just as an example of an object.
The result of typeof null is "object". That’s an officially recognized error in typeof, coming from very early days of JavaScript and kept for compatibility. Definitely, null is not an object. It is a special value with a separate type of its own. The behavior of typeof is wrong here.
The result of typeof alert is "function", because alert is a function. We’ll study functions in the next chapters where we’ll also see that there’s no special “function” type in JavaScript. Functions belong to the object type. But typeof treats them differently, returning "function". That also comes from the early days of JavaScript. Technically, such behavior isn’t correct, but can be convenient in practice.


            The typeof(x) syntax
            You may also come across another syntax: typeof(x). It’s the same as typeof x.
To put it clear: typeof is an operator, not a function. The parentheses here aren’t a part of typeof. It’s the kind of parentheses used for mathematical grouping.
Usually, such parentheses contain a mathematical expression, such as (2 + 2), but here they contain only one argument (x). Syntactically, they allow to avoid a space between the typeof operator and its argument, and some people like it.
Some people prefer typeof(x), although the typeof x syntax is much more common.

SummaryThere are 8 basic data types in JavaScript.

Seven primitive data types:

number for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).
bigint for integer numbers of arbitrary length.
string for strings. A string may have zero or more characters, there’s no separate single-character type.
boolean for true/false.
null for unknown values – a standalone type that has a single value null.
undefined for unassigned values – a standalone type that has a single value undefined.
symbol for unique identifiers.


And one non-primitive data type:

object for more complex data structures.



The typeof operator allows us to see which type is stored in a variable.

Usually used as typeof x, but typeof(x) is also possible.
Returns a string with the name of the type, like "string".
For null returns "object" – this is an error in the language, it’s not actually an object.

In the next chapters, we’ll concentrate on primitive values and once we’re familiar with them, we’ll move on to objects.
TasksString quotesimportance: 5What is the output of the script?

      
        
        
          let name = "Ilya";

alert( `hello ${1}` ); // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?
        
      
      
      solutionBackticks embed the expression inside ${...} into the string.

      
        
        
          
            
          
          
            
          
        
        
          let name = "Ilya";

// the expression is a number 1
alert( `hello ${1}` ); // hello 1

// the expression is a string "name"
alert( `hello ${"name"}` ); // hello name

// the expression is a variable, embed it
alert( `hello ${name}` ); // hello Ilya
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nAs we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.
alertThis one we’ve seen already. It shows a message and waits for the user to press “OK”.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");
        
      
      
      The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.
promptThe function prompt accepts two arguments:

      
        
        
          result = prompt(title, [default]);
        
      
      
      It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

title
The text to show the visitor.
default
An optional second parameter, the initial value for the input field.


            The square brackets in syntax [...]
            The square brackets around default in the syntax above denote that the parameter is optional, not required.

The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.
The call to prompt returns the text from the input field or null if the input was canceled.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('How old are you?', 100);

alert(`You are ${age} years old!`); // You are 100 years old!
        
      
      
      
            In IE: always supply a default
            The second parameter is optional, but if we don’t supply it, Internet Explorer will insert the text "undefined" into the prompt.
Run this code in Internet Explorer to see:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test");
        
      
      
      So, for prompts to look good in IE, we recommend always providing the second argument:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test", ''); // <-- for IE
        
      
      
      
confirmThe syntax:

      
        
        
          result = confirm(question);
        
      
      
      The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let isBoss = confirm("Are you the boss?");

alert( isBoss ); // true if OK is pressed
        
      
      
      SummaryWe covered 3 browser-specific functions to interact with visitors:

alert
shows a message.
prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.
confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.
There are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

That is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.\n\nTutorialThe JavaScript languageJavaScript FundamentalsSeptember 8, 2020Interaction: alert, prompt, confirmAs we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.
alertThis one we’ve seen already. It shows a message and waits for the user to press “OK”.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");
        
      
      
      The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.
promptThe function prompt accepts two arguments:

      
        
        
          result = prompt(title, [default]);
        
      
      
      It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

title
The text to show the visitor.
default
An optional second parameter, the initial value for the input field.


            The square brackets in syntax [...]
            The square brackets around default in the syntax above denote that the parameter is optional, not required.

The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.
The call to prompt returns the text from the input field or null if the input was canceled.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('How old are you?', 100);

alert(`You are ${age} years old!`); // You are 100 years old!
        
      
      
      
            In IE: always supply a default
            The second parameter is optional, but if we don’t supply it, Internet Explorer will insert the text "undefined" into the prompt.
Run this code in Internet Explorer to see:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test");
        
      
      
      So, for prompts to look good in IE, we recommend always providing the second argument:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test", ''); // <-- for IE
        
      
      
      
confirmThe syntax:

      
        
        
          result = confirm(question);
        
      
      
      The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let isBoss = confirm("Are you the boss?");

alert( isBoss ); // true if OK is pressed
        
      
      
      SummaryWe covered 3 browser-specific functions to interact with visitors:

alert
shows a message.
prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.
confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.
There are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

That is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.
TasksA simple pageimportance: 4Create a web-page that asks for a name and outputs it.
Run the demosolutionJavaScript-code:

      
        
        
          
            
          
          
            
          
        
        
          let name = prompt("What is your name?", "");
alert(name);
        
      
      
      The full page:

      
        
        
          <!DOCTYPE html>
<html>
<body>

  <script>
    'use strict';

    let name = prompt("What is your name?", "");
    alert(name);
  </script>

</body>
</html>
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nAs we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.
alertThis one we’ve seen already. It shows a message and waits for the user to press “OK”.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");
        
      
      
      The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.
promptThe function prompt accepts two arguments:

      
        
        
          result = prompt(title, [default]);
        
      
      
      It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

title
The text to show the visitor.
default
An optional second parameter, the initial value for the input field.


            The square brackets in syntax [...]
            The square brackets around default in the syntax above denote that the parameter is optional, not required.

The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.
The call to prompt returns the text from the input field or null if the input was canceled.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('How old are you?', 100);

alert(`You are ${age} years old!`); // You are 100 years old!
        
      
      
      
            In IE: always supply a default
            The second parameter is optional, but if we don’t supply it, Internet Explorer will insert the text "undefined" into the prompt.
Run this code in Internet Explorer to see:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test");
        
      
      
      So, for prompts to look good in IE, we recommend always providing the second argument:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test", ''); // <-- for IE
        
      
      
      
confirmThe syntax:

      
        
        
          result = confirm(question);
        
      
      
      The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let isBoss = confirm("Are you the boss?");

alert( isBoss ); // true if OK is pressed
        
      
      
      SummaryWe covered 3 browser-specific functions to interact with visitors:

alert
shows a message.
prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.
confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.
There are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

That is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.
TasksA simple pageimportance: 4Create a web-page that asks for a name and outputs it.
Run the demosolutionJavaScript-code:

      
        
        
          
            
          
          
            
          
        
        
          let name = prompt("What is your name?", "");
alert(name);
        
      
      
      The full page:

      
        
        
          <!DOCTYPE html>
<html>
<body>

  <script>
    'use strict';

    let name = prompt("What is your name?", "");
    alert(name);
  </script>

</body>
</html>\n\nTutorialThe JavaScript languageJavaScript FundamentalsSeptember 8, 2020Interaction: alert, prompt, confirmAs we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.
alertThis one we’ve seen already. It shows a message and waits for the user to press “OK”.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");
        
      
      
      The mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.
promptThe function prompt accepts two arguments:

      
        
        
          result = prompt(title, [default]);
        
      
      
      It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.

title
The text to show the visitor.
default
An optional second parameter, the initial value for the input field.


            The square brackets in syntax [...]
            The square brackets around default in the syntax above denote that the parameter is optional, not required.

The visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.
The call to prompt returns the text from the input field or null if the input was canceled.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('How old are you?', 100);

alert(`You are ${age} years old!`); // You are 100 years old!
        
      
      
      
            In IE: always supply a default
            The second parameter is optional, but if we don’t supply it, Internet Explorer will insert the text "undefined" into the prompt.
Run this code in Internet Explorer to see:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test");
        
      
      
      So, for prompts to look good in IE, we recommend always providing the second argument:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test", ''); // <-- for IE
        
      
      
      
confirmThe syntax:

      
        
        
          result = confirm(question);
        
      
      
      The function confirm shows a modal window with a question and two buttons: OK and Cancel.
The result is true if OK is pressed and false otherwise.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let isBoss = confirm("Are you the boss?");

alert( isBoss ); // true if OK is pressed
        
      
      
      SummaryWe covered 3 browser-specific functions to interact with visitors:

alert
shows a message.
prompt
shows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.
confirm
shows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.

All these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.
There are two limitations shared by all the methods above:

The exact location of the modal window is determined by the browser. Usually, it’s in the center.
The exact look of the window also depends on the browser. We can’t modify it.

That is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.
TasksA simple pageimportance: 4Create a web-page that asks for a name and outputs it.
Run the demosolutionJavaScript-code:

      
        
        
          
            
          
          
            
          
        
        
          let name = prompt("What is your name?", "");
alert(name);
        
      
      
      The full page:

      
        
        
          <!DOCTYPE html>
<html>
<body>

  <script>
    'use strict';

    let name = prompt("What is your name?", "");
    alert(name);
  </script>

</body>
</html>
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nMost of the time, operators and functions automatically convert the values given to them to the right type.
For example, alert automatically converts any value to a string to show it. Mathematical operations convert values to numbers.
There are also cases when we need to explicitly convert a value to the expected type.

            Not talking about objects yet
            In this chapter, we won’t cover objects. For now, we’ll just be talking about primitives.
Later, after we learn about objects, in the chapter Object to primitive conversion we’ll see how objects fit in.

String ConversionString conversion happens when we need the string form of a value.
For example, alert(value) does it to show the value.
We can also call the String(value) function to convert a value to a string:

      
        
        
          
            
          
          
            
          
        
        
          let value = true;
alert(typeof value); // boolean

value = String(value); // now value is a string "true"
alert(typeof value); // string
        
      
      
      String conversion is mostly obvious. A false becomes "false", null becomes "null", etc.
Numeric ConversionNumeric conversion in mathematical functions and expressions happens automatically.
For example, when division / is applied to non-numbers:

      
        
        
          
            
          
          
            
          
        
        
          alert( "6" / "2" ); // 3, strings are converted to numbers
        
      
      
      We can use the Number(value) function to explicitly convert a value to a number:

      
        
        
          
            
          
          
            
          
        
        
          let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
        
      
      
      Explicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered.
If the string is not a valid number, the result of such a conversion is NaN. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
        
      
      
      Numeric conversion rules:



Value
Becomes…




undefined
NaN


null
0


true and false
1 and 0


string
Whitespaces (includes spaces, tabs \t, newlines \n etc.) from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is “read” from the string. An error gives NaN.



Examples:

      
        
        
          
            
          
          
            
          
        
        
          alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
        
      
      
      Please note that null and undefined behave differently here: null becomes zero while undefined becomes NaN.
Most mathematical operators also perform such conversion, we’ll see that in the next chapter.
Boolean ConversionBoolean conversion is the simplest one.
It happens in logical operations (later we’ll meet condition tests and other similar things) but can also be performed explicitly with a call to Boolean(value).
The conversion rule:

Values that are intuitively “empty”, like 0, an empty string, null, undefined, and NaN, become false.
Other values become true.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
        
      
      
      
            Please note: the string with zero "0" is true
            Some languages (namely PHP) treat "0" as false. But in JavaScript, a non-empty string is always true.

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
        
      
      
      
SummaryThe three most widely used type conversions are to string, to number, and to boolean.
String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
Numeric Conversion – Occurs in math operations. Can be performed with Number(value).
The conversion follows the rules:



Value
Becomes…




undefined
NaN


null
0


true / false
1 / 0


string
The string is read “as is”, whitespaces (includes spaces, tabs \t, newlines \n etc.) from both sides are ignored. An empty string becomes 0. An error gives NaN.



Boolean Conversion – Occurs in logical operations. Can be performed with Boolean(value).
Follows the rules:



Value
Becomes…




0, null, undefined, NaN, ""
false


any other value
true



Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:

undefined is NaN as a number, not 0.
"0" and space-only strings like "   " are true as a boolean.

Objects aren’t covered here. We’ll return to them later in the chapter Object to primitive conversion that is devoted exclusively to objects after we learn more basic things about JavaScript.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJanuary 24, 2023Type ConversionsMost of the time, operators and functions automatically convert the values given to them to the right type.
For example, alert automatically converts any value to a string to show it. Mathematical operations convert values to numbers.
There are also cases when we need to explicitly convert a value to the expected type.

            Not talking about objects yet
            In this chapter, we won’t cover objects. For now, we’ll just be talking about primitives.
Later, after we learn about objects, in the chapter Object to primitive conversion we’ll see how objects fit in.

String ConversionString conversion happens when we need the string form of a value.
For example, alert(value) does it to show the value.
We can also call the String(value) function to convert a value to a string:

      
        
        
          
            
          
          
            
          
        
        
          let value = true;
alert(typeof value); // boolean

value = String(value); // now value is a string "true"
alert(typeof value); // string
        
      
      
      String conversion is mostly obvious. A false becomes "false", null becomes "null", etc.
Numeric ConversionNumeric conversion in mathematical functions and expressions happens automatically.
For example, when division / is applied to non-numbers:

      
        
        
          
            
          
          
            
          
        
        
          alert( "6" / "2" ); // 3, strings are converted to numbers
        
      
      
      We can use the Number(value) function to explicitly convert a value to a number:

      
        
        
          
            
          
          
            
          
        
        
          let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
        
      
      
      Explicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered.
If the string is not a valid number, the result of such a conversion is NaN. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
        
      
      
      Numeric conversion rules:



Value
Becomes…




undefined
NaN


null
0


true and false
1 and 0


string
Whitespaces (includes spaces, tabs \t, newlines \n etc.) from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is “read” from the string. An error gives NaN.



Examples:

      
        
        
          
            
          
          
            
          
        
        
          alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
        
      
      
      Please note that null and undefined behave differently here: null becomes zero while undefined becomes NaN.
Most mathematical operators also perform such conversion, we’ll see that in the next chapter.
Boolean ConversionBoolean conversion is the simplest one.
It happens in logical operations (later we’ll meet condition tests and other similar things) but can also be performed explicitly with a call to Boolean(value).
The conversion rule:

Values that are intuitively “empty”, like 0, an empty string, null, undefined, and NaN, become false.
Other values become true.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
        
      
      
      
            Please note: the string with zero "0" is true
            Some languages (namely PHP) treat "0" as false. But in JavaScript, a non-empty string is always true.

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
        
      
      
      
SummaryThe three most widely used type conversions are to string, to number, and to boolean.
String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
Numeric Conversion – Occurs in math operations. Can be performed with Number(value).
The conversion follows the rules:



Value
Becomes…




undefined
NaN


null
0


true / false
1 / 0


string
The string is read “as is”, whitespaces (includes spaces, tabs \t, newlines \n etc.) from both sides are ignored. An empty string becomes 0. An error gives NaN.



Boolean Conversion – Occurs in logical operations. Can be performed with Boolean(value).
Follows the rules:



Value
Becomes…




0, null, undefined, NaN, ""
false


any other value
true



Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:

undefined is NaN as a number, not 0.
"0" and space-only strings like "   " are true as a boolean.

Objects aren’t covered here. We’ll return to them later in the chapter Object to primitive conversion that is devoted exclusively to objects after we learn more basic things about JavaScript.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nMost of the time, operators and functions automatically convert the values given to them to the right type.
For example, alert automatically converts any value to a string to show it. Mathematical operations convert values to numbers.
There are also cases when we need to explicitly convert a value to the expected type.

            Not talking about objects yet
            In this chapter, we won’t cover objects. For now, we’ll just be talking about primitives.
Later, after we learn about objects, in the chapter Object to primitive conversion we’ll see how objects fit in.

String ConversionString conversion happens when we need the string form of a value.
For example, alert(value) does it to show the value.
We can also call the String(value) function to convert a value to a string:

      
        
        
          
            
          
          
            
          
        
        
          let value = true;
alert(typeof value); // boolean

value = String(value); // now value is a string "true"
alert(typeof value); // string
        
      
      
      String conversion is mostly obvious. A false becomes "false", null becomes "null", etc.
Numeric ConversionNumeric conversion in mathematical functions and expressions happens automatically.
For example, when division / is applied to non-numbers:

      
        
        
          
            
          
          
            
          
        
        
          alert( "6" / "2" ); // 3, strings are converted to numbers
        
      
      
      We can use the Number(value) function to explicitly convert a value to a number:

      
        
        
          
            
          
          
            
          
        
        
          let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
        
      
      
      Explicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered.
If the string is not a valid number, the result of such a conversion is NaN. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
        
      
      
      Numeric conversion rules:



Value
Becomes…




undefined
NaN


null
0


true and false
1 and 0


string
Whitespaces (includes spaces, tabs \t, newlines \n etc.) from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is “read” from the string. An error gives NaN.



Examples:

      
        
        
          
            
          
          
            
          
        
        
          alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
        
      
      
      Please note that null and undefined behave differently here: null becomes zero while undefined becomes NaN.
Most mathematical operators also perform such conversion, we’ll see that in the next chapter.
Boolean ConversionBoolean conversion is the simplest one.
It happens in logical operations (later we’ll meet condition tests and other similar things) but can also be performed explicitly with a call to Boolean(value).
The conversion rule:

Values that are intuitively “empty”, like 0, an empty string, null, undefined, and NaN, become false.
Other values become true.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
        
      
      
      
            Please note: the string with zero "0" is true
            Some languages (namely PHP) treat "0" as false. But in JavaScript, a non-empty string is always true.

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
        
      
      
      
SummaryThe three most widely used type conversions are to string, to number, and to boolean.
String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
Numeric Conversion – Occurs in math operations. Can be performed with Number(value).
The conversion follows the rules:



Value
Becomes…




undefined
NaN


null
0


true / false
1 / 0


string
The string is read “as is”, whitespaces (includes spaces, tabs \t, newlines \n etc.) from both sides are ignored. An empty string becomes 0. An error gives NaN.



Boolean Conversion – Occurs in logical operations. Can be performed with Boolean(value).
Follows the rules:



Value
Becomes…




0, null, undefined, NaN, ""
false


any other value
true



Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:

undefined is NaN as a number, not 0.
"0" and space-only strings like "   " are true as a boolean.

Objects aren’t covered here. We’ll return to them later in the chapter Object to primitive conversion that is devoted exclusively to objects after we learn more basic things about JavaScript.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJanuary 24, 2023Type ConversionsMost of the time, operators and functions automatically convert the values given to them to the right type.
For example, alert automatically converts any value to a string to show it. Mathematical operations convert values to numbers.
There are also cases when we need to explicitly convert a value to the expected type.

            Not talking about objects yet
            In this chapter, we won’t cover objects. For now, we’ll just be talking about primitives.
Later, after we learn about objects, in the chapter Object to primitive conversion we’ll see how objects fit in.

String ConversionString conversion happens when we need the string form of a value.
For example, alert(value) does it to show the value.
We can also call the String(value) function to convert a value to a string:

      
        
        
          
            
          
          
            
          
        
        
          let value = true;
alert(typeof value); // boolean

value = String(value); // now value is a string "true"
alert(typeof value); // string
        
      
      
      String conversion is mostly obvious. A false becomes "false", null becomes "null", etc.
Numeric ConversionNumeric conversion in mathematical functions and expressions happens automatically.
For example, when division / is applied to non-numbers:

      
        
        
          
            
          
          
            
          
        
        
          alert( "6" / "2" ); // 3, strings are converted to numbers
        
      
      
      We can use the Number(value) function to explicitly convert a value to a number:

      
        
        
          
            
          
          
            
          
        
        
          let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
        
      
      
      Explicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered.
If the string is not a valid number, the result of such a conversion is NaN. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
        
      
      
      Numeric conversion rules:



Value
Becomes…




undefined
NaN


null
0


true and false
1 and 0


string
Whitespaces (includes spaces, tabs \t, newlines \n etc.) from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is “read” from the string. An error gives NaN.



Examples:

      
        
        
          
            
          
          
            
          
        
        
          alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
        
      
      
      Please note that null and undefined behave differently here: null becomes zero while undefined becomes NaN.
Most mathematical operators also perform such conversion, we’ll see that in the next chapter.
Boolean ConversionBoolean conversion is the simplest one.
It happens in logical operations (later we’ll meet condition tests and other similar things) but can also be performed explicitly with a call to Boolean(value).
The conversion rule:

Values that are intuitively “empty”, like 0, an empty string, null, undefined, and NaN, become false.
Other values become true.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
        
      
      
      
            Please note: the string with zero "0" is true
            Some languages (namely PHP) treat "0" as false. But in JavaScript, a non-empty string is always true.

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
        
      
      
      
SummaryThe three most widely used type conversions are to string, to number, and to boolean.
String Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.
Numeric Conversion – Occurs in math operations. Can be performed with Number(value).
The conversion follows the rules:



Value
Becomes…




undefined
NaN


null
0


true / false
1 / 0


string
The string is read “as is”, whitespaces (includes spaces, tabs \t, newlines \n etc.) from both sides are ignored. An empty string becomes 0. An error gives NaN.



Boolean Conversion – Occurs in logical operations. Can be performed with Boolean(value).
Follows the rules:



Value
Becomes…




0, null, undefined, NaN, ""
false


any other value
true



Most of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:

undefined is NaN as a number, not 0.
"0" and space-only strings like "   " are true as a boolean.

Objects aren’t covered here. We’ll return to them later in the chapter Object to primitive conversion that is devoted exclusively to objects after we learn more basic things about JavaScript.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nWe know many operators from school. They are things like addition +, multiplication *, subtraction -, and so on.
In this chapter, we’ll start with simple operators, then concentrate on JavaScript-specific aspects, not covered by school arithmetic.
Terms: “unary”, “binary”, “operand”Before we move on, let’s grasp some common terminology.


An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.


An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
        
      
      
      

An operator is binary if it has two operands. The same minus exists in binary form as well:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
        
      
      
      Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.


MathsThe following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **.

The first four are straightforward, while % and ** need a few words about them.
Remainder %The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 5 % 2 ); // 1, the remainder of 5 divided by 2
alert( 8 % 3 ); // 2, the remainder of 8 divided by 3
alert( 8 % 4 ); // 0, the remainder of 8 divided by 4
        
      
      
      Exponentiation **The exponentiation operator a ** b raises a to the power of b.
In school maths, we write that as ab.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
        
      
      
      Just like in maths, the exponentiation operator is defined for non-integer numbers as well.
For example, a square root is an exponentiation by ½:

      
        
        
          
            
          
          
            
          
        
        
          alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)
        
      
      
      String concatenation with binary +Let’s meet the features of JavaScript operators that are beyond school arithmetics.
Usually, the plus operator + sums numbers.
But, if the binary + is applied to strings, it merges (concatenates) them:

      
        
        
          let s = "my" + "string";
alert(s); // mystring
        
      
      
      Note that if any of the operands is a string, then the other one is converted to a string too.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
        
      
      
      See, it doesn’t matter whether the first operand is a string or the second one.
Here’s a more complex example:

      
        
        
          
            
          
          
            
          
        
        
          alert(2 + 2 + '1' ); // "41" and not "221"
        
      
      
      Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.

      
        
        
          
            
          
          
            
          
        
        
          alert('1' + 2 + 2); // "122" and not "14"
        
      
      
      Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.
Here’s the demo for subtraction and division:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers
        
      
      
      Numeric conversion, unary +The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
For example:

      
        
        
          
            
          
          
            
          
        
        
          // No effect on numbers
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0
        
      
      
      It actually does the same thing as Number(...), but is shorter.
The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?
The binary plus would add them as strings:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", the binary plus concatenates strings
        
      
      
      If we want to treat them as numbers, we need to convert and then sum them:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5

// the longer variant
// alert( Number(apples) + Number(oranges) ); // 5
        
      
      
      From a mathematician’s standpoint, the abundance of pluses may seem strange. But from a programmer’s standpoint, there’s nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.
Why are unary pluses applied to values before the binary ones? As we’re going to see, that’s because of their higher precedence.
Operator precedenceIf an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
From school, we all know that the multiplication in the expression 1 + 2 * 2 should be calculated before the addition. That’s exactly the precedence thing. The multiplication is said to have a higher precedence than the addition.
Parentheses override any precedence, so if we’re not satisfied with the default order, we can use them to change it. For example, write (1 + 2) * 2.
There are many operators in JavaScript. Every operator has a corresponding precedence number. The one with the larger number executes first. If the precedence is the same, the execution order is from left to right.
Here’s an extract from the precedence table (you don’t need to remember this, but note that unary operators are higher than corresponding binary ones):



Precedence
Name
Sign




…
…
…


14
unary plus
+


14
unary negation
-


13
exponentiation
**


12
multiplication
*


12
division
/


11
addition
+


11
subtraction
-


…
…
…


2
assignment
=


…
…
…



As we can see, the “unary plus” has a priority of 14 which is higher than the 11 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.
AssignmentLet’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.

      
        
        
          let x = 2 * 2 + 1;

alert( x ); // 5
        
      
      
      Assignment = returns a valueThe fact of = being an operator, not a “magical” language construct has an interesting implication.
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.
Here’s a demo that uses an assignment as part of a more complex expression:

      
        
        
          
            
          
          
            
          
        
        
          let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
        
      
      
      In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3). It is then used for further evaluations.
Funny code, isn’t it? We should understand how it works, because sometimes we see it in JavaScript libraries.
Although, please don’t write the code like that. Such tricks definitely don’t make code clearer or readable.
Chaining assignmentsAnother interesting feature is the ability to chain assignments:

      
        
        
          
            
          
          
            
          
        
        
          let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
        
      
      
      Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.
Once again, for the purposes of readability it’s better to split such code into few lines:

      
        
        
          c = 2 + 2;
b = c;
a = c;
        
      
      
      That’s easier to read, especially when eye-scanning the code fast.
Modify-in-placeWe often need to apply an operator to a variable and store the new result in that same variable.
For example:

      
        
        
          let n = 2;
n = n + 5;
n = n * 2;
        
      
      
      This notation can be shortened using the operators += and *=:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14
        
      
      
      Short “modify-and-assign” operators exist for all arithmetical and bitwise operators: /=, -=, etc.
Such operators have the same precedence as a normal assignment, so they run after most other calculations:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;

n *= 3 + 5; // right part evaluated first, same as n *= 8

alert( n ); // 16
        
      
      
      Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:


Increment ++ increases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3
        
      
      
      

Decrement -- decreases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1
        
      
      
      


            Important:
            Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.

The operators ++ and -- can be placed either before or after a variable.

When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.

Both of these statements do the same thing: increase counter by 1.
Is there any difference? Yes, but we can only see it if we use the returned value of ++/--.
Let’s clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).
To see the difference, here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
        
      
      
      In the line (*), the prefix form ++counter increments counter and returns the new value, 2. So, the alert shows 2.
Now, let’s use the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = counter++; // (*) changed ++counter to counter++

alert(a); // 1
        
      
      
      In the line (*), the postfix form counter++ also increments counter but returns the old value (prior to increment). So, the alert shows 1.
To summarize:


If the result of increment/decrement is not used, there is no difference in which form to use:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
counter++;
++counter;
alert( counter ); // 2, the lines above did the same
        
      
      
      

If we’d like to increase a value and immediately use the result of the operator, we need the prefix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( ++counter ); // 1
        
      
      
      

If we’d like to increment a value but use its previous value, we need the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( counter++ ); // 0
        
      
      
      


            Increment/decrement among other operators
            The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * ++counter ); // 4
        
      
      
      Compare with:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value
        
      
      
      Though technically okay, such notation usually makes code less readable. One line does multiple things – not good.
While reading code, a fast “vertical” eye-scan can easily miss something like counter++ and it won’t be obvious that the variable increased.
We advise a style of “one line – one action”:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter );
counter++;
        
      
      
      
Bitwise operatorsBitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.
The list of operators:

AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won’t need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the Bitwise Operators chapter on MDN when a need arises.
CommaThe comma operator , is one of the rarest and most unusual operators. Sometimes, it’s used to write shorter code, so we need to know it in order to understand what’s going on.
The comma operator allows us to evaluate several expressions, dividing them with a comma ,. Each of them is evaluated but only the result of the last one is returned.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = (1 + 2, 3 + 4);

alert( a ); // 7 (the result of 3 + 4)
        
      
      
      Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

            Comma has a very low precedence
            Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.

Why do we need an operator that throws away everything except the last expression?
Sometimes, people use it in more complex constructs to put several actions in one line.
For example:

      
        
        
          // three operations in one line
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
        
      
      
      Such tricks are used in many JavaScript frameworks. That’s why we’re mentioning them. But usually they don’t improve code readability so we should think well before using them.\n\nTutorialThe JavaScript languageJavaScript FundamentalsNovember 14, 2022Basic operators, mathsWe know many operators from school. They are things like addition +, multiplication *, subtraction -, and so on.
In this chapter, we’ll start with simple operators, then concentrate on JavaScript-specific aspects, not covered by school arithmetic.
Terms: “unary”, “binary”, “operand”Before we move on, let’s grasp some common terminology.


An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.


An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
        
      
      
      

An operator is binary if it has two operands. The same minus exists in binary form as well:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
        
      
      
      Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.


MathsThe following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **.

The first four are straightforward, while % and ** need a few words about them.
Remainder %The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 5 % 2 ); // 1, the remainder of 5 divided by 2
alert( 8 % 3 ); // 2, the remainder of 8 divided by 3
alert( 8 % 4 ); // 0, the remainder of 8 divided by 4
        
      
      
      Exponentiation **The exponentiation operator a ** b raises a to the power of b.
In school maths, we write that as ab.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
        
      
      
      Just like in maths, the exponentiation operator is defined for non-integer numbers as well.
For example, a square root is an exponentiation by ½:

      
        
        
          
            
          
          
            
          
        
        
          alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)
        
      
      
      String concatenation with binary +Let’s meet the features of JavaScript operators that are beyond school arithmetics.
Usually, the plus operator + sums numbers.
But, if the binary + is applied to strings, it merges (concatenates) them:

      
        
        
          let s = "my" + "string";
alert(s); // mystring
        
      
      
      Note that if any of the operands is a string, then the other one is converted to a string too.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
        
      
      
      See, it doesn’t matter whether the first operand is a string or the second one.
Here’s a more complex example:

      
        
        
          
            
          
          
            
          
        
        
          alert(2 + 2 + '1' ); // "41" and not "221"
        
      
      
      Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.

      
        
        
          
            
          
          
            
          
        
        
          alert('1' + 2 + 2); // "122" and not "14"
        
      
      
      Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.
Here’s the demo for subtraction and division:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers
        
      
      
      Numeric conversion, unary +The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
For example:

      
        
        
          
            
          
          
            
          
        
        
          // No effect on numbers
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0
        
      
      
      It actually does the same thing as Number(...), but is shorter.
The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?
The binary plus would add them as strings:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", the binary plus concatenates strings
        
      
      
      If we want to treat them as numbers, we need to convert and then sum them:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5

// the longer variant
// alert( Number(apples) + Number(oranges) ); // 5
        
      
      
      From a mathematician’s standpoint, the abundance of pluses may seem strange. But from a programmer’s standpoint, there’s nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.
Why are unary pluses applied to values before the binary ones? As we’re going to see, that’s because of their higher precedence.
Operator precedenceIf an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
From school, we all know that the multiplication in the expression 1 + 2 * 2 should be calculated before the addition. That’s exactly the precedence thing. The multiplication is said to have a higher precedence than the addition.
Parentheses override any precedence, so if we’re not satisfied with the default order, we can use them to change it. For example, write (1 + 2) * 2.
There are many operators in JavaScript. Every operator has a corresponding precedence number. The one with the larger number executes first. If the precedence is the same, the execution order is from left to right.
Here’s an extract from the precedence table (you don’t need to remember this, but note that unary operators are higher than corresponding binary ones):



Precedence
Name
Sign




…
…
…


14
unary plus
+


14
unary negation
-


13
exponentiation
**


12
multiplication
*


12
division
/


11
addition
+


11
subtraction
-


…
…
…


2
assignment
=


…
…
…



As we can see, the “unary plus” has a priority of 14 which is higher than the 11 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.
AssignmentLet’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.

      
        
        
          let x = 2 * 2 + 1;

alert( x ); // 5
        
      
      
      Assignment = returns a valueThe fact of = being an operator, not a “magical” language construct has an interesting implication.
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.
Here’s a demo that uses an assignment as part of a more complex expression:

      
        
        
          
            
          
          
            
          
        
        
          let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
        
      
      
      In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3). It is then used for further evaluations.
Funny code, isn’t it? We should understand how it works, because sometimes we see it in JavaScript libraries.
Although, please don’t write the code like that. Such tricks definitely don’t make code clearer or readable.
Chaining assignmentsAnother interesting feature is the ability to chain assignments:

      
        
        
          
            
          
          
            
          
        
        
          let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
        
      
      
      Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.
Once again, for the purposes of readability it’s better to split such code into few lines:

      
        
        
          c = 2 + 2;
b = c;
a = c;
        
      
      
      That’s easier to read, especially when eye-scanning the code fast.
Modify-in-placeWe often need to apply an operator to a variable and store the new result in that same variable.
For example:

      
        
        
          let n = 2;
n = n + 5;
n = n * 2;
        
      
      
      This notation can be shortened using the operators += and *=:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14
        
      
      
      Short “modify-and-assign” operators exist for all arithmetical and bitwise operators: /=, -=, etc.
Such operators have the same precedence as a normal assignment, so they run after most other calculations:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;

n *= 3 + 5; // right part evaluated first, same as n *= 8

alert( n ); // 16
        
      
      
      Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:


Increment ++ increases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3
        
      
      
      

Decrement -- decreases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1
        
      
      
      


            Important:
            Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.

The operators ++ and -- can be placed either before or after a variable.

When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.

Both of these statements do the same thing: increase counter by 1.
Is there any difference? Yes, but we can only see it if we use the returned value of ++/--.
Let’s clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).
To see the difference, here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
        
      
      
      In the line (*), the prefix form ++counter increments counter and returns the new value, 2. So, the alert shows 2.
Now, let’s use the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = counter++; // (*) changed ++counter to counter++

alert(a); // 1
        
      
      
      In the line (*), the postfix form counter++ also increments counter but returns the old value (prior to increment). So, the alert shows 1.
To summarize:


If the result of increment/decrement is not used, there is no difference in which form to use:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
counter++;
++counter;
alert( counter ); // 2, the lines above did the same
        
      
      
      

If we’d like to increase a value and immediately use the result of the operator, we need the prefix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( ++counter ); // 1
        
      
      
      

If we’d like to increment a value but use its previous value, we need the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( counter++ ); // 0
        
      
      
      


            Increment/decrement among other operators
            The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * ++counter ); // 4
        
      
      
      Compare with:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value
        
      
      
      Though technically okay, such notation usually makes code less readable. One line does multiple things – not good.
While reading code, a fast “vertical” eye-scan can easily miss something like counter++ and it won’t be obvious that the variable increased.
We advise a style of “one line – one action”:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter );
counter++;
        
      
      
      
Bitwise operatorsBitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.
The list of operators:

AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won’t need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the Bitwise Operators chapter on MDN when a need arises.
CommaThe comma operator , is one of the rarest and most unusual operators. Sometimes, it’s used to write shorter code, so we need to know it in order to understand what’s going on.
The comma operator allows us to evaluate several expressions, dividing them with a comma ,. Each of them is evaluated but only the result of the last one is returned.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = (1 + 2, 3 + 4);

alert( a ); // 7 (the result of 3 + 4)
        
      
      
      Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

            Comma has a very low precedence
            Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.

Why do we need an operator that throws away everything except the last expression?
Sometimes, people use it in more complex constructs to put several actions in one line.
For example:

      
        
        
          // three operations in one line
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
        
      
      
      Such tricks are used in many JavaScript frameworks. That’s why we’re mentioning them. But usually they don’t improve code readability so we should think well before using them.
TasksThe postfix and prefix formsimportance: 5What are the final values of all variables a, b, c and d after the code below?

      
        
        
          let a = 1, b = 1;

let c = ++a; // ?
let d = b++; // ?
        
      
      
      solutionThe answer is:

a = 2
b = 2
c = 2
d = 1


      
        
        
          
            
          
          
            
          
        
        
          let a = 1, b = 1;

alert( ++a ); // 2, prefix form returns the new value
alert( b++ ); // 1, postfix form returns the old value

alert( a ); // 2, incremented once
alert( b ); // 2, incremented once
        
      
      
      Assignment resultimportance: 3What are the values of a and x after the code below?

      
        
        
          let a = 2;

let x = 1 + (a *= 2);
        
      
      
      solutionThe answer is:

a = 4 (multiplied by 2)
x = 5 (calculated as 1 + 4)

Type conversionsimportance: 5What are results of these expressions?

      
        
        
          "" + 1 + 0
"" - 1 + 0
true + false
6 / "3"
"2" * "3"
4 + 5 + "px"
"$" + 4 + 5
"4" - 2
"4px" - 2
"  -9  " + 5
"  -9  " - 5
null + 1
undefined + 1
" \t \n" - 2
        
      
      
      Think well, write down and then compare with the answer.
solution
      
        
        
          "" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)
        
      
      
      
The addition with a string "" + 1 converts 1 to a string: "" + 1 = "1", and then we have "1" + 0, the same rule is applied.
The subtraction - (like most math operations) only works with numbers, it converts an empty string "" to 0.
The addition with a string appends the number 5 to the string.
The subtraction always converts to numbers, so it makes "  -9  " a number -9 (ignoring spaces around it).
null becomes 0 after the numeric conversion.
undefined becomes NaN after the numeric conversion.
Space characters are trimmed off string start and end when a string is converted to a number. Here the whole string consists of space characters, such as \t, \n and a “regular” space between them. So, similarly to an empty string, it becomes 0.

Fix the additionimportance: 5Here’s a code that asks the user for two numbers and shows their sum.
It works incorrectly. The output in the example below is 12 (for default prompt values).
Why? Fix it. The result should be 3.

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("First number?", 1);
let b = prompt("Second number?", 2);

alert(a + b); // 12
        
      
      
      solutionThe reason is that prompt returns user input as a string.
So variables have values "1" and "2" respectively.

      
        
        
          
            
          
          
            
          
        
        
          let a = "1"; // prompt("First number?", 1);
let b = "2"; // prompt("Second number?", 2);

alert(a + b); // 12
        
      
      
      What we should do is to convert strings to numbers before +. For example, using Number() or prepending them with +.
For example, right before prompt:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("First number?", 1);
let b = +prompt("Second number?", 2);

alert(a + b); // 3
        
      
      
      Or in the alert:

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("First number?", 1);
let b = prompt("Second number?", 2);

alert(+a + +b); // 3
        
      
      
      Using both unary and binary + in the latest code. Looks funny, doesn’t it?
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nWe know many operators from school. They are things like addition +, multiplication *, subtraction -, and so on.
In this chapter, we’ll start with simple operators, then concentrate on JavaScript-specific aspects, not covered by school arithmetic.
Terms: “unary”, “binary”, “operand”Before we move on, let’s grasp some common terminology.


An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.


An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
        
      
      
      

An operator is binary if it has two operands. The same minus exists in binary form as well:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
        
      
      
      Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.


MathsThe following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **.

The first four are straightforward, while % and ** need a few words about them.
Remainder %The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 5 % 2 ); // 1, the remainder of 5 divided by 2
alert( 8 % 3 ); // 2, the remainder of 8 divided by 3
alert( 8 % 4 ); // 0, the remainder of 8 divided by 4
        
      
      
      Exponentiation **The exponentiation operator a ** b raises a to the power of b.
In school maths, we write that as ab.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
        
      
      
      Just like in maths, the exponentiation operator is defined for non-integer numbers as well.
For example, a square root is an exponentiation by ½:

      
        
        
          
            
          
          
            
          
        
        
          alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)
        
      
      
      String concatenation with binary +Let’s meet the features of JavaScript operators that are beyond school arithmetics.
Usually, the plus operator + sums numbers.
But, if the binary + is applied to strings, it merges (concatenates) them:

      
        
        
          let s = "my" + "string";
alert(s); // mystring
        
      
      
      Note that if any of the operands is a string, then the other one is converted to a string too.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
        
      
      
      See, it doesn’t matter whether the first operand is a string or the second one.
Here’s a more complex example:

      
        
        
          
            
          
          
            
          
        
        
          alert(2 + 2 + '1' ); // "41" and not "221"
        
      
      
      Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.

      
        
        
          
            
          
          
            
          
        
        
          alert('1' + 2 + 2); // "122" and not "14"
        
      
      
      Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.
Here’s the demo for subtraction and division:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers
        
      
      
      Numeric conversion, unary +The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
For example:

      
        
        
          
            
          
          
            
          
        
        
          // No effect on numbers
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0
        
      
      
      It actually does the same thing as Number(...), but is shorter.
The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?
The binary plus would add them as strings:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", the binary plus concatenates strings
        
      
      
      If we want to treat them as numbers, we need to convert and then sum them:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5

// the longer variant
// alert( Number(apples) + Number(oranges) ); // 5
        
      
      
      From a mathematician’s standpoint, the abundance of pluses may seem strange. But from a programmer’s standpoint, there’s nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.
Why are unary pluses applied to values before the binary ones? As we’re going to see, that’s because of their higher precedence.
Operator precedenceIf an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
From school, we all know that the multiplication in the expression 1 + 2 * 2 should be calculated before the addition. That’s exactly the precedence thing. The multiplication is said to have a higher precedence than the addition.
Parentheses override any precedence, so if we’re not satisfied with the default order, we can use them to change it. For example, write (1 + 2) * 2.
There are many operators in JavaScript. Every operator has a corresponding precedence number. The one with the larger number executes first. If the precedence is the same, the execution order is from left to right.
Here’s an extract from the precedence table (you don’t need to remember this, but note that unary operators are higher than corresponding binary ones):



Precedence
Name
Sign




…
…
…


14
unary plus
+


14
unary negation
-


13
exponentiation
**


12
multiplication
*


12
division
/


11
addition
+


11
subtraction
-


…
…
…


2
assignment
=


…
…
…



As we can see, the “unary plus” has a priority of 14 which is higher than the 11 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.
AssignmentLet’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.

      
        
        
          let x = 2 * 2 + 1;

alert( x ); // 5
        
      
      
      Assignment = returns a valueThe fact of = being an operator, not a “magical” language construct has an interesting implication.
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.
Here’s a demo that uses an assignment as part of a more complex expression:

      
        
        
          
            
          
          
            
          
        
        
          let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
        
      
      
      In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3). It is then used for further evaluations.
Funny code, isn’t it? We should understand how it works, because sometimes we see it in JavaScript libraries.
Although, please don’t write the code like that. Such tricks definitely don’t make code clearer or readable.
Chaining assignmentsAnother interesting feature is the ability to chain assignments:

      
        
        
          
            
          
          
            
          
        
        
          let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
        
      
      
      Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.
Once again, for the purposes of readability it’s better to split such code into few lines:

      
        
        
          c = 2 + 2;
b = c;
a = c;
        
      
      
      That’s easier to read, especially when eye-scanning the code fast.
Modify-in-placeWe often need to apply an operator to a variable and store the new result in that same variable.
For example:

      
        
        
          let n = 2;
n = n + 5;
n = n * 2;
        
      
      
      This notation can be shortened using the operators += and *=:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14
        
      
      
      Short “modify-and-assign” operators exist for all arithmetical and bitwise operators: /=, -=, etc.
Such operators have the same precedence as a normal assignment, so they run after most other calculations:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;

n *= 3 + 5; // right part evaluated first, same as n *= 8

alert( n ); // 16
        
      
      
      Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:


Increment ++ increases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3
        
      
      
      

Decrement -- decreases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1
        
      
      
      


            Important:
            Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.

The operators ++ and -- can be placed either before or after a variable.

When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.

Both of these statements do the same thing: increase counter by 1.
Is there any difference? Yes, but we can only see it if we use the returned value of ++/--.
Let’s clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).
To see the difference, here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
        
      
      
      In the line (*), the prefix form ++counter increments counter and returns the new value, 2. So, the alert shows 2.
Now, let’s use the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = counter++; // (*) changed ++counter to counter++

alert(a); // 1
        
      
      
      In the line (*), the postfix form counter++ also increments counter but returns the old value (prior to increment). So, the alert shows 1.
To summarize:


If the result of increment/decrement is not used, there is no difference in which form to use:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
counter++;
++counter;
alert( counter ); // 2, the lines above did the same
        
      
      
      

If we’d like to increase a value and immediately use the result of the operator, we need the prefix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( ++counter ); // 1
        
      
      
      

If we’d like to increment a value but use its previous value, we need the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( counter++ ); // 0
        
      
      
      


            Increment/decrement among other operators
            The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * ++counter ); // 4
        
      
      
      Compare with:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value
        
      
      
      Though technically okay, such notation usually makes code less readable. One line does multiple things – not good.
While reading code, a fast “vertical” eye-scan can easily miss something like counter++ and it won’t be obvious that the variable increased.
We advise a style of “one line – one action”:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter );
counter++;
        
      
      
      
Bitwise operatorsBitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.
The list of operators:

AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won’t need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the Bitwise Operators chapter on MDN when a need arises.
CommaThe comma operator , is one of the rarest and most unusual operators. Sometimes, it’s used to write shorter code, so we need to know it in order to understand what’s going on.
The comma operator allows us to evaluate several expressions, dividing them with a comma ,. Each of them is evaluated but only the result of the last one is returned.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = (1 + 2, 3 + 4);

alert( a ); // 7 (the result of 3 + 4)
        
      
      
      Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

            Comma has a very low precedence
            Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.

Why do we need an operator that throws away everything except the last expression?
Sometimes, people use it in more complex constructs to put several actions in one line.
For example:

      
        
        
          // three operations in one line
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
        
      
      
      Such tricks are used in many JavaScript frameworks. That’s why we’re mentioning them. But usually they don’t improve code readability so we should think well before using them.
TasksThe postfix and prefix formsimportance: 5What are the final values of all variables a, b, c and d after the code below?

      
        
        
          let a = 1, b = 1;

let c = ++a; // ?
let d = b++; // ?
        
      
      
      solutionThe answer is:

a = 2
b = 2
c = 2
d = 1


      
        
        
          
            
          
          
            
          
        
        
          let a = 1, b = 1;

alert( ++a ); // 2, prefix form returns the new value
alert( b++ ); // 1, postfix form returns the old value

alert( a ); // 2, incremented once
alert( b ); // 2, incremented once
        
      
      
      Assignment resultimportance: 3What are the values of a and x after the code below?

      
        
        
          let a = 2;

let x = 1 + (a *= 2);
        
      
      
      solutionThe answer is:

a = 4 (multiplied by 2)
x = 5 (calculated as 1 + 4)

Type conversionsimportance: 5What are results of these expressions?

      
        
        
          "" + 1 + 0
"" - 1 + 0
true + false
6 / "3"
"2" * "3"
4 + 5 + "px"
"$" + 4 + 5
"4" - 2
"4px" - 2
"  -9  " + 5
"  -9  " - 5
null + 1
undefined + 1
" \t \n" - 2
        
      
      
      Think well, write down and then compare with the answer.
solution
      
        
        
          "" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)
        
      
      
      
The addition with a string "" + 1 converts 1 to a string: "" + 1 = "1", and then we have "1" + 0, the same rule is applied.
The subtraction - (like most math operations) only works with numbers, it converts an empty string "" to 0.
The addition with a string appends the number 5 to the string.
The subtraction always converts to numbers, so it makes "  -9  " a number -9 (ignoring spaces around it).
null becomes 0 after the numeric conversion.
undefined becomes NaN after the numeric conversion.
Space characters are trimmed off string start and end when a string is converted to a number. Here the whole string consists of space characters, such as \t, \n and a “regular” space between them. So, similarly to an empty string, it becomes 0.

Fix the additionimportance: 5Here’s a code that asks the user for two numbers and shows their sum.
It works incorrectly. The output in the example below is 12 (for default prompt values).
Why? Fix it. The result should be 3.

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("First number?", 1);
let b = prompt("Second number?", 2);

alert(a + b); // 12
        
      
      
      solutionThe reason is that prompt returns user input as a string.
So variables have values "1" and "2" respectively.

      
        
        
          
            
          
          
            
          
        
        
          let a = "1"; // prompt("First number?", 1);
let b = "2"; // prompt("Second number?", 2);

alert(a + b); // 12
        
      
      
      What we should do is to convert strings to numbers before +. For example, using Number() or prepending them with +.
For example, right before prompt:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("First number?", 1);
let b = +prompt("Second number?", 2);

alert(a + b); // 3
        
      
      
      Or in the alert:

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("First number?", 1);
let b = prompt("Second number?", 2);

alert(+a + +b); // 3
        
      
      
      Using both unary and binary + in the latest code. Looks funny, doesn’t it?\n\nTutorialThe JavaScript languageJavaScript FundamentalsNovember 14, 2022Basic operators, mathsWe know many operators from school. They are things like addition +, multiplication *, subtraction -, and so on.
In this chapter, we’ll start with simple operators, then concentrate on JavaScript-specific aspects, not covered by school arithmetic.
Terms: “unary”, “binary”, “operand”Before we move on, let’s grasp some common terminology.


An operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.


An operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
        
      
      
      

An operator is binary if it has two operands. The same minus exists in binary form as well:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
        
      
      
      Formally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.


MathsThe following math operations are supported:

Addition +,
Subtraction -,
Multiplication *,
Division /,
Remainder %,
Exponentiation **.

The first four are straightforward, while % and ** need a few words about them.
Remainder %The remainder operator %, despite its appearance, is not related to percents.
The result of a % b is the remainder of the integer division of a by b.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 5 % 2 ); // 1, the remainder of 5 divided by 2
alert( 8 % 3 ); // 2, the remainder of 8 divided by 3
alert( 8 % 4 ); // 0, the remainder of 8 divided by 4
        
      
      
      Exponentiation **The exponentiation operator a ** b raises a to the power of b.
In school maths, we write that as ab.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
        
      
      
      Just like in maths, the exponentiation operator is defined for non-integer numbers as well.
For example, a square root is an exponentiation by ½:

      
        
        
          
            
          
          
            
          
        
        
          alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)
        
      
      
      String concatenation with binary +Let’s meet the features of JavaScript operators that are beyond school arithmetics.
Usually, the plus operator + sums numbers.
But, if the binary + is applied to strings, it merges (concatenates) them:

      
        
        
          let s = "my" + "string";
alert(s); // mystring
        
      
      
      Note that if any of the operands is a string, then the other one is converted to a string too.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
        
      
      
      See, it doesn’t matter whether the first operand is a string or the second one.
Here’s a more complex example:

      
        
        
          
            
          
          
            
          
        
        
          alert(2 + 2 + '1' ); // "41" and not "221"
        
      
      
      Here, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.

      
        
        
          
            
          
          
            
          
        
        
          alert('1' + 2 + 2); // "122" and not "14"
        
      
      
      Here, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = "12" and "12" + 2 = "122".
The binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.
Here’s the demo for subtraction and division:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers
        
      
      
      Numeric conversion, unary +The plus + exists in two forms: the binary form that we used above and the unary form.
The unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
For example:

      
        
        
          
            
          
          
            
          
        
        
          // No effect on numbers
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Converts non-numbers
alert( +true ); // 1
alert( +"" );   // 0
        
      
      
      It actually does the same thing as Number(...), but is shorter.
The need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?
The binary plus would add them as strings:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", the binary plus concatenates strings
        
      
      
      If we want to treat them as numbers, we need to convert and then sum them:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5

// the longer variant
// alert( Number(apples) + Number(oranges) ); // 5
        
      
      
      From a mathematician’s standpoint, the abundance of pluses may seem strange. But from a programmer’s standpoint, there’s nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.
Why are unary pluses applied to values before the binary ones? As we’re going to see, that’s because of their higher precedence.
Operator precedenceIf an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.
From school, we all know that the multiplication in the expression 1 + 2 * 2 should be calculated before the addition. That’s exactly the precedence thing. The multiplication is said to have a higher precedence than the addition.
Parentheses override any precedence, so if we’re not satisfied with the default order, we can use them to change it. For example, write (1 + 2) * 2.
There are many operators in JavaScript. Every operator has a corresponding precedence number. The one with the larger number executes first. If the precedence is the same, the execution order is from left to right.
Here’s an extract from the precedence table (you don’t need to remember this, but note that unary operators are higher than corresponding binary ones):



Precedence
Name
Sign




…
…
…


14
unary plus
+


14
unary negation
-


13
exponentiation
**


12
multiplication
*


12
division
/


11
addition
+


11
subtraction
-


…
…
…


2
assignment
=


…
…
…



As we can see, the “unary plus” has a priority of 14 which is higher than the 11 of “addition” (binary plus). That’s why, in the expression "+apples + +oranges", unary pluses work before the addition.
AssignmentLet’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.
That’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.

      
        
        
          let x = 2 * 2 + 1;

alert( x ); // 5
        
      
      
      Assignment = returns a valueThe fact of = being an operator, not a “magical” language construct has an interesting implication.
All operators in JavaScript return a value. That’s obvious for + and -, but also true for =.
The call x = value writes the value into x and then returns it.
Here’s a demo that uses an assignment as part of a more complex expression:

      
        
        
          
            
          
          
            
          
        
        
          let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
        
      
      
      In the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3). It is then used for further evaluations.
Funny code, isn’t it? We should understand how it works, because sometimes we see it in JavaScript libraries.
Although, please don’t write the code like that. Such tricks definitely don’t make code clearer or readable.
Chaining assignmentsAnother interesting feature is the ability to chain assignments:

      
        
        
          
            
          
          
            
          
        
        
          let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
        
      
      
      Chained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.
Once again, for the purposes of readability it’s better to split such code into few lines:

      
        
        
          c = 2 + 2;
b = c;
a = c;
        
      
      
      That’s easier to read, especially when eye-scanning the code fast.
Modify-in-placeWe often need to apply an operator to a variable and store the new result in that same variable.
For example:

      
        
        
          let n = 2;
n = n + 5;
n = n * 2;
        
      
      
      This notation can be shortened using the operators += and *=:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)

alert( n ); // 14
        
      
      
      Short “modify-and-assign” operators exist for all arithmetical and bitwise operators: /=, -=, etc.
Such operators have the same precedence as a normal assignment, so they run after most other calculations:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;

n *= 3 + 5; // right part evaluated first, same as n *= 8

alert( n ); // 16
        
      
      
      Increment/decrement
Increasing or decreasing a number by one is among the most common numerical operations.
So, there are special operators for it:


Increment ++ increases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter++;        // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3
        
      
      
      

Decrement -- decreases a variable by 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter--;        // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1
        
      
      
      


            Important:
            Increment/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.

The operators ++ and -- can be placed either before or after a variable.

When the operator goes after the variable, it is in “postfix form”: counter++.
The “prefix form” is when the operator goes before the variable: ++counter.

Both of these statements do the same thing: increase counter by 1.
Is there any difference? Yes, but we can only see it if we use the returned value of ++/--.
Let’s clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).
To see the difference, here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
        
      
      
      In the line (*), the prefix form ++counter increments counter and returns the new value, 2. So, the alert shows 2.
Now, let’s use the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = counter++; // (*) changed ++counter to counter++

alert(a); // 1
        
      
      
      In the line (*), the postfix form counter++ also increments counter but returns the old value (prior to increment). So, the alert shows 1.
To summarize:


If the result of increment/decrement is not used, there is no difference in which form to use:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
counter++;
++counter;
alert( counter ); // 2, the lines above did the same
        
      
      
      

If we’d like to increase a value and immediately use the result of the operator, we need the prefix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( ++counter ); // 1
        
      
      
      

If we’d like to increment a value but use its previous value, we need the postfix form:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( counter++ ); // 0
        
      
      
      


            Increment/decrement among other operators
            The operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * ++counter ); // 4
        
      
      
      Compare with:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the "old" value
        
      
      
      Though technically okay, such notation usually makes code less readable. One line does multiple things – not good.
While reading code, a fast “vertical” eye-scan can easily miss something like counter++ and it won’t be obvious that the variable increased.
We advise a style of “one line – one action”:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter );
counter++;
        
      
      
      
Bitwise operatorsBitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
These operators are not JavaScript-specific. They are supported in most programming languages.
The list of operators:

AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won’t need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the Bitwise Operators chapter on MDN when a need arises.
CommaThe comma operator , is one of the rarest and most unusual operators. Sometimes, it’s used to write shorter code, so we need to know it in order to understand what’s going on.
The comma operator allows us to evaluate several expressions, dividing them with a comma ,. Each of them is evaluated but only the result of the last one is returned.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = (1 + 2, 3 + 4);

alert( a ); // 7 (the result of 3 + 4)
        
      
      
      Here, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.

            Comma has a very low precedence
            Please note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.
Without them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.

Why do we need an operator that throws away everything except the last expression?
Sometimes, people use it in more complex constructs to put several actions in one line.
For example:

      
        
        
          // three operations in one line
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
        
      
      
      Such tricks are used in many JavaScript frameworks. That’s why we’re mentioning them. But usually they don’t improve code readability so we should think well before using them.
TasksThe postfix and prefix formsimportance: 5What are the final values of all variables a, b, c and d after the code below?

      
        
        
          let a = 1, b = 1;

let c = ++a; // ?
let d = b++; // ?
        
      
      
      solutionThe answer is:

a = 2
b = 2
c = 2
d = 1


      
        
        
          
            
          
          
            
          
        
        
          let a = 1, b = 1;

alert( ++a ); // 2, prefix form returns the new value
alert( b++ ); // 1, postfix form returns the old value

alert( a ); // 2, incremented once
alert( b ); // 2, incremented once
        
      
      
      Assignment resultimportance: 3What are the values of a and x after the code below?

      
        
        
          let a = 2;

let x = 1 + (a *= 2);
        
      
      
      solutionThe answer is:

a = 4 (multiplied by 2)
x = 5 (calculated as 1 + 4)

Type conversionsimportance: 5What are results of these expressions?

      
        
        
          "" + 1 + 0
"" - 1 + 0
true + false
6 / "3"
"2" * "3"
4 + 5 + "px"
"$" + 4 + 5
"4" - 2
"4px" - 2
"  -9  " + 5
"  -9  " - 5
null + 1
undefined + 1
" \t \n" - 2
        
      
      
      Think well, write down and then compare with the answer.
solution
      
        
        
          "" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)
        
      
      
      
The addition with a string "" + 1 converts 1 to a string: "" + 1 = "1", and then we have "1" + 0, the same rule is applied.
The subtraction - (like most math operations) only works with numbers, it converts an empty string "" to 0.
The addition with a string appends the number 5 to the string.
The subtraction always converts to numbers, so it makes "  -9  " a number -9 (ignoring spaces around it).
null becomes 0 after the numeric conversion.
undefined becomes NaN after the numeric conversion.
Space characters are trimmed off string start and end when a string is converted to a number. Here the whole string consists of space characters, such as \t, \n and a “regular” space between them. So, similarly to an empty string, it becomes 0.

Fix the additionimportance: 5Here’s a code that asks the user for two numbers and shows their sum.
It works incorrectly. The output in the example below is 12 (for default prompt values).
Why? Fix it. The result should be 3.

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("First number?", 1);
let b = prompt("Second number?", 2);

alert(a + b); // 12
        
      
      
      solutionThe reason is that prompt returns user input as a string.
So variables have values "1" and "2" respectively.

      
        
        
          
            
          
          
            
          
        
        
          let a = "1"; // prompt("First number?", 1);
let b = "2"; // prompt("Second number?", 2);

alert(a + b); // 12
        
      
      
      What we should do is to convert strings to numbers before +. For example, using Number() or prepending them with +.
For example, right before prompt:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("First number?", 1);
let b = +prompt("Second number?", 2);

alert(a + b); // 3
        
      
      
      Or in the alert:

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("First number?", 1);
let b = prompt("Second number?", 2);

alert(+a + +b); // 3
        
      
      
      Using both unary and binary + in the latest code. Looks funny, doesn’t it?
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nWe know many comparison operators from maths.
In JavaScript they are written like this:

Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.

In this article we’ll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities.
At the end you’ll find a good recipe to avoid “JavaScript quirks”-related issues.
Boolean is the resultAll comparison operators return a boolean value:

true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
        
      
      
      A comparison result can be assigned to a variable, just like any value:

      
        
        
          
            
          
          
            
          
        
        
          let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
        
      
      
      String comparisonTo see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
        
      
      
      The algorithm to compare two strings is simple:

Compare the first character of both strings.
If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
Repeat until the end of either string.
If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.
The second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:

G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.


            Not a real dictionary, but Unicode order
            The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it’s not exactly the same.
For instance, case matters. A capital letter "A" is not equal to the lowercase "a". Which one is greater? The lowercase "a". Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We’ll get back to specific details and consequences of this in the chapter Strings.

Comparison of different typesWhen comparing values of different types, JavaScript converts the values to numbers.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
        
      
      
      For boolean values, true becomes 1 and false becomes 0.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( true == 1 ); // true
alert( false == 0 ); // true
        
      
      
      
            A funny consequence
            It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.

For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
        
      
      
      From JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules.

Strict equalityA regular equality check == has a problem. It cannot differentiate 0 from false:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
        
      
      
      The same thing happens with an empty string:

      
        
        
          
            
          
          
            
          
        
        
          alert( '' == false ); // true
        
      
      
      This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.
What to do if we’d like to differentiate 0 from false?
A strict equality operator === checks the equality without type conversion.
In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.
Let’s try it:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 === false ); // false, because the types are different
        
      
      
      There is also a “strict non-equality” operator !== analogous to !=.
The strict equality operator is a bit longer to write, but makes it obvious what’s going on and leaves less room for errors.
Comparison with null and undefinedThere’s a non-intuitive behavior when null or undefined are compared to other values.

For a strict equality check ===

These values are different, because each of them is a different type.

      
        
        
          
            
          
          
            
          
        
        
          alert( null === undefined ); // false
        
      
      
      
For a non-strict check ==

There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null == undefined ); // true
        
      
      
      
For maths and other comparisons < > <= >=

null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.


Now let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them.
Strange result: null vs 0Let’s compare null with a zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
        
      
      
      Mathematically, that’s strange. The last result states that “null is greater than or equal to zero”, so in one of the comparisons above it must be true, but they are both false.
The reason is that an equality check == and comparisons > < >= <= work differently. Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.
An incomparable undefinedThe value undefined shouldn’t be compared to other values:

      
        
        
          
            
          
          
            
          
        
        
          alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
        
      
      
      Why does it dislike zero so much? Always false!
We get these results because:

Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.
The equality check (3) returns false because undefined only equals null, undefined, and no other value.

Avoid problemsWhy did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there’s a solid way to avoid problems with them:

Treat any comparison with undefined/null except the strict equality === with exceptional care.
Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.

Summary
Comparison operators return a boolean value.
Strings are compared letter-by-letter in the “dictionary” order.
When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
The values null and undefined equal == each other and do not equal any other value.
Be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.\n\nTutorialThe JavaScript languageJavaScript FundamentalsOctober 1, 2021ComparisonsWe know many comparison operators from maths.
In JavaScript they are written like this:

Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.

In this article we’ll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities.
At the end you’ll find a good recipe to avoid “JavaScript quirks”-related issues.
Boolean is the resultAll comparison operators return a boolean value:

true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
        
      
      
      A comparison result can be assigned to a variable, just like any value:

      
        
        
          
            
          
          
            
          
        
        
          let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
        
      
      
      String comparisonTo see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
        
      
      
      The algorithm to compare two strings is simple:

Compare the first character of both strings.
If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
Repeat until the end of either string.
If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.
The second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:

G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.


            Not a real dictionary, but Unicode order
            The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it’s not exactly the same.
For instance, case matters. A capital letter "A" is not equal to the lowercase "a". Which one is greater? The lowercase "a". Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We’ll get back to specific details and consequences of this in the chapter Strings.

Comparison of different typesWhen comparing values of different types, JavaScript converts the values to numbers.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
        
      
      
      For boolean values, true becomes 1 and false becomes 0.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( true == 1 ); // true
alert( false == 0 ); // true
        
      
      
      
            A funny consequence
            It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.

For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
        
      
      
      From JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules.

Strict equalityA regular equality check == has a problem. It cannot differentiate 0 from false:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
        
      
      
      The same thing happens with an empty string:

      
        
        
          
            
          
          
            
          
        
        
          alert( '' == false ); // true
        
      
      
      This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.
What to do if we’d like to differentiate 0 from false?
A strict equality operator === checks the equality without type conversion.
In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.
Let’s try it:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 === false ); // false, because the types are different
        
      
      
      There is also a “strict non-equality” operator !== analogous to !=.
The strict equality operator is a bit longer to write, but makes it obvious what’s going on and leaves less room for errors.
Comparison with null and undefinedThere’s a non-intuitive behavior when null or undefined are compared to other values.

For a strict equality check ===

These values are different, because each of them is a different type.

      
        
        
          
            
          
          
            
          
        
        
          alert( null === undefined ); // false
        
      
      
      
For a non-strict check ==

There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null == undefined ); // true
        
      
      
      
For maths and other comparisons < > <= >=

null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.


Now let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them.
Strange result: null vs 0Let’s compare null with a zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
        
      
      
      Mathematically, that’s strange. The last result states that “null is greater than or equal to zero”, so in one of the comparisons above it must be true, but they are both false.
The reason is that an equality check == and comparisons > < >= <= work differently. Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.
An incomparable undefinedThe value undefined shouldn’t be compared to other values:

      
        
        
          
            
          
          
            
          
        
        
          alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
        
      
      
      Why does it dislike zero so much? Always false!
We get these results because:

Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.
The equality check (3) returns false because undefined only equals null, undefined, and no other value.

Avoid problemsWhy did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there’s a solid way to avoid problems with them:

Treat any comparison with undefined/null except the strict equality === with exceptional care.
Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.

Summary
Comparison operators return a boolean value.
Strings are compared letter-by-letter in the “dictionary” order.
When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
The values null and undefined equal == each other and do not equal any other value.
Be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.

TasksComparisonsimportance: 5What will be the result for these expressions?

      
        
        
          5 > 4
"apple" > "pineapple"
"2" > "12"
undefined == null
undefined === null
null == "\n0\n"
null === +"\n0\n"
        
      
      
      solution
      
        
        
          5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
        
      
      
      Some of the reasons:

Obviously, true.
Dictionary comparison, hence false. "a" is smaller than "p".
Again, dictionary comparison, first char "2" is greater than the first char "1".
Values null and undefined equal each other only.
Strict equality is strict. Different types from both sides lead to false.
Similar to (4), null only equals undefined.
Strict equality of different types.

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nWe know many comparison operators from maths.
In JavaScript they are written like this:

Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.

In this article we’ll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities.
At the end you’ll find a good recipe to avoid “JavaScript quirks”-related issues.
Boolean is the resultAll comparison operators return a boolean value:

true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
        
      
      
      A comparison result can be assigned to a variable, just like any value:

      
        
        
          
            
          
          
            
          
        
        
          let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
        
      
      
      String comparisonTo see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
        
      
      
      The algorithm to compare two strings is simple:

Compare the first character of both strings.
If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
Repeat until the end of either string.
If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.
The second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:

G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.


            Not a real dictionary, but Unicode order
            The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it’s not exactly the same.
For instance, case matters. A capital letter "A" is not equal to the lowercase "a". Which one is greater? The lowercase "a". Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We’ll get back to specific details and consequences of this in the chapter Strings.

Comparison of different typesWhen comparing values of different types, JavaScript converts the values to numbers.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
        
      
      
      For boolean values, true becomes 1 and false becomes 0.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( true == 1 ); // true
alert( false == 0 ); // true
        
      
      
      
            A funny consequence
            It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.

For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
        
      
      
      From JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules.

Strict equalityA regular equality check == has a problem. It cannot differentiate 0 from false:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
        
      
      
      The same thing happens with an empty string:

      
        
        
          
            
          
          
            
          
        
        
          alert( '' == false ); // true
        
      
      
      This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.
What to do if we’d like to differentiate 0 from false?
A strict equality operator === checks the equality without type conversion.
In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.
Let’s try it:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 === false ); // false, because the types are different
        
      
      
      There is also a “strict non-equality” operator !== analogous to !=.
The strict equality operator is a bit longer to write, but makes it obvious what’s going on and leaves less room for errors.
Comparison with null and undefinedThere’s a non-intuitive behavior when null or undefined are compared to other values.

For a strict equality check ===

These values are different, because each of them is a different type.

      
        
        
          
            
          
          
            
          
        
        
          alert( null === undefined ); // false
        
      
      
      
For a non-strict check ==

There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null == undefined ); // true
        
      
      
      
For maths and other comparisons < > <= >=

null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.


Now let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them.
Strange result: null vs 0Let’s compare null with a zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
        
      
      
      Mathematically, that’s strange. The last result states that “null is greater than or equal to zero”, so in one of the comparisons above it must be true, but they are both false.
The reason is that an equality check == and comparisons > < >= <= work differently. Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.
An incomparable undefinedThe value undefined shouldn’t be compared to other values:

      
        
        
          
            
          
          
            
          
        
        
          alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
        
      
      
      Why does it dislike zero so much? Always false!
We get these results because:

Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.
The equality check (3) returns false because undefined only equals null, undefined, and no other value.

Avoid problemsWhy did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there’s a solid way to avoid problems with them:

Treat any comparison with undefined/null except the strict equality === with exceptional care.
Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.

Summary
Comparison operators return a boolean value.
Strings are compared letter-by-letter in the “dictionary” order.
When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
The values null and undefined equal == each other and do not equal any other value.
Be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.

TasksComparisonsimportance: 5What will be the result for these expressions?

      
        
        
          5 > 4
"apple" > "pineapple"
"2" > "12"
undefined == null
undefined === null
null == "\n0\n"
null === +"\n0\n"
        
      
      
      solution
      
        
        
          5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
        
      
      
      Some of the reasons:

Obviously, true.
Dictionary comparison, hence false. "a" is smaller than "p".
Again, dictionary comparison, first char "2" is greater than the first char "1".
Values null and undefined equal each other only.
Strict equality is strict. Different types from both sides lead to false.
Similar to (4), null only equals undefined.
Strict equality of different types.\n\nTutorialThe JavaScript languageJavaScript FundamentalsOctober 1, 2021ComparisonsWe know many comparison operators from maths.
In JavaScript they are written like this:

Greater/less than: a > b, a < b.
Greater/less than or equals: a >= b, a <= b.
Equals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.
Not equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.

In this article we’ll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities.
At the end you’ll find a good recipe to avoid “JavaScript quirks”-related issues.
Boolean is the resultAll comparison operators return a boolean value:

true – means “yes”, “correct” or “the truth”.
false – means “no”, “wrong” or “not the truth”.

For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
        
      
      
      A comparison result can be assigned to a variable, just like any value:

      
        
        
          
            
          
          
            
          
        
        
          let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
        
      
      
      String comparisonTo see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.
In other words, strings are compared letter-by-letter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
        
      
      
      The algorithm to compare two strings is simple:

Compare the first character of both strings.
If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
Repeat until the end of either string.
If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

In the first example above, the comparison 'Z' > 'A' gets to a result at the first step.
The second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:

G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.


            Not a real dictionary, but Unicode order
            The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it’s not exactly the same.
For instance, case matters. A capital letter "A" is not equal to the lowercase "a". Which one is greater? The lowercase "a". Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We’ll get back to specific details and consequences of this in the chapter Strings.

Comparison of different typesWhen comparing values of different types, JavaScript converts the values to numbers.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
        
      
      
      For boolean values, true becomes 1 and false becomes 0.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( true == 1 ); // true
alert( false == 0 ); // true
        
      
      
      
            A funny consequence
            It is possible that at the same time:

Two values are equal.
One of them is true as a boolean and the other one is false as a boolean.

For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
        
      
      
      From JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules.

Strict equalityA regular equality check == has a problem. It cannot differentiate 0 from false:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
        
      
      
      The same thing happens with an empty string:

      
        
        
          
            
          
          
            
          
        
        
          alert( '' == false ); // true
        
      
      
      This happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.
What to do if we’d like to differentiate 0 from false?
A strict equality operator === checks the equality without type conversion.
In other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.
Let’s try it:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 === false ); // false, because the types are different
        
      
      
      There is also a “strict non-equality” operator !== analogous to !=.
The strict equality operator is a bit longer to write, but makes it obvious what’s going on and leaves less room for errors.
Comparison with null and undefinedThere’s a non-intuitive behavior when null or undefined are compared to other values.

For a strict equality check ===

These values are different, because each of them is a different type.

      
        
        
          
            
          
          
            
          
        
        
          alert( null === undefined ); // false
        
      
      
      
For a non-strict check ==

There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null == undefined ); // true
        
      
      
      
For maths and other comparisons < > <= >=

null/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.


Now let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them.
Strange result: null vs 0Let’s compare null with a zero:

      
        
        
          
            
          
          
            
          
        
        
          alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
        
      
      
      Mathematically, that’s strange. The last result states that “null is greater than or equal to zero”, so in one of the comparisons above it must be true, but they are both false.
The reason is that an equality check == and comparisons > < >= <= work differently. Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.
An incomparable undefinedThe value undefined shouldn’t be compared to other values:

      
        
        
          
            
          
          
            
          
        
        
          alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
        
      
      
      Why does it dislike zero so much? Always false!
We get these results because:

Comparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.
The equality check (3) returns false because undefined only equals null, undefined, and no other value.

Avoid problemsWhy did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there’s a solid way to avoid problems with them:

Treat any comparison with undefined/null except the strict equality === with exceptional care.
Don’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.

Summary
Comparison operators return a boolean value.
Strings are compared letter-by-letter in the “dictionary” order.
When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
The values null and undefined equal == each other and do not equal any other value.
Be careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.

TasksComparisonsimportance: 5What will be the result for these expressions?

      
        
        
          5 > 4
"apple" > "pineapple"
"2" > "12"
undefined == null
undefined === null
null == "\n0\n"
null === +"\n0\n"
        
      
      
      solution
      
        
        
          5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
        
      
      
      Some of the reasons:

Obviously, true.
Dictionary comparison, hence false. "a" is smaller than "p".
Again, dictionary comparison, first char "2" is greater than the first char "1".
Values null and undefined equal each other only.
Strict equality is strict. Different types from both sides lead to false.
Similar to (4), null only equals undefined.
Strict equality of different types.

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nSometimes, we need to perform different actions based on different conditions.
To do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.
The “if” statementThe if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) alert( 'You are right!' );
        
      
      
      In the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.
If we want to execute more than one statement, we have to wrap our code block inside curly braces:

      
        
        
          if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
        
      
      
      We recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute. Doing so improves readability.
Boolean conversionThe if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.
Let’s recall the conversion rules from the chapter Type Conversions:

A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”.

So, the code under this condition would never execute:

      
        
        
          if (0) { // 0 is falsy
  ...
}
        
      
      
      …and inside this condition – it always will:

      
        
        
          if (1) { // 1 is truthy
  ...
}
        
      
      
      We can also pass a pre-evaluated boolean value to if, like this:

      
        
        
          let cond = (year == 2015); // equality evaluates to true or false

if (cond) {
  ...
}
        
      
      
      The “else” clauseThe if statement may contain an optional else block. It executes when the condition is falsy.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
}
        
      
      
      Several conditions: “else if”Sometimes, we’d like to test several variants of a condition. The else if clause lets us do that.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
        
      
      
      In the code above, JavaScript first checks year < 2015. If that is falsy, it goes to the next condition year > 2015. If that is also falsy, it shows the last alert.
There can be more else if blocks. The final else is optional.
Conditional operator ‘?’Sometimes, we need to assign a variable depending on a condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let accessAllowed;
let age = prompt('How old are you?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
        
      
      
      The so-called “conditional” or “question mark” operator lets us do that in a shorter and simpler way.
The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.
The syntax is:

      
        
        
          let result = condition ? value1 : value2;
        
      
      
      The condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.
For example:

      
        
        
          let accessAllowed = (age > 18) ? true : false;
        
      
      
      Technically, we can omit the parentheses around age > 18. The question mark operator has a low precedence, so it executes after the comparison >.
This example will do the same thing as the previous one:

      
        
        
          // the comparison operator "age > 18" executes first anyway
// (no need to wrap it into parentheses)
let accessAllowed = age > 18 ? true : false;
        
      
      
      But parentheses make the code more readable, so we recommend using them.

            Please note:
            In the example above, you can avoid using the question mark operator because the comparison itself returns true/false:

      
        
        
          // the same
let accessAllowed = age > 18;
        
      
      
      
Multiple ‘?’A sequence of question mark operators ? can return a value that depends on more than one condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
        
      
      
      It may be difficult at first to grasp what’s going on. But after a closer look, we can see that it’s just an ordinary sequence of tests:

The first question mark checks whether age < 3.
If true – it returns 'Hi, baby!'. Otherwise, it continues to the expression after the colon “:”, checking age < 18.
If that’s true – it returns 'Hello!'. Otherwise, it continues to the expression after the next colon “:”, checking age < 100.
If that’s true – it returns 'Greetings!'. Otherwise, it continues to the expression after the last colon “:”, returning 'What an unusual age!'.

Here’s how this looks using if..else:

      
        
        
          if (age < 3) {
  message = 'Hi, baby!';
} else if (age < 18) {
  message = 'Hello!';
} else if (age < 100) {
  message = 'Greetings!';
} else {
  message = 'What an unusual age!';
}
        
      
      
      Non-traditional use of ‘?’Sometimes the question mark ? is used as a replacement for if:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
        
      
      
      Depending on the condition company == 'Netscape', either the first or the second expression after the ? gets executed and shows an alert.
We don’t assign a result to a variable here. Instead, we execute different code depending on the condition.
It’s not recommended to use the question mark operator in this way.
The notation is shorter than the equivalent if statement, which appeals to some programmers. But it is less readable.
Here is the same code using if for comparison:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
}
        
      
      
      Our eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.
The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.\n\nTutorialThe JavaScript languageJavaScript FundamentalsDecember 7, 2022Conditional branching: if, '?'Sometimes, we need to perform different actions based on different conditions.
To do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.
The “if” statementThe if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) alert( 'You are right!' );
        
      
      
      In the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.
If we want to execute more than one statement, we have to wrap our code block inside curly braces:

      
        
        
          if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
        
      
      
      We recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute. Doing so improves readability.
Boolean conversionThe if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.
Let’s recall the conversion rules from the chapter Type Conversions:

A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”.

So, the code under this condition would never execute:

      
        
        
          if (0) { // 0 is falsy
  ...
}
        
      
      
      …and inside this condition – it always will:

      
        
        
          if (1) { // 1 is truthy
  ...
}
        
      
      
      We can also pass a pre-evaluated boolean value to if, like this:

      
        
        
          let cond = (year == 2015); // equality evaluates to true or false

if (cond) {
  ...
}
        
      
      
      The “else” clauseThe if statement may contain an optional else block. It executes when the condition is falsy.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
}
        
      
      
      Several conditions: “else if”Sometimes, we’d like to test several variants of a condition. The else if clause lets us do that.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
        
      
      
      In the code above, JavaScript first checks year < 2015. If that is falsy, it goes to the next condition year > 2015. If that is also falsy, it shows the last alert.
There can be more else if blocks. The final else is optional.
Conditional operator ‘?’Sometimes, we need to assign a variable depending on a condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let accessAllowed;
let age = prompt('How old are you?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
        
      
      
      The so-called “conditional” or “question mark” operator lets us do that in a shorter and simpler way.
The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.
The syntax is:

      
        
        
          let result = condition ? value1 : value2;
        
      
      
      The condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.
For example:

      
        
        
          let accessAllowed = (age > 18) ? true : false;
        
      
      
      Technically, we can omit the parentheses around age > 18. The question mark operator has a low precedence, so it executes after the comparison >.
This example will do the same thing as the previous one:

      
        
        
          // the comparison operator "age > 18" executes first anyway
// (no need to wrap it into parentheses)
let accessAllowed = age > 18 ? true : false;
        
      
      
      But parentheses make the code more readable, so we recommend using them.

            Please note:
            In the example above, you can avoid using the question mark operator because the comparison itself returns true/false:

      
        
        
          // the same
let accessAllowed = age > 18;
        
      
      
      
Multiple ‘?’A sequence of question mark operators ? can return a value that depends on more than one condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
        
      
      
      It may be difficult at first to grasp what’s going on. But after a closer look, we can see that it’s just an ordinary sequence of tests:

The first question mark checks whether age < 3.
If true – it returns 'Hi, baby!'. Otherwise, it continues to the expression after the colon “:”, checking age < 18.
If that’s true – it returns 'Hello!'. Otherwise, it continues to the expression after the next colon “:”, checking age < 100.
If that’s true – it returns 'Greetings!'. Otherwise, it continues to the expression after the last colon “:”, returning 'What an unusual age!'.

Here’s how this looks using if..else:

      
        
        
          if (age < 3) {
  message = 'Hi, baby!';
} else if (age < 18) {
  message = 'Hello!';
} else if (age < 100) {
  message = 'Greetings!';
} else {
  message = 'What an unusual age!';
}
        
      
      
      Non-traditional use of ‘?’Sometimes the question mark ? is used as a replacement for if:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
        
      
      
      Depending on the condition company == 'Netscape', either the first or the second expression after the ? gets executed and shows an alert.
We don’t assign a result to a variable here. Instead, we execute different code depending on the condition.
It’s not recommended to use the question mark operator in this way.
The notation is shorter than the equivalent if statement, which appeals to some programmers. But it is less readable.
Here is the same code using if for comparison:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
}
        
      
      
      Our eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.
The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.
Tasksif (a string with zero)importance: 5Will alert be shown?

      
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      solutionYes, it will.
Any string except an empty one (and "0" is not empty) becomes true in the logical context.
We can run and check:

      
        
        
          
            
          
          
            
          
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      The name of JavaScriptimportance: 2Using the if..else construct, write the code which asks: ‘What is the “official” name of JavaScript?’
If the visitor enters “ECMAScript”, then output “Right!”, otherwise – output: “You don’t know? ECMAScript!”

      
      
        
      
      Demo in new windowsolution
      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE html>
<html>

<body>
  <script>
    'use strict';

    let value = prompt('What is the "official" name of JavaScript?', '');

    if (value == 'ECMAScript') {
      alert('Right!');
    } else {
      alert("You don't know? ECMAScript!");
    }
  </script>


</body>

</html>
        
      
      
      Show the signimportance: 2Using if..else, write the code which gets a number via prompt and then shows in alert:

1, if the value is greater than zero,
-1, if less than zero,
0, if equals zero.

In this task we assume that the input is always a number.
Demo in new windowsolution
      
        
        
          
            
          
          
            
          
        
        
          let value = prompt('Type a number', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}
        
      
      
      Rewrite 'if' into '?'importance: 5Rewrite this if using the conditional operator '?':

      
        
        
          let result;

if (a + b < 4) {
  result = 'Below';
} else {
  result = 'Over';
}
        
      
      
      solution
      
        
        
          let result = (a + b < 4) ? 'Below' : 'Over';
        
      
      
      Rewrite 'if..else' into '?'importance: 5Rewrite if..else using multiple ternary operators '?'.
For readability, it’s recommended to split the code into multiple lines.

      
        
        
          let message;

if (login == 'Employee') {
  message = 'Hello';
} else if (login == 'Director') {
  message = 'Greetings';
} else if (login == '') {
  message = 'No login';
} else {
  message = '';
}
        
      
      
      solution
      
        
        
          let message = (login == 'Employee') ? 'Hello' :
  (login == 'Director') ? 'Greetings' :
  (login == '') ? 'No login' :
  '';
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nSometimes, we need to perform different actions based on different conditions.
To do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.
The “if” statementThe if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) alert( 'You are right!' );
        
      
      
      In the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.
If we want to execute more than one statement, we have to wrap our code block inside curly braces:

      
        
        
          if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
        
      
      
      We recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute. Doing so improves readability.
Boolean conversionThe if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.
Let’s recall the conversion rules from the chapter Type Conversions:

A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”.

So, the code under this condition would never execute:

      
        
        
          if (0) { // 0 is falsy
  ...
}
        
      
      
      …and inside this condition – it always will:

      
        
        
          if (1) { // 1 is truthy
  ...
}
        
      
      
      We can also pass a pre-evaluated boolean value to if, like this:

      
        
        
          let cond = (year == 2015); // equality evaluates to true or false

if (cond) {
  ...
}
        
      
      
      The “else” clauseThe if statement may contain an optional else block. It executes when the condition is falsy.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
}
        
      
      
      Several conditions: “else if”Sometimes, we’d like to test several variants of a condition. The else if clause lets us do that.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
        
      
      
      In the code above, JavaScript first checks year < 2015. If that is falsy, it goes to the next condition year > 2015. If that is also falsy, it shows the last alert.
There can be more else if blocks. The final else is optional.
Conditional operator ‘?’Sometimes, we need to assign a variable depending on a condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let accessAllowed;
let age = prompt('How old are you?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
        
      
      
      The so-called “conditional” or “question mark” operator lets us do that in a shorter and simpler way.
The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.
The syntax is:

      
        
        
          let result = condition ? value1 : value2;
        
      
      
      The condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.
For example:

      
        
        
          let accessAllowed = (age > 18) ? true : false;
        
      
      
      Technically, we can omit the parentheses around age > 18. The question mark operator has a low precedence, so it executes after the comparison >.
This example will do the same thing as the previous one:

      
        
        
          // the comparison operator "age > 18" executes first anyway
// (no need to wrap it into parentheses)
let accessAllowed = age > 18 ? true : false;
        
      
      
      But parentheses make the code more readable, so we recommend using them.

            Please note:
            In the example above, you can avoid using the question mark operator because the comparison itself returns true/false:

      
        
        
          // the same
let accessAllowed = age > 18;
        
      
      
      
Multiple ‘?’A sequence of question mark operators ? can return a value that depends on more than one condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
        
      
      
      It may be difficult at first to grasp what’s going on. But after a closer look, we can see that it’s just an ordinary sequence of tests:

The first question mark checks whether age < 3.
If true – it returns 'Hi, baby!'. Otherwise, it continues to the expression after the colon “:”, checking age < 18.
If that’s true – it returns 'Hello!'. Otherwise, it continues to the expression after the next colon “:”, checking age < 100.
If that’s true – it returns 'Greetings!'. Otherwise, it continues to the expression after the last colon “:”, returning 'What an unusual age!'.

Here’s how this looks using if..else:

      
        
        
          if (age < 3) {
  message = 'Hi, baby!';
} else if (age < 18) {
  message = 'Hello!';
} else if (age < 100) {
  message = 'Greetings!';
} else {
  message = 'What an unusual age!';
}
        
      
      
      Non-traditional use of ‘?’Sometimes the question mark ? is used as a replacement for if:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
        
      
      
      Depending on the condition company == 'Netscape', either the first or the second expression after the ? gets executed and shows an alert.
We don’t assign a result to a variable here. Instead, we execute different code depending on the condition.
It’s not recommended to use the question mark operator in this way.
The notation is shorter than the equivalent if statement, which appeals to some programmers. But it is less readable.
Here is the same code using if for comparison:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
}
        
      
      
      Our eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.
The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.
Tasksif (a string with zero)importance: 5Will alert be shown?

      
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      solutionYes, it will.
Any string except an empty one (and "0" is not empty) becomes true in the logical context.
We can run and check:

      
        
        
          
            
          
          
            
          
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      The name of JavaScriptimportance: 2Using the if..else construct, write the code which asks: ‘What is the “official” name of JavaScript?’
If the visitor enters “ECMAScript”, then output “Right!”, otherwise – output: “You don’t know? ECMAScript!”

      
      
        
      
      Demo in new windowsolution
      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE html>
<html>

<body>
  <script>
    'use strict';

    let value = prompt('What is the "official" name of JavaScript?', '');

    if (value == 'ECMAScript') {
      alert('Right!');
    } else {
      alert("You don't know? ECMAScript!");
    }
  </script>


</body>

</html>
        
      
      
      Show the signimportance: 2Using if..else, write the code which gets a number via prompt and then shows in alert:

1, if the value is greater than zero,
-1, if less than zero,
0, if equals zero.

In this task we assume that the input is always a number.
Demo in new windowsolution
      
        
        
          
            
          
          
            
          
        
        
          let value = prompt('Type a number', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}
        
      
      
      Rewrite 'if' into '?'importance: 5Rewrite this if using the conditional operator '?':

      
        
        
          let result;

if (a + b < 4) {
  result = 'Below';
} else {
  result = 'Over';
}
        
      
      
      solution
      
        
        
          let result = (a + b < 4) ? 'Below' : 'Over';
        
      
      
      Rewrite 'if..else' into '?'importance: 5Rewrite if..else using multiple ternary operators '?'.
For readability, it’s recommended to split the code into multiple lines.

      
        
        
          let message;

if (login == 'Employee') {
  message = 'Hello';
} else if (login == 'Director') {
  message = 'Greetings';
} else if (login == '') {
  message = 'No login';
} else {
  message = '';
}
        
      
      
      solution
      
        
        
          let message = (login == 'Employee') ? 'Hello' :
  (login == 'Director') ? 'Greetings' :
  (login == '') ? 'No login' :
  '';\n\nTutorialThe JavaScript languageJavaScript FundamentalsDecember 7, 2022Conditional branching: if, '?'Sometimes, we need to perform different actions based on different conditions.
To do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.
The “if” statementThe if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) alert( 'You are right!' );
        
      
      
      In the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.
If we want to execute more than one statement, we have to wrap our code block inside curly braces:

      
        
        
          if (year == 2015) {
  alert( "That's correct!" );
  alert( "You're so smart!" );
}
        
      
      
      We recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute. Doing so improves readability.
Boolean conversionThe if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.
Let’s recall the conversion rules from the chapter Type Conversions:

A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
Other values become true, so they are called “truthy”.

So, the code under this condition would never execute:

      
        
        
          if (0) { // 0 is falsy
  ...
}
        
      
      
      …and inside this condition – it always will:

      
        
        
          if (1) { // 1 is truthy
  ...
}
        
      
      
      We can also pass a pre-evaluated boolean value to if, like this:

      
        
        
          let cond = (year == 2015); // equality evaluates to true or false

if (cond) {
  ...
}
        
      
      
      The “else” clauseThe if statement may contain an optional else block. It executes when the condition is falsy.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
}
        
      
      
      Several conditions: “else if”Sometimes, we’d like to test several variants of a condition. The else if clause lets us do that.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
        
      
      
      In the code above, JavaScript first checks year < 2015. If that is falsy, it goes to the next condition year > 2015. If that is also falsy, it shows the last alert.
There can be more else if blocks. The final else is optional.
Conditional operator ‘?’Sometimes, we need to assign a variable depending on a condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let accessAllowed;
let age = prompt('How old are you?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
        
      
      
      The so-called “conditional” or “question mark” operator lets us do that in a shorter and simpler way.
The operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.
The syntax is:

      
        
        
          let result = condition ? value1 : value2;
        
      
      
      The condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.
For example:

      
        
        
          let accessAllowed = (age > 18) ? true : false;
        
      
      
      Technically, we can omit the parentheses around age > 18. The question mark operator has a low precedence, so it executes after the comparison >.
This example will do the same thing as the previous one:

      
        
        
          // the comparison operator "age > 18" executes first anyway
// (no need to wrap it into parentheses)
let accessAllowed = age > 18 ? true : false;
        
      
      
      But parentheses make the code more readable, so we recommend using them.

            Please note:
            In the example above, you can avoid using the question mark operator because the comparison itself returns true/false:

      
        
        
          // the same
let accessAllowed = age > 18;
        
      
      
      
Multiple ‘?’A sequence of question mark operators ? can return a value that depends on more than one condition.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
        
      
      
      It may be difficult at first to grasp what’s going on. But after a closer look, we can see that it’s just an ordinary sequence of tests:

The first question mark checks whether age < 3.
If true – it returns 'Hi, baby!'. Otherwise, it continues to the expression after the colon “:”, checking age < 18.
If that’s true – it returns 'Hello!'. Otherwise, it continues to the expression after the next colon “:”, checking age < 100.
If that’s true – it returns 'Greetings!'. Otherwise, it continues to the expression after the last colon “:”, returning 'What an unusual age!'.

Here’s how this looks using if..else:

      
        
        
          if (age < 3) {
  message = 'Hi, baby!';
} else if (age < 18) {
  message = 'Hello!';
} else if (age < 100) {
  message = 'Greetings!';
} else {
  message = 'What an unusual age!';
}
        
      
      
      Non-traditional use of ‘?’Sometimes the question mark ? is used as a replacement for if:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
        
      
      
      Depending on the condition company == 'Netscape', either the first or the second expression after the ? gets executed and shows an alert.
We don’t assign a result to a variable here. Instead, we execute different code depending on the condition.
It’s not recommended to use the question mark operator in this way.
The notation is shorter than the equivalent if statement, which appeals to some programmers. But it is less readable.
Here is the same code using if for comparison:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('Which company created JavaScript?', '');

if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
}
        
      
      
      Our eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.
The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.
Tasksif (a string with zero)importance: 5Will alert be shown?

      
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      solutionYes, it will.
Any string except an empty one (and "0" is not empty) becomes true in the logical context.
We can run and check:

      
        
        
          
            
          
          
            
          
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      The name of JavaScriptimportance: 2Using the if..else construct, write the code which asks: ‘What is the “official” name of JavaScript?’
If the visitor enters “ECMAScript”, then output “Right!”, otherwise – output: “You don’t know? ECMAScript!”

      
      
        
      
      Demo in new windowsolution
      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE html>
<html>

<body>
  <script>
    'use strict';

    let value = prompt('What is the "official" name of JavaScript?', '');

    if (value == 'ECMAScript') {
      alert('Right!');
    } else {
      alert("You don't know? ECMAScript!");
    }
  </script>


</body>

</html>
        
      
      
      Show the signimportance: 2Using if..else, write the code which gets a number via prompt and then shows in alert:

1, if the value is greater than zero,
-1, if less than zero,
0, if equals zero.

In this task we assume that the input is always a number.
Demo in new windowsolution
      
        
        
          
            
          
          
            
          
        
        
          let value = prompt('Type a number', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}
        
      
      
      Rewrite 'if' into '?'importance: 5Rewrite this if using the conditional operator '?':

      
        
        
          let result;

if (a + b < 4) {
  result = 'Below';
} else {
  result = 'Over';
}
        
      
      
      solution
      
        
        
          let result = (a + b < 4) ? 'Below' : 'Over';
        
      
      
      Rewrite 'if..else' into '?'importance: 5Rewrite if..else using multiple ternary operators '?'.
For readability, it’s recommended to split the code into multiple lines.

      
        
        
          let message;

if (login == 'Employee') {
  message = 'Hello';
} else if (login == 'Director') {
  message = 'Greetings';
} else if (login == '') {
  message = 'No login';
} else {
  message = '';
}
        
      
      
      solution
      
        
        
          let message = (login == 'Employee') ? 'Hello' :
  (login == 'Director') ? 'Greetings' :
  (login == '') ? 'No login' :
  '';
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThere are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing). Here we cover the first three, the ?? operator is in the next article.
Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.
Let’s see the details.
|| (OR)The “OR” operator is represented with two vertical line symbols:

      
        
        
          result = a || b;
        
      
      
      In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.
In JavaScript, the operator is a little bit trickier and more powerful. But first, let’s see what happens with boolean values.
There are four possible logical combinations:

      
        
        
          
            
          
          
            
          
        
        
          alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
        
      
      
      As we can see, the result is always true except for the case when both operands are false.
If an operand is not a boolean, it’s converted to a boolean for the evaluation.
For instance, the number 1 is treated as true, the number 0 as false:

      
        
        
          
            
          
          
            
          
        
        
          if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}
        
      
      
      Most of the time, OR || is used in an if statement to test if any of the given conditions is true.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'The office is closed.' );
}
        
      
      
      We can pass more conditions:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // it is the weekend
}
        
      
      
      OR "||" finds the first truthy valueThe logic described above is somewhat classical. Now, let’s bring in the “extra” features of JavaScript.
The extended algorithm works as follows.
Given multiple OR’ed values:

      
        
        
          result = value1 || value2 || value3;
        
      
      
      The OR || operator does the following:

Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.

A value is returned in its original form, without the conversion.
In other words, a chain of OR || returns the first truthy value or the last one if no truthy value is found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 || 0 ); // 1 (1 is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)

alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
        
      
      
      This leads to some interesting usage compared to a “pure, classical, boolean-only OR”.


Getting the first truthy value from a list of variables or expressions.
For instance, we have firstName, lastName and nickName variables, all optional (i.e. can be undefined or have falsy values).
Let’s use OR || to choose the one that has the data and show it (or "Anonymous" if nothing set):

      
        
        
          
            
          
          
            
          
        
        
          let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
        
      
      
      If all variables were falsy, "Anonymous" would show up.


Short-circuit evaluation.
Another feature of OR || operator is the so-called “short-circuit” evaluation.
It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.
The importance of this feature becomes obvious if an operand isn’t just a value, but an expression with a side effect, such as a variable assignment or a function call.
In the example below, only the second message is printed:

      
        
        
          
            
          
          
            
          
        
        
          true || alert("not printed");
false || alert("printed");
        
      
      
      In the first line, the OR || operator stops the evaluation immediately upon seeing true, so the alert isn’t run.
Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.


&& (AND)The AND operator is represented with two ampersands &&:

      
        
        
          result = a && b;
        
      
      
      In classical programming, AND returns true if both operands are truthy and false otherwise:

      
        
        
          
            
          
          
            
          
        
        
          alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
        
      
      
      An example with if:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}
        
      
      
      Just as with OR, any value is allowed as an operand of AND:

      
        
        
          
            
          
          
            
          
        
        
          if (1 && 0) { // evaluated as true && false
  alert( "won't work, because the result is falsy" );
}
        
      
      
      AND “&&” finds the first falsy valueGiven multiple AND’ed values:

      
        
        
          result = value1 && value2 && value3;
        
      
      
      The AND && operator does the following:

Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.

In other words, AND returns the first falsy value or the last value if none were found.
The rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy one.
Examples:

      
        
        
          
            
          
          
            
          
        
        
          // if the first operand is truthy,
// AND returns the second operand:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// if the first operand is falsy,
// AND returns it. The second operand is ignored
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
        
      
      
      We can also pass several values in a row. See how the first falsy one is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && null && 3 ); // null
        
      
      
      When all values are truthy, the last value is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && 3 ); // 3, the last one
        
      
      
      
            Precedence of AND && is higher than OR ||
            The precedence of AND && operator is higher than OR ||.
So the code a && b || c && d is essentially the same as if the && expressions were in parentheses: (a && b) || (c && d).


            Don’t replace if with || or &&
            Sometimes, people use the AND && operator as a “shorter way to write if”.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

(x > 0) && alert( 'Greater than zero!' );
        
      
      
      The action in the right part of && would execute only if the evaluation reaches it. That is, only if (x > 0) is true.
So we basically have an analogue for:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

if (x > 0) alert( 'Greater than zero!' );
        
      
      
      Although, the variant with && appears shorter, if is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use if if we want if and use && if we want AND.

! (NOT)The boolean NOT operator is represented with an exclamation sign !.
The syntax is pretty simple:

      
        
        
          result = !value;
        
      
      
      The operator accepts a single argument and does the following:

Converts the operand to boolean type: true/false.
Returns the inverse value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( !true ); // false
alert( !0 ); // true
        
      
      
      A double NOT !! is sometimes used for converting a value to boolean type:

      
        
        
          
            
          
          
            
          
        
        
          alert( !!"non-empty string" ); // true
alert( !!null ); // false
        
      
      
      That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.
There’s a little more verbose way to do the same thing – a built-in Boolean function:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
        
      
      
      The precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJune 5, 2022Logical operatorsThere are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing). Here we cover the first three, the ?? operator is in the next article.
Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.
Let’s see the details.
|| (OR)The “OR” operator is represented with two vertical line symbols:

      
        
        
          result = a || b;
        
      
      
      In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.
In JavaScript, the operator is a little bit trickier and more powerful. But first, let’s see what happens with boolean values.
There are four possible logical combinations:

      
        
        
          
            
          
          
            
          
        
        
          alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
        
      
      
      As we can see, the result is always true except for the case when both operands are false.
If an operand is not a boolean, it’s converted to a boolean for the evaluation.
For instance, the number 1 is treated as true, the number 0 as false:

      
        
        
          
            
          
          
            
          
        
        
          if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}
        
      
      
      Most of the time, OR || is used in an if statement to test if any of the given conditions is true.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'The office is closed.' );
}
        
      
      
      We can pass more conditions:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // it is the weekend
}
        
      
      
      OR "||" finds the first truthy valueThe logic described above is somewhat classical. Now, let’s bring in the “extra” features of JavaScript.
The extended algorithm works as follows.
Given multiple OR’ed values:

      
        
        
          result = value1 || value2 || value3;
        
      
      
      The OR || operator does the following:

Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.

A value is returned in its original form, without the conversion.
In other words, a chain of OR || returns the first truthy value or the last one if no truthy value is found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 || 0 ); // 1 (1 is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)

alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
        
      
      
      This leads to some interesting usage compared to a “pure, classical, boolean-only OR”.


Getting the first truthy value from a list of variables or expressions.
For instance, we have firstName, lastName and nickName variables, all optional (i.e. can be undefined or have falsy values).
Let’s use OR || to choose the one that has the data and show it (or "Anonymous" if nothing set):

      
        
        
          
            
          
          
            
          
        
        
          let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
        
      
      
      If all variables were falsy, "Anonymous" would show up.


Short-circuit evaluation.
Another feature of OR || operator is the so-called “short-circuit” evaluation.
It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.
The importance of this feature becomes obvious if an operand isn’t just a value, but an expression with a side effect, such as a variable assignment or a function call.
In the example below, only the second message is printed:

      
        
        
          
            
          
          
            
          
        
        
          true || alert("not printed");
false || alert("printed");
        
      
      
      In the first line, the OR || operator stops the evaluation immediately upon seeing true, so the alert isn’t run.
Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.


&& (AND)The AND operator is represented with two ampersands &&:

      
        
        
          result = a && b;
        
      
      
      In classical programming, AND returns true if both operands are truthy and false otherwise:

      
        
        
          
            
          
          
            
          
        
        
          alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
        
      
      
      An example with if:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}
        
      
      
      Just as with OR, any value is allowed as an operand of AND:

      
        
        
          
            
          
          
            
          
        
        
          if (1 && 0) { // evaluated as true && false
  alert( "won't work, because the result is falsy" );
}
        
      
      
      AND “&&” finds the first falsy valueGiven multiple AND’ed values:

      
        
        
          result = value1 && value2 && value3;
        
      
      
      The AND && operator does the following:

Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.

In other words, AND returns the first falsy value or the last value if none were found.
The rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy one.
Examples:

      
        
        
          
            
          
          
            
          
        
        
          // if the first operand is truthy,
// AND returns the second operand:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// if the first operand is falsy,
// AND returns it. The second operand is ignored
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
        
      
      
      We can also pass several values in a row. See how the first falsy one is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && null && 3 ); // null
        
      
      
      When all values are truthy, the last value is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && 3 ); // 3, the last one
        
      
      
      
            Precedence of AND && is higher than OR ||
            The precedence of AND && operator is higher than OR ||.
So the code a && b || c && d is essentially the same as if the && expressions were in parentheses: (a && b) || (c && d).


            Don’t replace if with || or &&
            Sometimes, people use the AND && operator as a “shorter way to write if”.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

(x > 0) && alert( 'Greater than zero!' );
        
      
      
      The action in the right part of && would execute only if the evaluation reaches it. That is, only if (x > 0) is true.
So we basically have an analogue for:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

if (x > 0) alert( 'Greater than zero!' );
        
      
      
      Although, the variant with && appears shorter, if is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use if if we want if and use && if we want AND.

! (NOT)The boolean NOT operator is represented with an exclamation sign !.
The syntax is pretty simple:

      
        
        
          result = !value;
        
      
      
      The operator accepts a single argument and does the following:

Converts the operand to boolean type: true/false.
Returns the inverse value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( !true ); // false
alert( !0 ); // true
        
      
      
      A double NOT !! is sometimes used for converting a value to boolean type:

      
        
        
          
            
          
          
            
          
        
        
          alert( !!"non-empty string" ); // true
alert( !!null ); // false
        
      
      
      That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.
There’s a little more verbose way to do the same thing – a built-in Boolean function:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
        
      
      
      The precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.
TasksWhat's the result of OR?importance: 5What is the code below going to output?

      
        
        
          alert( null || 2 || undefined );
        
      
      
      solutionThe answer is 2, that’s the first truthy value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 || undefined );
        
      
      
      What's the result of OR'ed alerts?importance: 3What will the code below output?

      
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      solutionThe answer: first 1, then 2.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      The call to alert does not return a value. Or, in other words, it returns undefined.

The first OR || evaluates its left operand alert(1). That shows the first message with 1.
The alert returns undefined, so OR goes on to the second operand searching for a truthy value.
The second operand 2 is truthy, so the execution is halted, 2 is returned and then shown by the outer alert.

There will be no 3, because the evaluation does not reach alert(3).
What is the result of AND?importance: 5What is this code going to show?

      
        
        
          alert( 1 && null && 2 );
        
      
      
      solutionThe answer: null, because it’s the first falsy value from the list.

      
        
        
          
            
          
          
            
          
        
        
          alert(1 && null && 2);
        
      
      
      What is the result of AND'ed alerts?importance: 3What will this code show?

      
        
        
          alert( alert(1) && alert(2) );
        
      
      
      solutionThe answer: 1, and then undefined.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) && alert(2) );
        
      
      
      The call to alert returns undefined (it just shows a message, so there’s no meaningful return).
Because of that, && evaluates the left operand (outputs 1), and immediately stops, because undefined is a falsy value. And && looks for a falsy value and returns it, so it’s done.
The result of OR AND ORimportance: 5What will the result be?

      
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      solutionThe answer: 3.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      The precedence of AND && is higher than ||, so it executes first.
The result of 2 && 3 = 3, so the expression becomes:

      
        
        
          null || 3 || 4
        
      
      
      Now the result is the first truthy value: 3.
Check the range betweenimportance: 3Write an if condition to check that age is between 14 and 90 inclusively.
“Inclusively” means that age can reach the edges 14 or 90.
solution
      
        
        
          if (age >= 14 && age <= 90)
        
      
      
      Check the range outsideimportance: 3Write an if condition to check that age is NOT between 14 and 90 inclusively.
Create two variants: the first one using NOT !, the second one – without it.
solutionThe first variant:

      
        
        
          if (!(age >= 14 && age <= 90))
        
      
      
      The second variant:

      
        
        
          if (age < 14 || age > 90)
        
      
      
      A question about "if"importance: 5Which of these alerts are going to execute?
What will the results of the expressions be inside if(...)?

      
        
        
          if (-1 || 0) alert( 'first' );
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );
        
      
      
      solutionThe answer: the first and the third will execute.
Details:

      
        
        
          
            
          
          
            
          
        
        
          // Runs.
// The result of -1 || 0 = -1, truthy
if (-1 || 0) alert( 'first' );

// Doesn't run
// -1 && 0 = 0, falsy
if (-1 && 0) alert( 'second' );

// Executes
// Operator && has a higher precedence than ||
// so -1 && 1 executes first, giving us the chain:
// null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );
        
      
      
      Check the loginimportance: 3Write the code which asks for a login with prompt.
If the visitor enters "Admin", then prompt for a password, if the input is an empty line or Esc – show “Canceled”, if it’s another string – then show “I don’t know you”.
The password is checked as follows:

If it equals “TheMaster”, then show “Welcome!”,
Another string – show “Wrong password”,
For an empty string or cancelled input, show “Canceled”

The schema:

      
      
        
      
      Please use nested if blocks. Mind the overall readability of the code.
Hint:  passing an empty input to a prompt returns an empty string ''. Pressing ESC during a prompt returns null.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Who's there?", '');

if (userName === 'Admin') {

  let pass = prompt('Password?', '');

  if (pass === 'TheMaster') {
    alert( 'Welcome!' );
  } else if (pass === '' || pass === null) {
    alert( 'Canceled' );
  } else {
    alert( 'Wrong password' );
  }

} else if (userName === '' || userName === null) {
  alert( 'Canceled' );
} else {
  alert( "I don't know you" );
}
        
      
      
      Note the vertical indents inside the if blocks. They are technically not required, but make the code more readable.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThere are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing). Here we cover the first three, the ?? operator is in the next article.
Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.
Let’s see the details.
|| (OR)The “OR” operator is represented with two vertical line symbols:

      
        
        
          result = a || b;
        
      
      
      In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.
In JavaScript, the operator is a little bit trickier and more powerful. But first, let’s see what happens with boolean values.
There are four possible logical combinations:

      
        
        
          
            
          
          
            
          
        
        
          alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
        
      
      
      As we can see, the result is always true except for the case when both operands are false.
If an operand is not a boolean, it’s converted to a boolean for the evaluation.
For instance, the number 1 is treated as true, the number 0 as false:

      
        
        
          
            
          
          
            
          
        
        
          if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}
        
      
      
      Most of the time, OR || is used in an if statement to test if any of the given conditions is true.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'The office is closed.' );
}
        
      
      
      We can pass more conditions:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // it is the weekend
}
        
      
      
      OR "||" finds the first truthy valueThe logic described above is somewhat classical. Now, let’s bring in the “extra” features of JavaScript.
The extended algorithm works as follows.
Given multiple OR’ed values:

      
        
        
          result = value1 || value2 || value3;
        
      
      
      The OR || operator does the following:

Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.

A value is returned in its original form, without the conversion.
In other words, a chain of OR || returns the first truthy value or the last one if no truthy value is found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 || 0 ); // 1 (1 is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)

alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
        
      
      
      This leads to some interesting usage compared to a “pure, classical, boolean-only OR”.


Getting the first truthy value from a list of variables or expressions.
For instance, we have firstName, lastName and nickName variables, all optional (i.e. can be undefined or have falsy values).
Let’s use OR || to choose the one that has the data and show it (or "Anonymous" if nothing set):

      
        
        
          
            
          
          
            
          
        
        
          let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
        
      
      
      If all variables were falsy, "Anonymous" would show up.


Short-circuit evaluation.
Another feature of OR || operator is the so-called “short-circuit” evaluation.
It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.
The importance of this feature becomes obvious if an operand isn’t just a value, but an expression with a side effect, such as a variable assignment or a function call.
In the example below, only the second message is printed:

      
        
        
          
            
          
          
            
          
        
        
          true || alert("not printed");
false || alert("printed");
        
      
      
      In the first line, the OR || operator stops the evaluation immediately upon seeing true, so the alert isn’t run.
Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.


&& (AND)The AND operator is represented with two ampersands &&:

      
        
        
          result = a && b;
        
      
      
      In classical programming, AND returns true if both operands are truthy and false otherwise:

      
        
        
          
            
          
          
            
          
        
        
          alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
        
      
      
      An example with if:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}
        
      
      
      Just as with OR, any value is allowed as an operand of AND:

      
        
        
          
            
          
          
            
          
        
        
          if (1 && 0) { // evaluated as true && false
  alert( "won't work, because the result is falsy" );
}
        
      
      
      AND “&&” finds the first falsy valueGiven multiple AND’ed values:

      
        
        
          result = value1 && value2 && value3;
        
      
      
      The AND && operator does the following:

Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.

In other words, AND returns the first falsy value or the last value if none were found.
The rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy one.
Examples:

      
        
        
          
            
          
          
            
          
        
        
          // if the first operand is truthy,
// AND returns the second operand:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// if the first operand is falsy,
// AND returns it. The second operand is ignored
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
        
      
      
      We can also pass several values in a row. See how the first falsy one is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && null && 3 ); // null
        
      
      
      When all values are truthy, the last value is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && 3 ); // 3, the last one
        
      
      
      
            Precedence of AND && is higher than OR ||
            The precedence of AND && operator is higher than OR ||.
So the code a && b || c && d is essentially the same as if the && expressions were in parentheses: (a && b) || (c && d).


            Don’t replace if with || or &&
            Sometimes, people use the AND && operator as a “shorter way to write if”.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

(x > 0) && alert( 'Greater than zero!' );
        
      
      
      The action in the right part of && would execute only if the evaluation reaches it. That is, only if (x > 0) is true.
So we basically have an analogue for:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

if (x > 0) alert( 'Greater than zero!' );
        
      
      
      Although, the variant with && appears shorter, if is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use if if we want if and use && if we want AND.

! (NOT)The boolean NOT operator is represented with an exclamation sign !.
The syntax is pretty simple:

      
        
        
          result = !value;
        
      
      
      The operator accepts a single argument and does the following:

Converts the operand to boolean type: true/false.
Returns the inverse value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( !true ); // false
alert( !0 ); // true
        
      
      
      A double NOT !! is sometimes used for converting a value to boolean type:

      
        
        
          
            
          
          
            
          
        
        
          alert( !!"non-empty string" ); // true
alert( !!null ); // false
        
      
      
      That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.
There’s a little more verbose way to do the same thing – a built-in Boolean function:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
        
      
      
      The precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.
TasksWhat's the result of OR?importance: 5What is the code below going to output?

      
        
        
          alert( null || 2 || undefined );
        
      
      
      solutionThe answer is 2, that’s the first truthy value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 || undefined );
        
      
      
      What's the result of OR'ed alerts?importance: 3What will the code below output?

      
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      solutionThe answer: first 1, then 2.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      The call to alert does not return a value. Or, in other words, it returns undefined.

The first OR || evaluates its left operand alert(1). That shows the first message with 1.
The alert returns undefined, so OR goes on to the second operand searching for a truthy value.
The second operand 2 is truthy, so the execution is halted, 2 is returned and then shown by the outer alert.

There will be no 3, because the evaluation does not reach alert(3).
What is the result of AND?importance: 5What is this code going to show?

      
        
        
          alert( 1 && null && 2 );
        
      
      
      solutionThe answer: null, because it’s the first falsy value from the list.

      
        
        
          
            
          
          
            
          
        
        
          alert(1 && null && 2);
        
      
      
      What is the result of AND'ed alerts?importance: 3What will this code show?

      
        
        
          alert( alert(1) && alert(2) );
        
      
      
      solutionThe answer: 1, and then undefined.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) && alert(2) );
        
      
      
      The call to alert returns undefined (it just shows a message, so there’s no meaningful return).
Because of that, && evaluates the left operand (outputs 1), and immediately stops, because undefined is a falsy value. And && looks for a falsy value and returns it, so it’s done.
The result of OR AND ORimportance: 5What will the result be?

      
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      solutionThe answer: 3.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      The precedence of AND && is higher than ||, so it executes first.
The result of 2 && 3 = 3, so the expression becomes:

      
        
        
          null || 3 || 4
        
      
      
      Now the result is the first truthy value: 3.
Check the range betweenimportance: 3Write an if condition to check that age is between 14 and 90 inclusively.
“Inclusively” means that age can reach the edges 14 or 90.
solution
      
        
        
          if (age >= 14 && age <= 90)
        
      
      
      Check the range outsideimportance: 3Write an if condition to check that age is NOT between 14 and 90 inclusively.
Create two variants: the first one using NOT !, the second one – without it.
solutionThe first variant:

      
        
        
          if (!(age >= 14 && age <= 90))
        
      
      
      The second variant:

      
        
        
          if (age < 14 || age > 90)
        
      
      
      A question about "if"importance: 5Which of these alerts are going to execute?
What will the results of the expressions be inside if(...)?

      
        
        
          if (-1 || 0) alert( 'first' );
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );
        
      
      
      solutionThe answer: the first and the third will execute.
Details:

      
        
        
          
            
          
          
            
          
        
        
          // Runs.
// The result of -1 || 0 = -1, truthy
if (-1 || 0) alert( 'first' );

// Doesn't run
// -1 && 0 = 0, falsy
if (-1 && 0) alert( 'second' );

// Executes
// Operator && has a higher precedence than ||
// so -1 && 1 executes first, giving us the chain:
// null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );
        
      
      
      Check the loginimportance: 3Write the code which asks for a login with prompt.
If the visitor enters "Admin", then prompt for a password, if the input is an empty line or Esc – show “Canceled”, if it’s another string – then show “I don’t know you”.
The password is checked as follows:

If it equals “TheMaster”, then show “Welcome!”,
Another string – show “Wrong password”,
For an empty string or cancelled input, show “Canceled”

The schema:

      
      
        
      
      Please use nested if blocks. Mind the overall readability of the code.
Hint:  passing an empty input to a prompt returns an empty string ''. Pressing ESC during a prompt returns null.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Who's there?", '');

if (userName === 'Admin') {

  let pass = prompt('Password?', '');

  if (pass === 'TheMaster') {
    alert( 'Welcome!' );
  } else if (pass === '' || pass === null) {
    alert( 'Canceled' );
  } else {
    alert( 'Wrong password' );
  }

} else if (userName === '' || userName === null) {
  alert( 'Canceled' );
} else {
  alert( "I don't know you" );
}
        
      
      
      Note the vertical indents inside the if blocks. They are technically not required, but make the code more readable.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJune 5, 2022Logical operatorsThere are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing). Here we cover the first three, the ?? operator is in the next article.
Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.
Let’s see the details.
|| (OR)The “OR” operator is represented with two vertical line symbols:

      
        
        
          result = a || b;
        
      
      
      In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.
In JavaScript, the operator is a little bit trickier and more powerful. But first, let’s see what happens with boolean values.
There are four possible logical combinations:

      
        
        
          
            
          
          
            
          
        
        
          alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
        
      
      
      As we can see, the result is always true except for the case when both operands are false.
If an operand is not a boolean, it’s converted to a boolean for the evaluation.
For instance, the number 1 is treated as true, the number 0 as false:

      
        
        
          
            
          
          
            
          
        
        
          if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}
        
      
      
      Most of the time, OR || is used in an if statement to test if any of the given conditions is true.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'The office is closed.' );
}
        
      
      
      We can pass more conditions:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // it is the weekend
}
        
      
      
      OR "||" finds the first truthy valueThe logic described above is somewhat classical. Now, let’s bring in the “extra” features of JavaScript.
The extended algorithm works as follows.
Given multiple OR’ed values:

      
        
        
          result = value1 || value2 || value3;
        
      
      
      The OR || operator does the following:

Evaluates operands from left to right.
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.

A value is returned in its original form, without the conversion.
In other words, a chain of OR || returns the first truthy value or the last one if no truthy value is found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 || 0 ); // 1 (1 is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)

alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
        
      
      
      This leads to some interesting usage compared to a “pure, classical, boolean-only OR”.


Getting the first truthy value from a list of variables or expressions.
For instance, we have firstName, lastName and nickName variables, all optional (i.e. can be undefined or have falsy values).
Let’s use OR || to choose the one that has the data and show it (or "Anonymous" if nothing set):

      
        
        
          
            
          
          
            
          
        
        
          let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
        
      
      
      If all variables were falsy, "Anonymous" would show up.


Short-circuit evaluation.
Another feature of OR || operator is the so-called “short-circuit” evaluation.
It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.
The importance of this feature becomes obvious if an operand isn’t just a value, but an expression with a side effect, such as a variable assignment or a function call.
In the example below, only the second message is printed:

      
        
        
          
            
          
          
            
          
        
        
          true || alert("not printed");
false || alert("printed");
        
      
      
      In the first line, the OR || operator stops the evaluation immediately upon seeing true, so the alert isn’t run.
Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.


&& (AND)The AND operator is represented with two ampersands &&:

      
        
        
          result = a && b;
        
      
      
      In classical programming, AND returns true if both operands are truthy and false otherwise:

      
        
        
          
            
          
          
            
          
        
        
          alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
        
      
      
      An example with if:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}
        
      
      
      Just as with OR, any value is allowed as an operand of AND:

      
        
        
          
            
          
          
            
          
        
        
          if (1 && 0) { // evaluated as true && false
  alert( "won't work, because the result is falsy" );
}
        
      
      
      AND “&&” finds the first falsy valueGiven multiple AND’ed values:

      
        
        
          result = value1 && value2 && value3;
        
      
      
      The AND && operator does the following:

Evaluates operands from left to right.
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.

In other words, AND returns the first falsy value or the last value if none were found.
The rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy one.
Examples:

      
        
        
          
            
          
          
            
          
        
        
          // if the first operand is truthy,
// AND returns the second operand:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// if the first operand is falsy,
// AND returns it. The second operand is ignored
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
        
      
      
      We can also pass several values in a row. See how the first falsy one is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && null && 3 ); // null
        
      
      
      When all values are truthy, the last value is returned:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 && 2 && 3 ); // 3, the last one
        
      
      
      
            Precedence of AND && is higher than OR ||
            The precedence of AND && operator is higher than OR ||.
So the code a && b || c && d is essentially the same as if the && expressions were in parentheses: (a && b) || (c && d).


            Don’t replace if with || or &&
            Sometimes, people use the AND && operator as a “shorter way to write if”.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

(x > 0) && alert( 'Greater than zero!' );
        
      
      
      The action in the right part of && would execute only if the evaluation reaches it. That is, only if (x > 0) is true.
So we basically have an analogue for:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

if (x > 0) alert( 'Greater than zero!' );
        
      
      
      Although, the variant with && appears shorter, if is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use if if we want if and use && if we want AND.

! (NOT)The boolean NOT operator is represented with an exclamation sign !.
The syntax is pretty simple:

      
        
        
          result = !value;
        
      
      
      The operator accepts a single argument and does the following:

Converts the operand to boolean type: true/false.
Returns the inverse value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( !true ); // false
alert( !0 ); // true
        
      
      
      A double NOT !! is sometimes used for converting a value to boolean type:

      
        
        
          
            
          
          
            
          
        
        
          alert( !!"non-empty string" ); // true
alert( !!null ); // false
        
      
      
      That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.
There’s a little more verbose way to do the same thing – a built-in Boolean function:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
        
      
      
      The precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.
TasksWhat's the result of OR?importance: 5What is the code below going to output?

      
        
        
          alert( null || 2 || undefined );
        
      
      
      solutionThe answer is 2, that’s the first truthy value.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 || undefined );
        
      
      
      What's the result of OR'ed alerts?importance: 3What will the code below output?

      
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      solutionThe answer: first 1, then 2.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      The call to alert does not return a value. Or, in other words, it returns undefined.

The first OR || evaluates its left operand alert(1). That shows the first message with 1.
The alert returns undefined, so OR goes on to the second operand searching for a truthy value.
The second operand 2 is truthy, so the execution is halted, 2 is returned and then shown by the outer alert.

There will be no 3, because the evaluation does not reach alert(3).
What is the result of AND?importance: 5What is this code going to show?

      
        
        
          alert( 1 && null && 2 );
        
      
      
      solutionThe answer: null, because it’s the first falsy value from the list.

      
        
        
          
            
          
          
            
          
        
        
          alert(1 && null && 2);
        
      
      
      What is the result of AND'ed alerts?importance: 3What will this code show?

      
        
        
          alert( alert(1) && alert(2) );
        
      
      
      solutionThe answer: 1, and then undefined.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) && alert(2) );
        
      
      
      The call to alert returns undefined (it just shows a message, so there’s no meaningful return).
Because of that, && evaluates the left operand (outputs 1), and immediately stops, because undefined is a falsy value. And && looks for a falsy value and returns it, so it’s done.
The result of OR AND ORimportance: 5What will the result be?

      
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      solutionThe answer: 3.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      The precedence of AND && is higher than ||, so it executes first.
The result of 2 && 3 = 3, so the expression becomes:

      
        
        
          null || 3 || 4
        
      
      
      Now the result is the first truthy value: 3.
Check the range betweenimportance: 3Write an if condition to check that age is between 14 and 90 inclusively.
“Inclusively” means that age can reach the edges 14 or 90.
solution
      
        
        
          if (age >= 14 && age <= 90)
        
      
      
      Check the range outsideimportance: 3Write an if condition to check that age is NOT between 14 and 90 inclusively.
Create two variants: the first one using NOT !, the second one – without it.
solutionThe first variant:

      
        
        
          if (!(age >= 14 && age <= 90))
        
      
      
      The second variant:

      
        
        
          if (age < 14 || age > 90)
        
      
      
      A question about "if"importance: 5Which of these alerts are going to execute?
What will the results of the expressions be inside if(...)?

      
        
        
          if (-1 || 0) alert( 'first' );
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );
        
      
      
      solutionThe answer: the first and the third will execute.
Details:

      
        
        
          
            
          
          
            
          
        
        
          // Runs.
// The result of -1 || 0 = -1, truthy
if (-1 || 0) alert( 'first' );

// Doesn't run
// -1 && 0 = 0, falsy
if (-1 && 0) alert( 'second' );

// Executes
// Operator && has a higher precedence than ||
// so -1 && 1 executes first, giving us the chain:
// null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );
        
      
      
      Check the loginimportance: 3Write the code which asks for a login with prompt.
If the visitor enters "Admin", then prompt for a password, if the input is an empty line or Esc – show “Canceled”, if it’s another string – then show “I don’t know you”.
The password is checked as follows:

If it equals “TheMaster”, then show “Welcome!”,
Another string – show “Wrong password”,
For an empty string or cancelled input, show “Canceled”

The schema:

      
      
        
      
      Please use nested if blocks. Mind the overall readability of the code.
Hint:  passing an empty input to a prompt returns an empty string ''. Pressing ESC during a prompt returns null.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Who's there?", '');

if (userName === 'Admin') {

  let pass = prompt('Password?', '');

  if (pass === 'TheMaster') {
    alert( 'Welcome!' );
  } else if (pass === '' || pass === null) {
    alert( 'Canceled' );
  } else {
    alert( 'Wrong password' );
  }

} else if (userName === '' || userName === null) {
  alert( 'Canceled' );
} else {
  alert( "I don't know you" );
}
        
      
      
      Note the vertical indents inside the if blocks. They are technically not required, but make the code more readable.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nA recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The nullish coalescing operator is written as two question marks ??.
As it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.
The result of a ?? b is:

if a is defined, then a,
if a isn’t defined, then b.

In other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.
The nullish coalescing operator isn’t anything completely new. It’s just a nice syntax to get the first “defined” value of the two.
We can rewrite result = a ?? b using the operators that we already know, like this:

      
        
        
          result = (a !== null && a !== undefined) ? a : b;
        
      
      
      Now it should be absolutely clear what ?? does. Let’s see where it helps.
The common use case for ?? is to provide a default value.
For example, here we show user if its value isn’t null/undefined, otherwise Anonymous:

      
        
        
          
            
          
          
            
          
        
        
          let user;

alert(user ?? "Anonymous"); // Anonymous (user is undefined)
        
      
      
      Here’s the example with user assigned to a name:

      
        
        
          
            
          
          
            
          
        
        
          let user = "John";

alert(user ?? "Anonymous"); // John (user is not null/undefined)
        
      
      
      We can also use a sequence of ?? to select the first value from a list that isn’t null/undefined.
Let’s say we have a user’s data in variables firstName, lastName or nickName. All of them may be not defined, if the user decided not to fill in the corresponding values.
We’d like to display the user name using one of these variables, or show “Anonymous” if all of them are null/undefined.
Let’s use the ?? operator for that:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first defined value:
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
        
      
      
      Comparison with ||The OR || operator can be used in the same way as ??, as it was described in the previous chapter.
For example, in the code above we could replace ?? with || and still get the same result:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first truthy value:
alert(firstName || lastName || nickName || "Anonymous"); // Supercoder
        
      
      
      Historically, the OR || operator was there first. It’s been there since the beginning of JavaScript, so developers were using it for such purposes for a long time.
On the other hand, the nullish coalescing operator ?? was added to JavaScript only recently, and the reason for that was that people weren’t quite happy with ||.
The important difference between them is that:

|| returns the first truthy value.
?? returns the first defined value.

In other words, || doesn’t distinguish between false, 0, an empty string "" and null/undefined. They are all the same – falsy values. If any of these is the first argument of ||, then we’ll get the second argument as the result.
In practice though, we may want to use default value only when the variable is null/undefined. That is, when the value is really unknown/not set.
For example, consider this:

      
        
        
          
            
          
          
            
          
        
        
          let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
        
      
      
      
The height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.

so the result of || is the second argument, 100.


The height ?? 100 checks height for being null/undefined, and it’s not,

so the result is height “as is”, that is 0.



In practice, the zero height is often a valid value, that shouldn’t be replaced with the default. So ?? does just the right thing.
PrecedenceThe precedence of the ?? operator is the same as ||. They both equal 3 in the MDN table.
That means that, just like ||, the nullish coalescing operator ?? is evaluated before = and ?, but after most other operations, such as +, *.
So we may need to add parentheses in expressions like this:

      
        
        
          
            
          
          
            
          
        
        
          let height = null;
let width = null;

// important: use parentheses
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
        
      
      
      Otherwise, if we omit parentheses, then as * has the higher precedence than ??, it would execute first, leading to incorrect results.

      
        
        
          // without parentheses
let area = height ?? 100 * width ?? 50;

// ...works this way (not what we want):
let area = height ?? (100 * width) ?? 50;
        
      
      
      Using ?? with && or ||Due to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.
The code below triggers a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1 && 2 ?? 3; // Syntax error
        
      
      
      The limitation is surely debatable, it was added to the language specification with the purpose to avoid programming mistakes, when people start to switch from || to ??.
Use explicit parentheses to work around it:

      
        
        
          
            
          
          
            
          
        
        
          let x = (1 && 2) ?? 3; // Works

alert(x); // 2
        
      
      
      Summary

The nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.
It’s used to assign default values to variables:

      
        
        
          // set height=100, if height is null or undefined
height = height ?? 100;
        
      
      
      

The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.


It’s forbidden to use it with || or && without explicit parentheses.\n\nTutorialThe JavaScript languageJavaScript FundamentalsApril 23, 2023Nullish coalescing operator '??'
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The nullish coalescing operator is written as two question marks ??.
As it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.
The result of a ?? b is:

if a is defined, then a,
if a isn’t defined, then b.

In other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.
The nullish coalescing operator isn’t anything completely new. It’s just a nice syntax to get the first “defined” value of the two.
We can rewrite result = a ?? b using the operators that we already know, like this:

      
        
        
          result = (a !== null && a !== undefined) ? a : b;
        
      
      
      Now it should be absolutely clear what ?? does. Let’s see where it helps.
The common use case for ?? is to provide a default value.
For example, here we show user if its value isn’t null/undefined, otherwise Anonymous:

      
        
        
          
            
          
          
            
          
        
        
          let user;

alert(user ?? "Anonymous"); // Anonymous (user is undefined)
        
      
      
      Here’s the example with user assigned to a name:

      
        
        
          
            
          
          
            
          
        
        
          let user = "John";

alert(user ?? "Anonymous"); // John (user is not null/undefined)
        
      
      
      We can also use a sequence of ?? to select the first value from a list that isn’t null/undefined.
Let’s say we have a user’s data in variables firstName, lastName or nickName. All of them may be not defined, if the user decided not to fill in the corresponding values.
We’d like to display the user name using one of these variables, or show “Anonymous” if all of them are null/undefined.
Let’s use the ?? operator for that:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first defined value:
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
        
      
      
      Comparison with ||The OR || operator can be used in the same way as ??, as it was described in the previous chapter.
For example, in the code above we could replace ?? with || and still get the same result:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first truthy value:
alert(firstName || lastName || nickName || "Anonymous"); // Supercoder
        
      
      
      Historically, the OR || operator was there first. It’s been there since the beginning of JavaScript, so developers were using it for such purposes for a long time.
On the other hand, the nullish coalescing operator ?? was added to JavaScript only recently, and the reason for that was that people weren’t quite happy with ||.
The important difference between them is that:

|| returns the first truthy value.
?? returns the first defined value.

In other words, || doesn’t distinguish between false, 0, an empty string "" and null/undefined. They are all the same – falsy values. If any of these is the first argument of ||, then we’ll get the second argument as the result.
In practice though, we may want to use default value only when the variable is null/undefined. That is, when the value is really unknown/not set.
For example, consider this:

      
        
        
          
            
          
          
            
          
        
        
          let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
        
      
      
      
The height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.

so the result of || is the second argument, 100.


The height ?? 100 checks height for being null/undefined, and it’s not,

so the result is height “as is”, that is 0.



In practice, the zero height is often a valid value, that shouldn’t be replaced with the default. So ?? does just the right thing.
PrecedenceThe precedence of the ?? operator is the same as ||. They both equal 3 in the MDN table.
That means that, just like ||, the nullish coalescing operator ?? is evaluated before = and ?, but after most other operations, such as +, *.
So we may need to add parentheses in expressions like this:

      
        
        
          
            
          
          
            
          
        
        
          let height = null;
let width = null;

// important: use parentheses
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
        
      
      
      Otherwise, if we omit parentheses, then as * has the higher precedence than ??, it would execute first, leading to incorrect results.

      
        
        
          // without parentheses
let area = height ?? 100 * width ?? 50;

// ...works this way (not what we want):
let area = height ?? (100 * width) ?? 50;
        
      
      
      Using ?? with && or ||Due to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.
The code below triggers a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1 && 2 ?? 3; // Syntax error
        
      
      
      The limitation is surely debatable, it was added to the language specification with the purpose to avoid programming mistakes, when people start to switch from || to ??.
Use explicit parentheses to work around it:

      
        
        
          
            
          
          
            
          
        
        
          let x = (1 && 2) ?? 3; // Works

alert(x); // 2
        
      
      
      Summary

The nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.
It’s used to assign default values to variables:

      
        
        
          // set height=100, if height is null or undefined
height = height ?? 100;
        
      
      
      

The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.


It’s forbidden to use it with || or && without explicit parentheses.


Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nA recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The nullish coalescing operator is written as two question marks ??.
As it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.
The result of a ?? b is:

if a is defined, then a,
if a isn’t defined, then b.

In other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.
The nullish coalescing operator isn’t anything completely new. It’s just a nice syntax to get the first “defined” value of the two.
We can rewrite result = a ?? b using the operators that we already know, like this:

      
        
        
          result = (a !== null && a !== undefined) ? a : b;
        
      
      
      Now it should be absolutely clear what ?? does. Let’s see where it helps.
The common use case for ?? is to provide a default value.
For example, here we show user if its value isn’t null/undefined, otherwise Anonymous:

      
        
        
          
            
          
          
            
          
        
        
          let user;

alert(user ?? "Anonymous"); // Anonymous (user is undefined)
        
      
      
      Here’s the example with user assigned to a name:

      
        
        
          
            
          
          
            
          
        
        
          let user = "John";

alert(user ?? "Anonymous"); // John (user is not null/undefined)
        
      
      
      We can also use a sequence of ?? to select the first value from a list that isn’t null/undefined.
Let’s say we have a user’s data in variables firstName, lastName or nickName. All of them may be not defined, if the user decided not to fill in the corresponding values.
We’d like to display the user name using one of these variables, or show “Anonymous” if all of them are null/undefined.
Let’s use the ?? operator for that:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first defined value:
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
        
      
      
      Comparison with ||The OR || operator can be used in the same way as ??, as it was described in the previous chapter.
For example, in the code above we could replace ?? with || and still get the same result:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first truthy value:
alert(firstName || lastName || nickName || "Anonymous"); // Supercoder
        
      
      
      Historically, the OR || operator was there first. It’s been there since the beginning of JavaScript, so developers were using it for such purposes for a long time.
On the other hand, the nullish coalescing operator ?? was added to JavaScript only recently, and the reason for that was that people weren’t quite happy with ||.
The important difference between them is that:

|| returns the first truthy value.
?? returns the first defined value.

In other words, || doesn’t distinguish between false, 0, an empty string "" and null/undefined. They are all the same – falsy values. If any of these is the first argument of ||, then we’ll get the second argument as the result.
In practice though, we may want to use default value only when the variable is null/undefined. That is, when the value is really unknown/not set.
For example, consider this:

      
        
        
          
            
          
          
            
          
        
        
          let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
        
      
      
      
The height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.

so the result of || is the second argument, 100.


The height ?? 100 checks height for being null/undefined, and it’s not,

so the result is height “as is”, that is 0.



In practice, the zero height is often a valid value, that shouldn’t be replaced with the default. So ?? does just the right thing.
PrecedenceThe precedence of the ?? operator is the same as ||. They both equal 3 in the MDN table.
That means that, just like ||, the nullish coalescing operator ?? is evaluated before = and ?, but after most other operations, such as +, *.
So we may need to add parentheses in expressions like this:

      
        
        
          
            
          
          
            
          
        
        
          let height = null;
let width = null;

// important: use parentheses
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
        
      
      
      Otherwise, if we omit parentheses, then as * has the higher precedence than ??, it would execute first, leading to incorrect results.

      
        
        
          // without parentheses
let area = height ?? 100 * width ?? 50;

// ...works this way (not what we want):
let area = height ?? (100 * width) ?? 50;
        
      
      
      Using ?? with && or ||Due to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.
The code below triggers a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1 && 2 ?? 3; // Syntax error
        
      
      
      The limitation is surely debatable, it was added to the language specification with the purpose to avoid programming mistakes, when people start to switch from || to ??.
Use explicit parentheses to work around it:

      
        
        
          
            
          
          
            
          
        
        
          let x = (1 && 2) ?? 3; // Works

alert(x); // 2
        
      
      
      Summary

The nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.
It’s used to assign default values to variables:

      
        
        
          // set height=100, if height is null or undefined
height = height ?? 100;
        
      
      
      

The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.


It’s forbidden to use it with || or && without explicit parentheses.\n\nTutorialThe JavaScript languageJavaScript FundamentalsApril 23, 2023Nullish coalescing operator '??'
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The nullish coalescing operator is written as two question marks ??.
As it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.
The result of a ?? b is:

if a is defined, then a,
if a isn’t defined, then b.

In other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.
The nullish coalescing operator isn’t anything completely new. It’s just a nice syntax to get the first “defined” value of the two.
We can rewrite result = a ?? b using the operators that we already know, like this:

      
        
        
          result = (a !== null && a !== undefined) ? a : b;
        
      
      
      Now it should be absolutely clear what ?? does. Let’s see where it helps.
The common use case for ?? is to provide a default value.
For example, here we show user if its value isn’t null/undefined, otherwise Anonymous:

      
        
        
          
            
          
          
            
          
        
        
          let user;

alert(user ?? "Anonymous"); // Anonymous (user is undefined)
        
      
      
      Here’s the example with user assigned to a name:

      
        
        
          
            
          
          
            
          
        
        
          let user = "John";

alert(user ?? "Anonymous"); // John (user is not null/undefined)
        
      
      
      We can also use a sequence of ?? to select the first value from a list that isn’t null/undefined.
Let’s say we have a user’s data in variables firstName, lastName or nickName. All of them may be not defined, if the user decided not to fill in the corresponding values.
We’d like to display the user name using one of these variables, or show “Anonymous” if all of them are null/undefined.
Let’s use the ?? operator for that:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first defined value:
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
        
      
      
      Comparison with ||The OR || operator can be used in the same way as ??, as it was described in the previous chapter.
For example, in the code above we could replace ?? with || and still get the same result:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// shows the first truthy value:
alert(firstName || lastName || nickName || "Anonymous"); // Supercoder
        
      
      
      Historically, the OR || operator was there first. It’s been there since the beginning of JavaScript, so developers were using it for such purposes for a long time.
On the other hand, the nullish coalescing operator ?? was added to JavaScript only recently, and the reason for that was that people weren’t quite happy with ||.
The important difference between them is that:

|| returns the first truthy value.
?? returns the first defined value.

In other words, || doesn’t distinguish between false, 0, an empty string "" and null/undefined. They are all the same – falsy values. If any of these is the first argument of ||, then we’ll get the second argument as the result.
In practice though, we may want to use default value only when the variable is null/undefined. That is, when the value is really unknown/not set.
For example, consider this:

      
        
        
          
            
          
          
            
          
        
        
          let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
        
      
      
      
The height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.

so the result of || is the second argument, 100.


The height ?? 100 checks height for being null/undefined, and it’s not,

so the result is height “as is”, that is 0.



In practice, the zero height is often a valid value, that shouldn’t be replaced with the default. So ?? does just the right thing.
PrecedenceThe precedence of the ?? operator is the same as ||. They both equal 3 in the MDN table.
That means that, just like ||, the nullish coalescing operator ?? is evaluated before = and ?, but after most other operations, such as +, *.
So we may need to add parentheses in expressions like this:

      
        
        
          
            
          
          
            
          
        
        
          let height = null;
let width = null;

// important: use parentheses
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
        
      
      
      Otherwise, if we omit parentheses, then as * has the higher precedence than ??, it would execute first, leading to incorrect results.

      
        
        
          // without parentheses
let area = height ?? 100 * width ?? 50;

// ...works this way (not what we want):
let area = height ?? (100 * width) ?? 50;
        
      
      
      Using ?? with && or ||Due to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.
The code below triggers a syntax error:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1 && 2 ?? 3; // Syntax error
        
      
      
      The limitation is surely debatable, it was added to the language specification with the purpose to avoid programming mistakes, when people start to switch from || to ??.
Use explicit parentheses to work around it:

      
        
        
          
            
          
          
            
          
        
        
          let x = (1 && 2) ?? 3; // Works

alert(x); // 2
        
      
      
      Summary

The nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.
It’s used to assign default values to variables:

      
        
        
          // set height=100, if height is null or undefined
height = height ?? 100;
        
      
      
      

The operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.


It’s forbidden to use it with || or && without explicit parentheses.


Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nWe often need to repeat actions.
For example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.
Loops are a way to repeat the same code multiple times.

            The for…of and for…in loops
            A small announcement for advanced readers.
This article covers only basic loops: while, do..while and for(..;..;..).
If you came to this article searching for other types of loops, here are the pointers:

See for…in to loop over object properties.
See for…of and iterables for looping over arrays and iterable objects.

Otherwise, please read on.

The “while” loopThe while loop has the following syntax:

      
        
        
          while (condition) {
  // code
  // so-called "loop body"
}
        
      
      
      While the condition is truthy, the code from the loop body is executed.
For instance, the loop below outputs i while i < 3:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}
        
      
      
      A single execution of the loop body is called an iteration. The loop in the example above makes three iterations.
If i++ was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.
Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.
For instance, a shorter way to write while (i != 0) is while (i):

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) { // when i becomes 0, the condition becomes falsy, and the loop stops
  alert( i );
  i--;
}
        
      
      
      
            Curly braces are not required for a single-line body
            If the loop body has a single statement, we can omit the curly braces {…}:

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) alert(i--);
        
      
      
      
The “do…while” loopThe condition check can be moved below the loop body using the do..while syntax:

      
        
        
          do {
  // loop body
} while (condition);
        
      
      
      The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
        
      
      
      This form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.
The “for” loopThe for loop is more complex, but it’s also the most commonly used loop.
It looks like this:

      
        
        
          for (begin; condition; step) {
  // ... loop body ...
}
        
      
      
      Let’s learn the meaning of these parts by example. The loop below runs alert(i) for i from 0 up to (but not including) 3:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}
        
      
      
      Let’s examine the for statement part-by-part:



part






begin
let i = 0
Executes once upon entering the loop.


condition
i < 3
Checked before every loop iteration. If false, the loop stops.


body
alert(i)
Runs again and again while the condition is truthy.


step
i++
Executes after the body on each iteration.



The general loop algorithm works like this:

      
        
        
          Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
        
      
      
      That is, begin executes once, and then it iterates: after each condition test, body and step are executed.
If you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.
Here’s exactly what happens in our case:

      
        
        
          // for (let i = 0; i < 3; i++) alert(i)

// run begin
let i = 0
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// ...finish, because now i == 3
        
      
      
      
            Inline variable declaration
            Here, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable
        
      
      
      Instead of defining a variable, we could use an existing one:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (i = 0; i < 3; i++) { // use an existing variable
  alert(i); // 0, 1, 2
}

alert(i); // 3, visible, because declared outside of the loop
        
      
      
      
Skipping partsAny part of for can be skipped.
For example, we can omit begin if we don’t need to do anything at the loop start.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0; // we have i already declared and assigned

for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
        
      
      
      We can also remove the step part:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (; i < 3;) {
  alert( i++ );
}
        
      
      
      This makes the loop identical to while (i < 3).
We can actually remove everything, creating an infinite loop:

      
        
        
          for (;;) {
  // repeats without limits
}
        
      
      
      Please note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.
Breaking the loopNormally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.
For example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Sum: ' + sum );
        
      
      
      The break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.
Continue to the next iterationThe continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).
We can use it if we’re done with the current iteration and would like to move on to the next one.
The loop below uses continue to output only odd values:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}
        
      
      
      For even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.

            The continue directive helps decrease nesting
            A loop that shows odd values could look like this:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
        
      
      
      From a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an if block instead of using continue.
But as a side effect, this created one more level of nesting (the alert call inside the curly braces). If the code inside of if is longer than a few lines, that may decrease the overall readability.


            No break/continue to the right side of ‘?’
            Please note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.
For example, if we take this code:

      
        
        
          if (i > 5) {
  alert(i);
} else {
  continue;
}
        
      
      
      …and rewrite it using a question mark:

      
        
        
          (i > 5) ? alert(i) : continue; // continue isn't allowed here
        
      
      
      …it stops working: there’s a syntax error.
This is just another reason not to use the question mark operator ? instead of if.

Labels for break/continueSometimes we need to break out from multiple nested loops at once.
For example, in the code below we loop over i and j, prompting for the coordinates (i, j) from (0,0) to (2,2):

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // what if we want to exit from here to Done (below)?
  }
}

alert('Done!');
        
      
      
      We need a way to stop the process if the user cancels the input.
The ordinary break after input would only break the inner loop. That’s not sufficient – labels, come to the rescue!
A label is an identifier with a colon before a loop:

      
        
        
          labelName: for (...) {
  ...
}
        
      
      
      The break <labelName> statement in the loop below breaks out to the label:

      
        
        
          
            
          
          
            
          
        
        
          outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)

    // do something with the value...
  }
}

alert('Done!');
        
      
      
      In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
So the control goes straight from (*) to alert('Done!').
We can also move the label onto a separate line:

      
        
        
          outer:
for (let i = 0; i < 3; i++) { ... }
        
      
      
      The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.

            Labels do not allow to “jump” anywhere
            Labels do not allow us to jump into an arbitrary place in the code.
For example, it is impossible to do this:

      
        
        
          break label; // jump to the label below (doesn't work)

label: for (...)
        
      
      
      A break directive must be inside a code block. Technically, any labelled code block will do, e.g.:

      
        
        
          label: {
  // ...
  break label; // works
  // ...
}
        
      
      
      …Although, 99.9% of the time break is used inside loops, as we’ve seen in the examples above.
A continue is only possible from inside a loop.

SummaryWe covered 3 types of loops:

while – The condition is checked before each iteration.
do..while – The condition is checked after each iteration.
for (;;) – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.
If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.
break/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJune 19, 2022Loops: while and forWe often need to repeat actions.
For example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.
Loops are a way to repeat the same code multiple times.

            The for…of and for…in loops
            A small announcement for advanced readers.
This article covers only basic loops: while, do..while and for(..;..;..).
If you came to this article searching for other types of loops, here are the pointers:

See for…in to loop over object properties.
See for…of and iterables for looping over arrays and iterable objects.

Otherwise, please read on.

The “while” loopThe while loop has the following syntax:

      
        
        
          while (condition) {
  // code
  // so-called "loop body"
}
        
      
      
      While the condition is truthy, the code from the loop body is executed.
For instance, the loop below outputs i while i < 3:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}
        
      
      
      A single execution of the loop body is called an iteration. The loop in the example above makes three iterations.
If i++ was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.
Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.
For instance, a shorter way to write while (i != 0) is while (i):

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) { // when i becomes 0, the condition becomes falsy, and the loop stops
  alert( i );
  i--;
}
        
      
      
      
            Curly braces are not required for a single-line body
            If the loop body has a single statement, we can omit the curly braces {…}:

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) alert(i--);
        
      
      
      
The “do…while” loopThe condition check can be moved below the loop body using the do..while syntax:

      
        
        
          do {
  // loop body
} while (condition);
        
      
      
      The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
        
      
      
      This form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.
The “for” loopThe for loop is more complex, but it’s also the most commonly used loop.
It looks like this:

      
        
        
          for (begin; condition; step) {
  // ... loop body ...
}
        
      
      
      Let’s learn the meaning of these parts by example. The loop below runs alert(i) for i from 0 up to (but not including) 3:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}
        
      
      
      Let’s examine the for statement part-by-part:



part






begin
let i = 0
Executes once upon entering the loop.


condition
i < 3
Checked before every loop iteration. If false, the loop stops.


body
alert(i)
Runs again and again while the condition is truthy.


step
i++
Executes after the body on each iteration.



The general loop algorithm works like this:

      
        
        
          Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
        
      
      
      That is, begin executes once, and then it iterates: after each condition test, body and step are executed.
If you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.
Here’s exactly what happens in our case:

      
        
        
          // for (let i = 0; i < 3; i++) alert(i)

// run begin
let i = 0
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// ...finish, because now i == 3
        
      
      
      
            Inline variable declaration
            Here, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable
        
      
      
      Instead of defining a variable, we could use an existing one:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (i = 0; i < 3; i++) { // use an existing variable
  alert(i); // 0, 1, 2
}

alert(i); // 3, visible, because declared outside of the loop
        
      
      
      
Skipping partsAny part of for can be skipped.
For example, we can omit begin if we don’t need to do anything at the loop start.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0; // we have i already declared and assigned

for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
        
      
      
      We can also remove the step part:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (; i < 3;) {
  alert( i++ );
}
        
      
      
      This makes the loop identical to while (i < 3).
We can actually remove everything, creating an infinite loop:

      
        
        
          for (;;) {
  // repeats without limits
}
        
      
      
      Please note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.
Breaking the loopNormally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.
For example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Sum: ' + sum );
        
      
      
      The break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.
Continue to the next iterationThe continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).
We can use it if we’re done with the current iteration and would like to move on to the next one.
The loop below uses continue to output only odd values:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}
        
      
      
      For even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.

            The continue directive helps decrease nesting
            A loop that shows odd values could look like this:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
        
      
      
      From a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an if block instead of using continue.
But as a side effect, this created one more level of nesting (the alert call inside the curly braces). If the code inside of if is longer than a few lines, that may decrease the overall readability.


            No break/continue to the right side of ‘?’
            Please note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.
For example, if we take this code:

      
        
        
          if (i > 5) {
  alert(i);
} else {
  continue;
}
        
      
      
      …and rewrite it using a question mark:

      
        
        
          (i > 5) ? alert(i) : continue; // continue isn't allowed here
        
      
      
      …it stops working: there’s a syntax error.
This is just another reason not to use the question mark operator ? instead of if.

Labels for break/continueSometimes we need to break out from multiple nested loops at once.
For example, in the code below we loop over i and j, prompting for the coordinates (i, j) from (0,0) to (2,2):

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // what if we want to exit from here to Done (below)?
  }
}

alert('Done!');
        
      
      
      We need a way to stop the process if the user cancels the input.
The ordinary break after input would only break the inner loop. That’s not sufficient – labels, come to the rescue!
A label is an identifier with a colon before a loop:

      
        
        
          labelName: for (...) {
  ...
}
        
      
      
      The break <labelName> statement in the loop below breaks out to the label:

      
        
        
          
            
          
          
            
          
        
        
          outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)

    // do something with the value...
  }
}

alert('Done!');
        
      
      
      In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
So the control goes straight from (*) to alert('Done!').
We can also move the label onto a separate line:

      
        
        
          outer:
for (let i = 0; i < 3; i++) { ... }
        
      
      
      The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.

            Labels do not allow to “jump” anywhere
            Labels do not allow us to jump into an arbitrary place in the code.
For example, it is impossible to do this:

      
        
        
          break label; // jump to the label below (doesn't work)

label: for (...)
        
      
      
      A break directive must be inside a code block. Technically, any labelled code block will do, e.g.:

      
        
        
          label: {
  // ...
  break label; // works
  // ...
}
        
      
      
      …Although, 99.9% of the time break is used inside loops, as we’ve seen in the examples above.
A continue is only possible from inside a loop.

SummaryWe covered 3 types of loops:

while – The condition is checked before each iteration.
do..while – The condition is checked after each iteration.
for (;;) – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.
If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.
break/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.
TasksLast loop valueimportance: 3What is the last value alerted by this code? Why?

      
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      solutionThe answer: 1.

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      Every loop iteration decreases i by 1. The check while(i) stops the loop when i = 0.
Hence, the steps of the loop form the following sequence (“loop unrolled”):

      
        
        
          let i = 3;

alert(i--); // shows 3, decreases i to 2

alert(i--) // shows 2, decreases i to 1

alert(i--) // shows 1, decreases i to 0

// done, while(i) check stops the loop
        
      
      
      Which values does the while loop show?importance: 4For every loop iteration, write down which value it outputs and then compare it with the solution.
Both loops alert the same values, or not?


The prefix form ++i:

      
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      

The postfix form i++

      
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      

solutionThe task demonstrates how postfix/prefix forms can lead to different results when used in comparisons.


From 1 to 4

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      The first value is i = 1, because ++i first increments i and then returns the new value. So the first comparison is 1 < 5 and the alert shows 1.
Then follow 2, 3, 4… – the values show up one after another. The comparison always uses the incremented value, because ++ is before the variable.
Finally, i = 4 is incremented to 5, the comparison while(5 < 5) fails, and the loop stops. So 5 is not shown.


From 1 to 5

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      The first value is again i = 1. The postfix form of i++ increments i and then returns the old value, so the comparison i++ < 5 will use i = 0 (contrary to ++i < 5).
But the alert call is separate. It’s another statement which executes after the increment and the comparison. So it gets the current i = 1.
Then follow 2, 3, 4…
Let’s stop on i = 4. The prefix form ++i would increment it and use 5 in the comparison. But here we have the postfix form i++. So it increments i to 5, but returns the old value. Hence the comparison is actually while(4 < 5) – true, and the control goes on to alert.
The value i = 5 is the last one, because on the next step while(5 < 5) is false.


Which values get shown by the "for" loop?importance: 4For each loop write down which values it is going to show. Then compare with the answer.
Both loops alert same values or not?


The postfix form:

      
        
        
          for (let i = 0; i < 5; i++) alert( i );
        
      
      
      

The prefix form:

      
        
        
          for (let i = 0; i < 5; ++i) alert( i );
        
      
      
      

solutionThe answer: from 0 to 4 in both cases.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 5; ++i) alert( i );

for (let i = 0; i < 5; i++) alert( i );
        
      
      
      That can be easily deducted from the algorithm of for:

Execute once i = 0 before everything (begin).
Check the condition i < 5
If true – execute the loop body alert(i), and then i++

The increment i++ is separated from the condition check (2). That’s just another statement.
The value returned by the increment is not used here, so there’s no difference between i++ and ++i.
Output even numbers in the loopimportance: 5Use the for loop to output even numbers from 2 to 10.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
        
      
      
      We use the “modulo” operator % to get the remainder and check for the evenness here.
Replace "for" with "while"importance: 5Rewrite the code changing the for loop to while without altering its behavior (the output should stay same).

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert( `number ${i}!` );
}
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) {
  alert( `number ${i}!` );
  i++;
}
        
      
      
      Repeat until the input is correctimportance: 5Write a loop which prompts for a number greater than 100. If the visitor enters another number – ask them to input again.
The loop must ask for a number until either the visitor enters a number greater than 100 or cancels the input/enters an empty line.
Here we can assume that the visitor only inputs numbers. There’s no need to implement a special handling for a non-numeric input in this task.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          let num;

do {
  num = prompt("Enter a number greater than 100?", 0);
} while (num <= 100 && num);
        
      
      
      The loop do..while repeats while both checks are truthy:

The check for num <= 100 – that is, the entered value is still not greater than 100.
The check && num is false when num is null or an empty string. Then the while loop stops too.

P.S. If num is null then num <= 100 is true, so without the 2nd check the loop wouldn’t stop if the user clicks CANCEL. Both checks are required.
Output prime numbersimportance: 3An integer number greater than 1 is called a prime if it cannot be divided without a remainder by anything except 1 and itself.
In other words, n > 1 is a prime if it can’t be evenly divided by anything except 1 and n.
For example, 5 is a prime, because it cannot be divided without a remainder by 2, 3 and 4.
Write the code which outputs prime numbers in the interval from 2 to n.
For n = 10 the result will be 2,3,5,7.
P.S. The code should work for any n, not be hard-tuned for any fixed value.
solutionThere are many algorithms for this task.
Let’s use a nested loop:

      
        
        
          For each i in the interval {
  check if i has a divisor from 1..i
  if yes => the value is not a prime
  if no => the value is a prime, show it
}
        
      
      
      The code using a label:

      
        
        
          
            
          
          
            
          
        
        
          let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // for each i...

  for (let j = 2; j < i; j++) { // look for a divisor..
    if (i % j == 0) continue nextPrime; // not a prime, go next i
  }

  alert( i ); // a prime
}
        
      
      
      There’s a lot of space to optimize it. For instance, we could look for the divisors from 2 to square root of i. But anyway, if we want to be really efficient for large intervals, we need to change the approach and rely on advanced maths and complex algorithms like Quadratic sieve, General number field sieve etc.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nWe often need to repeat actions.
For example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.
Loops are a way to repeat the same code multiple times.

            The for…of and for…in loops
            A small announcement for advanced readers.
This article covers only basic loops: while, do..while and for(..;..;..).
If you came to this article searching for other types of loops, here are the pointers:

See for…in to loop over object properties.
See for…of and iterables for looping over arrays and iterable objects.

Otherwise, please read on.

The “while” loopThe while loop has the following syntax:

      
        
        
          while (condition) {
  // code
  // so-called "loop body"
}
        
      
      
      While the condition is truthy, the code from the loop body is executed.
For instance, the loop below outputs i while i < 3:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}
        
      
      
      A single execution of the loop body is called an iteration. The loop in the example above makes three iterations.
If i++ was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.
Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.
For instance, a shorter way to write while (i != 0) is while (i):

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) { // when i becomes 0, the condition becomes falsy, and the loop stops
  alert( i );
  i--;
}
        
      
      
      
            Curly braces are not required for a single-line body
            If the loop body has a single statement, we can omit the curly braces {…}:

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) alert(i--);
        
      
      
      
The “do…while” loopThe condition check can be moved below the loop body using the do..while syntax:

      
        
        
          do {
  // loop body
} while (condition);
        
      
      
      The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
        
      
      
      This form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.
The “for” loopThe for loop is more complex, but it’s also the most commonly used loop.
It looks like this:

      
        
        
          for (begin; condition; step) {
  // ... loop body ...
}
        
      
      
      Let’s learn the meaning of these parts by example. The loop below runs alert(i) for i from 0 up to (but not including) 3:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}
        
      
      
      Let’s examine the for statement part-by-part:



part






begin
let i = 0
Executes once upon entering the loop.


condition
i < 3
Checked before every loop iteration. If false, the loop stops.


body
alert(i)
Runs again and again while the condition is truthy.


step
i++
Executes after the body on each iteration.



The general loop algorithm works like this:

      
        
        
          Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
        
      
      
      That is, begin executes once, and then it iterates: after each condition test, body and step are executed.
If you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.
Here’s exactly what happens in our case:

      
        
        
          // for (let i = 0; i < 3; i++) alert(i)

// run begin
let i = 0
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// ...finish, because now i == 3
        
      
      
      
            Inline variable declaration
            Here, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable
        
      
      
      Instead of defining a variable, we could use an existing one:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (i = 0; i < 3; i++) { // use an existing variable
  alert(i); // 0, 1, 2
}

alert(i); // 3, visible, because declared outside of the loop
        
      
      
      
Skipping partsAny part of for can be skipped.
For example, we can omit begin if we don’t need to do anything at the loop start.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0; // we have i already declared and assigned

for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
        
      
      
      We can also remove the step part:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (; i < 3;) {
  alert( i++ );
}
        
      
      
      This makes the loop identical to while (i < 3).
We can actually remove everything, creating an infinite loop:

      
        
        
          for (;;) {
  // repeats without limits
}
        
      
      
      Please note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.
Breaking the loopNormally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.
For example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Sum: ' + sum );
        
      
      
      The break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.
Continue to the next iterationThe continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).
We can use it if we’re done with the current iteration and would like to move on to the next one.
The loop below uses continue to output only odd values:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}
        
      
      
      For even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.

            The continue directive helps decrease nesting
            A loop that shows odd values could look like this:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
        
      
      
      From a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an if block instead of using continue.
But as a side effect, this created one more level of nesting (the alert call inside the curly braces). If the code inside of if is longer than a few lines, that may decrease the overall readability.


            No break/continue to the right side of ‘?’
            Please note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.
For example, if we take this code:

      
        
        
          if (i > 5) {
  alert(i);
} else {
  continue;
}
        
      
      
      …and rewrite it using a question mark:

      
        
        
          (i > 5) ? alert(i) : continue; // continue isn't allowed here
        
      
      
      …it stops working: there’s a syntax error.
This is just another reason not to use the question mark operator ? instead of if.

Labels for break/continueSometimes we need to break out from multiple nested loops at once.
For example, in the code below we loop over i and j, prompting for the coordinates (i, j) from (0,0) to (2,2):

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // what if we want to exit from here to Done (below)?
  }
}

alert('Done!');
        
      
      
      We need a way to stop the process if the user cancels the input.
The ordinary break after input would only break the inner loop. That’s not sufficient – labels, come to the rescue!
A label is an identifier with a colon before a loop:

      
        
        
          labelName: for (...) {
  ...
}
        
      
      
      The break <labelName> statement in the loop below breaks out to the label:

      
        
        
          
            
          
          
            
          
        
        
          outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)

    // do something with the value...
  }
}

alert('Done!');
        
      
      
      In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
So the control goes straight from (*) to alert('Done!').
We can also move the label onto a separate line:

      
        
        
          outer:
for (let i = 0; i < 3; i++) { ... }
        
      
      
      The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.

            Labels do not allow to “jump” anywhere
            Labels do not allow us to jump into an arbitrary place in the code.
For example, it is impossible to do this:

      
        
        
          break label; // jump to the label below (doesn't work)

label: for (...)
        
      
      
      A break directive must be inside a code block. Technically, any labelled code block will do, e.g.:

      
        
        
          label: {
  // ...
  break label; // works
  // ...
}
        
      
      
      …Although, 99.9% of the time break is used inside loops, as we’ve seen in the examples above.
A continue is only possible from inside a loop.

SummaryWe covered 3 types of loops:

while – The condition is checked before each iteration.
do..while – The condition is checked after each iteration.
for (;;) – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.
If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.
break/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.
TasksLast loop valueimportance: 3What is the last value alerted by this code? Why?

      
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      solutionThe answer: 1.

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      Every loop iteration decreases i by 1. The check while(i) stops the loop when i = 0.
Hence, the steps of the loop form the following sequence (“loop unrolled”):

      
        
        
          let i = 3;

alert(i--); // shows 3, decreases i to 2

alert(i--) // shows 2, decreases i to 1

alert(i--) // shows 1, decreases i to 0

// done, while(i) check stops the loop
        
      
      
      Which values does the while loop show?importance: 4For every loop iteration, write down which value it outputs and then compare it with the solution.
Both loops alert the same values, or not?


The prefix form ++i:

      
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      

The postfix form i++

      
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      

solutionThe task demonstrates how postfix/prefix forms can lead to different results when used in comparisons.


From 1 to 4

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      The first value is i = 1, because ++i first increments i and then returns the new value. So the first comparison is 1 < 5 and the alert shows 1.
Then follow 2, 3, 4… – the values show up one after another. The comparison always uses the incremented value, because ++ is before the variable.
Finally, i = 4 is incremented to 5, the comparison while(5 < 5) fails, and the loop stops. So 5 is not shown.


From 1 to 5

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      The first value is again i = 1. The postfix form of i++ increments i and then returns the old value, so the comparison i++ < 5 will use i = 0 (contrary to ++i < 5).
But the alert call is separate. It’s another statement which executes after the increment and the comparison. So it gets the current i = 1.
Then follow 2, 3, 4…
Let’s stop on i = 4. The prefix form ++i would increment it and use 5 in the comparison. But here we have the postfix form i++. So it increments i to 5, but returns the old value. Hence the comparison is actually while(4 < 5) – true, and the control goes on to alert.
The value i = 5 is the last one, because on the next step while(5 < 5) is false.


Which values get shown by the "for" loop?importance: 4For each loop write down which values it is going to show. Then compare with the answer.
Both loops alert same values or not?


The postfix form:

      
        
        
          for (let i = 0; i < 5; i++) alert( i );
        
      
      
      

The prefix form:

      
        
        
          for (let i = 0; i < 5; ++i) alert( i );
        
      
      
      

solutionThe answer: from 0 to 4 in both cases.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 5; ++i) alert( i );

for (let i = 0; i < 5; i++) alert( i );
        
      
      
      That can be easily deducted from the algorithm of for:

Execute once i = 0 before everything (begin).
Check the condition i < 5
If true – execute the loop body alert(i), and then i++

The increment i++ is separated from the condition check (2). That’s just another statement.
The value returned by the increment is not used here, so there’s no difference between i++ and ++i.
Output even numbers in the loopimportance: 5Use the for loop to output even numbers from 2 to 10.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
        
      
      
      We use the “modulo” operator % to get the remainder and check for the evenness here.
Replace "for" with "while"importance: 5Rewrite the code changing the for loop to while without altering its behavior (the output should stay same).

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert( `number ${i}!` );
}
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) {
  alert( `number ${i}!` );
  i++;
}
        
      
      
      Repeat until the input is correctimportance: 5Write a loop which prompts for a number greater than 100. If the visitor enters another number – ask them to input again.
The loop must ask for a number until either the visitor enters a number greater than 100 or cancels the input/enters an empty line.
Here we can assume that the visitor only inputs numbers. There’s no need to implement a special handling for a non-numeric input in this task.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          let num;

do {
  num = prompt("Enter a number greater than 100?", 0);
} while (num <= 100 && num);
        
      
      
      The loop do..while repeats while both checks are truthy:

The check for num <= 100 – that is, the entered value is still not greater than 100.
The check && num is false when num is null or an empty string. Then the while loop stops too.

P.S. If num is null then num <= 100 is true, so without the 2nd check the loop wouldn’t stop if the user clicks CANCEL. Both checks are required.
Output prime numbersimportance: 3An integer number greater than 1 is called a prime if it cannot be divided without a remainder by anything except 1 and itself.
In other words, n > 1 is a prime if it can’t be evenly divided by anything except 1 and n.
For example, 5 is a prime, because it cannot be divided without a remainder by 2, 3 and 4.
Write the code which outputs prime numbers in the interval from 2 to n.
For n = 10 the result will be 2,3,5,7.
P.S. The code should work for any n, not be hard-tuned for any fixed value.
solutionThere are many algorithms for this task.
Let’s use a nested loop:

      
        
        
          For each i in the interval {
  check if i has a divisor from 1..i
  if yes => the value is not a prime
  if no => the value is a prime, show it
}
        
      
      
      The code using a label:

      
        
        
          
            
          
          
            
          
        
        
          let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // for each i...

  for (let j = 2; j < i; j++) { // look for a divisor..
    if (i % j == 0) continue nextPrime; // not a prime, go next i
  }

  alert( i ); // a prime
}
        
      
      
      There’s a lot of space to optimize it. For instance, we could look for the divisors from 2 to square root of i. But anyway, if we want to be really efficient for large intervals, we need to change the approach and rely on advanced maths and complex algorithms like Quadratic sieve, General number field sieve etc.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJune 19, 2022Loops: while and forWe often need to repeat actions.
For example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.
Loops are a way to repeat the same code multiple times.

            The for…of and for…in loops
            A small announcement for advanced readers.
This article covers only basic loops: while, do..while and for(..;..;..).
If you came to this article searching for other types of loops, here are the pointers:

See for…in to loop over object properties.
See for…of and iterables for looping over arrays and iterable objects.

Otherwise, please read on.

The “while” loopThe while loop has the following syntax:

      
        
        
          while (condition) {
  // code
  // so-called "loop body"
}
        
      
      
      While the condition is truthy, the code from the loop body is executed.
For instance, the loop below outputs i while i < 3:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}
        
      
      
      A single execution of the loop body is called an iteration. The loop in the example above makes three iterations.
If i++ was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.
Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.
For instance, a shorter way to write while (i != 0) is while (i):

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) { // when i becomes 0, the condition becomes falsy, and the loop stops
  alert( i );
  i--;
}
        
      
      
      
            Curly braces are not required for a single-line body
            If the loop body has a single statement, we can omit the curly braces {…}:

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) alert(i--);
        
      
      
      
The “do…while” loopThe condition check can be moved below the loop body using the do..while syntax:

      
        
        
          do {
  // loop body
} while (condition);
        
      
      
      The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
        
      
      
      This form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.
The “for” loopThe for loop is more complex, but it’s also the most commonly used loop.
It looks like this:

      
        
        
          for (begin; condition; step) {
  // ... loop body ...
}
        
      
      
      Let’s learn the meaning of these parts by example. The loop below runs alert(i) for i from 0 up to (but not including) 3:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}
        
      
      
      Let’s examine the for statement part-by-part:



part






begin
let i = 0
Executes once upon entering the loop.


condition
i < 3
Checked before every loop iteration. If false, the loop stops.


body
alert(i)
Runs again and again while the condition is truthy.


step
i++
Executes after the body on each iteration.



The general loop algorithm works like this:

      
        
        
          Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
        
      
      
      That is, begin executes once, and then it iterates: after each condition test, body and step are executed.
If you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.
Here’s exactly what happens in our case:

      
        
        
          // for (let i = 0; i < 3; i++) alert(i)

// run begin
let i = 0
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// ...finish, because now i == 3
        
      
      
      
            Inline variable declaration
            Here, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable
        
      
      
      Instead of defining a variable, we could use an existing one:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (i = 0; i < 3; i++) { // use an existing variable
  alert(i); // 0, 1, 2
}

alert(i); // 3, visible, because declared outside of the loop
        
      
      
      
Skipping partsAny part of for can be skipped.
For example, we can omit begin if we don’t need to do anything at the loop start.
Like here:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0; // we have i already declared and assigned

for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
        
      
      
      We can also remove the step part:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (; i < 3;) {
  alert( i++ );
}
        
      
      
      This makes the loop identical to while (i < 3).
We can actually remove everything, creating an infinite loop:

      
        
        
          for (;;) {
  // repeats without limits
}
        
      
      
      Please note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.
Breaking the loopNormally, a loop exits when its condition becomes falsy.
But we can force the exit at any time using the special break directive.
For example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Sum: ' + sum );
        
      
      
      The break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.
Continue to the next iterationThe continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).
We can use it if we’re done with the current iteration and would like to move on to the next one.
The loop below uses continue to output only odd values:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}
        
      
      
      For even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.

            The continue directive helps decrease nesting
            A loop that shows odd values could look like this:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
        
      
      
      From a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an if block instead of using continue.
But as a side effect, this created one more level of nesting (the alert call inside the curly braces). If the code inside of if is longer than a few lines, that may decrease the overall readability.


            No break/continue to the right side of ‘?’
            Please note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.
For example, if we take this code:

      
        
        
          if (i > 5) {
  alert(i);
} else {
  continue;
}
        
      
      
      …and rewrite it using a question mark:

      
        
        
          (i > 5) ? alert(i) : continue; // continue isn't allowed here
        
      
      
      …it stops working: there’s a syntax error.
This is just another reason not to use the question mark operator ? instead of if.

Labels for break/continueSometimes we need to break out from multiple nested loops at once.
For example, in the code below we loop over i and j, prompting for the coordinates (i, j) from (0,0) to (2,2):

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // what if we want to exit from here to Done (below)?
  }
}

alert('Done!');
        
      
      
      We need a way to stop the process if the user cancels the input.
The ordinary break after input would only break the inner loop. That’s not sufficient – labels, come to the rescue!
A label is an identifier with a colon before a loop:

      
        
        
          labelName: for (...) {
  ...
}
        
      
      
      The break <labelName> statement in the loop below breaks out to the label:

      
        
        
          
            
          
          
            
          
        
        
          outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)

    // do something with the value...
  }
}

alert('Done!');
        
      
      
      In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
So the control goes straight from (*) to alert('Done!').
We can also move the label onto a separate line:

      
        
        
          outer:
for (let i = 0; i < 3; i++) { ... }
        
      
      
      The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.

            Labels do not allow to “jump” anywhere
            Labels do not allow us to jump into an arbitrary place in the code.
For example, it is impossible to do this:

      
        
        
          break label; // jump to the label below (doesn't work)

label: for (...)
        
      
      
      A break directive must be inside a code block. Technically, any labelled code block will do, e.g.:

      
        
        
          label: {
  // ...
  break label; // works
  // ...
}
        
      
      
      …Although, 99.9% of the time break is used inside loops, as we’ve seen in the examples above.
A continue is only possible from inside a loop.

SummaryWe covered 3 types of loops:

while – The condition is checked before each iteration.
do..while – The condition is checked after each iteration.
for (;;) – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.
If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.
break/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.
TasksLast loop valueimportance: 3What is the last value alerted by this code? Why?

      
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      solutionThe answer: 1.

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      Every loop iteration decreases i by 1. The check while(i) stops the loop when i = 0.
Hence, the steps of the loop form the following sequence (“loop unrolled”):

      
        
        
          let i = 3;

alert(i--); // shows 3, decreases i to 2

alert(i--) // shows 2, decreases i to 1

alert(i--) // shows 1, decreases i to 0

// done, while(i) check stops the loop
        
      
      
      Which values does the while loop show?importance: 4For every loop iteration, write down which value it outputs and then compare it with the solution.
Both loops alert the same values, or not?


The prefix form ++i:

      
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      

The postfix form i++

      
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      

solutionThe task demonstrates how postfix/prefix forms can lead to different results when used in comparisons.


From 1 to 4

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      The first value is i = 1, because ++i first increments i and then returns the new value. So the first comparison is 1 < 5 and the alert shows 1.
Then follow 2, 3, 4… – the values show up one after another. The comparison always uses the incremented value, because ++ is before the variable.
Finally, i = 4 is incremented to 5, the comparison while(5 < 5) fails, and the loop stops. So 5 is not shown.


From 1 to 5

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      The first value is again i = 1. The postfix form of i++ increments i and then returns the old value, so the comparison i++ < 5 will use i = 0 (contrary to ++i < 5).
But the alert call is separate. It’s another statement which executes after the increment and the comparison. So it gets the current i = 1.
Then follow 2, 3, 4…
Let’s stop on i = 4. The prefix form ++i would increment it and use 5 in the comparison. But here we have the postfix form i++. So it increments i to 5, but returns the old value. Hence the comparison is actually while(4 < 5) – true, and the control goes on to alert.
The value i = 5 is the last one, because on the next step while(5 < 5) is false.


Which values get shown by the "for" loop?importance: 4For each loop write down which values it is going to show. Then compare with the answer.
Both loops alert same values or not?


The postfix form:

      
        
        
          for (let i = 0; i < 5; i++) alert( i );
        
      
      
      

The prefix form:

      
        
        
          for (let i = 0; i < 5; ++i) alert( i );
        
      
      
      

solutionThe answer: from 0 to 4 in both cases.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 5; ++i) alert( i );

for (let i = 0; i < 5; i++) alert( i );
        
      
      
      That can be easily deducted from the algorithm of for:

Execute once i = 0 before everything (begin).
Check the condition i < 5
If true – execute the loop body alert(i), and then i++

The increment i++ is separated from the condition check (2). That’s just another statement.
The value returned by the increment is not used here, so there’s no difference between i++ and ++i.
Output even numbers in the loopimportance: 5Use the for loop to output even numbers from 2 to 10.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
        
      
      
      We use the “modulo” operator % to get the remainder and check for the evenness here.
Replace "for" with "while"importance: 5Rewrite the code changing the for loop to while without altering its behavior (the output should stay same).

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert( `number ${i}!` );
}
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) {
  alert( `number ${i}!` );
  i++;
}
        
      
      
      Repeat until the input is correctimportance: 5Write a loop which prompts for a number greater than 100. If the visitor enters another number – ask them to input again.
The loop must ask for a number until either the visitor enters a number greater than 100 or cancels the input/enters an empty line.
Here we can assume that the visitor only inputs numbers. There’s no need to implement a special handling for a non-numeric input in this task.
Run the demosolution
      
        
        
          
            
          
          
            
          
        
        
          let num;

do {
  num = prompt("Enter a number greater than 100?", 0);
} while (num <= 100 && num);
        
      
      
      The loop do..while repeats while both checks are truthy:

The check for num <= 100 – that is, the entered value is still not greater than 100.
The check && num is false when num is null or an empty string. Then the while loop stops too.

P.S. If num is null then num <= 100 is true, so without the 2nd check the loop wouldn’t stop if the user clicks CANCEL. Both checks are required.
Output prime numbersimportance: 3An integer number greater than 1 is called a prime if it cannot be divided without a remainder by anything except 1 and itself.
In other words, n > 1 is a prime if it can’t be evenly divided by anything except 1 and n.
For example, 5 is a prime, because it cannot be divided without a remainder by 2, 3 and 4.
Write the code which outputs prime numbers in the interval from 2 to n.
For n = 10 the result will be 2,3,5,7.
P.S. The code should work for any n, not be hard-tuned for any fixed value.
solutionThere are many algorithms for this task.
Let’s use a nested loop:

      
        
        
          For each i in the interval {
  check if i has a divisor from 1..i
  if yes => the value is not a prime
  if no => the value is a prime, show it
}
        
      
      
      The code using a label:

      
        
        
          
            
          
          
            
          
        
        
          let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // for each i...

  for (let j = 2; j < i; j++) { // look for a divisor..
    if (i % j == 0) continue nextPrime; // not a prime, go next i
  }

  alert( i ); // a prime
}
        
      
      
      There’s a lot of space to optimize it. For instance, we could look for the divisors from 2 to square root of i. But anyway, if we want to be really efficient for large intervals, we need to change the approach and rely on advanced maths and complex algorithms like Quadratic sieve, General number field sieve etc.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nA switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.
The syntaxThe switch has one or more case blocks and an optional default.
It looks like this:

      
        
        
          switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
        
      
      
      
The value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.
If the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).
If no case is matched then the default code is executed (if it exists).

An exampleAn example of switch (the executed code is highlighted):

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too big' );
    break;
  default:
    alert( "I don't know such values" );
}
        
      
      
      Here the switch starts to compare a from the first case variant that is 3. The match fails.
Then 4. That’s a match, so the execution starts from case 4 until the nearest break.
If there is no break then the execution continues with the next case without any checks.
An example without break:

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
}
        
      
      
      In the example above we’ll see sequential execution of three alerts:

      
        
        
          alert( 'Exactly!' );
alert( 'Too big' );
alert( "I don't know such values" );
        
      
      
      
            Any expression can be a switch/case argument
            Both switch and case allow arbitrary expressions.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("this runs, because +a is 1, exactly equals b+1");
    break;

  default:
    alert("this doesn't run");
}
        
      
      
      Here +a gives 1, that’s compared with b + 1 in case, and the corresponding code is executed.

Grouping of “case”Several variants of case which share the same code can be grouped.
For example, if we want the same code to run for case 3 and case 5:

      
        
        
          
            
          
          
            
          
        
        
          let a = 3;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
        
      
      
      Now both 3 and 5 show the same message.
The ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.
Type mattersLet’s emphasize that the equality check is always strict. The values must be of the same type to match.
For example, let’s consider the code:

      
        
        
          
            
          
          
            
          
        
        
          let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;

  case '2':
    alert( 'Two' );
    break;

  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' );
}
        
      
      
      
For 0, 1, the first alert runs.
For 2 the second alert runs.
But for 3, the result of the prompt is a string "3", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.\n\nTutorialThe JavaScript languageJavaScript FundamentalsApril 25, 2022The "switch" statementA switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.
The syntaxThe switch has one or more case blocks and an optional default.
It looks like this:

      
        
        
          switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
        
      
      
      
The value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.
If the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).
If no case is matched then the default code is executed (if it exists).

An exampleAn example of switch (the executed code is highlighted):

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too big' );
    break;
  default:
    alert( "I don't know such values" );
}
        
      
      
      Here the switch starts to compare a from the first case variant that is 3. The match fails.
Then 4. That’s a match, so the execution starts from case 4 until the nearest break.
If there is no break then the execution continues with the next case without any checks.
An example without break:

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
}
        
      
      
      In the example above we’ll see sequential execution of three alerts:

      
        
        
          alert( 'Exactly!' );
alert( 'Too big' );
alert( "I don't know such values" );
        
      
      
      
            Any expression can be a switch/case argument
            Both switch and case allow arbitrary expressions.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("this runs, because +a is 1, exactly equals b+1");
    break;

  default:
    alert("this doesn't run");
}
        
      
      
      Here +a gives 1, that’s compared with b + 1 in case, and the corresponding code is executed.

Grouping of “case”Several variants of case which share the same code can be grouped.
For example, if we want the same code to run for case 3 and case 5:

      
        
        
          
            
          
          
            
          
        
        
          let a = 3;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
        
      
      
      Now both 3 and 5 show the same message.
The ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.
Type mattersLet’s emphasize that the equality check is always strict. The values must be of the same type to match.
For example, let’s consider the code:

      
        
        
          
            
          
          
            
          
        
        
          let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;

  case '2':
    alert( 'Two' );
    break;

  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' );
}
        
      
      
      
For 0, 1, the first alert runs.
For 2 the second alert runs.
But for 3, the result of the prompt is a string "3", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.

TasksRewrite the "switch" into an "if"importance: 5Write the code using if..else which would correspond to the following switch:

      
        
        
          switch (browser) {
  case 'Edge':
    alert( "You've got the Edge!" );
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Okay we support these browsers too' );
    break;

  default:
    alert( 'We hope that this page looks ok!' );
}
        
      
      
      solutionTo precisely match the functionality of switch, the if must use a strict comparison '==='.
For given strings though, a simple '==' works too.

      
        
        
          if(browser == 'Edge') {
  alert("You've got the Edge!");
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert( 'Okay we support these browsers too' );
} else {
  alert( 'We hope that this page looks ok!' );
}
        
      
      
      Please note: the construct browser == 'Chrome' || browser == 'Firefox' … is split into multiple lines for better readability.
But the switch construct is still cleaner and more descriptive.
Rewrite "if" into "switch"importance: 4Rewrite the code below using a single switch statement:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

if (a == 0) {
  alert( 0 );
}
if (a == 1) {
  alert( 1 );
}

if (a == 2 || a == 3) {
  alert( '2,3' );
}
        
      
      
      solutionThe first two checks turn into two case. The third check is split into two cases:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
        
      
      
      Please note: the break at the bottom is not required. But we put it to make the code future-proof.
In the future, there is a chance that we’d want to add one more case, for example case 4. And if we forget to add a break before it, at the end of case 3, there will be an error. So that’s a kind of self-insurance.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nA switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.
The syntaxThe switch has one or more case blocks and an optional default.
It looks like this:

      
        
        
          switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
        
      
      
      
The value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.
If the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).
If no case is matched then the default code is executed (if it exists).

An exampleAn example of switch (the executed code is highlighted):

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too big' );
    break;
  default:
    alert( "I don't know such values" );
}
        
      
      
      Here the switch starts to compare a from the first case variant that is 3. The match fails.
Then 4. That’s a match, so the execution starts from case 4 until the nearest break.
If there is no break then the execution continues with the next case without any checks.
An example without break:

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
}
        
      
      
      In the example above we’ll see sequential execution of three alerts:

      
        
        
          alert( 'Exactly!' );
alert( 'Too big' );
alert( "I don't know such values" );
        
      
      
      
            Any expression can be a switch/case argument
            Both switch and case allow arbitrary expressions.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("this runs, because +a is 1, exactly equals b+1");
    break;

  default:
    alert("this doesn't run");
}
        
      
      
      Here +a gives 1, that’s compared with b + 1 in case, and the corresponding code is executed.

Grouping of “case”Several variants of case which share the same code can be grouped.
For example, if we want the same code to run for case 3 and case 5:

      
        
        
          
            
          
          
            
          
        
        
          let a = 3;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
        
      
      
      Now both 3 and 5 show the same message.
The ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.
Type mattersLet’s emphasize that the equality check is always strict. The values must be of the same type to match.
For example, let’s consider the code:

      
        
        
          
            
          
          
            
          
        
        
          let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;

  case '2':
    alert( 'Two' );
    break;

  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' );
}
        
      
      
      
For 0, 1, the first alert runs.
For 2 the second alert runs.
But for 3, the result of the prompt is a string "3", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.

TasksRewrite the "switch" into an "if"importance: 5Write the code using if..else which would correspond to the following switch:

      
        
        
          switch (browser) {
  case 'Edge':
    alert( "You've got the Edge!" );
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Okay we support these browsers too' );
    break;

  default:
    alert( 'We hope that this page looks ok!' );
}
        
      
      
      solutionTo precisely match the functionality of switch, the if must use a strict comparison '==='.
For given strings though, a simple '==' works too.

      
        
        
          if(browser == 'Edge') {
  alert("You've got the Edge!");
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert( 'Okay we support these browsers too' );
} else {
  alert( 'We hope that this page looks ok!' );
}
        
      
      
      Please note: the construct browser == 'Chrome' || browser == 'Firefox' … is split into multiple lines for better readability.
But the switch construct is still cleaner and more descriptive.
Rewrite "if" into "switch"importance: 4Rewrite the code below using a single switch statement:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

if (a == 0) {
  alert( 0 );
}
if (a == 1) {
  alert( 1 );
}

if (a == 2 || a == 3) {
  alert( '2,3' );
}
        
      
      
      solutionThe first two checks turn into two case. The third check is split into two cases:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
        
      
      
      Please note: the break at the bottom is not required. But we put it to make the code future-proof.
In the future, there is a chance that we’d want to add one more case, for example case 4. And if we forget to add a break before it, at the end of case 3, there will be an error. So that’s a kind of self-insurance.\n\nTutorialThe JavaScript languageJavaScript FundamentalsApril 25, 2022The "switch" statementA switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.
The syntaxThe switch has one or more case blocks and an optional default.
It looks like this:

      
        
        
          switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
        
      
      
      
The value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.
If the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).
If no case is matched then the default code is executed (if it exists).

An exampleAn example of switch (the executed code is highlighted):

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too big' );
    break;
  default:
    alert( "I don't know such values" );
}
        
      
      
      Here the switch starts to compare a from the first case variant that is 3. The match fails.
Then 4. That’s a match, so the execution starts from case 4 until the nearest break.
If there is no break then the execution continues with the next case without any checks.
An example without break:

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
}
        
      
      
      In the example above we’ll see sequential execution of three alerts:

      
        
        
          alert( 'Exactly!' );
alert( 'Too big' );
alert( "I don't know such values" );
        
      
      
      
            Any expression can be a switch/case argument
            Both switch and case allow arbitrary expressions.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("this runs, because +a is 1, exactly equals b+1");
    break;

  default:
    alert("this doesn't run");
}
        
      
      
      Here +a gives 1, that’s compared with b + 1 in case, and the corresponding code is executed.

Grouping of “case”Several variants of case which share the same code can be grouped.
For example, if we want the same code to run for case 3 and case 5:

      
        
        
          
            
          
          
            
          
        
        
          let a = 3;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
        
      
      
      Now both 3 and 5 show the same message.
The ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.
Type mattersLet’s emphasize that the equality check is always strict. The values must be of the same type to match.
For example, let’s consider the code:

      
        
        
          
            
          
          
            
          
        
        
          let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;

  case '2':
    alert( 'Two' );
    break;

  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' );
}
        
      
      
      
For 0, 1, the first alert runs.
For 2 the second alert runs.
But for 3, the result of the prompt is a string "3", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.

TasksRewrite the "switch" into an "if"importance: 5Write the code using if..else which would correspond to the following switch:

      
        
        
          switch (browser) {
  case 'Edge':
    alert( "You've got the Edge!" );
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Okay we support these browsers too' );
    break;

  default:
    alert( 'We hope that this page looks ok!' );
}
        
      
      
      solutionTo precisely match the functionality of switch, the if must use a strict comparison '==='.
For given strings though, a simple '==' works too.

      
        
        
          if(browser == 'Edge') {
  alert("You've got the Edge!");
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert( 'Okay we support these browsers too' );
} else {
  alert( 'We hope that this page looks ok!' );
}
        
      
      
      Please note: the construct browser == 'Chrome' || browser == 'Firefox' … is split into multiple lines for better readability.
But the switch construct is still cleaner and more descriptive.
Rewrite "if" into "switch"importance: 4Rewrite the code below using a single switch statement:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

if (a == 0) {
  alert( 0 );
}
if (a == 1) {
  alert( 1 );
}

if (a == 2 || a == 3) {
  alert( '2,3' );
}
        
      
      
      solutionThe first two checks turn into two case. The third check is split into two cases:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
        
      
      
      Please note: the break at the bottom is not required. But we put it to make the code future-proof.
In the future, there is a chance that we’d want to add one more case, for example case 4. And if we forget to add a break before it, at the end of case 3, there will be an error. So that’s a kind of self-insurance.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nQuite often we need to perform a similar action in many places of the script.
For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.
Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.
We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.
Function DeclarationTo create a function we can use a function declaration.
It looks like this:

      
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}
        
      
      
      The function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.

      
        
        
          function name(parameter1, parameter2, ... parameterN) {
 // body
}
        
      
      
      Our new function can be called by its name: showMessage().
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
        
      
      
      The call showMessage() executes the code of the function. Here we will see the message two times.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.
Local variablesA variable declared inside a function is only visible inside that function.
For example:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! The variable is local to the function
        
      
      
      Outer variablesA function can access an outer variable as well, for example:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
        
      
      
      The function has full access to the outer variable. It can modify it as well.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, the value was modified by the function
        
      
      
      The outer variable is only used if there’s no local one.
If a same-named variable is declared inside the function then it shadows the outer one. For instance, in the code below the function uses the local userName. The outer one is ignored:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use its own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable
        
      
      
      
            Global variables
            Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).
It’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data.

ParametersWe can pass arbitrary data to functions using parameters.
In the example below, the function has two parameters: from and text.

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
        
      
      
      When the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.
Here’s one more example: we have a variable from and pass it to the function. Please note: the function changes from, but the change is not seen outside, because a function always gets a copy of the value:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) {

  from = '*' + from + '*'; // make "from" look nicer

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// the value of "from" is the same, the function modified a local copy
alert( from ); // Ann
        
      
      
      When a value is passed as a function parameter, it’s also called an argument.
In other words, to put these terms straight:

A parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).
An argument is the value that is passed to the function when it is called (it’s a call time term).

We declare functions listing their parameters, then call them passing arguments.
In the example above, one might say: “the function showMessage is declared with two parameters, then called with two arguments: from and "Hello"”.
Default valuesIf a function is called, but an argument is not provided, then the corresponding value becomes undefined.
For instance, the aforementioned function showMessage(from, text) can be called with a single argument:

      
        
        
          showMessage("Ann");
        
      
      
      That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it becomes undefined.
We can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
        
      
      
      Now if the text parameter is not passed, it will get the value "no text given".
The default value also jumps in if the parameter exists, but strictly equals undefined, like this:

      
        
        
          showMessage("Ann", undefined); // Ann: no text given
        
      
      
      Here "no text given" is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}
        
      
      
      
            Evaluation of default parameters
            In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.
In the example above, anotherFunction() isn’t called at all, if the text parameter is provided.
On the other hand, it’s independently called every time when text is missing.


            Default parameters in old JavaScript code
            Several years ago, JavaScript didn’t support the syntax for default parameters. So people used other ways to specify them.
Nowadays, we can come across them in old scripts.
For example, an explicit check for undefined:

      
        
        
          function showMessage(from, text) {
  if (text === undefined) {
    text = 'no text given';
  }

  alert( from + ": " + text );
}
        
      
      
      …Or using the || operator:

      
        
        
          function showMessage(from, text) {
  // If the value of text is falsy, assign the default value
  // this assumes that text == "" is the same as no text at all
  text = text || 'no text given';
  ...
}
        
      
      
      
Alternative default parametersSometimes it makes sense to assign default values for parameters at a later stage after the function declaration.
We can check if the parameter is passed during the function execution, by comparing it with undefined:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(text) {
  // ...

  if (text === undefined) { // if the parameter is missing
    text = 'empty message';
  }

  alert(text);
}

showMessage(); // empty message
        
      
      
      …Or we could use the || operator:

      
        
        
          function showMessage(text) {
  // if text is undefined or otherwise falsy, set it to 'empty'
  text = text || 'empty';
  ...
}
        
      
      
      Modern JavaScript engines support the nullish coalescing operator ??, it’s better when most falsy values, such as 0, should be considered “normal”:

      
        
        
          
            
          
          
            
          
        
        
          function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
        
      
      
      Returning a valueA function can return a value back into the calling code as the result.
The simplest example would be a function that sums two values:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
        
      
      
      The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).
There may be many occurrences of return in a single function. For instance:

      
        
        
          
            
          
          
            
          
        
        
          function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('Do you have permission from your parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
        
      
      
      It is possible to use return without a value. That causes the function to exit immediately.
For example:

      
        
        
          function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
        
      
      
      In the code above, if checkAge(age) returns false, then showMovie won’t proceed to the alert.

            A function with an empty return or without it returns undefined
            If a function does not return a value, it is the same as if it returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
        
      
      
      An empty return is also the same as return undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
        
      
      
      

            Never add a newline between return and the value
            For a long expression in return, it might be tempting to put it on a separate line, like this:

      
        
        
          return
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      That doesn’t work, because JavaScript assumes a semicolon after return. That’ll work the same as:

      
        
        
          return;
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      So, it effectively becomes an empty return.
If we want the returned expression to wrap across multiple lines, we should start it at the same line as return. Or at least put the opening parentheses there as follows:

      
        
        
          return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
        
      
      
      And it will work just as we expect it to.

Naming a functionFunctions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.
It is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.
For instance, functions that start with "show" usually show something.
Function starting with…

"get…" – return a value,
"calc…" – calculate something,
"create…" – create something,
"check…" – check something and return a boolean, etc.

Examples of such names:

      
        
        
          showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false
        
      
      
      With prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.

            One function – one action
            A function should do exactly what is suggested by its name, no more.
Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).
A few examples of breaking this rule:

getAge – would be bad if it shows an alert with the age (should only get).
createForm – would be bad if it modifies the document, adding a form to it (should only create it and return).
checkPermission – would be bad if it displays the access granted/denied message (should only perform the check and return the result).

These examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they’re not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge.


            Ultrashort function names
            Functions that are used very often sometimes have ultrashort names.
For example, the jQuery framework defines a function with $. The Lodash library has its core function named _.
These are exceptions. Generally function names should be concise and descriptive.

Functions == CommentsFunctions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.
A separate function is not only easier to test and debug – its very existence is a great comment!
For instance, compare the two functions showPrimes(n) below. Each one outputs prime numbers up to n.
The first variant uses a label:

      
        
        
          function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
        
      
      
      The second variant uses an additional function isPrime(n) to test for primality:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
        
      
      
      The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (isPrime). Sometimes people refer to such code as self-describing.
So, functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.
SummaryA function declaration looks like this:

      
        
        
          function name(parameters, delimited, by, comma) {
  /* code */
}
        
      
      
      
Values passed to a function as parameters are copied to its local variables.
A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
A function can return a value. If it doesn’t, then its result is undefined.

To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.
Function naming:

A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
A function is an action, so function names are usually verbal.
There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.

Functions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can start creating and using them. But that’s only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.\n\nTutorialThe JavaScript languageJavaScript FundamentalsOctober 14, 2022FunctionsQuite often we need to perform a similar action in many places of the script.
For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.
Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.
We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.
Function DeclarationTo create a function we can use a function declaration.
It looks like this:

      
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}
        
      
      
      The function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.

      
        
        
          function name(parameter1, parameter2, ... parameterN) {
 // body
}
        
      
      
      Our new function can be called by its name: showMessage().
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
        
      
      
      The call showMessage() executes the code of the function. Here we will see the message two times.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.
Local variablesA variable declared inside a function is only visible inside that function.
For example:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! The variable is local to the function
        
      
      
      Outer variablesA function can access an outer variable as well, for example:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
        
      
      
      The function has full access to the outer variable. It can modify it as well.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, the value was modified by the function
        
      
      
      The outer variable is only used if there’s no local one.
If a same-named variable is declared inside the function then it shadows the outer one. For instance, in the code below the function uses the local userName. The outer one is ignored:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use its own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable
        
      
      
      
            Global variables
            Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).
It’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data.

ParametersWe can pass arbitrary data to functions using parameters.
In the example below, the function has two parameters: from and text.

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
        
      
      
      When the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.
Here’s one more example: we have a variable from and pass it to the function. Please note: the function changes from, but the change is not seen outside, because a function always gets a copy of the value:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) {

  from = '*' + from + '*'; // make "from" look nicer

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// the value of "from" is the same, the function modified a local copy
alert( from ); // Ann
        
      
      
      When a value is passed as a function parameter, it’s also called an argument.
In other words, to put these terms straight:

A parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).
An argument is the value that is passed to the function when it is called (it’s a call time term).

We declare functions listing their parameters, then call them passing arguments.
In the example above, one might say: “the function showMessage is declared with two parameters, then called with two arguments: from and "Hello"”.
Default valuesIf a function is called, but an argument is not provided, then the corresponding value becomes undefined.
For instance, the aforementioned function showMessage(from, text) can be called with a single argument:

      
        
        
          showMessage("Ann");
        
      
      
      That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it becomes undefined.
We can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
        
      
      
      Now if the text parameter is not passed, it will get the value "no text given".
The default value also jumps in if the parameter exists, but strictly equals undefined, like this:

      
        
        
          showMessage("Ann", undefined); // Ann: no text given
        
      
      
      Here "no text given" is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}
        
      
      
      
            Evaluation of default parameters
            In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.
In the example above, anotherFunction() isn’t called at all, if the text parameter is provided.
On the other hand, it’s independently called every time when text is missing.


            Default parameters in old JavaScript code
            Several years ago, JavaScript didn’t support the syntax for default parameters. So people used other ways to specify them.
Nowadays, we can come across them in old scripts.
For example, an explicit check for undefined:

      
        
        
          function showMessage(from, text) {
  if (text === undefined) {
    text = 'no text given';
  }

  alert( from + ": " + text );
}
        
      
      
      …Or using the || operator:

      
        
        
          function showMessage(from, text) {
  // If the value of text is falsy, assign the default value
  // this assumes that text == "" is the same as no text at all
  text = text || 'no text given';
  ...
}
        
      
      
      
Alternative default parametersSometimes it makes sense to assign default values for parameters at a later stage after the function declaration.
We can check if the parameter is passed during the function execution, by comparing it with undefined:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(text) {
  // ...

  if (text === undefined) { // if the parameter is missing
    text = 'empty message';
  }

  alert(text);
}

showMessage(); // empty message
        
      
      
      …Or we could use the || operator:

      
        
        
          function showMessage(text) {
  // if text is undefined or otherwise falsy, set it to 'empty'
  text = text || 'empty';
  ...
}
        
      
      
      Modern JavaScript engines support the nullish coalescing operator ??, it’s better when most falsy values, such as 0, should be considered “normal”:

      
        
        
          
            
          
          
            
          
        
        
          function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
        
      
      
      Returning a valueA function can return a value back into the calling code as the result.
The simplest example would be a function that sums two values:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
        
      
      
      The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).
There may be many occurrences of return in a single function. For instance:

      
        
        
          
            
          
          
            
          
        
        
          function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('Do you have permission from your parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
        
      
      
      It is possible to use return without a value. That causes the function to exit immediately.
For example:

      
        
        
          function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
        
      
      
      In the code above, if checkAge(age) returns false, then showMovie won’t proceed to the alert.

            A function with an empty return or without it returns undefined
            If a function does not return a value, it is the same as if it returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
        
      
      
      An empty return is also the same as return undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
        
      
      
      

            Never add a newline between return and the value
            For a long expression in return, it might be tempting to put it on a separate line, like this:

      
        
        
          return
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      That doesn’t work, because JavaScript assumes a semicolon after return. That’ll work the same as:

      
        
        
          return;
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      So, it effectively becomes an empty return.
If we want the returned expression to wrap across multiple lines, we should start it at the same line as return. Or at least put the opening parentheses there as follows:

      
        
        
          return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
        
      
      
      And it will work just as we expect it to.

Naming a functionFunctions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.
It is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.
For instance, functions that start with "show" usually show something.
Function starting with…

"get…" – return a value,
"calc…" – calculate something,
"create…" – create something,
"check…" – check something and return a boolean, etc.

Examples of such names:

      
        
        
          showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false
        
      
      
      With prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.

            One function – one action
            A function should do exactly what is suggested by its name, no more.
Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).
A few examples of breaking this rule:

getAge – would be bad if it shows an alert with the age (should only get).
createForm – would be bad if it modifies the document, adding a form to it (should only create it and return).
checkPermission – would be bad if it displays the access granted/denied message (should only perform the check and return the result).

These examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they’re not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge.


            Ultrashort function names
            Functions that are used very often sometimes have ultrashort names.
For example, the jQuery framework defines a function with $. The Lodash library has its core function named _.
These are exceptions. Generally function names should be concise and descriptive.

Functions == CommentsFunctions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.
A separate function is not only easier to test and debug – its very existence is a great comment!
For instance, compare the two functions showPrimes(n) below. Each one outputs prime numbers up to n.
The first variant uses a label:

      
        
        
          function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
        
      
      
      The second variant uses an additional function isPrime(n) to test for primality:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
        
      
      
      The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (isPrime). Sometimes people refer to such code as self-describing.
So, functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.
SummaryA function declaration looks like this:

      
        
        
          function name(parameters, delimited, by, comma) {
  /* code */
}
        
      
      
      
Values passed to a function as parameters are copied to its local variables.
A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
A function can return a value. If it doesn’t, then its result is undefined.

To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.
Function naming:

A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
A function is an action, so function names are usually verbal.
There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.

Functions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can start creating and using them. But that’s only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.
TasksIs "else" required?importance: 4The following function returns true if the parameter age is greater than 18.
Otherwise it asks for a confirmation and returns its result:

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}
        
      
      
      Will the function work differently if else is removed?

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}
        
      
      
      Is there any difference in the behavior of these two variants?
solutionNo difference!
In both cases, return confirm('Did parents allow you?') executes exactly when the if condition is falsy.
Rewrite the function using '?' or '||'importance: 4The following function returns true if the parameter age is greater than 18.
Otherwise it asks for a confirmation and returns its result.

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Did parents allow you?');
  }
}
        
      
      
      Rewrite it, to perform the same, but without if, in a single line.
Make two variants of checkAge:

Using a question mark operator ?
Using OR ||

solutionUsing a question mark operator '?':

      
        
        
          function checkAge(age) {
  return (age > 18) ? true : confirm('Did parents allow you?');
}
        
      
      
      Using OR || (the shortest variant):

      
        
        
          function checkAge(age) {
  return (age > 18) || confirm('Did parents allow you?');
}
        
      
      
      Note that the parentheses around age > 18 are not required here. They exist for better readability.
Function min(a, b)importance: 1Write a function min(a,b) which returns the least of two numbers a and b.
For instance:

      
        
        
          min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1
        
      
      
      solutionA solution using if:

      
        
        
          function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
        
      
      
      A solution with a question mark operator '?':

      
        
        
          function min(a, b) {
  return a < b ? a : b;
}
        
      
      
      P.S. In the case of an equality a == b it does not matter what to return.
Function pow(x,n)importance: 4Write a function pow(x,n) that returns x in power n. Or, in other words, multiplies x by itself n times and returns the result.

      
        
        
          pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...* 1 = 1
        
      
      
      Create a web-page that prompts for x and n, and then shows the result of pow(x,n).
Run the demoP.S. In this task the function should support only natural values of n: integers up from 1.
solution
      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n < 1) {
  alert(`Power ${n} is not supported, use a positive integer`);
} else {
  alert( pow(x, n) );
}
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nQuite often we need to perform a similar action in many places of the script.
For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.
Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.
We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.
Function DeclarationTo create a function we can use a function declaration.
It looks like this:

      
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}
        
      
      
      The function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.

      
        
        
          function name(parameter1, parameter2, ... parameterN) {
 // body
}
        
      
      
      Our new function can be called by its name: showMessage().
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
        
      
      
      The call showMessage() executes the code of the function. Here we will see the message two times.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.
Local variablesA variable declared inside a function is only visible inside that function.
For example:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! The variable is local to the function
        
      
      
      Outer variablesA function can access an outer variable as well, for example:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
        
      
      
      The function has full access to the outer variable. It can modify it as well.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, the value was modified by the function
        
      
      
      The outer variable is only used if there’s no local one.
If a same-named variable is declared inside the function then it shadows the outer one. For instance, in the code below the function uses the local userName. The outer one is ignored:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use its own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable
        
      
      
      
            Global variables
            Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).
It’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data.

ParametersWe can pass arbitrary data to functions using parameters.
In the example below, the function has two parameters: from and text.

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
        
      
      
      When the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.
Here’s one more example: we have a variable from and pass it to the function. Please note: the function changes from, but the change is not seen outside, because a function always gets a copy of the value:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) {

  from = '*' + from + '*'; // make "from" look nicer

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// the value of "from" is the same, the function modified a local copy
alert( from ); // Ann
        
      
      
      When a value is passed as a function parameter, it’s also called an argument.
In other words, to put these terms straight:

A parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).
An argument is the value that is passed to the function when it is called (it’s a call time term).

We declare functions listing their parameters, then call them passing arguments.
In the example above, one might say: “the function showMessage is declared with two parameters, then called with two arguments: from and "Hello"”.
Default valuesIf a function is called, but an argument is not provided, then the corresponding value becomes undefined.
For instance, the aforementioned function showMessage(from, text) can be called with a single argument:

      
        
        
          showMessage("Ann");
        
      
      
      That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it becomes undefined.
We can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
        
      
      
      Now if the text parameter is not passed, it will get the value "no text given".
The default value also jumps in if the parameter exists, but strictly equals undefined, like this:

      
        
        
          showMessage("Ann", undefined); // Ann: no text given
        
      
      
      Here "no text given" is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}
        
      
      
      
            Evaluation of default parameters
            In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.
In the example above, anotherFunction() isn’t called at all, if the text parameter is provided.
On the other hand, it’s independently called every time when text is missing.


            Default parameters in old JavaScript code
            Several years ago, JavaScript didn’t support the syntax for default parameters. So people used other ways to specify them.
Nowadays, we can come across them in old scripts.
For example, an explicit check for undefined:

      
        
        
          function showMessage(from, text) {
  if (text === undefined) {
    text = 'no text given';
  }

  alert( from + ": " + text );
}
        
      
      
      …Or using the || operator:

      
        
        
          function showMessage(from, text) {
  // If the value of text is falsy, assign the default value
  // this assumes that text == "" is the same as no text at all
  text = text || 'no text given';
  ...
}
        
      
      
      
Alternative default parametersSometimes it makes sense to assign default values for parameters at a later stage after the function declaration.
We can check if the parameter is passed during the function execution, by comparing it with undefined:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(text) {
  // ...

  if (text === undefined) { // if the parameter is missing
    text = 'empty message';
  }

  alert(text);
}

showMessage(); // empty message
        
      
      
      …Or we could use the || operator:

      
        
        
          function showMessage(text) {
  // if text is undefined or otherwise falsy, set it to 'empty'
  text = text || 'empty';
  ...
}
        
      
      
      Modern JavaScript engines support the nullish coalescing operator ??, it’s better when most falsy values, such as 0, should be considered “normal”:

      
        
        
          
            
          
          
            
          
        
        
          function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
        
      
      
      Returning a valueA function can return a value back into the calling code as the result.
The simplest example would be a function that sums two values:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
        
      
      
      The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).
There may be many occurrences of return in a single function. For instance:

      
        
        
          
            
          
          
            
          
        
        
          function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('Do you have permission from your parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
        
      
      
      It is possible to use return without a value. That causes the function to exit immediately.
For example:

      
        
        
          function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
        
      
      
      In the code above, if checkAge(age) returns false, then showMovie won’t proceed to the alert.

            A function with an empty return or without it returns undefined
            If a function does not return a value, it is the same as if it returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
        
      
      
      An empty return is also the same as return undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
        
      
      
      

            Never add a newline between return and the value
            For a long expression in return, it might be tempting to put it on a separate line, like this:

      
        
        
          return
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      That doesn’t work, because JavaScript assumes a semicolon after return. That’ll work the same as:

      
        
        
          return;
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      So, it effectively becomes an empty return.
If we want the returned expression to wrap across multiple lines, we should start it at the same line as return. Or at least put the opening parentheses there as follows:

      
        
        
          return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
        
      
      
      And it will work just as we expect it to.

Naming a functionFunctions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.
It is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.
For instance, functions that start with "show" usually show something.
Function starting with…

"get…" – return a value,
"calc…" – calculate something,
"create…" – create something,
"check…" – check something and return a boolean, etc.

Examples of such names:

      
        
        
          showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false
        
      
      
      With prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.

            One function – one action
            A function should do exactly what is suggested by its name, no more.
Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).
A few examples of breaking this rule:

getAge – would be bad if it shows an alert with the age (should only get).
createForm – would be bad if it modifies the document, adding a form to it (should only create it and return).
checkPermission – would be bad if it displays the access granted/denied message (should only perform the check and return the result).

These examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they’re not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge.


            Ultrashort function names
            Functions that are used very often sometimes have ultrashort names.
For example, the jQuery framework defines a function with $. The Lodash library has its core function named _.
These are exceptions. Generally function names should be concise and descriptive.

Functions == CommentsFunctions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.
A separate function is not only easier to test and debug – its very existence is a great comment!
For instance, compare the two functions showPrimes(n) below. Each one outputs prime numbers up to n.
The first variant uses a label:

      
        
        
          function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
        
      
      
      The second variant uses an additional function isPrime(n) to test for primality:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
        
      
      
      The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (isPrime). Sometimes people refer to such code as self-describing.
So, functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.
SummaryA function declaration looks like this:

      
        
        
          function name(parameters, delimited, by, comma) {
  /* code */
}
        
      
      
      
Values passed to a function as parameters are copied to its local variables.
A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
A function can return a value. If it doesn’t, then its result is undefined.

To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.
Function naming:

A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
A function is an action, so function names are usually verbal.
There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.

Functions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can start creating and using them. But that’s only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.
TasksIs "else" required?importance: 4The following function returns true if the parameter age is greater than 18.
Otherwise it asks for a confirmation and returns its result:

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}
        
      
      
      Will the function work differently if else is removed?

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}
        
      
      
      Is there any difference in the behavior of these two variants?
solutionNo difference!
In both cases, return confirm('Did parents allow you?') executes exactly when the if condition is falsy.
Rewrite the function using '?' or '||'importance: 4The following function returns true if the parameter age is greater than 18.
Otherwise it asks for a confirmation and returns its result.

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Did parents allow you?');
  }
}
        
      
      
      Rewrite it, to perform the same, but without if, in a single line.
Make two variants of checkAge:

Using a question mark operator ?
Using OR ||

solutionUsing a question mark operator '?':

      
        
        
          function checkAge(age) {
  return (age > 18) ? true : confirm('Did parents allow you?');
}
        
      
      
      Using OR || (the shortest variant):

      
        
        
          function checkAge(age) {
  return (age > 18) || confirm('Did parents allow you?');
}
        
      
      
      Note that the parentheses around age > 18 are not required here. They exist for better readability.
Function min(a, b)importance: 1Write a function min(a,b) which returns the least of two numbers a and b.
For instance:

      
        
        
          min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1
        
      
      
      solutionA solution using if:

      
        
        
          function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
        
      
      
      A solution with a question mark operator '?':

      
        
        
          function min(a, b) {
  return a < b ? a : b;
}
        
      
      
      P.S. In the case of an equality a == b it does not matter what to return.
Function pow(x,n)importance: 4Write a function pow(x,n) that returns x in power n. Or, in other words, multiplies x by itself n times and returns the result.

      
        
        
          pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...* 1 = 1
        
      
      
      Create a web-page that prompts for x and n, and then shows the result of pow(x,n).
Run the demoP.S. In this task the function should support only natural values of n: integers up from 1.
solution
      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n < 1) {
  alert(`Power ${n} is not supported, use a positive integer`);
} else {
  alert( pow(x, n) );
}\n\nTutorialThe JavaScript languageJavaScript FundamentalsOctober 14, 2022FunctionsQuite often we need to perform a similar action in many places of the script.
For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.
Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.
We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.
Function DeclarationTo create a function we can use a function declaration.
It looks like this:

      
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}
        
      
      
      The function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.

      
        
        
          function name(parameter1, parameter2, ... parameterN) {
 // body
}
        
      
      
      Our new function can be called by its name: showMessage().
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
        
      
      
      The call showMessage() executes the code of the function. Here we will see the message two times.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.
Local variablesA variable declared inside a function is only visible inside that function.
For example:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! The variable is local to the function
        
      
      
      Outer variablesA function can access an outer variable as well, for example:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
        
      
      
      The function has full access to the outer variable. It can modify it as well.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, the value was modified by the function
        
      
      
      The outer variable is only used if there’s no local one.
If a same-named variable is declared inside the function then it shadows the outer one. For instance, in the code below the function uses the local userName. The outer one is ignored:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use its own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable
        
      
      
      
            Global variables
            Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).
It’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data.

ParametersWe can pass arbitrary data to functions using parameters.
In the example below, the function has two parameters: from and text.

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
        
      
      
      When the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.
Here’s one more example: we have a variable from and pass it to the function. Please note: the function changes from, but the change is not seen outside, because a function always gets a copy of the value:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) {

  from = '*' + from + '*'; // make "from" look nicer

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// the value of "from" is the same, the function modified a local copy
alert( from ); // Ann
        
      
      
      When a value is passed as a function parameter, it’s also called an argument.
In other words, to put these terms straight:

A parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).
An argument is the value that is passed to the function when it is called (it’s a call time term).

We declare functions listing their parameters, then call them passing arguments.
In the example above, one might say: “the function showMessage is declared with two parameters, then called with two arguments: from and "Hello"”.
Default valuesIf a function is called, but an argument is not provided, then the corresponding value becomes undefined.
For instance, the aforementioned function showMessage(from, text) can be called with a single argument:

      
        
        
          showMessage("Ann");
        
      
      
      That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it becomes undefined.
We can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
        
      
      
      Now if the text parameter is not passed, it will get the value "no text given".
The default value also jumps in if the parameter exists, but strictly equals undefined, like this:

      
        
        
          showMessage("Ann", undefined); // Ann: no text given
        
      
      
      Here "no text given" is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}
        
      
      
      
            Evaluation of default parameters
            In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.
In the example above, anotherFunction() isn’t called at all, if the text parameter is provided.
On the other hand, it’s independently called every time when text is missing.


            Default parameters in old JavaScript code
            Several years ago, JavaScript didn’t support the syntax for default parameters. So people used other ways to specify them.
Nowadays, we can come across them in old scripts.
For example, an explicit check for undefined:

      
        
        
          function showMessage(from, text) {
  if (text === undefined) {
    text = 'no text given';
  }

  alert( from + ": " + text );
}
        
      
      
      …Or using the || operator:

      
        
        
          function showMessage(from, text) {
  // If the value of text is falsy, assign the default value
  // this assumes that text == "" is the same as no text at all
  text = text || 'no text given';
  ...
}
        
      
      
      
Alternative default parametersSometimes it makes sense to assign default values for parameters at a later stage after the function declaration.
We can check if the parameter is passed during the function execution, by comparing it with undefined:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(text) {
  // ...

  if (text === undefined) { // if the parameter is missing
    text = 'empty message';
  }

  alert(text);
}

showMessage(); // empty message
        
      
      
      …Or we could use the || operator:

      
        
        
          function showMessage(text) {
  // if text is undefined or otherwise falsy, set it to 'empty'
  text = text || 'empty';
  ...
}
        
      
      
      Modern JavaScript engines support the nullish coalescing operator ??, it’s better when most falsy values, such as 0, should be considered “normal”:

      
        
        
          
            
          
          
            
          
        
        
          function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
        
      
      
      Returning a valueA function can return a value back into the calling code as the result.
The simplest example would be a function that sums two values:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
        
      
      
      The directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).
There may be many occurrences of return in a single function. For instance:

      
        
        
          
            
          
          
            
          
        
        
          function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('Do you have permission from your parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
        
      
      
      It is possible to use return without a value. That causes the function to exit immediately.
For example:

      
        
        
          function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
        
      
      
      In the code above, if checkAge(age) returns false, then showMovie won’t proceed to the alert.

            A function with an empty return or without it returns undefined
            If a function does not return a value, it is the same as if it returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
        
      
      
      An empty return is also the same as return undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
        
      
      
      

            Never add a newline between return and the value
            For a long expression in return, it might be tempting to put it on a separate line, like this:

      
        
        
          return
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      That doesn’t work, because JavaScript assumes a semicolon after return. That’ll work the same as:

      
        
        
          return;
 (some + long + expression + or + whatever * f(a) + f(b))
        
      
      
      So, it effectively becomes an empty return.
If we want the returned expression to wrap across multiple lines, we should start it at the same line as return. Or at least put the opening parentheses there as follows:

      
        
        
          return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
        
      
      
      And it will work just as we expect it to.

Naming a functionFunctions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.
It is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.
For instance, functions that start with "show" usually show something.
Function starting with…

"get…" – return a value,
"calc…" – calculate something,
"create…" – create something,
"check…" – check something and return a boolean, etc.

Examples of such names:

      
        
        
          showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false
        
      
      
      With prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.

            One function – one action
            A function should do exactly what is suggested by its name, no more.
Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).
A few examples of breaking this rule:

getAge – would be bad if it shows an alert with the age (should only get).
createForm – would be bad if it modifies the document, adding a form to it (should only create it and return).
checkPermission – would be bad if it displays the access granted/denied message (should only perform the check and return the result).

These examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they’re not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge.


            Ultrashort function names
            Functions that are used very often sometimes have ultrashort names.
For example, the jQuery framework defines a function with $. The Lodash library has its core function named _.
These are exceptions. Generally function names should be concise and descriptive.

Functions == CommentsFunctions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.
A separate function is not only easier to test and debug – its very existence is a great comment!
For instance, compare the two functions showPrimes(n) below. Each one outputs prime numbers up to n.
The first variant uses a label:

      
        
        
          function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
        
      
      
      The second variant uses an additional function isPrime(n) to test for primality:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
        
      
      
      The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (isPrime). Sometimes people refer to such code as self-describing.
So, functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.
SummaryA function declaration looks like this:

      
        
        
          function name(parameters, delimited, by, comma) {
  /* code */
}
        
      
      
      
Values passed to a function as parameters are copied to its local variables.
A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
A function can return a value. If it doesn’t, then its result is undefined.

To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.
It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.
Function naming:

A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
A function is an action, so function names are usually verbal.
There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.

Functions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can start creating and using them. But that’s only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.
TasksIs "else" required?importance: 4The following function returns true if the parameter age is greater than 18.
Otherwise it asks for a confirmation and returns its result:

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}
        
      
      
      Will the function work differently if else is removed?

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}
        
      
      
      Is there any difference in the behavior of these two variants?
solutionNo difference!
In both cases, return confirm('Did parents allow you?') executes exactly when the if condition is falsy.
Rewrite the function using '?' or '||'importance: 4The following function returns true if the parameter age is greater than 18.
Otherwise it asks for a confirmation and returns its result.

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Did parents allow you?');
  }
}
        
      
      
      Rewrite it, to perform the same, but without if, in a single line.
Make two variants of checkAge:

Using a question mark operator ?
Using OR ||

solutionUsing a question mark operator '?':

      
        
        
          function checkAge(age) {
  return (age > 18) ? true : confirm('Did parents allow you?');
}
        
      
      
      Using OR || (the shortest variant):

      
        
        
          function checkAge(age) {
  return (age > 18) || confirm('Did parents allow you?');
}
        
      
      
      Note that the parentheses around age > 18 are not required here. They exist for better readability.
Function min(a, b)importance: 1Write a function min(a,b) which returns the least of two numbers a and b.
For instance:

      
        
        
          min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1
        
      
      
      solutionA solution using if:

      
        
        
          function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
        
      
      
      A solution with a question mark operator '?':

      
        
        
          function min(a, b) {
  return a < b ? a : b;
}
        
      
      
      P.S. In the case of an equality a == b it does not matter what to return.
Function pow(x,n)importance: 4Write a function pow(x,n) that returns x in power n. Or, in other words, multiplies x by itself n times and returns the result.

      
        
        
          pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...* 1 = 1
        
      
      
      Create a web-page that prompts for x and n, and then shows the result of pow(x,n).
Run the demoP.S. In this task the function should support only natural values of n: integers up from 1.
solution
      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n < 1) {
  alert(`Power ${n} is not supported, use a positive integer`);
} else {
  alert( pow(x, n) );
}
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nIn JavaScript, a function is not a “magical language structure”, but a special kind of value.
The syntax that we used before is called a Function Declaration:

      
        
        
          function sayHi() {
  alert( "Hello" );
}
        
      
      
      There is another syntax for creating a function that is called a Function Expression.
It allows us to create a new function in the middle of any expression.
For example:

      
        
        
          let sayHi = function() {
  alert( "Hello" );
};
        
      
      
      Here we can see a variable sayHi getting a value, the new function, created as function() { alert("Hello"); }.
As the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.
Please note, there’s no name after the function keyword. Omitting a name is allowed for Function Expressions.
Here we immediately assign it to the variable, so the meaning of these code samples is the same: “create a function and put it into the variable sayHi”.
In more advanced situations, that we’ll come across later, a function may be created and immediately called or scheduled for a later execution, not stored anywhere, thus remaining anonymous.
Function is a valueLet’s reiterate: no matter how the function is created, a function is a value. Both examples above store a function in the sayHi variable.
We can even print out that value using alert:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
        
      
      
      Please note that the last line does not run the function, because there are no parentheses after sayHi. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.
In JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.
Surely, a function is a special value, in the sense that we can call it like sayHi().
But it’s still a value. So we can work with it like with other kinds of values.
We can copy a function to another variable:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
        
      
      
      Here’s what happens above in detail:

The Function Declaration (1) creates the function and puts it into the variable named sayHi.
Line (2) copies it into the variable func. Please note again: there are no parentheses after sayHi. If there were, then func = sayHi() would write  the result of the call sayHi() into func, not the function sayHi itself.
Now the function can be called as both sayHi() and func().

We could also have used a Function Expression to declare sayHi, in the first line:

      
        
        
          let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;  //(2)
// ...
        
      
      
      Everything would work the same.

            Why is there a semicolon at the end?
            You might wonder, why do Function Expressions have a semicolon ; at the end, but Function Declarations do not:

      
        
        
          function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
        
      
      
      The answer is simple: a Function Expression is created here as function(…) {…} inside the assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.
The semicolon would be there for a simpler assignment, such as let sayHi = 5;, and it’s also there for a function assignment.

Callback functionsLet’s look at more examples of passing functions as values and using function expressions.
We’ll write a function ask(question, yes, no) with three parameters:

question
Text of the question
yes
Function to run if the answer is “Yes”
no
Function to run if the answer is “No”

The function should ask the question and, depending on the user’s answer, call yes() or no():

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);
        
      
      
      In practice, such functions are quite useful. The major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm. In the browser, such functions usually draw a nice-looking question window. But that’s another story.
The arguments showOk and showCancel of ask are called callback functions or just callbacks.
The idea is that we pass a function and expect it to be “called back” later if necessary. In our case, showOk becomes the callback for “yes” answer, and showCancel for “no” answer.
We can use Function Expressions to write an equivalent, shorter function:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      Here, functions are declared right inside the ask(...) call. They have no name, and so are called anonymous. Such functions are not accessible outside of ask (because they are not assigned to variables), but that’s just what we want here.
Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

            A function is a value representing an “action”
            Regular values like strings or numbers represent the data.
A function can be perceived as an action.
We can pass it between variables and run when we want.

Function Expression vs Function DeclarationLet’s formulate the key differences between Function Declarations and Expressions.
First, the syntax: how to differentiate between them in the code.


Function Declaration: a function, declared as a separate statement, in the main code flow:

      
        
        
          // Function Declaration
function sum(a, b) {
  return a + b;
}
        
      
      
      

Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =:

      
        
        
          // Function Expression
let sum = function(a, b) {
  return a + b;
};
        
      
      
      

The more subtle difference is when a function is created by the JavaScript engine.
A Function Expression is created when the execution reaches it and is usable only from that moment.
Once the execution flow passes to the right side of the assignment let sum = function… – here we go, the function is created and can be used (assigned, called, etc. ) from now on.
Function Declarations are different.
A Function Declaration can be called earlier than it is defined.
For example, a global Function Declaration is visible in the whole script, no matter where it is.
That’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.
And after all Function Declarations are processed, the code is executed. So it has access to these functions.
For example, this works:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
        
      
      
      The Function Declaration sayHi is created when JavaScript is preparing to start the script and is visible everywhere in it.
…If it were a Function Expression, then it wouldn’t work:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
        
      
      
      Function Expressions are created when the execution reaches them. That would happen only in the line (*). Too late.
Another special feature of Function Declarations is their block scope.
In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.
For instance, let’s imagine that we need to declare a function welcome() depending on the age variable that we get during runtime. And then we plan to use it some time later.
If we use Function Declaration, it won’t work as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...use it later
welcome(); // Error: welcome is not defined
        
      
      
      That’s because a Function Declaration is only visible inside the code block in which it resides.
Here’s another example:

      
        
        
          
            
          
          
            
          
        
        
          let age = 16; // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
  welcome();               // /   (runs)

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.

welcome(); // Error: welcome is not defined
        
      
      
      What can we do to make welcome visible outside of if?
The correct approach would be to use a Function Expression and assign welcome to the variable that is declared outside of if and has the proper visibility.
This code works as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

welcome(); // ok now
        
      
      
      Or we could simplify it even further using a question mark operator ?:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

welcome(); // ok now
        
      
      
      
            When to choose Function Declaration versus Function Expression?
            As a rule of thumb, when we need to declare a function, the first thing to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.
That’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.
…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used.

Summary
Functions are values. They can be assigned, copied or declared in any place of the code.
If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.
If the function is created as a part of an expression, it’s called a “Function Expression”.
Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.
So we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJanuary 22, 2025Function expressionsIn JavaScript, a function is not a “magical language structure”, but a special kind of value.
The syntax that we used before is called a Function Declaration:

      
        
        
          function sayHi() {
  alert( "Hello" );
}
        
      
      
      There is another syntax for creating a function that is called a Function Expression.
It allows us to create a new function in the middle of any expression.
For example:

      
        
        
          let sayHi = function() {
  alert( "Hello" );
};
        
      
      
      Here we can see a variable sayHi getting a value, the new function, created as function() { alert("Hello"); }.
As the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.
Please note, there’s no name after the function keyword. Omitting a name is allowed for Function Expressions.
Here we immediately assign it to the variable, so the meaning of these code samples is the same: “create a function and put it into the variable sayHi”.
In more advanced situations, that we’ll come across later, a function may be created and immediately called or scheduled for a later execution, not stored anywhere, thus remaining anonymous.
Function is a valueLet’s reiterate: no matter how the function is created, a function is a value. Both examples above store a function in the sayHi variable.
We can even print out that value using alert:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
        
      
      
      Please note that the last line does not run the function, because there are no parentheses after sayHi. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.
In JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.
Surely, a function is a special value, in the sense that we can call it like sayHi().
But it’s still a value. So we can work with it like with other kinds of values.
We can copy a function to another variable:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
        
      
      
      Here’s what happens above in detail:

The Function Declaration (1) creates the function and puts it into the variable named sayHi.
Line (2) copies it into the variable func. Please note again: there are no parentheses after sayHi. If there were, then func = sayHi() would write  the result of the call sayHi() into func, not the function sayHi itself.
Now the function can be called as both sayHi() and func().

We could also have used a Function Expression to declare sayHi, in the first line:

      
        
        
          let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;  //(2)
// ...
        
      
      
      Everything would work the same.

            Why is there a semicolon at the end?
            You might wonder, why do Function Expressions have a semicolon ; at the end, but Function Declarations do not:

      
        
        
          function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
        
      
      
      The answer is simple: a Function Expression is created here as function(…) {…} inside the assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.
The semicolon would be there for a simpler assignment, such as let sayHi = 5;, and it’s also there for a function assignment.

Callback functionsLet’s look at more examples of passing functions as values and using function expressions.
We’ll write a function ask(question, yes, no) with three parameters:

question
Text of the question
yes
Function to run if the answer is “Yes”
no
Function to run if the answer is “No”

The function should ask the question and, depending on the user’s answer, call yes() or no():

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);
        
      
      
      In practice, such functions are quite useful. The major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm. In the browser, such functions usually draw a nice-looking question window. But that’s another story.
The arguments showOk and showCancel of ask are called callback functions or just callbacks.
The idea is that we pass a function and expect it to be “called back” later if necessary. In our case, showOk becomes the callback for “yes” answer, and showCancel for “no” answer.
We can use Function Expressions to write an equivalent, shorter function:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      Here, functions are declared right inside the ask(...) call. They have no name, and so are called anonymous. Such functions are not accessible outside of ask (because they are not assigned to variables), but that’s just what we want here.
Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

            A function is a value representing an “action”
            Regular values like strings or numbers represent the data.
A function can be perceived as an action.
We can pass it between variables and run when we want.

Function Expression vs Function DeclarationLet’s formulate the key differences between Function Declarations and Expressions.
First, the syntax: how to differentiate between them in the code.


Function Declaration: a function, declared as a separate statement, in the main code flow:

      
        
        
          // Function Declaration
function sum(a, b) {
  return a + b;
}
        
      
      
      

Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =:

      
        
        
          // Function Expression
let sum = function(a, b) {
  return a + b;
};
        
      
      
      

The more subtle difference is when a function is created by the JavaScript engine.
A Function Expression is created when the execution reaches it and is usable only from that moment.
Once the execution flow passes to the right side of the assignment let sum = function… – here we go, the function is created and can be used (assigned, called, etc. ) from now on.
Function Declarations are different.
A Function Declaration can be called earlier than it is defined.
For example, a global Function Declaration is visible in the whole script, no matter where it is.
That’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.
And after all Function Declarations are processed, the code is executed. So it has access to these functions.
For example, this works:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
        
      
      
      The Function Declaration sayHi is created when JavaScript is preparing to start the script and is visible everywhere in it.
…If it were a Function Expression, then it wouldn’t work:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
        
      
      
      Function Expressions are created when the execution reaches them. That would happen only in the line (*). Too late.
Another special feature of Function Declarations is their block scope.
In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.
For instance, let’s imagine that we need to declare a function welcome() depending on the age variable that we get during runtime. And then we plan to use it some time later.
If we use Function Declaration, it won’t work as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...use it later
welcome(); // Error: welcome is not defined
        
      
      
      That’s because a Function Declaration is only visible inside the code block in which it resides.
Here’s another example:

      
        
        
          
            
          
          
            
          
        
        
          let age = 16; // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
  welcome();               // /   (runs)

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.

welcome(); // Error: welcome is not defined
        
      
      
      What can we do to make welcome visible outside of if?
The correct approach would be to use a Function Expression and assign welcome to the variable that is declared outside of if and has the proper visibility.
This code works as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

welcome(); // ok now
        
      
      
      Or we could simplify it even further using a question mark operator ?:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

welcome(); // ok now
        
      
      
      
            When to choose Function Declaration versus Function Expression?
            As a rule of thumb, when we need to declare a function, the first thing to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.
That’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.
…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used.

Summary
Functions are values. They can be assigned, copied or declared in any place of the code.
If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.
If the function is created as a part of an expression, it’s called a “Function Expression”.
Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.
So we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nIn JavaScript, a function is not a “magical language structure”, but a special kind of value.
The syntax that we used before is called a Function Declaration:

      
        
        
          function sayHi() {
  alert( "Hello" );
}
        
      
      
      There is another syntax for creating a function that is called a Function Expression.
It allows us to create a new function in the middle of any expression.
For example:

      
        
        
          let sayHi = function() {
  alert( "Hello" );
};
        
      
      
      Here we can see a variable sayHi getting a value, the new function, created as function() { alert("Hello"); }.
As the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.
Please note, there’s no name after the function keyword. Omitting a name is allowed for Function Expressions.
Here we immediately assign it to the variable, so the meaning of these code samples is the same: “create a function and put it into the variable sayHi”.
In more advanced situations, that we’ll come across later, a function may be created and immediately called or scheduled for a later execution, not stored anywhere, thus remaining anonymous.
Function is a valueLet’s reiterate: no matter how the function is created, a function is a value. Both examples above store a function in the sayHi variable.
We can even print out that value using alert:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
        
      
      
      Please note that the last line does not run the function, because there are no parentheses after sayHi. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.
In JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.
Surely, a function is a special value, in the sense that we can call it like sayHi().
But it’s still a value. So we can work with it like with other kinds of values.
We can copy a function to another variable:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
        
      
      
      Here’s what happens above in detail:

The Function Declaration (1) creates the function and puts it into the variable named sayHi.
Line (2) copies it into the variable func. Please note again: there are no parentheses after sayHi. If there were, then func = sayHi() would write  the result of the call sayHi() into func, not the function sayHi itself.
Now the function can be called as both sayHi() and func().

We could also have used a Function Expression to declare sayHi, in the first line:

      
        
        
          let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;  //(2)
// ...
        
      
      
      Everything would work the same.

            Why is there a semicolon at the end?
            You might wonder, why do Function Expressions have a semicolon ; at the end, but Function Declarations do not:

      
        
        
          function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
        
      
      
      The answer is simple: a Function Expression is created here as function(…) {…} inside the assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.
The semicolon would be there for a simpler assignment, such as let sayHi = 5;, and it’s also there for a function assignment.

Callback functionsLet’s look at more examples of passing functions as values and using function expressions.
We’ll write a function ask(question, yes, no) with three parameters:

question
Text of the question
yes
Function to run if the answer is “Yes”
no
Function to run if the answer is “No”

The function should ask the question and, depending on the user’s answer, call yes() or no():

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);
        
      
      
      In practice, such functions are quite useful. The major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm. In the browser, such functions usually draw a nice-looking question window. But that’s another story.
The arguments showOk and showCancel of ask are called callback functions or just callbacks.
The idea is that we pass a function and expect it to be “called back” later if necessary. In our case, showOk becomes the callback for “yes” answer, and showCancel for “no” answer.
We can use Function Expressions to write an equivalent, shorter function:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      Here, functions are declared right inside the ask(...) call. They have no name, and so are called anonymous. Such functions are not accessible outside of ask (because they are not assigned to variables), but that’s just what we want here.
Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

            A function is a value representing an “action”
            Regular values like strings or numbers represent the data.
A function can be perceived as an action.
We can pass it between variables and run when we want.

Function Expression vs Function DeclarationLet’s formulate the key differences between Function Declarations and Expressions.
First, the syntax: how to differentiate between them in the code.


Function Declaration: a function, declared as a separate statement, in the main code flow:

      
        
        
          // Function Declaration
function sum(a, b) {
  return a + b;
}
        
      
      
      

Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =:

      
        
        
          // Function Expression
let sum = function(a, b) {
  return a + b;
};
        
      
      
      

The more subtle difference is when a function is created by the JavaScript engine.
A Function Expression is created when the execution reaches it and is usable only from that moment.
Once the execution flow passes to the right side of the assignment let sum = function… – here we go, the function is created and can be used (assigned, called, etc. ) from now on.
Function Declarations are different.
A Function Declaration can be called earlier than it is defined.
For example, a global Function Declaration is visible in the whole script, no matter where it is.
That’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.
And after all Function Declarations are processed, the code is executed. So it has access to these functions.
For example, this works:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
        
      
      
      The Function Declaration sayHi is created when JavaScript is preparing to start the script and is visible everywhere in it.
…If it were a Function Expression, then it wouldn’t work:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
        
      
      
      Function Expressions are created when the execution reaches them. That would happen only in the line (*). Too late.
Another special feature of Function Declarations is their block scope.
In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.
For instance, let’s imagine that we need to declare a function welcome() depending on the age variable that we get during runtime. And then we plan to use it some time later.
If we use Function Declaration, it won’t work as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...use it later
welcome(); // Error: welcome is not defined
        
      
      
      That’s because a Function Declaration is only visible inside the code block in which it resides.
Here’s another example:

      
        
        
          
            
          
          
            
          
        
        
          let age = 16; // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
  welcome();               // /   (runs)

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.

welcome(); // Error: welcome is not defined
        
      
      
      What can we do to make welcome visible outside of if?
The correct approach would be to use a Function Expression and assign welcome to the variable that is declared outside of if and has the proper visibility.
This code works as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

welcome(); // ok now
        
      
      
      Or we could simplify it even further using a question mark operator ?:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

welcome(); // ok now
        
      
      
      
            When to choose Function Declaration versus Function Expression?
            As a rule of thumb, when we need to declare a function, the first thing to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.
That’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.
…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used.

Summary
Functions are values. They can be assigned, copied or declared in any place of the code.
If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.
If the function is created as a part of an expression, it’s called a “Function Expression”.
Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.
So we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJanuary 22, 2025Function expressionsIn JavaScript, a function is not a “magical language structure”, but a special kind of value.
The syntax that we used before is called a Function Declaration:

      
        
        
          function sayHi() {
  alert( "Hello" );
}
        
      
      
      There is another syntax for creating a function that is called a Function Expression.
It allows us to create a new function in the middle of any expression.
For example:

      
        
        
          let sayHi = function() {
  alert( "Hello" );
};
        
      
      
      Here we can see a variable sayHi getting a value, the new function, created as function() { alert("Hello"); }.
As the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.
Please note, there’s no name after the function keyword. Omitting a name is allowed for Function Expressions.
Here we immediately assign it to the variable, so the meaning of these code samples is the same: “create a function and put it into the variable sayHi”.
In more advanced situations, that we’ll come across later, a function may be created and immediately called or scheduled for a later execution, not stored anywhere, thus remaining anonymous.
Function is a valueLet’s reiterate: no matter how the function is created, a function is a value. Both examples above store a function in the sayHi variable.
We can even print out that value using alert:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
        
      
      
      Please note that the last line does not run the function, because there are no parentheses after sayHi. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.
In JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.
Surely, a function is a special value, in the sense that we can call it like sayHi().
But it’s still a value. So we can work with it like with other kinds of values.
We can copy a function to another variable:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
        
      
      
      Here’s what happens above in detail:

The Function Declaration (1) creates the function and puts it into the variable named sayHi.
Line (2) copies it into the variable func. Please note again: there are no parentheses after sayHi. If there were, then func = sayHi() would write  the result of the call sayHi() into func, not the function sayHi itself.
Now the function can be called as both sayHi() and func().

We could also have used a Function Expression to declare sayHi, in the first line:

      
        
        
          let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;  //(2)
// ...
        
      
      
      Everything would work the same.

            Why is there a semicolon at the end?
            You might wonder, why do Function Expressions have a semicolon ; at the end, but Function Declarations do not:

      
        
        
          function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
        
      
      
      The answer is simple: a Function Expression is created here as function(…) {…} inside the assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.
The semicolon would be there for a simpler assignment, such as let sayHi = 5;, and it’s also there for a function assignment.

Callback functionsLet’s look at more examples of passing functions as values and using function expressions.
We’ll write a function ask(question, yes, no) with three parameters:

question
Text of the question
yes
Function to run if the answer is “Yes”
no
Function to run if the answer is “No”

The function should ask the question and, depending on the user’s answer, call yes() or no():

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);
        
      
      
      In practice, such functions are quite useful. The major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm. In the browser, such functions usually draw a nice-looking question window. But that’s another story.
The arguments showOk and showCancel of ask are called callback functions or just callbacks.
The idea is that we pass a function and expect it to be “called back” later if necessary. In our case, showOk becomes the callback for “yes” answer, and showCancel for “no” answer.
We can use Function Expressions to write an equivalent, shorter function:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      Here, functions are declared right inside the ask(...) call. They have no name, and so are called anonymous. Such functions are not accessible outside of ask (because they are not assigned to variables), but that’s just what we want here.
Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

            A function is a value representing an “action”
            Regular values like strings or numbers represent the data.
A function can be perceived as an action.
We can pass it between variables and run when we want.

Function Expression vs Function DeclarationLet’s formulate the key differences between Function Declarations and Expressions.
First, the syntax: how to differentiate between them in the code.


Function Declaration: a function, declared as a separate statement, in the main code flow:

      
        
        
          // Function Declaration
function sum(a, b) {
  return a + b;
}
        
      
      
      

Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =:

      
        
        
          // Function Expression
let sum = function(a, b) {
  return a + b;
};
        
      
      
      

The more subtle difference is when a function is created by the JavaScript engine.
A Function Expression is created when the execution reaches it and is usable only from that moment.
Once the execution flow passes to the right side of the assignment let sum = function… – here we go, the function is created and can be used (assigned, called, etc. ) from now on.
Function Declarations are different.
A Function Declaration can be called earlier than it is defined.
For example, a global Function Declaration is visible in the whole script, no matter where it is.
That’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.
And after all Function Declarations are processed, the code is executed. So it has access to these functions.
For example, this works:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
        
      
      
      The Function Declaration sayHi is created when JavaScript is preparing to start the script and is visible everywhere in it.
…If it were a Function Expression, then it wouldn’t work:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
        
      
      
      Function Expressions are created when the execution reaches them. That would happen only in the line (*). Too late.
Another special feature of Function Declarations is their block scope.
In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.
For instance, let’s imagine that we need to declare a function welcome() depending on the age variable that we get during runtime. And then we plan to use it some time later.
If we use Function Declaration, it won’t work as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...use it later
welcome(); // Error: welcome is not defined
        
      
      
      That’s because a Function Declaration is only visible inside the code block in which it resides.
Here’s another example:

      
        
        
          
            
          
          
            
          
        
        
          let age = 16; // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
  welcome();               // /   (runs)

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.

welcome(); // Error: welcome is not defined
        
      
      
      What can we do to make welcome visible outside of if?
The correct approach would be to use a Function Expression and assign welcome to the variable that is declared outside of if and has the proper visibility.
This code works as intended:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

welcome(); // ok now
        
      
      
      Or we could simplify it even further using a question mark operator ?:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

welcome(); // ok now
        
      
      
      
            When to choose Function Declaration versus Function Expression?
            As a rule of thumb, when we need to declare a function, the first thing to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.
That’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.
…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used.

Summary
Functions are values. They can be assigned, copied or declared in any place of the code.
If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.
If the function is created as a part of an expression, it’s called a “Function Expression”.
Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.
So we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThere’s another very simple and concise syntax for creating functions, that’s often better than Function Expressions.
It’s called “arrow functions”, because it looks like this:

      
        
        
          let func = (arg1, arg2, ..., argN) => expression;
        
      
      
      This creates a function func that accepts arguments arg1..argN, then evaluates the expression on the right side with their use and returns its result.
In other words, it’s the shorter version of:

      
        
        
          let func = function(arg1, arg2, ..., argN) {
  return expression;
};
        
      
      
      Let’s see a concrete example:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => a + b;

/* This arrow function is a shorter form of:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
        
      
      
      As you can see, (a, b) => a + b means a function that accepts two arguments named a and b. Upon the execution, it evaluates the expression a + b and returns the result.


If we have only one argument, then parentheses around parameters can be omitted, making that even shorter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let double = n => n * 2;
// roughly the same as: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
        
      
      
      

If there are no arguments, parentheses are empty, but they must be present:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = () => alert("Hello!");

sayHi();
        
      
      
      

Arrow functions can be used in the same way as Function Expressions.
For instance, to dynamically create a function:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

welcome();
        
      
      
      Arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.
They are very convenient for simple one-line actions, when we’re just too lazy to write many words.
Multiline arrow functionsThe arrow functions that we’ve seen so far were very simple. They took arguments from the left of =>, evaluated and returned the right-side expression with them.
Sometimes we need a more complex function, with multiple expressions and statements. In that case, we can enclose them in curly braces. The major difference is that curly braces require a return within them to return a value (just like a regular function does).
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};

alert( sum(1, 2) ); // 3
        
      
      
      
            More to come
            Here we praised arrow functions for brevity. But that’s not all!
Arrow functions have other interesting features.
To study them in-depth, we first need to get to know some other aspects of JavaScript, so we’ll return to arrow functions later in the chapter Arrow functions revisited.
For now, we can already use arrow functions for one-line actions and callbacks.

SummaryArrow functions are handy for simple actions, especially for one-liners. They come in two flavors:

Without curly braces: (...args) => expression – the right side is an expression: the function evaluates it and returns the result. Parentheses can be omitted, if there’s only a single argument, e.g. n => n*2.
With curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.\n\nTutorialThe JavaScript languageJavaScript FundamentalsApril 14, 2022Arrow functions, the basicsThere’s another very simple and concise syntax for creating functions, that’s often better than Function Expressions.
It’s called “arrow functions”, because it looks like this:

      
        
        
          let func = (arg1, arg2, ..., argN) => expression;
        
      
      
      This creates a function func that accepts arguments arg1..argN, then evaluates the expression on the right side with their use and returns its result.
In other words, it’s the shorter version of:

      
        
        
          let func = function(arg1, arg2, ..., argN) {
  return expression;
};
        
      
      
      Let’s see a concrete example:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => a + b;

/* This arrow function is a shorter form of:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
        
      
      
      As you can see, (a, b) => a + b means a function that accepts two arguments named a and b. Upon the execution, it evaluates the expression a + b and returns the result.


If we have only one argument, then parentheses around parameters can be omitted, making that even shorter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let double = n => n * 2;
// roughly the same as: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
        
      
      
      

If there are no arguments, parentheses are empty, but they must be present:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = () => alert("Hello!");

sayHi();
        
      
      
      

Arrow functions can be used in the same way as Function Expressions.
For instance, to dynamically create a function:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

welcome();
        
      
      
      Arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.
They are very convenient for simple one-line actions, when we’re just too lazy to write many words.
Multiline arrow functionsThe arrow functions that we’ve seen so far were very simple. They took arguments from the left of =>, evaluated and returned the right-side expression with them.
Sometimes we need a more complex function, with multiple expressions and statements. In that case, we can enclose them in curly braces. The major difference is that curly braces require a return within them to return a value (just like a regular function does).
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};

alert( sum(1, 2) ); // 3
        
      
      
      
            More to come
            Here we praised arrow functions for brevity. But that’s not all!
Arrow functions have other interesting features.
To study them in-depth, we first need to get to know some other aspects of JavaScript, so we’ll return to arrow functions later in the chapter Arrow functions revisited.
For now, we can already use arrow functions for one-line actions and callbacks.

SummaryArrow functions are handy for simple actions, especially for one-liners. They come in two flavors:

Without curly braces: (...args) => expression – the right side is an expression: the function evaluates it and returns the result. Parentheses can be omitted, if there’s only a single argument, e.g. n => n*2.
With curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.

TasksRewrite with arrow functionsReplace Function Expressions with arrow functions in the code below:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  () => alert("You agreed."),
  () => alert("You canceled the execution.")
);
        
      
      
      Looks short and clean, right?
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThere’s another very simple and concise syntax for creating functions, that’s often better than Function Expressions.
It’s called “arrow functions”, because it looks like this:

      
        
        
          let func = (arg1, arg2, ..., argN) => expression;
        
      
      
      This creates a function func that accepts arguments arg1..argN, then evaluates the expression on the right side with their use and returns its result.
In other words, it’s the shorter version of:

      
        
        
          let func = function(arg1, arg2, ..., argN) {
  return expression;
};
        
      
      
      Let’s see a concrete example:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => a + b;

/* This arrow function is a shorter form of:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
        
      
      
      As you can see, (a, b) => a + b means a function that accepts two arguments named a and b. Upon the execution, it evaluates the expression a + b and returns the result.


If we have only one argument, then parentheses around parameters can be omitted, making that even shorter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let double = n => n * 2;
// roughly the same as: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
        
      
      
      

If there are no arguments, parentheses are empty, but they must be present:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = () => alert("Hello!");

sayHi();
        
      
      
      

Arrow functions can be used in the same way as Function Expressions.
For instance, to dynamically create a function:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

welcome();
        
      
      
      Arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.
They are very convenient for simple one-line actions, when we’re just too lazy to write many words.
Multiline arrow functionsThe arrow functions that we’ve seen so far were very simple. They took arguments from the left of =>, evaluated and returned the right-side expression with them.
Sometimes we need a more complex function, with multiple expressions and statements. In that case, we can enclose them in curly braces. The major difference is that curly braces require a return within them to return a value (just like a regular function does).
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};

alert( sum(1, 2) ); // 3
        
      
      
      
            More to come
            Here we praised arrow functions for brevity. But that’s not all!
Arrow functions have other interesting features.
To study them in-depth, we first need to get to know some other aspects of JavaScript, so we’ll return to arrow functions later in the chapter Arrow functions revisited.
For now, we can already use arrow functions for one-line actions and callbacks.

SummaryArrow functions are handy for simple actions, especially for one-liners. They come in two flavors:

Without curly braces: (...args) => expression – the right side is an expression: the function evaluates it and returns the result. Parentheses can be omitted, if there’s only a single argument, e.g. n => n*2.
With curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.

TasksRewrite with arrow functionsReplace Function Expressions with arrow functions in the code below:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  () => alert("You agreed."),
  () => alert("You canceled the execution.")
);
        
      
      
      Looks short and clean, right?\n\nTutorialThe JavaScript languageJavaScript FundamentalsApril 14, 2022Arrow functions, the basicsThere’s another very simple and concise syntax for creating functions, that’s often better than Function Expressions.
It’s called “arrow functions”, because it looks like this:

      
        
        
          let func = (arg1, arg2, ..., argN) => expression;
        
      
      
      This creates a function func that accepts arguments arg1..argN, then evaluates the expression on the right side with their use and returns its result.
In other words, it’s the shorter version of:

      
        
        
          let func = function(arg1, arg2, ..., argN) {
  return expression;
};
        
      
      
      Let’s see a concrete example:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => a + b;

/* This arrow function is a shorter form of:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
        
      
      
      As you can see, (a, b) => a + b means a function that accepts two arguments named a and b. Upon the execution, it evaluates the expression a + b and returns the result.


If we have only one argument, then parentheses around parameters can be omitted, making that even shorter.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let double = n => n * 2;
// roughly the same as: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
        
      
      
      

If there are no arguments, parentheses are empty, but they must be present:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = () => alert("Hello!");

sayHi();
        
      
      
      

Arrow functions can be used in the same way as Function Expressions.
For instance, to dynamically create a function:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

welcome();
        
      
      
      Arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.
They are very convenient for simple one-line actions, when we’re just too lazy to write many words.
Multiline arrow functionsThe arrow functions that we’ve seen so far were very simple. They took arguments from the left of =>, evaluated and returned the right-side expression with them.
Sometimes we need a more complex function, with multiple expressions and statements. In that case, we can enclose them in curly braces. The major difference is that curly braces require a return within them to return a value (just like a regular function does).
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};

alert( sum(1, 2) ); // 3
        
      
      
      
            More to come
            Here we praised arrow functions for brevity. But that’s not all!
Arrow functions have other interesting features.
To study them in-depth, we first need to get to know some other aspects of JavaScript, so we’ll return to arrow functions later in the chapter Arrow functions revisited.
For now, we can already use arrow functions for one-line actions and callbacks.

SummaryArrow functions are handy for simple actions, especially for one-liners. They come in two flavors:

Without curly braces: (...args) => expression – the right side is an expression: the function evaluates it and returns the result. Parentheses can be omitted, if there’s only a single argument, e.g. n => n*2.
With curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.

TasksRewrite with arrow functionsReplace Function Expressions with arrow functions in the code below:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  () => alert("You agreed."),
  () => alert("You canceled the execution.")
);
        
      
      
      Looks short and clean, right?
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThis chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.
Code structureStatements are delimited with a semicolon:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, a line-break is also treated as a delimiter, so that would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      That’s called “automatic semicolon insertion”. Sometimes it doesn’t work, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert("There will be an error after this message")

[1, 2].forEach(alert)
        
      
      
      Most codestyle guides agree that we should put a semicolon after each statement.
Semicolons are not required after code blocks {...} and syntax constructs with them like loops:

      
        
        
          function f() {
  // no semicolon needed after function declaration
}

for(;;) {
  // no semicolon needed after the loop
}
        
      
      
      …But even if we can put an “extra” semicolon somewhere, that’s not an error. It will be ignored.
More in: Code structure.
Strict modeTo fully enable all features of modern JavaScript, we should start scripts with "use strict".

      
        
        
          'use strict';

...
        
      
      
      The directive must be at the top of a script or at the beginning of a function body.
Without "use strict", everything still works, but some features behave in the old-fashioned, “compatible” way. We’d generally prefer the modern behavior.
Some modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.
More in: The modern mode, "use strict".
VariablesCan be declared using:

let
const (constant, can’t be changed)
var (old-style, will see later)

A variable name can include:

Letters and digits, but the first character may not be a digit.
Characters $ and _ are normal, on par with letters.
Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.

Variables are dynamically typed. They can store any value:

      
        
        
          let x = 5;
x = "John";
        
      
      
      There are 8 data types:

number for both floating-point and integer numbers,
bigint for integer numbers of arbitrary length,
string for strings,
boolean for logical values: true/false,
null – a type with a single value null, meaning “empty” or “does not exist”,
undefined – a type with a single value undefined, meaning “not assigned”,
object and symbol – for complex data structures and unique identifiers, we haven’t learnt them yet.

The typeof operator returns the type for a value, with two exceptions:

      
        
        
          typeof null == "object" // error in the language
typeof function(){} == "function" // functions are treated specially
        
      
      
      More in: Variables and Data types.
InteractionWe’re using a browser as a working environment, so basic UI functions will be:

prompt(question, [default])
Ask a question, and return either what the visitor entered or null if they clicked “cancel”.
confirm(question)
Ask a question and suggest to choose between Ok and Cancel. The choice is returned as true/false.
alert(message)
Output a message.

All these functions are modal, they pause the code execution and prevent the visitor from interacting with the page until they answer.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
        
      
      
      More in: Interaction: alert, prompt, confirm.
OperatorsJavaScript supports the following operators:

Arithmetical

Regular: * + - /, also % for the remainder and ** for power of a number.
The binary plus + concatenates strings. And if any of the operands is a string, the other one is converted to string too:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string
        
      
      
      
Assignments

There is a simple assignment: a = b and combined ones like a *= 2.

Bitwise

Bitwise operators work with 32-bit integers at the lowest, bit-level: see the docs when they are needed.

Conditional

The only operator with three parameters: cond ? resultA : resultB. If cond is truthy, returns resultA, otherwise resultB.

Logical operators

Logical AND && and OR || perform short-circuit evaluation and then return the value where it stopped (not necessary true/false). Logical NOT ! converts the operand to boolean type and returns the inverse value.

Nullish coalescing operator

The ?? operator provides a way to choose a defined value from a list of variables. The result of a ?? b is a unless it’s null/undefined, then b.

Comparisons

Equality check == for values of different types converts them to a number (except null and undefined that equal each other and nothing else), so these are equal:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
alert( 0 == '' ); // true
        
      
      
      Other comparisons convert to a number as well.
The strict equality operator === doesn’t do the conversion: different types always mean different values for it.
Values null and undefined are special: they equal == each other and don’t equal anything else.
Greater/less comparisons compare strings character-by-character, other types are converted to a number.

Other operators

There are few others, like a comma operator.


More in: Basic operators, maths, Comparisons, Logical operators, Nullish coalescing operator '??'.
Loops

We covered 3 types of loops:

      
        
        
          // 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
        
      
      
      

The variable declared in for(let...) loop is visible only inside the loop. But we can also omit let and reuse an existing variable.


Directives break/continue allow to exit the whole loop/current iteration. Use labels to break nested loops.


Details in: Loops: while and for.
Later we’ll study more types of loops to deal with objects.
The “switch” constructThe “switch” construct can replace multiple if checks. It uses === (strict equality) for comparisons.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('Your age?', 18);

switch (age) {
  case 18:
    alert("Won't work"); // the result of prompt is a string, not a number
    break;

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
        
      
      
      Details in: The "switch" statement.
FunctionsWe covered three ways to create a function in JavaScript:


Function Declaration: the function in the main code flow

      
        
        
          function sum(a, b) {
  let result = a + b;

  return result;
}
        
      
      
      

Function Expression: the function in the context of an expression

      
        
        
          let sum = function(a, b) {
  let result = a + b;

  return result;
};
        
      
      
      

Arrow functions:

      
        
        
          // expression on the right side
let sum = (a, b) => a + b;

// or multi-line syntax with { ... }, need return here:
let sum = (a, b) => {
  // ...
  return a + b;
}

// without arguments
let sayHi = () => alert("Hello");

// with a single argument
let double = n => n * 2;
        
      
      
      


Functions may have local variables: those declared inside its body or its parameter list. Such variables are only visible inside the function.
Parameters can have default values: function sum(a = 1, b = 2) {...}.
Functions always return something. If there’s no return statement, then the result is undefined.

Details: see Functions, Arrow functions, the basics.
More to comeThat was a brief list of JavaScript features. As of now we’ve studied only basics. Further in the tutorial you’ll find more specials and advanced features of JavaScript.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJanuary 22, 2023JavaScript specialsThis chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.
Code structureStatements are delimited with a semicolon:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, a line-break is also treated as a delimiter, so that would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      That’s called “automatic semicolon insertion”. Sometimes it doesn’t work, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert("There will be an error after this message")

[1, 2].forEach(alert)
        
      
      
      Most codestyle guides agree that we should put a semicolon after each statement.
Semicolons are not required after code blocks {...} and syntax constructs with them like loops:

      
        
        
          function f() {
  // no semicolon needed after function declaration
}

for(;;) {
  // no semicolon needed after the loop
}
        
      
      
      …But even if we can put an “extra” semicolon somewhere, that’s not an error. It will be ignored.
More in: Code structure.
Strict modeTo fully enable all features of modern JavaScript, we should start scripts with "use strict".

      
        
        
          'use strict';

...
        
      
      
      The directive must be at the top of a script or at the beginning of a function body.
Without "use strict", everything still works, but some features behave in the old-fashioned, “compatible” way. We’d generally prefer the modern behavior.
Some modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.
More in: The modern mode, "use strict".
VariablesCan be declared using:

let
const (constant, can’t be changed)
var (old-style, will see later)

A variable name can include:

Letters and digits, but the first character may not be a digit.
Characters $ and _ are normal, on par with letters.
Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.

Variables are dynamically typed. They can store any value:

      
        
        
          let x = 5;
x = "John";
        
      
      
      There are 8 data types:

number for both floating-point and integer numbers,
bigint for integer numbers of arbitrary length,
string for strings,
boolean for logical values: true/false,
null – a type with a single value null, meaning “empty” or “does not exist”,
undefined – a type with a single value undefined, meaning “not assigned”,
object and symbol – for complex data structures and unique identifiers, we haven’t learnt them yet.

The typeof operator returns the type for a value, with two exceptions:

      
        
        
          typeof null == "object" // error in the language
typeof function(){} == "function" // functions are treated specially
        
      
      
      More in: Variables and Data types.
InteractionWe’re using a browser as a working environment, so basic UI functions will be:

prompt(question, [default])
Ask a question, and return either what the visitor entered or null if they clicked “cancel”.
confirm(question)
Ask a question and suggest to choose between Ok and Cancel. The choice is returned as true/false.
alert(message)
Output a message.

All these functions are modal, they pause the code execution and prevent the visitor from interacting with the page until they answer.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
        
      
      
      More in: Interaction: alert, prompt, confirm.
OperatorsJavaScript supports the following operators:

Arithmetical

Regular: * + - /, also % for the remainder and ** for power of a number.
The binary plus + concatenates strings. And if any of the operands is a string, the other one is converted to string too:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string
        
      
      
      
Assignments

There is a simple assignment: a = b and combined ones like a *= 2.

Bitwise

Bitwise operators work with 32-bit integers at the lowest, bit-level: see the docs when they are needed.

Conditional

The only operator with three parameters: cond ? resultA : resultB. If cond is truthy, returns resultA, otherwise resultB.

Logical operators

Logical AND && and OR || perform short-circuit evaluation and then return the value where it stopped (not necessary true/false). Logical NOT ! converts the operand to boolean type and returns the inverse value.

Nullish coalescing operator

The ?? operator provides a way to choose a defined value from a list of variables. The result of a ?? b is a unless it’s null/undefined, then b.

Comparisons

Equality check == for values of different types converts them to a number (except null and undefined that equal each other and nothing else), so these are equal:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
alert( 0 == '' ); // true
        
      
      
      Other comparisons convert to a number as well.
The strict equality operator === doesn’t do the conversion: different types always mean different values for it.
Values null and undefined are special: they equal == each other and don’t equal anything else.
Greater/less comparisons compare strings character-by-character, other types are converted to a number.

Other operators

There are few others, like a comma operator.


More in: Basic operators, maths, Comparisons, Logical operators, Nullish coalescing operator '??'.
Loops

We covered 3 types of loops:

      
        
        
          // 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
        
      
      
      

The variable declared in for(let...) loop is visible only inside the loop. But we can also omit let and reuse an existing variable.


Directives break/continue allow to exit the whole loop/current iteration. Use labels to break nested loops.


Details in: Loops: while and for.
Later we’ll study more types of loops to deal with objects.
The “switch” constructThe “switch” construct can replace multiple if checks. It uses === (strict equality) for comparisons.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('Your age?', 18);

switch (age) {
  case 18:
    alert("Won't work"); // the result of prompt is a string, not a number
    break;

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
        
      
      
      Details in: The "switch" statement.
FunctionsWe covered three ways to create a function in JavaScript:


Function Declaration: the function in the main code flow

      
        
        
          function sum(a, b) {
  let result = a + b;

  return result;
}
        
      
      
      

Function Expression: the function in the context of an expression

      
        
        
          let sum = function(a, b) {
  let result = a + b;

  return result;
};
        
      
      
      

Arrow functions:

      
        
        
          // expression on the right side
let sum = (a, b) => a + b;

// or multi-line syntax with { ... }, need return here:
let sum = (a, b) => {
  // ...
  return a + b;
}

// without arguments
let sayHi = () => alert("Hello");

// with a single argument
let double = n => n * 2;
        
      
      
      


Functions may have local variables: those declared inside its body or its parameter list. Such variables are only visible inside the function.
Parameters can have default values: function sum(a = 1, b = 2) {...}.
Functions always return something. If there’s no return statement, then the result is undefined.

Details: see Functions, Arrow functions, the basics.
More to comeThat was a brief list of JavaScript features. As of now we’ve studied only basics. Further in the tutorial you’ll find more specials and advanced features of JavaScript.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThis chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.
Code structureStatements are delimited with a semicolon:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, a line-break is also treated as a delimiter, so that would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      That’s called “automatic semicolon insertion”. Sometimes it doesn’t work, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert("There will be an error after this message")

[1, 2].forEach(alert)
        
      
      
      Most codestyle guides agree that we should put a semicolon after each statement.
Semicolons are not required after code blocks {...} and syntax constructs with them like loops:

      
        
        
          function f() {
  // no semicolon needed after function declaration
}

for(;;) {
  // no semicolon needed after the loop
}
        
      
      
      …But even if we can put an “extra” semicolon somewhere, that’s not an error. It will be ignored.
More in: Code structure.
Strict modeTo fully enable all features of modern JavaScript, we should start scripts with "use strict".

      
        
        
          'use strict';

...
        
      
      
      The directive must be at the top of a script or at the beginning of a function body.
Without "use strict", everything still works, but some features behave in the old-fashioned, “compatible” way. We’d generally prefer the modern behavior.
Some modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.
More in: The modern mode, "use strict".
VariablesCan be declared using:

let
const (constant, can’t be changed)
var (old-style, will see later)

A variable name can include:

Letters and digits, but the first character may not be a digit.
Characters $ and _ are normal, on par with letters.
Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.

Variables are dynamically typed. They can store any value:

      
        
        
          let x = 5;
x = "John";
        
      
      
      There are 8 data types:

number for both floating-point and integer numbers,
bigint for integer numbers of arbitrary length,
string for strings,
boolean for logical values: true/false,
null – a type with a single value null, meaning “empty” or “does not exist”,
undefined – a type with a single value undefined, meaning “not assigned”,
object and symbol – for complex data structures and unique identifiers, we haven’t learnt them yet.

The typeof operator returns the type for a value, with two exceptions:

      
        
        
          typeof null == "object" // error in the language
typeof function(){} == "function" // functions are treated specially
        
      
      
      More in: Variables and Data types.
InteractionWe’re using a browser as a working environment, so basic UI functions will be:

prompt(question, [default])
Ask a question, and return either what the visitor entered or null if they clicked “cancel”.
confirm(question)
Ask a question and suggest to choose between Ok and Cancel. The choice is returned as true/false.
alert(message)
Output a message.

All these functions are modal, they pause the code execution and prevent the visitor from interacting with the page until they answer.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
        
      
      
      More in: Interaction: alert, prompt, confirm.
OperatorsJavaScript supports the following operators:

Arithmetical

Regular: * + - /, also % for the remainder and ** for power of a number.
The binary plus + concatenates strings. And if any of the operands is a string, the other one is converted to string too:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string
        
      
      
      
Assignments

There is a simple assignment: a = b and combined ones like a *= 2.

Bitwise

Bitwise operators work with 32-bit integers at the lowest, bit-level: see the docs when they are needed.

Conditional

The only operator with three parameters: cond ? resultA : resultB. If cond is truthy, returns resultA, otherwise resultB.

Logical operators

Logical AND && and OR || perform short-circuit evaluation and then return the value where it stopped (not necessary true/false). Logical NOT ! converts the operand to boolean type and returns the inverse value.

Nullish coalescing operator

The ?? operator provides a way to choose a defined value from a list of variables. The result of a ?? b is a unless it’s null/undefined, then b.

Comparisons

Equality check == for values of different types converts them to a number (except null and undefined that equal each other and nothing else), so these are equal:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
alert( 0 == '' ); // true
        
      
      
      Other comparisons convert to a number as well.
The strict equality operator === doesn’t do the conversion: different types always mean different values for it.
Values null and undefined are special: they equal == each other and don’t equal anything else.
Greater/less comparisons compare strings character-by-character, other types are converted to a number.

Other operators

There are few others, like a comma operator.


More in: Basic operators, maths, Comparisons, Logical operators, Nullish coalescing operator '??'.
Loops

We covered 3 types of loops:

      
        
        
          // 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
        
      
      
      

The variable declared in for(let...) loop is visible only inside the loop. But we can also omit let and reuse an existing variable.


Directives break/continue allow to exit the whole loop/current iteration. Use labels to break nested loops.


Details in: Loops: while and for.
Later we’ll study more types of loops to deal with objects.
The “switch” constructThe “switch” construct can replace multiple if checks. It uses === (strict equality) for comparisons.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('Your age?', 18);

switch (age) {
  case 18:
    alert("Won't work"); // the result of prompt is a string, not a number
    break;

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
        
      
      
      Details in: The "switch" statement.
FunctionsWe covered three ways to create a function in JavaScript:


Function Declaration: the function in the main code flow

      
        
        
          function sum(a, b) {
  let result = a + b;

  return result;
}
        
      
      
      

Function Expression: the function in the context of an expression

      
        
        
          let sum = function(a, b) {
  let result = a + b;

  return result;
};
        
      
      
      

Arrow functions:

      
        
        
          // expression on the right side
let sum = (a, b) => a + b;

// or multi-line syntax with { ... }, need return here:
let sum = (a, b) => {
  // ...
  return a + b;
}

// without arguments
let sayHi = () => alert("Hello");

// with a single argument
let double = n => n * 2;
        
      
      
      


Functions may have local variables: those declared inside its body or its parameter list. Such variables are only visible inside the function.
Parameters can have default values: function sum(a = 1, b = 2) {...}.
Functions always return something. If there’s no return statement, then the result is undefined.

Details: see Functions, Arrow functions, the basics.
More to comeThat was a brief list of JavaScript features. As of now we’ve studied only basics. Further in the tutorial you’ll find more specials and advanced features of JavaScript.\n\nTutorialThe JavaScript languageJavaScript FundamentalsJanuary 22, 2023JavaScript specialsThis chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.
Code structureStatements are delimited with a semicolon:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello'); alert('World');
        
      
      
      Usually, a line-break is also treated as a delimiter, so that would also work:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hello')
alert('World')
        
      
      
      That’s called “automatic semicolon insertion”. Sometimes it doesn’t work, for instance:

      
        
        
          
            
          
          
            
          
        
        
          alert("There will be an error after this message")

[1, 2].forEach(alert)
        
      
      
      Most codestyle guides agree that we should put a semicolon after each statement.
Semicolons are not required after code blocks {...} and syntax constructs with them like loops:

      
        
        
          function f() {
  // no semicolon needed after function declaration
}

for(;;) {
  // no semicolon needed after the loop
}
        
      
      
      …But even if we can put an “extra” semicolon somewhere, that’s not an error. It will be ignored.
More in: Code structure.
Strict modeTo fully enable all features of modern JavaScript, we should start scripts with "use strict".

      
        
        
          'use strict';

...
        
      
      
      The directive must be at the top of a script or at the beginning of a function body.
Without "use strict", everything still works, but some features behave in the old-fashioned, “compatible” way. We’d generally prefer the modern behavior.
Some modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.
More in: The modern mode, "use strict".
VariablesCan be declared using:

let
const (constant, can’t be changed)
var (old-style, will see later)

A variable name can include:

Letters and digits, but the first character may not be a digit.
Characters $ and _ are normal, on par with letters.
Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.

Variables are dynamically typed. They can store any value:

      
        
        
          let x = 5;
x = "John";
        
      
      
      There are 8 data types:

number for both floating-point and integer numbers,
bigint for integer numbers of arbitrary length,
string for strings,
boolean for logical values: true/false,
null – a type with a single value null, meaning “empty” or “does not exist”,
undefined – a type with a single value undefined, meaning “not assigned”,
object and symbol – for complex data structures and unique identifiers, we haven’t learnt them yet.

The typeof operator returns the type for a value, with two exceptions:

      
        
        
          typeof null == "object" // error in the language
typeof function(){} == "function" // functions are treated specially
        
      
      
      More in: Variables and Data types.
InteractionWe’re using a browser as a working environment, so basic UI functions will be:

prompt(question, [default])
Ask a question, and return either what the visitor entered or null if they clicked “cancel”.
confirm(question)
Ask a question and suggest to choose between Ok and Cancel. The choice is returned as true/false.
alert(message)
Output a message.

All these functions are modal, they pause the code execution and prevent the visitor from interacting with the page until they answer.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
        
      
      
      More in: Interaction: alert, prompt, confirm.
OperatorsJavaScript supports the following operators:

Arithmetical

Regular: * + - /, also % for the remainder and ** for power of a number.
The binary plus + concatenates strings. And if any of the operands is a string, the other one is converted to string too:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string
        
      
      
      
Assignments

There is a simple assignment: a = b and combined ones like a *= 2.

Bitwise

Bitwise operators work with 32-bit integers at the lowest, bit-level: see the docs when they are needed.

Conditional

The only operator with three parameters: cond ? resultA : resultB. If cond is truthy, returns resultA, otherwise resultB.

Logical operators

Logical AND && and OR || perform short-circuit evaluation and then return the value where it stopped (not necessary true/false). Logical NOT ! converts the operand to boolean type and returns the inverse value.

Nullish coalescing operator

The ?? operator provides a way to choose a defined value from a list of variables. The result of a ?? b is a unless it’s null/undefined, then b.

Comparisons

Equality check == for values of different types converts them to a number (except null and undefined that equal each other and nothing else), so these are equal:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
alert( 0 == '' ); // true
        
      
      
      Other comparisons convert to a number as well.
The strict equality operator === doesn’t do the conversion: different types always mean different values for it.
Values null and undefined are special: they equal == each other and don’t equal anything else.
Greater/less comparisons compare strings character-by-character, other types are converted to a number.

Other operators

There are few others, like a comma operator.


More in: Basic operators, maths, Comparisons, Logical operators, Nullish coalescing operator '??'.
Loops

We covered 3 types of loops:

      
        
        
          // 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
        
      
      
      

The variable declared in for(let...) loop is visible only inside the loop. But we can also omit let and reuse an existing variable.


Directives break/continue allow to exit the whole loop/current iteration. Use labels to break nested loops.


Details in: Loops: while and for.
Later we’ll study more types of loops to deal with objects.
The “switch” constructThe “switch” construct can replace multiple if checks. It uses === (strict equality) for comparisons.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('Your age?', 18);

switch (age) {
  case 18:
    alert("Won't work"); // the result of prompt is a string, not a number
    break;

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
        
      
      
      Details in: The "switch" statement.
FunctionsWe covered three ways to create a function in JavaScript:


Function Declaration: the function in the main code flow

      
        
        
          function sum(a, b) {
  let result = a + b;

  return result;
}
        
      
      
      

Function Expression: the function in the context of an expression

      
        
        
          let sum = function(a, b) {
  let result = a + b;

  return result;
};
        
      
      
      

Arrow functions:

      
        
        
          // expression on the right side
let sum = (a, b) => a + b;

// or multi-line syntax with { ... }, need return here:
let sum = (a, b) => {
  // ...
  return a + b;
}

// without arguments
let sayHi = () => alert("Hello");

// with a single argument
let double = n => n * 2;
        
      
      
      


Functions may have local variables: those declared inside its body or its parameter list. Such variables are only visible inside the function.
Parameters can have default values: function sum(a = 1, b = 2) {...}.
Functions always return something. If there’s no return statement, then the result is undefined.

Details: see Functions, Arrow functions, the basics.
More to comeThat was a brief list of JavaScript features. As of now we’ve studied only basics. Further in the tutorial you’ll find more specials and advanced features of JavaScript.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.\n\nPart 1The JavaScript languagePart 2Browser: Document, Events, InterfacesPart 3Additional articlesThe JavaScript languageHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.
We concentrate on the language itself here, with the minimum of environment-specific notes.
An introductionAn Introduction to JavaScriptManuals and specificationsCode editorsDeveloper consoleJavaScript FundamentalsHello, world!Code structureThe modern mode, "use strict"VariablesData typesInteraction: alert, prompt, confirmType ConversionsBasic operators, mathsComparisonsConditional branching: if, '?'Logical operatorsNullish coalescing operator '??'Loops: while and forThe "switch" statementFunctionsFunction expressionsArrow functions, the basicsJavaScript specialsMore…Code qualityDebugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionData typesMethods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONMore…Advanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedMore…Object properties configurationProperty flags and descriptorsProperty getters and settersPrototypes, inheritancePrototypal inheritanceF.prototypeNative prototypesPrototype methods, objects without __proto__ClassesClass basic syntaxClass inheritanceStatic properties and methodsPrivate and protected properties and methodsExtending built-in classesClass checking: "instanceof"MixinsError handlingError handling, "try...catch"Custom errors, extending ErrorPromises, async/awaitIntroduction: callbacksPromisePromises chainingError handling with promisesPromise APIPromisificationMicrotasksAsync/awaitGenerators, advanced iterationGeneratorsAsync iteration and generatorsModulesModules, introductionExport and ImportDynamic importsMiscellaneousProxy and ReflectEval: run a code stringCurryingReference TypeBigIntUnicode, String internalsWeakRef and FinalizationRegistryBrowser: Document, Events, InterfacesLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.
DocumentBrowser environment, specsDOM treeWalking the DOMSearching: getElement*, querySelector*Node properties: type, tag and contentsAttributes and propertiesModifying the documentStyles and classesElement size and scrollingWindow sizes and scrollingCoordinatesMore…Introduction to EventsIntroduction to browser eventsBubbling and capturingEvent delegationBrowser default actionsDispatching custom eventsUI EventsMouse eventsMoving the mouse: mouseover/out, mouseenter/leaveDrag'n'Drop with mouse eventsPointer eventsKeyboard: keydown and keyupScrollingForms, controlsForm properties and methodsFocusing: focus/blurEvents: change, input, cut, copy, pasteForms: event and method submitDocument and resource loadingPage: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferResource loading: onload and onerrorMiscellaneousMutation observerSelection and RangeEvent loop: microtasks and macrotasksAdditional articlesList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.Frames and windowsPopups and window methodsCross-window communicationThe clickjacking attackBinary data, filesArrayBuffer, binary arraysTextDecoder and TextEncoderBlobFile and FileReaderNetwork requestsFetchFormDataFetch: Download progressFetch: AbortFetch: Cross-Origin RequestsFetch APIURL objectsXMLHttpRequestResumable file uploadLong pollingWebSocketServer Sent EventsMore…Storing data in the browserCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimationBezier curveCSS-animationsJavaScript animationsWeb componentsFrom the orbital heightCustom elementsShadow DOMTemplate elementShadow DOM slots, compositionShadow DOM stylingShadow DOM and eventsRegular expressionsPatterns and flagsCharacter classesUnicode: flag "u" and class \p{...}Anchors: string start ^ and end $Multiline mode of anchors ^ $, flag "m"Word boundary: \bEscaping, special charactersSets and ranges [...]Quantifiers +, *, ? and {n}Greedy and lazy quantifiersCapturing groupsBackreferences in pattern: \N and \k<name>Alternation (OR) |Lookahead and lookbehindCatastrophic backtrackingSticky flag "y", searching at positionMethods of RegExp and StringMore…Watch for javascript.info updatesWe do not send advertisements, only relevant stuff. You choose what to receive:Common updatesNew courses and screencasts, site updatesJavascript/DOM/Interfaces courseNode.JS courseAngular courseReact.JS courseTypescript courseSubscribeBy signing up to newsletters you agree to the terms of usage.ShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTutorialThe JavaScript languageCode qualityThis chapter explains coding practices that we’ll use further in the development.
Debugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersPrevious lessonNext lessonShareTutorial map\n\nThis chapter explains coding practices that we’ll use further in the development.
Debugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilers\n\nTutorialThe JavaScript languageCode qualityThis chapter explains coding practices that we’ll use further in the development.
Debugging in the browserCoding StyleCommentsNinja codeAutomated testing with MochaPolyfills and transpilersPrevious lessonNext lessonShareTutorial map\n\n\n\nBefore writing more complex code, let’s talk about debugging.
Debugging is the process of finding and fixing errors within a script. All modern browsers and most other environments support debugging tools – a special UI in developer tools that makes debugging much easier. It also allows to trace the code step by step to see what exactly is going on.
We’ll be using Chrome here, because it has enough features, most other browsers have a similar process.
The “Sources” panelYour Chrome version may look a little bit different, but it still should be obvious what’s there.

Open the example page in Chrome.
Turn on developer tools with F12 (Mac: Cmd+Opt+I).
Select the Sources panel.

Here’s what you should see if you are doing it for the first time:

      
      
        
      
      The toggler button  opens the tab with files.
Let’s click it and select hello.js in the tree view. Here’s what should show up:

      
      
        
      
      The Sources panel has 3 parts:

The File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
The Code Editor pane shows the source code.
The JavaScript Debugging pane is for debugging, we’ll explore it soon.

Now you could click the same toggler  again to hide the resources list and give the code some space.
ConsoleIf we press Esc, then a console opens below. We can type commands there and press Enter to execute.
After a statement is executed, its result is shown below.
For example, here 1+2 results in 3, while the function call hello("debugger") returns nothing, so the result is undefined:

      
      
        
      
      BreakpointsLet’s examine what’s going on within the code of the example page. In hello.js, click at line number 4. Yes, right on the 4 digit, not on the code.
Congratulations! You’ve set a breakpoint. Please also click on the number for line 8.
It should look like this (blue is where you should click):

      
      
        
      
      A breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.
While the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.
We can always find a list of breakpoints in the right panel. That’s useful when we have many breakpoints in various files. It allows us to:

Quickly jump to the breakpoint in the code (by clicking on it in the right panel).
Temporarily disable the breakpoint by unchecking it.
Remove the breakpoint by right-clicking and selecting Remove.
…And so on.


            Conditional breakpoints
            Right click on the line number allows to create a conditional breakpoint. It only triggers when the given expression, that you should provide when you create it, is truthy.
That’s handy when we need to stop only for a certain variable value or for certain function parameters.

The command “debugger”We can also pause the code by using the debugger command in it, like this:

      
        
        
          function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- the debugger stops here

  say(phrase);
}
        
      
      
      Such command works only when the development tools are open, otherwise the browser ignores it.
Pause and look aroundIn our example, hello() is called during the page load, so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page. So let’s press F5 (Windows, Linux) or Cmd+R (Mac).
As the breakpoint is set, the execution pauses at the 4th line:

      
      
        
      
      Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:


Watch – shows current values for any expressions.
You can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.


Call Stack – shows the nested calls chain.
At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).
If you click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.


Scope – current variables.
Local shows local function variables. You can also see their values highlighted right over the source.
Global has global variables (out of any functions).
There’s also this keyword there that we didn’t study yet, but we’ll do that soon.


Tracing the executionNow it’s time to trace the script.
There are buttons for it at the top of the right panel. Let’s engage them.


 – “Resume”: continue the execution, hotkey F8.

Resumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.
Here’s what we can see after a click on it:

      
      
        
      
      The execution has resumed, reached another breakpoint inside say() and paused there. Take a look at the “Call Stack” at the right. It has increased by one more call. We’re inside say() now.

 – “Step”: run the next command, hotkey F9.

Run the next statement. If we click it now, alert will be shown.
Clicking this again and again will step through all script statements one by one.

 – “Step over”: run the next command, but don’t go into a function, hotkey F10.

Similar to the previous “Step” command, but behaves differently if the next statement is a function call (not a built-in, like alert, but a function of our own).
If we compare them, the “Step” command goes into a nested function call and pauses the execution at its first line, while “Step over” executes the nested function call invisibly to us, skipping the function internals.
The execution is then paused immediately after that function call.
That’s good if we’re not interested to see what happens inside the function call.

 – “Step into”, hotkey F11.

That’s similar to “Step”, but behaves differently in case of asynchronous function calls. If you’re only starting to learn JavaScript, then you can ignore the difference, as we don’t have asynchronous calls yet.
For the future, just note that “Step” command ignores async actions, such as setTimeout (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary. See DevTools manual for more details.

 – “Step out”: continue the execution till the end of the current function, hotkey Shift+F11.

Continue the execution and stop it at the very last line of the current function. That’s handy when we accidentally entered a nested call using , but it does not interest us, and we want to continue to its end as soon as possible.

 – enable/disable all breakpoints.

That button does not move the execution. Just a mass on/off for breakpoints.

 – enable/disable automatic pause in case of an error.

When enabled, if the developer tools is open, an error during the script execution automatically pauses it. Then we can analyze variables in the debugger to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.



            Continue to here
            Right click on a line of code opens the context menu with a great option called “Continue to here”.
That’s handy when we want to move multiple steps forward to the line, but we’re too lazy to set a breakpoint.

LoggingTo output something to console from our code, there’s console.log function.
For instance, this outputs values from 0 to 4 to console:

      
        
        
          
            
          
          
            
          
        
        
          // open console to see
for (let i = 0; i < 5; i++) {
  console.log("value,", i);
}
        
      
      
      Regular users don’t see that output, it is in the console. To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom.
If we have enough logging in our code, then we can see what’s going on from the records, without the debugger.
SummaryAs we can see, there are three main ways to pause a script:

A breakpoint.
The debugger statements.
An error (if dev tools are open and the button  is “on”).

When paused, we can debug: examine variables and trace the code to see where the execution goes wrong.
There are many more options in developer tools than covered here. The full manual is at https://developers.google.com/web/tools/chrome-devtools.
The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.
Oh, and also you can click at various places of dev tools and just see what’s showing up. That’s probably the fastest route to learn dev tools. Don’t forget about the right click and context menus!\n\nTutorialThe JavaScript languageCode qualityJune 26, 2022Debugging in the browserBefore writing more complex code, let’s talk about debugging.
Debugging is the process of finding and fixing errors within a script. All modern browsers and most other environments support debugging tools – a special UI in developer tools that makes debugging much easier. It also allows to trace the code step by step to see what exactly is going on.
We’ll be using Chrome here, because it has enough features, most other browsers have a similar process.
The “Sources” panelYour Chrome version may look a little bit different, but it still should be obvious what’s there.

Open the example page in Chrome.
Turn on developer tools with F12 (Mac: Cmd+Opt+I).
Select the Sources panel.

Here’s what you should see if you are doing it for the first time:

      
      
        
      
      The toggler button  opens the tab with files.
Let’s click it and select hello.js in the tree view. Here’s what should show up:

      
      
        
      
      The Sources panel has 3 parts:

The File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
The Code Editor pane shows the source code.
The JavaScript Debugging pane is for debugging, we’ll explore it soon.

Now you could click the same toggler  again to hide the resources list and give the code some space.
ConsoleIf we press Esc, then a console opens below. We can type commands there and press Enter to execute.
After a statement is executed, its result is shown below.
For example, here 1+2 results in 3, while the function call hello("debugger") returns nothing, so the result is undefined:

      
      
        
      
      BreakpointsLet’s examine what’s going on within the code of the example page. In hello.js, click at line number 4. Yes, right on the 4 digit, not on the code.
Congratulations! You’ve set a breakpoint. Please also click on the number for line 8.
It should look like this (blue is where you should click):

      
      
        
      
      A breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.
While the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.
We can always find a list of breakpoints in the right panel. That’s useful when we have many breakpoints in various files. It allows us to:

Quickly jump to the breakpoint in the code (by clicking on it in the right panel).
Temporarily disable the breakpoint by unchecking it.
Remove the breakpoint by right-clicking and selecting Remove.
…And so on.


            Conditional breakpoints
            Right click on the line number allows to create a conditional breakpoint. It only triggers when the given expression, that you should provide when you create it, is truthy.
That’s handy when we need to stop only for a certain variable value or for certain function parameters.

The command “debugger”We can also pause the code by using the debugger command in it, like this:

      
        
        
          function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- the debugger stops here

  say(phrase);
}
        
      
      
      Such command works only when the development tools are open, otherwise the browser ignores it.
Pause and look aroundIn our example, hello() is called during the page load, so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page. So let’s press F5 (Windows, Linux) or Cmd+R (Mac).
As the breakpoint is set, the execution pauses at the 4th line:

      
      
        
      
      Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:


Watch – shows current values for any expressions.
You can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.


Call Stack – shows the nested calls chain.
At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).
If you click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.


Scope – current variables.
Local shows local function variables. You can also see their values highlighted right over the source.
Global has global variables (out of any functions).
There’s also this keyword there that we didn’t study yet, but we’ll do that soon.


Tracing the executionNow it’s time to trace the script.
There are buttons for it at the top of the right panel. Let’s engage them.


 – “Resume”: continue the execution, hotkey F8.

Resumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.
Here’s what we can see after a click on it:

      
      
        
      
      The execution has resumed, reached another breakpoint inside say() and paused there. Take a look at the “Call Stack” at the right. It has increased by one more call. We’re inside say() now.

 – “Step”: run the next command, hotkey F9.

Run the next statement. If we click it now, alert will be shown.
Clicking this again and again will step through all script statements one by one.

 – “Step over”: run the next command, but don’t go into a function, hotkey F10.

Similar to the previous “Step” command, but behaves differently if the next statement is a function call (not a built-in, like alert, but a function of our own).
If we compare them, the “Step” command goes into a nested function call and pauses the execution at its first line, while “Step over” executes the nested function call invisibly to us, skipping the function internals.
The execution is then paused immediately after that function call.
That’s good if we’re not interested to see what happens inside the function call.

 – “Step into”, hotkey F11.

That’s similar to “Step”, but behaves differently in case of asynchronous function calls. If you’re only starting to learn JavaScript, then you can ignore the difference, as we don’t have asynchronous calls yet.
For the future, just note that “Step” command ignores async actions, such as setTimeout (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary. See DevTools manual for more details.

 – “Step out”: continue the execution till the end of the current function, hotkey Shift+F11.

Continue the execution and stop it at the very last line of the current function. That’s handy when we accidentally entered a nested call using , but it does not interest us, and we want to continue to its end as soon as possible.

 – enable/disable all breakpoints.

That button does not move the execution. Just a mass on/off for breakpoints.

 – enable/disable automatic pause in case of an error.

When enabled, if the developer tools is open, an error during the script execution automatically pauses it. Then we can analyze variables in the debugger to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.



            Continue to here
            Right click on a line of code opens the context menu with a great option called “Continue to here”.
That’s handy when we want to move multiple steps forward to the line, but we’re too lazy to set a breakpoint.

LoggingTo output something to console from our code, there’s console.log function.
For instance, this outputs values from 0 to 4 to console:

      
        
        
          
            
          
          
            
          
        
        
          // open console to see
for (let i = 0; i < 5; i++) {
  console.log("value,", i);
}
        
      
      
      Regular users don’t see that output, it is in the console. To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom.
If we have enough logging in our code, then we can see what’s going on from the records, without the debugger.
SummaryAs we can see, there are three main ways to pause a script:

A breakpoint.
The debugger statements.
An error (if dev tools are open and the button  is “on”).

When paused, we can debug: examine variables and trace the code to see where the execution goes wrong.
There are many more options in developer tools than covered here. The full manual is at https://developers.google.com/web/tools/chrome-devtools.
The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.
Oh, and also you can click at various places of dev tools and just see what’s showing up. That’s probably the fastest route to learn dev tools. Don’t forget about the right click and context menus!
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nBefore writing more complex code, let’s talk about debugging.
Debugging is the process of finding and fixing errors within a script. All modern browsers and most other environments support debugging tools – a special UI in developer tools that makes debugging much easier. It also allows to trace the code step by step to see what exactly is going on.
We’ll be using Chrome here, because it has enough features, most other browsers have a similar process.
The “Sources” panelYour Chrome version may look a little bit different, but it still should be obvious what’s there.

Open the example page in Chrome.
Turn on developer tools with F12 (Mac: Cmd+Opt+I).
Select the Sources panel.

Here’s what you should see if you are doing it for the first time:

      
      
        
      
      The toggler button  opens the tab with files.
Let’s click it and select hello.js in the tree view. Here’s what should show up:

      
      
        
      
      The Sources panel has 3 parts:

The File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
The Code Editor pane shows the source code.
The JavaScript Debugging pane is for debugging, we’ll explore it soon.

Now you could click the same toggler  again to hide the resources list and give the code some space.
ConsoleIf we press Esc, then a console opens below. We can type commands there and press Enter to execute.
After a statement is executed, its result is shown below.
For example, here 1+2 results in 3, while the function call hello("debugger") returns nothing, so the result is undefined:

      
      
        
      
      BreakpointsLet’s examine what’s going on within the code of the example page. In hello.js, click at line number 4. Yes, right on the 4 digit, not on the code.
Congratulations! You’ve set a breakpoint. Please also click on the number for line 8.
It should look like this (blue is where you should click):

      
      
        
      
      A breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.
While the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.
We can always find a list of breakpoints in the right panel. That’s useful when we have many breakpoints in various files. It allows us to:

Quickly jump to the breakpoint in the code (by clicking on it in the right panel).
Temporarily disable the breakpoint by unchecking it.
Remove the breakpoint by right-clicking and selecting Remove.
…And so on.


            Conditional breakpoints
            Right click on the line number allows to create a conditional breakpoint. It only triggers when the given expression, that you should provide when you create it, is truthy.
That’s handy when we need to stop only for a certain variable value or for certain function parameters.

The command “debugger”We can also pause the code by using the debugger command in it, like this:

      
        
        
          function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- the debugger stops here

  say(phrase);
}
        
      
      
      Such command works only when the development tools are open, otherwise the browser ignores it.
Pause and look aroundIn our example, hello() is called during the page load, so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page. So let’s press F5 (Windows, Linux) or Cmd+R (Mac).
As the breakpoint is set, the execution pauses at the 4th line:

      
      
        
      
      Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:


Watch – shows current values for any expressions.
You can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.


Call Stack – shows the nested calls chain.
At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).
If you click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.


Scope – current variables.
Local shows local function variables. You can also see their values highlighted right over the source.
Global has global variables (out of any functions).
There’s also this keyword there that we didn’t study yet, but we’ll do that soon.


Tracing the executionNow it’s time to trace the script.
There are buttons for it at the top of the right panel. Let’s engage them.


 – “Resume”: continue the execution, hotkey F8.

Resumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.
Here’s what we can see after a click on it:

      
      
        
      
      The execution has resumed, reached another breakpoint inside say() and paused there. Take a look at the “Call Stack” at the right. It has increased by one more call. We’re inside say() now.

 – “Step”: run the next command, hotkey F9.

Run the next statement. If we click it now, alert will be shown.
Clicking this again and again will step through all script statements one by one.

 – “Step over”: run the next command, but don’t go into a function, hotkey F10.

Similar to the previous “Step” command, but behaves differently if the next statement is a function call (not a built-in, like alert, but a function of our own).
If we compare them, the “Step” command goes into a nested function call and pauses the execution at its first line, while “Step over” executes the nested function call invisibly to us, skipping the function internals.
The execution is then paused immediately after that function call.
That’s good if we’re not interested to see what happens inside the function call.

 – “Step into”, hotkey F11.

That’s similar to “Step”, but behaves differently in case of asynchronous function calls. If you’re only starting to learn JavaScript, then you can ignore the difference, as we don’t have asynchronous calls yet.
For the future, just note that “Step” command ignores async actions, such as setTimeout (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary. See DevTools manual for more details.

 – “Step out”: continue the execution till the end of the current function, hotkey Shift+F11.

Continue the execution and stop it at the very last line of the current function. That’s handy when we accidentally entered a nested call using , but it does not interest us, and we want to continue to its end as soon as possible.

 – enable/disable all breakpoints.

That button does not move the execution. Just a mass on/off for breakpoints.

 – enable/disable automatic pause in case of an error.

When enabled, if the developer tools is open, an error during the script execution automatically pauses it. Then we can analyze variables in the debugger to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.



            Continue to here
            Right click on a line of code opens the context menu with a great option called “Continue to here”.
That’s handy when we want to move multiple steps forward to the line, but we’re too lazy to set a breakpoint.

LoggingTo output something to console from our code, there’s console.log function.
For instance, this outputs values from 0 to 4 to console:

      
        
        
          
            
          
          
            
          
        
        
          // open console to see
for (let i = 0; i < 5; i++) {
  console.log("value,", i);
}
        
      
      
      Regular users don’t see that output, it is in the console. To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom.
If we have enough logging in our code, then we can see what’s going on from the records, without the debugger.
SummaryAs we can see, there are three main ways to pause a script:

A breakpoint.
The debugger statements.
An error (if dev tools are open and the button  is “on”).

When paused, we can debug: examine variables and trace the code to see where the execution goes wrong.
There are many more options in developer tools than covered here. The full manual is at https://developers.google.com/web/tools/chrome-devtools.
The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.
Oh, and also you can click at various places of dev tools and just see what’s showing up. That’s probably the fastest route to learn dev tools. Don’t forget about the right click and context menus!\n\nTutorialThe JavaScript languageCode qualityJune 26, 2022Debugging in the browserBefore writing more complex code, let’s talk about debugging.
Debugging is the process of finding and fixing errors within a script. All modern browsers and most other environments support debugging tools – a special UI in developer tools that makes debugging much easier. It also allows to trace the code step by step to see what exactly is going on.
We’ll be using Chrome here, because it has enough features, most other browsers have a similar process.
The “Sources” panelYour Chrome version may look a little bit different, but it still should be obvious what’s there.

Open the example page in Chrome.
Turn on developer tools with F12 (Mac: Cmd+Opt+I).
Select the Sources panel.

Here’s what you should see if you are doing it for the first time:

      
      
        
      
      The toggler button  opens the tab with files.
Let’s click it and select hello.js in the tree view. Here’s what should show up:

      
      
        
      
      The Sources panel has 3 parts:

The File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
The Code Editor pane shows the source code.
The JavaScript Debugging pane is for debugging, we’ll explore it soon.

Now you could click the same toggler  again to hide the resources list and give the code some space.
ConsoleIf we press Esc, then a console opens below. We can type commands there and press Enter to execute.
After a statement is executed, its result is shown below.
For example, here 1+2 results in 3, while the function call hello("debugger") returns nothing, so the result is undefined:

      
      
        
      
      BreakpointsLet’s examine what’s going on within the code of the example page. In hello.js, click at line number 4. Yes, right on the 4 digit, not on the code.
Congratulations! You’ve set a breakpoint. Please also click on the number for line 8.
It should look like this (blue is where you should click):

      
      
        
      
      A breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.
While the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.
We can always find a list of breakpoints in the right panel. That’s useful when we have many breakpoints in various files. It allows us to:

Quickly jump to the breakpoint in the code (by clicking on it in the right panel).
Temporarily disable the breakpoint by unchecking it.
Remove the breakpoint by right-clicking and selecting Remove.
…And so on.


            Conditional breakpoints
            Right click on the line number allows to create a conditional breakpoint. It only triggers when the given expression, that you should provide when you create it, is truthy.
That’s handy when we need to stop only for a certain variable value or for certain function parameters.

The command “debugger”We can also pause the code by using the debugger command in it, like this:

      
        
        
          function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- the debugger stops here

  say(phrase);
}
        
      
      
      Such command works only when the development tools are open, otherwise the browser ignores it.
Pause and look aroundIn our example, hello() is called during the page load, so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page. So let’s press F5 (Windows, Linux) or Cmd+R (Mac).
As the breakpoint is set, the execution pauses at the 4th line:

      
      
        
      
      Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:


Watch – shows current values for any expressions.
You can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.


Call Stack – shows the nested calls chain.
At the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).
If you click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.


Scope – current variables.
Local shows local function variables. You can also see their values highlighted right over the source.
Global has global variables (out of any functions).
There’s also this keyword there that we didn’t study yet, but we’ll do that soon.


Tracing the executionNow it’s time to trace the script.
There are buttons for it at the top of the right panel. Let’s engage them.


 – “Resume”: continue the execution, hotkey F8.

Resumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.
Here’s what we can see after a click on it:

      
      
        
      
      The execution has resumed, reached another breakpoint inside say() and paused there. Take a look at the “Call Stack” at the right. It has increased by one more call. We’re inside say() now.

 – “Step”: run the next command, hotkey F9.

Run the next statement. If we click it now, alert will be shown.
Clicking this again and again will step through all script statements one by one.

 – “Step over”: run the next command, but don’t go into a function, hotkey F10.

Similar to the previous “Step” command, but behaves differently if the next statement is a function call (not a built-in, like alert, but a function of our own).
If we compare them, the “Step” command goes into a nested function call and pauses the execution at its first line, while “Step over” executes the nested function call invisibly to us, skipping the function internals.
The execution is then paused immediately after that function call.
That’s good if we’re not interested to see what happens inside the function call.

 – “Step into”, hotkey F11.

That’s similar to “Step”, but behaves differently in case of asynchronous function calls. If you’re only starting to learn JavaScript, then you can ignore the difference, as we don’t have asynchronous calls yet.
For the future, just note that “Step” command ignores async actions, such as setTimeout (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary. See DevTools manual for more details.

 – “Step out”: continue the execution till the end of the current function, hotkey Shift+F11.

Continue the execution and stop it at the very last line of the current function. That’s handy when we accidentally entered a nested call using , but it does not interest us, and we want to continue to its end as soon as possible.

 – enable/disable all breakpoints.

That button does not move the execution. Just a mass on/off for breakpoints.

 – enable/disable automatic pause in case of an error.

When enabled, if the developer tools is open, an error during the script execution automatically pauses it. Then we can analyze variables in the debugger to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.



            Continue to here
            Right click on a line of code opens the context menu with a great option called “Continue to here”.
That’s handy when we want to move multiple steps forward to the line, but we’re too lazy to set a breakpoint.

LoggingTo output something to console from our code, there’s console.log function.
For instance, this outputs values from 0 to 4 to console:

      
        
        
          
            
          
          
            
          
        
        
          // open console to see
for (let i = 0; i < 5; i++) {
  console.log("value,", i);
}
        
      
      
      Regular users don’t see that output, it is in the console. To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom.
If we have enough logging in our code, then we can see what’s going on from the records, without the debugger.
SummaryAs we can see, there are three main ways to pause a script:

A breakpoint.
The debugger statements.
An error (if dev tools are open and the button  is “on”).

When paused, we can debug: examine variables and trace the code to see where the execution goes wrong.
There are many more options in developer tools than covered here. The full manual is at https://developers.google.com/web/tools/chrome-devtools.
The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.
Oh, and also you can click at various places of dev tools and just see what’s showing up. That’s probably the fastest route to learn dev tools. Don’t forget about the right click and context menus!
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nOur code must be as clean and easy to read as possible.
That is actually the art of programming – to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.
SyntaxHere is a cheat sheet with some suggested rules (see below for more details):

      
      
        
      
      
Now let’s discuss the rules and reasons for them in detail.

            There are no “you must” rules
            Nothing is set in stone here. These are style preferences, not religious dogmas.

Curly BracesIn most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:

      
        
        
          if (condition) {
  // do this
  // ...and that
  // ...and that
}
        
      
      
      A single-line construct, such as if (condition) doSomething(), is an important edge case. Should we use braces at all?
Here are the annotated variants so you can judge their readability for yourself:

😠 Beginners sometimes do that. Bad! Curly braces are not needed:
      
        
        
          if (n < 0) {alert(`Power ${n} is not supported`);}
        
      
      
      
😠 Split to a separate line without braces. Never do that, easy to make an error when adding new lines:
      
        
        
          if (n < 0)
  alert(`Power ${n} is not supported`);
        
      
      
      
😏 One line without braces – acceptable, if it’s short:
      
        
        
          if (n < 0) alert(`Power ${n} is not supported`);
        
      
      
      
😃 The best variant:
      
        
        
          if (n < 0) {
  alert(`Power ${n} is not supported`);
}
        
      
      
      

For a very brief code, one line is allowed, e.g. if (cond) return null. But a code block (the last variant) is usually more readable.
Line LengthNo one likes to read a long horizontal line of code. It’s best practice to split them.
For example:

      
        
        
          // backtick quotes ` allow to split the string into multiple lines
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
        
      
      
      And, for if statements:

      
        
        
          if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
        
      
      
      The maximum line length should be agreed upon at the team-level. It’s usually 80 or 120 characters.
IndentsThere are two types of indents:


Horizontal indents: 2 or 4 spaces.
A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.
One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.
For instance, we can align the parameters with the opening bracket, like this:

      
        
        
          show(parameters,
     aligned, // 5 spaces padding at the left
     one,
     after,
     another
  ) {
  // ...
}
        
      
      
      

Vertical indents: empty lines for splitting code into logical blocks.
Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:

      
        
        
          function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
        
      
      
      Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.


SemicolonsA semicolon should be present after each statement, even if it could possibly be skipped.
There are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter Code structure.
If you’re an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it’s best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.
Nesting LevelsTry to avoid nesting code too many levels deep.
For example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.
For example, instead of adding a nested if conditional like this:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- one more nesting level
  }
}
        
      
      
      We can write:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- no extra nesting level
}
        
      
      
      A similar thing can be done with if/else and return.
For example, two constructs below are identical.
Option 1:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
        
      
      
      Option 2:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The second one is more readable because the “special case” of n < 0 is handled early on. Once the check is done we can move on to the “main” code flow without the need for additional nesting.
Function PlacementIf you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.


Declare the functions above the code that uses them:

      
        
        
          // function declarations
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();
        
      
      
      

Code first, then functions

      
        
        
          // the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();

// --- helper functions ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
        
      
      
      

Mixed: a function is declared where it’s first used.


Most of time, the second variant is preferred.
That’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. Then, maybe we won’t need to read the functions at all, especially if their names are descriptive of what they actually do.
Style GuidesA style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.
When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.
Of course, a team can always write their own style guide, but usually there’s no need to. There are many existing guides to choose from.
Some popular choices:

Google JavaScript Style Guide
Airbnb JavaScript Style Guide
Idiomatic.JS
StandardJS
(plus many more)

If you’re a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.
Automated LintersLinters are tools that can automatically check the style of your code and make improving suggestions.
The great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don’t want to stick to one particular “code style”.
Here are some well-known linting tools:

JSLint – one of the first linters.
JSHint – more settings than JSLint.
ESLint – probably the newest one.

All of them can do the job. The author uses ESLint.
Most linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.
For instance, for ESLint you should do the following:

Install Node.js.
Install ESLint with the command npm install -g eslint (npm is a JavaScript package installer).
Create a config file named .eslintrc in the root of your JavaScript project (in the folder that contains all your files).
Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.

Here’s an example of an .eslintrc file:

      
        
        
          {
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": 2
  }
}
        
      
      
      Here the directive "extends" denotes that the configuration is based on the “eslint:recommended” set of settings. After that, we specify our own.
It is also possible to download style rule sets from the web and extend them instead. See https://eslint.org/docs/user-guide/getting-started for more details about installation.
Also certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.
SummaryAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.
When we think about writing “better” code, the questions we should ask ourselves are: “What makes the code more readable and easier to understand?” and “What can help us avoid errors?” These are the main things to keep in mind when choosing and debating code styles.
Reading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices.\n\nTutorialThe JavaScript languageCode qualityJune 26, 2022Coding StyleOur code must be as clean and easy to read as possible.
That is actually the art of programming – to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.
SyntaxHere is a cheat sheet with some suggested rules (see below for more details):

      
      
        
      
      
Now let’s discuss the rules and reasons for them in detail.

            There are no “you must” rules
            Nothing is set in stone here. These are style preferences, not religious dogmas.

Curly BracesIn most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:

      
        
        
          if (condition) {
  // do this
  // ...and that
  // ...and that
}
        
      
      
      A single-line construct, such as if (condition) doSomething(), is an important edge case. Should we use braces at all?
Here are the annotated variants so you can judge their readability for yourself:

😠 Beginners sometimes do that. Bad! Curly braces are not needed:
      
        
        
          if (n < 0) {alert(`Power ${n} is not supported`);}
        
      
      
      
😠 Split to a separate line without braces. Never do that, easy to make an error when adding new lines:
      
        
        
          if (n < 0)
  alert(`Power ${n} is not supported`);
        
      
      
      
😏 One line without braces – acceptable, if it’s short:
      
        
        
          if (n < 0) alert(`Power ${n} is not supported`);
        
      
      
      
😃 The best variant:
      
        
        
          if (n < 0) {
  alert(`Power ${n} is not supported`);
}
        
      
      
      

For a very brief code, one line is allowed, e.g. if (cond) return null. But a code block (the last variant) is usually more readable.
Line LengthNo one likes to read a long horizontal line of code. It’s best practice to split them.
For example:

      
        
        
          // backtick quotes ` allow to split the string into multiple lines
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
        
      
      
      And, for if statements:

      
        
        
          if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
        
      
      
      The maximum line length should be agreed upon at the team-level. It’s usually 80 or 120 characters.
IndentsThere are two types of indents:


Horizontal indents: 2 or 4 spaces.
A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.
One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.
For instance, we can align the parameters with the opening bracket, like this:

      
        
        
          show(parameters,
     aligned, // 5 spaces padding at the left
     one,
     after,
     another
  ) {
  // ...
}
        
      
      
      

Vertical indents: empty lines for splitting code into logical blocks.
Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:

      
        
        
          function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
        
      
      
      Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.


SemicolonsA semicolon should be present after each statement, even if it could possibly be skipped.
There are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter Code structure.
If you’re an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it’s best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.
Nesting LevelsTry to avoid nesting code too many levels deep.
For example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.
For example, instead of adding a nested if conditional like this:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- one more nesting level
  }
}
        
      
      
      We can write:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- no extra nesting level
}
        
      
      
      A similar thing can be done with if/else and return.
For example, two constructs below are identical.
Option 1:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
        
      
      
      Option 2:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The second one is more readable because the “special case” of n < 0 is handled early on. Once the check is done we can move on to the “main” code flow without the need for additional nesting.
Function PlacementIf you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.


Declare the functions above the code that uses them:

      
        
        
          // function declarations
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();
        
      
      
      

Code first, then functions

      
        
        
          // the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();

// --- helper functions ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
        
      
      
      

Mixed: a function is declared where it’s first used.


Most of time, the second variant is preferred.
That’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. Then, maybe we won’t need to read the functions at all, especially if their names are descriptive of what they actually do.
Style GuidesA style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.
When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.
Of course, a team can always write their own style guide, but usually there’s no need to. There are many existing guides to choose from.
Some popular choices:

Google JavaScript Style Guide
Airbnb JavaScript Style Guide
Idiomatic.JS
StandardJS
(plus many more)

If you’re a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.
Automated LintersLinters are tools that can automatically check the style of your code and make improving suggestions.
The great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don’t want to stick to one particular “code style”.
Here are some well-known linting tools:

JSLint – one of the first linters.
JSHint – more settings than JSLint.
ESLint – probably the newest one.

All of them can do the job. The author uses ESLint.
Most linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.
For instance, for ESLint you should do the following:

Install Node.js.
Install ESLint with the command npm install -g eslint (npm is a JavaScript package installer).
Create a config file named .eslintrc in the root of your JavaScript project (in the folder that contains all your files).
Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.

Here’s an example of an .eslintrc file:

      
        
        
          {
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": 2
  }
}
        
      
      
      Here the directive "extends" denotes that the configuration is based on the “eslint:recommended” set of settings. After that, we specify our own.
It is also possible to download style rule sets from the web and extend them instead. See https://eslint.org/docs/user-guide/getting-started for more details about installation.
Also certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.
SummaryAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.
When we think about writing “better” code, the questions we should ask ourselves are: “What makes the code more readable and easier to understand?” and “What can help us avoid errors?” These are the main things to keep in mind when choosing and debating code styles.
Reading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices.
TasksBad styleimportance: 4What’s wrong with the code style below?

      
        
        
          function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}
        
      
      
      Fix it.
solutionYou could note the following:

      
        
        
          function pow(x,n)  // <- no space between arguments
{  // <- figure bracket on a separate line
  let result=1;   // <- no spaces before or after =
  for(let i=0;i<n;i++) {result*=x;}   // <- no spaces
  // the contents of { ... } should be on a new line
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'') // <-- technically possible,
// but better make it 2 lines, also there's no spaces and missing ;
if (n<=0)  // <- no spaces inside (n <= 0), and should be extra line above it
{   // <- figure bracket on a separate line
  // below - long lines can be split into multiple lines for improved readability
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else // <- could write it on a single line like "} else {"
{
  alert(pow(x,n))  // no spaces and missing ;
}
        
      
      
      The fixed variant:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", "");
let n = prompt("n?", "");

if (n <= 0) {
  alert(`Power ${n} is not supported,
    please enter an integer number greater than zero`);
} else {
  alert( pow(x, n) );
}
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nOur code must be as clean and easy to read as possible.
That is actually the art of programming – to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.
SyntaxHere is a cheat sheet with some suggested rules (see below for more details):

      
      
        
      
      
Now let’s discuss the rules and reasons for them in detail.

            There are no “you must” rules
            Nothing is set in stone here. These are style preferences, not religious dogmas.

Curly BracesIn most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:

      
        
        
          if (condition) {
  // do this
  // ...and that
  // ...and that
}
        
      
      
      A single-line construct, such as if (condition) doSomething(), is an important edge case. Should we use braces at all?
Here are the annotated variants so you can judge their readability for yourself:

😠 Beginners sometimes do that. Bad! Curly braces are not needed:
      
        
        
          if (n < 0) {alert(`Power ${n} is not supported`);}
        
      
      
      
😠 Split to a separate line without braces. Never do that, easy to make an error when adding new lines:
      
        
        
          if (n < 0)
  alert(`Power ${n} is not supported`);
        
      
      
      
😏 One line without braces – acceptable, if it’s short:
      
        
        
          if (n < 0) alert(`Power ${n} is not supported`);
        
      
      
      
😃 The best variant:
      
        
        
          if (n < 0) {
  alert(`Power ${n} is not supported`);
}
        
      
      
      

For a very brief code, one line is allowed, e.g. if (cond) return null. But a code block (the last variant) is usually more readable.
Line LengthNo one likes to read a long horizontal line of code. It’s best practice to split them.
For example:

      
        
        
          // backtick quotes ` allow to split the string into multiple lines
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
        
      
      
      And, for if statements:

      
        
        
          if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
        
      
      
      The maximum line length should be agreed upon at the team-level. It’s usually 80 or 120 characters.
IndentsThere are two types of indents:


Horizontal indents: 2 or 4 spaces.
A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.
One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.
For instance, we can align the parameters with the opening bracket, like this:

      
        
        
          show(parameters,
     aligned, // 5 spaces padding at the left
     one,
     after,
     another
  ) {
  // ...
}
        
      
      
      

Vertical indents: empty lines for splitting code into logical blocks.
Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:

      
        
        
          function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
        
      
      
      Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.


SemicolonsA semicolon should be present after each statement, even if it could possibly be skipped.
There are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter Code structure.
If you’re an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it’s best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.
Nesting LevelsTry to avoid nesting code too many levels deep.
For example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.
For example, instead of adding a nested if conditional like this:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- one more nesting level
  }
}
        
      
      
      We can write:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- no extra nesting level
}
        
      
      
      A similar thing can be done with if/else and return.
For example, two constructs below are identical.
Option 1:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
        
      
      
      Option 2:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The second one is more readable because the “special case” of n < 0 is handled early on. Once the check is done we can move on to the “main” code flow without the need for additional nesting.
Function PlacementIf you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.


Declare the functions above the code that uses them:

      
        
        
          // function declarations
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();
        
      
      
      

Code first, then functions

      
        
        
          // the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();

// --- helper functions ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
        
      
      
      

Mixed: a function is declared where it’s first used.


Most of time, the second variant is preferred.
That’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. Then, maybe we won’t need to read the functions at all, especially if their names are descriptive of what they actually do.
Style GuidesA style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.
When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.
Of course, a team can always write their own style guide, but usually there’s no need to. There are many existing guides to choose from.
Some popular choices:

Google JavaScript Style Guide
Airbnb JavaScript Style Guide
Idiomatic.JS
StandardJS
(plus many more)

If you’re a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.
Automated LintersLinters are tools that can automatically check the style of your code and make improving suggestions.
The great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don’t want to stick to one particular “code style”.
Here are some well-known linting tools:

JSLint – one of the first linters.
JSHint – more settings than JSLint.
ESLint – probably the newest one.

All of them can do the job. The author uses ESLint.
Most linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.
For instance, for ESLint you should do the following:

Install Node.js.
Install ESLint with the command npm install -g eslint (npm is a JavaScript package installer).
Create a config file named .eslintrc in the root of your JavaScript project (in the folder that contains all your files).
Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.

Here’s an example of an .eslintrc file:

      
        
        
          {
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": 2
  }
}
        
      
      
      Here the directive "extends" denotes that the configuration is based on the “eslint:recommended” set of settings. After that, we specify our own.
It is also possible to download style rule sets from the web and extend them instead. See https://eslint.org/docs/user-guide/getting-started for more details about installation.
Also certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.
SummaryAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.
When we think about writing “better” code, the questions we should ask ourselves are: “What makes the code more readable and easier to understand?” and “What can help us avoid errors?” These are the main things to keep in mind when choosing and debating code styles.
Reading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices.
TasksBad styleimportance: 4What’s wrong with the code style below?

      
        
        
          function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}
        
      
      
      Fix it.
solutionYou could note the following:

      
        
        
          function pow(x,n)  // <- no space between arguments
{  // <- figure bracket on a separate line
  let result=1;   // <- no spaces before or after =
  for(let i=0;i<n;i++) {result*=x;}   // <- no spaces
  // the contents of { ... } should be on a new line
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'') // <-- technically possible,
// but better make it 2 lines, also there's no spaces and missing ;
if (n<=0)  // <- no spaces inside (n <= 0), and should be extra line above it
{   // <- figure bracket on a separate line
  // below - long lines can be split into multiple lines for improved readability
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else // <- could write it on a single line like "} else {"
{
  alert(pow(x,n))  // no spaces and missing ;
}
        
      
      
      The fixed variant:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", "");
let n = prompt("n?", "");

if (n <= 0) {
  alert(`Power ${n} is not supported,
    please enter an integer number greater than zero`);
} else {
  alert( pow(x, n) );
}\n\nTutorialThe JavaScript languageCode qualityJune 26, 2022Coding StyleOur code must be as clean and easy to read as possible.
That is actually the art of programming – to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.
SyntaxHere is a cheat sheet with some suggested rules (see below for more details):

      
      
        
      
      
Now let’s discuss the rules and reasons for them in detail.

            There are no “you must” rules
            Nothing is set in stone here. These are style preferences, not religious dogmas.

Curly BracesIn most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:

      
        
        
          if (condition) {
  // do this
  // ...and that
  // ...and that
}
        
      
      
      A single-line construct, such as if (condition) doSomething(), is an important edge case. Should we use braces at all?
Here are the annotated variants so you can judge their readability for yourself:

😠 Beginners sometimes do that. Bad! Curly braces are not needed:
      
        
        
          if (n < 0) {alert(`Power ${n} is not supported`);}
        
      
      
      
😠 Split to a separate line without braces. Never do that, easy to make an error when adding new lines:
      
        
        
          if (n < 0)
  alert(`Power ${n} is not supported`);
        
      
      
      
😏 One line without braces – acceptable, if it’s short:
      
        
        
          if (n < 0) alert(`Power ${n} is not supported`);
        
      
      
      
😃 The best variant:
      
        
        
          if (n < 0) {
  alert(`Power ${n} is not supported`);
}
        
      
      
      

For a very brief code, one line is allowed, e.g. if (cond) return null. But a code block (the last variant) is usually more readable.
Line LengthNo one likes to read a long horizontal line of code. It’s best practice to split them.
For example:

      
        
        
          // backtick quotes ` allow to split the string into multiple lines
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
        
      
      
      And, for if statements:

      
        
        
          if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
        
      
      
      The maximum line length should be agreed upon at the team-level. It’s usually 80 or 120 characters.
IndentsThere are two types of indents:


Horizontal indents: 2 or 4 spaces.
A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.
One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.
For instance, we can align the parameters with the opening bracket, like this:

      
        
        
          show(parameters,
     aligned, // 5 spaces padding at the left
     one,
     after,
     another
  ) {
  // ...
}
        
      
      
      

Vertical indents: empty lines for splitting code into logical blocks.
Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:

      
        
        
          function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
        
      
      
      Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.


SemicolonsA semicolon should be present after each statement, even if it could possibly be skipped.
There are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter Code structure.
If you’re an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it’s best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.
Nesting LevelsTry to avoid nesting code too many levels deep.
For example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.
For example, instead of adding a nested if conditional like this:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- one more nesting level
  }
}
        
      
      
      We can write:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- no extra nesting level
}
        
      
      
      A similar thing can be done with if/else and return.
For example, two constructs below are identical.
Option 1:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
        
      
      
      Option 2:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The second one is more readable because the “special case” of n < 0 is handled early on. Once the check is done we can move on to the “main” code flow without the need for additional nesting.
Function PlacementIf you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.


Declare the functions above the code that uses them:

      
        
        
          // function declarations
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();
        
      
      
      

Code first, then functions

      
        
        
          // the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();

// --- helper functions ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
        
      
      
      

Mixed: a function is declared where it’s first used.


Most of time, the second variant is preferred.
That’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. Then, maybe we won’t need to read the functions at all, especially if their names are descriptive of what they actually do.
Style GuidesA style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.
When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.
Of course, a team can always write their own style guide, but usually there’s no need to. There are many existing guides to choose from.
Some popular choices:

Google JavaScript Style Guide
Airbnb JavaScript Style Guide
Idiomatic.JS
StandardJS
(plus many more)

If you’re a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.
Automated LintersLinters are tools that can automatically check the style of your code and make improving suggestions.
The great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don’t want to stick to one particular “code style”.
Here are some well-known linting tools:

JSLint – one of the first linters.
JSHint – more settings than JSLint.
ESLint – probably the newest one.

All of them can do the job. The author uses ESLint.
Most linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.
For instance, for ESLint you should do the following:

Install Node.js.
Install ESLint with the command npm install -g eslint (npm is a JavaScript package installer).
Create a config file named .eslintrc in the root of your JavaScript project (in the folder that contains all your files).
Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.

Here’s an example of an .eslintrc file:

      
        
        
          {
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": 2
  }
}
        
      
      
      Here the directive "extends" denotes that the configuration is based on the “eslint:recommended” set of settings. After that, we specify our own.
It is also possible to download style rule sets from the web and extend them instead. See https://eslint.org/docs/user-guide/getting-started for more details about installation.
Also certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.
SummaryAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.
When we think about writing “better” code, the questions we should ask ourselves are: “What makes the code more readable and easier to understand?” and “What can help us avoid errors?” These are the main things to keep in mind when choosing and debating code styles.
Reading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices.
TasksBad styleimportance: 4What’s wrong with the code style below?

      
        
        
          function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}
        
      
      
      Fix it.
solutionYou could note the following:

      
        
        
          function pow(x,n)  // <- no space between arguments
{  // <- figure bracket on a separate line
  let result=1;   // <- no spaces before or after =
  for(let i=0;i<n;i++) {result*=x;}   // <- no spaces
  // the contents of { ... } should be on a new line
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'') // <-- technically possible,
// but better make it 2 lines, also there's no spaces and missing ;
if (n<=0)  // <- no spaces inside (n <= 0), and should be extra line above it
{   // <- figure bracket on a separate line
  // below - long lines can be split into multiple lines for improved readability
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else // <- could write it on a single line like "} else {"
{
  alert(pow(x,n))  // no spaces and missing ;
}
        
      
      
      The fixed variant:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", "");
let n = prompt("n?", "");

if (n <= 0) {
  alert(`Power ${n} is not supported,
    please enter an integer number greater than zero`);
} else {
  alert( pow(x, n) );
}
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nAs we know from the chapter Code structure, comments can be single-line: starting with // and multiline: /* ... */.
We normally use them to describe how and why the code works.
At first sight, commenting might be obvious, but novices in programming often use them wrongly.
Bad commentsNovices tend to use comments to explain “what is going on in the code”. Like this:

      
        
        
          // This code will do this thing (...) and that thing (...)
// ...and who knows what else...
very;
complex;
code;
        
      
      
      But in good code, the amount of such “explanatory” comments should be minimal. Seriously, the code should be easy to understand without them.
There’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.
Recipe: factor out functionsSometimes it’s beneficial to replace a code piece with a function, like here:

      
        
        
          function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // check if i is a prime number
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
        
      
      
      The better variant, with a factored out function isPrime:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
        
      
      
      Now we can understand the code easily. The function itself becomes the comment. Such code is called self-descriptive.
Recipe: create functionsAnd if we have a long “code sheet” like this:

      
        
        
          // here we add whiskey
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// here we add juice
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
        
      
      
      Then it might be a better variant to refactor it into functions like:

      
        
        
          addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
        
      
      
      Once again, functions themselves tell what’s going on. There’s nothing to comment. And also the code structure is better when split. It’s clear what every function does, what it takes and what it returns.
In reality, we can’t totally avoid “explanatory” comments. There are complex algorithms. And there are smart “tweaks” for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.
Good commentsSo, explanatory comments are usually bad. Which comments are good?

Describe the architecture
Provide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. There’s a special language UML to build high-level architecture diagrams explaining the code. Definitely worth studying.
Document function parameters and usage
There’s a special syntax JSDoc to document a function: usage, parameters, returned value.

For instance:

      
        
        
          /**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power.
 */
function pow(x, n) {
  ...
}
        
      
      
      Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.
By the way, many editors like WebStorm can understand them as well and use them to provide autocomplete and some automatic code-checking.
Also, there are tools like JSDoc 3 that can generate HTML-documentation from the comments. You can read more information about JSDoc at https://jsdoc.app.

Why is the task solved this way?

What’s written is important. But what’s not written may be even more important to understand what’s going on. Why is the task solved exactly this way? The code gives no answer.
If there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.
Without such comments the following situation is possible:

You (or your colleague) open the code written some time ago, and see that it’s “suboptimal”.
You think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant.
…The urge to rewrite was good. But in the process you see that the “more obvious” solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.

Comments that explain the solution are very important. They help to continue development the right way.

Any subtle features of the code? Where they are used?

If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.


SummaryAn important sign of a good developer is comments: their presence and even their absence.
Good comments allow us to maintain the code well, come back to it after a delay and use it more effectively.
Comment this:

Overall architecture, high-level view.
Function usage.
Important solutions, especially when not immediately obvious.

Avoid comments:

That tell “how code works” and “what it does”.
Put them in only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require them.

Comments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format).\n\nTutorialThe JavaScript languageCode qualityMay 22, 2022CommentsAs we know from the chapter Code structure, comments can be single-line: starting with // and multiline: /* ... */.
We normally use them to describe how and why the code works.
At first sight, commenting might be obvious, but novices in programming often use them wrongly.
Bad commentsNovices tend to use comments to explain “what is going on in the code”. Like this:

      
        
        
          // This code will do this thing (...) and that thing (...)
// ...and who knows what else...
very;
complex;
code;
        
      
      
      But in good code, the amount of such “explanatory” comments should be minimal. Seriously, the code should be easy to understand without them.
There’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.
Recipe: factor out functionsSometimes it’s beneficial to replace a code piece with a function, like here:

      
        
        
          function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // check if i is a prime number
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
        
      
      
      The better variant, with a factored out function isPrime:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
        
      
      
      Now we can understand the code easily. The function itself becomes the comment. Such code is called self-descriptive.
Recipe: create functionsAnd if we have a long “code sheet” like this:

      
        
        
          // here we add whiskey
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// here we add juice
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
        
      
      
      Then it might be a better variant to refactor it into functions like:

      
        
        
          addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
        
      
      
      Once again, functions themselves tell what’s going on. There’s nothing to comment. And also the code structure is better when split. It’s clear what every function does, what it takes and what it returns.
In reality, we can’t totally avoid “explanatory” comments. There are complex algorithms. And there are smart “tweaks” for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.
Good commentsSo, explanatory comments are usually bad. Which comments are good?

Describe the architecture
Provide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. There’s a special language UML to build high-level architecture diagrams explaining the code. Definitely worth studying.
Document function parameters and usage
There’s a special syntax JSDoc to document a function: usage, parameters, returned value.

For instance:

      
        
        
          /**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power.
 */
function pow(x, n) {
  ...
}
        
      
      
      Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.
By the way, many editors like WebStorm can understand them as well and use them to provide autocomplete and some automatic code-checking.
Also, there are tools like JSDoc 3 that can generate HTML-documentation from the comments. You can read more information about JSDoc at https://jsdoc.app.

Why is the task solved this way?

What’s written is important. But what’s not written may be even more important to understand what’s going on. Why is the task solved exactly this way? The code gives no answer.
If there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.
Without such comments the following situation is possible:

You (or your colleague) open the code written some time ago, and see that it’s “suboptimal”.
You think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant.
…The urge to rewrite was good. But in the process you see that the “more obvious” solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.

Comments that explain the solution are very important. They help to continue development the right way.

Any subtle features of the code? Where they are used?

If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.


SummaryAn important sign of a good developer is comments: their presence and even their absence.
Good comments allow us to maintain the code well, come back to it after a delay and use it more effectively.
Comment this:

Overall architecture, high-level view.
Function usage.
Important solutions, especially when not immediately obvious.

Avoid comments:

That tell “how code works” and “what it does”.
Put them in only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require them.

Comments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format).
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nAs we know from the chapter Code structure, comments can be single-line: starting with // and multiline: /* ... */.
We normally use them to describe how and why the code works.
At first sight, commenting might be obvious, but novices in programming often use them wrongly.
Bad commentsNovices tend to use comments to explain “what is going on in the code”. Like this:

      
        
        
          // This code will do this thing (...) and that thing (...)
// ...and who knows what else...
very;
complex;
code;
        
      
      
      But in good code, the amount of such “explanatory” comments should be minimal. Seriously, the code should be easy to understand without them.
There’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.
Recipe: factor out functionsSometimes it’s beneficial to replace a code piece with a function, like here:

      
        
        
          function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // check if i is a prime number
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
        
      
      
      The better variant, with a factored out function isPrime:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
        
      
      
      Now we can understand the code easily. The function itself becomes the comment. Such code is called self-descriptive.
Recipe: create functionsAnd if we have a long “code sheet” like this:

      
        
        
          // here we add whiskey
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// here we add juice
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
        
      
      
      Then it might be a better variant to refactor it into functions like:

      
        
        
          addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
        
      
      
      Once again, functions themselves tell what’s going on. There’s nothing to comment. And also the code structure is better when split. It’s clear what every function does, what it takes and what it returns.
In reality, we can’t totally avoid “explanatory” comments. There are complex algorithms. And there are smart “tweaks” for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.
Good commentsSo, explanatory comments are usually bad. Which comments are good?

Describe the architecture
Provide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. There’s a special language UML to build high-level architecture diagrams explaining the code. Definitely worth studying.
Document function parameters and usage
There’s a special syntax JSDoc to document a function: usage, parameters, returned value.

For instance:

      
        
        
          /**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power.
 */
function pow(x, n) {
  ...
}
        
      
      
      Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.
By the way, many editors like WebStorm can understand them as well and use them to provide autocomplete and some automatic code-checking.
Also, there are tools like JSDoc 3 that can generate HTML-documentation from the comments. You can read more information about JSDoc at https://jsdoc.app.

Why is the task solved this way?

What’s written is important. But what’s not written may be even more important to understand what’s going on. Why is the task solved exactly this way? The code gives no answer.
If there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.
Without such comments the following situation is possible:

You (or your colleague) open the code written some time ago, and see that it’s “suboptimal”.
You think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant.
…The urge to rewrite was good. But in the process you see that the “more obvious” solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.

Comments that explain the solution are very important. They help to continue development the right way.

Any subtle features of the code? Where they are used?

If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.


SummaryAn important sign of a good developer is comments: their presence and even their absence.
Good comments allow us to maintain the code well, come back to it after a delay and use it more effectively.
Comment this:

Overall architecture, high-level view.
Function usage.
Important solutions, especially when not immediately obvious.

Avoid comments:

That tell “how code works” and “what it does”.
Put them in only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require them.

Comments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format).\n\nTutorialThe JavaScript languageCode qualityMay 22, 2022CommentsAs we know from the chapter Code structure, comments can be single-line: starting with // and multiline: /* ... */.
We normally use them to describe how and why the code works.
At first sight, commenting might be obvious, but novices in programming often use them wrongly.
Bad commentsNovices tend to use comments to explain “what is going on in the code”. Like this:

      
        
        
          // This code will do this thing (...) and that thing (...)
// ...and who knows what else...
very;
complex;
code;
        
      
      
      But in good code, the amount of such “explanatory” comments should be minimal. Seriously, the code should be easy to understand without them.
There’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.
Recipe: factor out functionsSometimes it’s beneficial to replace a code piece with a function, like here:

      
        
        
          function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // check if i is a prime number
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
        
      
      
      The better variant, with a factored out function isPrime:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
        
      
      
      Now we can understand the code easily. The function itself becomes the comment. Such code is called self-descriptive.
Recipe: create functionsAnd if we have a long “code sheet” like this:

      
        
        
          // here we add whiskey
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// here we add juice
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
        
      
      
      Then it might be a better variant to refactor it into functions like:

      
        
        
          addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
        
      
      
      Once again, functions themselves tell what’s going on. There’s nothing to comment. And also the code structure is better when split. It’s clear what every function does, what it takes and what it returns.
In reality, we can’t totally avoid “explanatory” comments. There are complex algorithms. And there are smart “tweaks” for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.
Good commentsSo, explanatory comments are usually bad. Which comments are good?

Describe the architecture
Provide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. There’s a special language UML to build high-level architecture diagrams explaining the code. Definitely worth studying.
Document function parameters and usage
There’s a special syntax JSDoc to document a function: usage, parameters, returned value.

For instance:

      
        
        
          /**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power.
 */
function pow(x, n) {
  ...
}
        
      
      
      Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.
By the way, many editors like WebStorm can understand them as well and use them to provide autocomplete and some automatic code-checking.
Also, there are tools like JSDoc 3 that can generate HTML-documentation from the comments. You can read more information about JSDoc at https://jsdoc.app.

Why is the task solved this way?

What’s written is important. But what’s not written may be even more important to understand what’s going on. Why is the task solved exactly this way? The code gives no answer.
If there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.
Without such comments the following situation is possible:

You (or your colleague) open the code written some time ago, and see that it’s “suboptimal”.
You think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant.
…The urge to rewrite was good. But in the process you see that the “more obvious” solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.

Comments that explain the solution are very important. They help to continue development the right way.

Any subtle features of the code? Where they are used?

If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.


SummaryAn important sign of a good developer is comments: their presence and even their absence.
Good comments allow us to maintain the code well, come back to it after a delay and use it more effectively.
Comment this:

Overall architecture, high-level view.
Function usage.
Important solutions, especially when not immediately obvious.

Avoid comments:

That tell “how code works” and “what it does”.
Put them in only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require them.

Comments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format).
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nLearning without thought is labor lost; thought without learning is perilous.

        Confucius (Analects)
       Programmer ninjas of the past used these tricks to sharpen the mind of code maintainers.
Code review gurus look for them in test tasks.
Novice developers sometimes use them even better than programmer ninjas.
Read them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?

            Irony detected
            Many try to follow ninja paths. Few succeed.

Brevity is the soul of witMake the code as short as possible. Show how smart you are.
Let subtle language features guide you.
For instance, take a look at this ternary operator '?':

      
        
        
          // taken from a well-known javascript library
i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
        
      
      
      Cool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of i is going to have a merry time. Then come to you, seeking for an answer.
Tell them that shorter is always better. Initiate them into the paths of ninja.
One-letter variablesThe Dao hides in wordlessness. Only the Dao is well begun and well
completed.

        Laozi (Tao Te Ching)
       Another way to code shorter is to use single-letter variable names everywhere. Like a, b or c.
A short variable disappears in the code like a real ninja in the forest. No one will be able to find it using “search” of the editor. And even if someone does, they won’t be able to “decipher” what the name a or b means.
…But there’s an exception. A real ninja will never use i as the counter in a "for" loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, x or y.
An exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won’t be able to quickly figure out that the variable named x is the loop counter.
Use abbreviationsIf the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.
Like this:

list → lst.
userAgent → ua.
browser → brsr.
…etc

Only the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.
Soar high. Be abstract.The great square is cornerless
The great vessel is last complete,
The great note is rarified sound,
The great image has no form.

        Laozi (Tao Te Ching)
       While choosing a name try to use the most abstract word. Like obj, data, value, item, elem and so on.


The ideal name for a variable is data. Use it everywhere you can. Indeed, every variable holds data, right?
…But what to do if data is already taken? Try value, it’s also universal. After all, a variable eventually gets a value.


Name a variable by its type: str, num…
Give them a try. A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!
Sure, the variable name still means something. It says what’s inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.
The value type is easy to find out by debugging. But what’s the meaning of the variable? Which string/number does it store?
There’s just no way to figure out without a good meditation!


…But what if there are no more such names? Just add a number: data1, item2, elem5…


Attention testOnly a truly attentive programmer should be able to understand your code. But how to check that?
One of the ways – use similar variable names, like date and data.
Mix them where you can.
A quick read of such code becomes impossible. And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.
Smart synonymsThe Tao that can be told is not the eternal Tao. The name that can be named is not the eternal name.

        Laozi (Tao Te Ching)
       Using similar names for same things makes life more interesting and shows your creativity to the public.
For instance, consider function prefixes. If a function shows a message on the screen – start it with display…, like displayMessage. And then if another function shows on the screen something else, like a user name, start it with show… (like showName).
Insinuate that there’s a subtle difference between such functions, while there is none.
Make a pact with fellow ninjas of the team: if John starts “showing” functions with display... in his code, then Peter could use render.., and Ann – paint.... Note how much more interesting and diverse the code became.
…And now the hat trick!
For two functions with important differences – use the same prefix!
For instance, the function printPage(page) will use a printer. And the function printText(text) will put the text on-screen. Let an unfamiliar reader think well over similarly named function printMessage: “Where does it put the message? To a printer or on the screen?”. To make it really shine, printMessage(message) should output it in the new window!
Reuse namesOnce the whole is divided, the parts
need names.
There are already enough names.
One must know when to stop.

        Laozi (Tao Te Ching)
       Add a new variable only when absolutely necessary.
Instead, reuse existing names. Just write new values into them.
In a function try to use only variables passed as parameters.
That would make it really hard to identify what’s exactly in the variable now. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.
An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.
For instance:

      
        
        
          function ninjaFunction(elem) {
  // 20 lines of code working with elem

  elem = clone(elem);

  // 20 more lines, now working with the clone of the elem!
}
        
      
      
      A fellow programmer who wants to work with elem in the second half of the function will be surprised… Only during the debugging, after examining the code they will find out that they’re working with a clone!
Seen in code regularly. Deadly effective even against an experienced ninja.
Underscores for funPut underscores _ and __ before variable names. Like _name or __value. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.
You kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.
A smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.
Show your loveLet everyone see how magnificent your entities are! Names like superElement, megaFrame and niceItem will definitely enlighten a reader.
Indeed, from one hand, something is written: super.., mega.., nice.. But from the other hand – that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.
Overlap outer variablesWhen in the light, can’t see anything in the darkness.
When in the darkness, can see everything in the light.

        Guan Yin Zi
       Use same names for variables inside and outside a function. As simple. No efforts to invent new names.

      
        
        
          let user = authenticateUser();

function render() {
  let user = anotherValue();
  ...
  ...many lines...
  ...
  ... // <-- a programmer wants to work with user here and...
  ...
}
        
      
      
      A programmer who jumps inside the render will probably fail to notice that there’s a local user shadowing the outer one.
Then they’ll try to work with user assuming that it’s the external variable, the result of authenticateUser()… The trap is sprung! Hello, debugger…
Side-effects everywhere!There are functions that look like they don’t change anything. Like isReady(), checkPermission(), findTags()… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without “side-effects”.
A really beautiful trick is to add a “useful” action to them, besides the main task.
An expression of dazed surprise on the face of your colleague when they see a function named is.., check.. or find... changing something – will definitely broaden your boundaries of reason.
Another way to surprise is to return a non-standard result.
Show your original thinking! Let the call of checkPermission return not true/false, but a complex object with the results of the check.
Those developers who try to write if (checkPermission(..)), will wonder why it doesn’t work. Tell them: “Read the docs!”. And give this article.
Powerful functions!The great Tao flows everywhere,
both to the left and to the right.

        Laozi (Tao Te Ching)
       Don’t limit the function by what’s written in its name. Be broader.
For instance, a function validateEmail(email) could (besides checking the email for correctness) show an error message and ask to re-enter the email.
Additional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.
Joining several actions into one protects your code from reuse.
Imagine, another developer wants only to check the email, and not output any message. Your function  validateEmail(email) that does both will not suit them. So they won’t break your meditation by asking anything about it.
SummaryAll “pieces of advice” above are from the real code… Sometimes, written by experienced developers. Maybe even more experienced than you are ;)

Follow some of them, and your code will become full of surprises.
Follow many of them, and your code will become truly yours, no one would want to change it.
Follow all, and your code will become a valuable lesson for young developers looking for enlightenment.\n\nTutorialThe JavaScript languageCode qualitySeptember 5, 2020Ninja codeLearning without thought is labor lost; thought without learning is perilous.

        Confucius (Analects)
       Programmer ninjas of the past used these tricks to sharpen the mind of code maintainers.
Code review gurus look for them in test tasks.
Novice developers sometimes use them even better than programmer ninjas.
Read them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?

            Irony detected
            Many try to follow ninja paths. Few succeed.

Brevity is the soul of witMake the code as short as possible. Show how smart you are.
Let subtle language features guide you.
For instance, take a look at this ternary operator '?':

      
        
        
          // taken from a well-known javascript library
i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
        
      
      
      Cool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of i is going to have a merry time. Then come to you, seeking for an answer.
Tell them that shorter is always better. Initiate them into the paths of ninja.
One-letter variablesThe Dao hides in wordlessness. Only the Dao is well begun and well
completed.

        Laozi (Tao Te Ching)
       Another way to code shorter is to use single-letter variable names everywhere. Like a, b or c.
A short variable disappears in the code like a real ninja in the forest. No one will be able to find it using “search” of the editor. And even if someone does, they won’t be able to “decipher” what the name a or b means.
…But there’s an exception. A real ninja will never use i as the counter in a "for" loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, x or y.
An exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won’t be able to quickly figure out that the variable named x is the loop counter.
Use abbreviationsIf the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.
Like this:

list → lst.
userAgent → ua.
browser → brsr.
…etc

Only the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.
Soar high. Be abstract.The great square is cornerless
The great vessel is last complete,
The great note is rarified sound,
The great image has no form.

        Laozi (Tao Te Ching)
       While choosing a name try to use the most abstract word. Like obj, data, value, item, elem and so on.


The ideal name for a variable is data. Use it everywhere you can. Indeed, every variable holds data, right?
…But what to do if data is already taken? Try value, it’s also universal. After all, a variable eventually gets a value.


Name a variable by its type: str, num…
Give them a try. A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!
Sure, the variable name still means something. It says what’s inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.
The value type is easy to find out by debugging. But what’s the meaning of the variable? Which string/number does it store?
There’s just no way to figure out without a good meditation!


…But what if there are no more such names? Just add a number: data1, item2, elem5…


Attention testOnly a truly attentive programmer should be able to understand your code. But how to check that?
One of the ways – use similar variable names, like date and data.
Mix them where you can.
A quick read of such code becomes impossible. And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.
Smart synonymsThe Tao that can be told is not the eternal Tao. The name that can be named is not the eternal name.

        Laozi (Tao Te Ching)
       Using similar names for same things makes life more interesting and shows your creativity to the public.
For instance, consider function prefixes. If a function shows a message on the screen – start it with display…, like displayMessage. And then if another function shows on the screen something else, like a user name, start it with show… (like showName).
Insinuate that there’s a subtle difference between such functions, while there is none.
Make a pact with fellow ninjas of the team: if John starts “showing” functions with display... in his code, then Peter could use render.., and Ann – paint.... Note how much more interesting and diverse the code became.
…And now the hat trick!
For two functions with important differences – use the same prefix!
For instance, the function printPage(page) will use a printer. And the function printText(text) will put the text on-screen. Let an unfamiliar reader think well over similarly named function printMessage: “Where does it put the message? To a printer or on the screen?”. To make it really shine, printMessage(message) should output it in the new window!
Reuse namesOnce the whole is divided, the parts
need names.
There are already enough names.
One must know when to stop.

        Laozi (Tao Te Ching)
       Add a new variable only when absolutely necessary.
Instead, reuse existing names. Just write new values into them.
In a function try to use only variables passed as parameters.
That would make it really hard to identify what’s exactly in the variable now. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.
An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.
For instance:

      
        
        
          function ninjaFunction(elem) {
  // 20 lines of code working with elem

  elem = clone(elem);

  // 20 more lines, now working with the clone of the elem!
}
        
      
      
      A fellow programmer who wants to work with elem in the second half of the function will be surprised… Only during the debugging, after examining the code they will find out that they’re working with a clone!
Seen in code regularly. Deadly effective even against an experienced ninja.
Underscores for funPut underscores _ and __ before variable names. Like _name or __value. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.
You kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.
A smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.
Show your loveLet everyone see how magnificent your entities are! Names like superElement, megaFrame and niceItem will definitely enlighten a reader.
Indeed, from one hand, something is written: super.., mega.., nice.. But from the other hand – that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.
Overlap outer variablesWhen in the light, can’t see anything in the darkness.
When in the darkness, can see everything in the light.

        Guan Yin Zi
       Use same names for variables inside and outside a function. As simple. No efforts to invent new names.

      
        
        
          let user = authenticateUser();

function render() {
  let user = anotherValue();
  ...
  ...many lines...
  ...
  ... // <-- a programmer wants to work with user here and...
  ...
}
        
      
      
      A programmer who jumps inside the render will probably fail to notice that there’s a local user shadowing the outer one.
Then they’ll try to work with user assuming that it’s the external variable, the result of authenticateUser()… The trap is sprung! Hello, debugger…
Side-effects everywhere!There are functions that look like they don’t change anything. Like isReady(), checkPermission(), findTags()… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without “side-effects”.
A really beautiful trick is to add a “useful” action to them, besides the main task.
An expression of dazed surprise on the face of your colleague when they see a function named is.., check.. or find... changing something – will definitely broaden your boundaries of reason.
Another way to surprise is to return a non-standard result.
Show your original thinking! Let the call of checkPermission return not true/false, but a complex object with the results of the check.
Those developers who try to write if (checkPermission(..)), will wonder why it doesn’t work. Tell them: “Read the docs!”. And give this article.
Powerful functions!The great Tao flows everywhere,
both to the left and to the right.

        Laozi (Tao Te Ching)
       Don’t limit the function by what’s written in its name. Be broader.
For instance, a function validateEmail(email) could (besides checking the email for correctness) show an error message and ask to re-enter the email.
Additional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.
Joining several actions into one protects your code from reuse.
Imagine, another developer wants only to check the email, and not output any message. Your function  validateEmail(email) that does both will not suit them. So they won’t break your meditation by asking anything about it.
SummaryAll “pieces of advice” above are from the real code… Sometimes, written by experienced developers. Maybe even more experienced than you are ;)

Follow some of them, and your code will become full of surprises.
Follow many of them, and your code will become truly yours, no one would want to change it.
Follow all, and your code will become a valuable lesson for young developers looking for enlightenment.

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nLearning without thought is labor lost; thought without learning is perilous.

        Confucius (Analects)
       Programmer ninjas of the past used these tricks to sharpen the mind of code maintainers.
Code review gurus look for them in test tasks.
Novice developers sometimes use them even better than programmer ninjas.
Read them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?

            Irony detected
            Many try to follow ninja paths. Few succeed.

Brevity is the soul of witMake the code as short as possible. Show how smart you are.
Let subtle language features guide you.
For instance, take a look at this ternary operator '?':

      
        
        
          // taken from a well-known javascript library
i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
        
      
      
      Cool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of i is going to have a merry time. Then come to you, seeking for an answer.
Tell them that shorter is always better. Initiate them into the paths of ninja.
One-letter variablesThe Dao hides in wordlessness. Only the Dao is well begun and well
completed.

        Laozi (Tao Te Ching)
       Another way to code shorter is to use single-letter variable names everywhere. Like a, b or c.
A short variable disappears in the code like a real ninja in the forest. No one will be able to find it using “search” of the editor. And even if someone does, they won’t be able to “decipher” what the name a or b means.
…But there’s an exception. A real ninja will never use i as the counter in a "for" loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, x or y.
An exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won’t be able to quickly figure out that the variable named x is the loop counter.
Use abbreviationsIf the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.
Like this:

list → lst.
userAgent → ua.
browser → brsr.
…etc

Only the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.
Soar high. Be abstract.The great square is cornerless
The great vessel is last complete,
The great note is rarified sound,
The great image has no form.

        Laozi (Tao Te Ching)
       While choosing a name try to use the most abstract word. Like obj, data, value, item, elem and so on.


The ideal name for a variable is data. Use it everywhere you can. Indeed, every variable holds data, right?
…But what to do if data is already taken? Try value, it’s also universal. After all, a variable eventually gets a value.


Name a variable by its type: str, num…
Give them a try. A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!
Sure, the variable name still means something. It says what’s inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.
The value type is easy to find out by debugging. But what’s the meaning of the variable? Which string/number does it store?
There’s just no way to figure out without a good meditation!


…But what if there are no more such names? Just add a number: data1, item2, elem5…


Attention testOnly a truly attentive programmer should be able to understand your code. But how to check that?
One of the ways – use similar variable names, like date and data.
Mix them where you can.
A quick read of such code becomes impossible. And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.
Smart synonymsThe Tao that can be told is not the eternal Tao. The name that can be named is not the eternal name.

        Laozi (Tao Te Ching)
       Using similar names for same things makes life more interesting and shows your creativity to the public.
For instance, consider function prefixes. If a function shows a message on the screen – start it with display…, like displayMessage. And then if another function shows on the screen something else, like a user name, start it with show… (like showName).
Insinuate that there’s a subtle difference between such functions, while there is none.
Make a pact with fellow ninjas of the team: if John starts “showing” functions with display... in his code, then Peter could use render.., and Ann – paint.... Note how much more interesting and diverse the code became.
…And now the hat trick!
For two functions with important differences – use the same prefix!
For instance, the function printPage(page) will use a printer. And the function printText(text) will put the text on-screen. Let an unfamiliar reader think well over similarly named function printMessage: “Where does it put the message? To a printer or on the screen?”. To make it really shine, printMessage(message) should output it in the new window!
Reuse namesOnce the whole is divided, the parts
need names.
There are already enough names.
One must know when to stop.

        Laozi (Tao Te Ching)
       Add a new variable only when absolutely necessary.
Instead, reuse existing names. Just write new values into them.
In a function try to use only variables passed as parameters.
That would make it really hard to identify what’s exactly in the variable now. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.
An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.
For instance:

      
        
        
          function ninjaFunction(elem) {
  // 20 lines of code working with elem

  elem = clone(elem);

  // 20 more lines, now working with the clone of the elem!
}
        
      
      
      A fellow programmer who wants to work with elem in the second half of the function will be surprised… Only during the debugging, after examining the code they will find out that they’re working with a clone!
Seen in code regularly. Deadly effective even against an experienced ninja.
Underscores for funPut underscores _ and __ before variable names. Like _name or __value. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.
You kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.
A smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.
Show your loveLet everyone see how magnificent your entities are! Names like superElement, megaFrame and niceItem will definitely enlighten a reader.
Indeed, from one hand, something is written: super.., mega.., nice.. But from the other hand – that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.
Overlap outer variablesWhen in the light, can’t see anything in the darkness.
When in the darkness, can see everything in the light.

        Guan Yin Zi
       Use same names for variables inside and outside a function. As simple. No efforts to invent new names.

      
        
        
          let user = authenticateUser();

function render() {
  let user = anotherValue();
  ...
  ...many lines...
  ...
  ... // <-- a programmer wants to work with user here and...
  ...
}
        
      
      
      A programmer who jumps inside the render will probably fail to notice that there’s a local user shadowing the outer one.
Then they’ll try to work with user assuming that it’s the external variable, the result of authenticateUser()… The trap is sprung! Hello, debugger…
Side-effects everywhere!There are functions that look like they don’t change anything. Like isReady(), checkPermission(), findTags()… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without “side-effects”.
A really beautiful trick is to add a “useful” action to them, besides the main task.
An expression of dazed surprise on the face of your colleague when they see a function named is.., check.. or find... changing something – will definitely broaden your boundaries of reason.
Another way to surprise is to return a non-standard result.
Show your original thinking! Let the call of checkPermission return not true/false, but a complex object with the results of the check.
Those developers who try to write if (checkPermission(..)), will wonder why it doesn’t work. Tell them: “Read the docs!”. And give this article.
Powerful functions!The great Tao flows everywhere,
both to the left and to the right.

        Laozi (Tao Te Ching)
       Don’t limit the function by what’s written in its name. Be broader.
For instance, a function validateEmail(email) could (besides checking the email for correctness) show an error message and ask to re-enter the email.
Additional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.
Joining several actions into one protects your code from reuse.
Imagine, another developer wants only to check the email, and not output any message. Your function  validateEmail(email) that does both will not suit them. So they won’t break your meditation by asking anything about it.
SummaryAll “pieces of advice” above are from the real code… Sometimes, written by experienced developers. Maybe even more experienced than you are ;)

Follow some of them, and your code will become full of surprises.
Follow many of them, and your code will become truly yours, no one would want to change it.
Follow all, and your code will become a valuable lesson for young developers looking for enlightenment.\n\nTutorialThe JavaScript languageCode qualitySeptember 5, 2020Ninja codeLearning without thought is labor lost; thought without learning is perilous.

        Confucius (Analects)
       Programmer ninjas of the past used these tricks to sharpen the mind of code maintainers.
Code review gurus look for them in test tasks.
Novice developers sometimes use them even better than programmer ninjas.
Read them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?

            Irony detected
            Many try to follow ninja paths. Few succeed.

Brevity is the soul of witMake the code as short as possible. Show how smart you are.
Let subtle language features guide you.
For instance, take a look at this ternary operator '?':

      
        
        
          // taken from a well-known javascript library
i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
        
      
      
      Cool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of i is going to have a merry time. Then come to you, seeking for an answer.
Tell them that shorter is always better. Initiate them into the paths of ninja.
One-letter variablesThe Dao hides in wordlessness. Only the Dao is well begun and well
completed.

        Laozi (Tao Te Ching)
       Another way to code shorter is to use single-letter variable names everywhere. Like a, b or c.
A short variable disappears in the code like a real ninja in the forest. No one will be able to find it using “search” of the editor. And even if someone does, they won’t be able to “decipher” what the name a or b means.
…But there’s an exception. A real ninja will never use i as the counter in a "for" loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, x or y.
An exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won’t be able to quickly figure out that the variable named x is the loop counter.
Use abbreviationsIf the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.
Like this:

list → lst.
userAgent → ua.
browser → brsr.
…etc

Only the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.
Soar high. Be abstract.The great square is cornerless
The great vessel is last complete,
The great note is rarified sound,
The great image has no form.

        Laozi (Tao Te Ching)
       While choosing a name try to use the most abstract word. Like obj, data, value, item, elem and so on.


The ideal name for a variable is data. Use it everywhere you can. Indeed, every variable holds data, right?
…But what to do if data is already taken? Try value, it’s also universal. After all, a variable eventually gets a value.


Name a variable by its type: str, num…
Give them a try. A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!
Sure, the variable name still means something. It says what’s inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.
The value type is easy to find out by debugging. But what’s the meaning of the variable? Which string/number does it store?
There’s just no way to figure out without a good meditation!


…But what if there are no more such names? Just add a number: data1, item2, elem5…


Attention testOnly a truly attentive programmer should be able to understand your code. But how to check that?
One of the ways – use similar variable names, like date and data.
Mix them where you can.
A quick read of such code becomes impossible. And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.
Smart synonymsThe Tao that can be told is not the eternal Tao. The name that can be named is not the eternal name.

        Laozi (Tao Te Ching)
       Using similar names for same things makes life more interesting and shows your creativity to the public.
For instance, consider function prefixes. If a function shows a message on the screen – start it with display…, like displayMessage. And then if another function shows on the screen something else, like a user name, start it with show… (like showName).
Insinuate that there’s a subtle difference between such functions, while there is none.
Make a pact with fellow ninjas of the team: if John starts “showing” functions with display... in his code, then Peter could use render.., and Ann – paint.... Note how much more interesting and diverse the code became.
…And now the hat trick!
For two functions with important differences – use the same prefix!
For instance, the function printPage(page) will use a printer. And the function printText(text) will put the text on-screen. Let an unfamiliar reader think well over similarly named function printMessage: “Where does it put the message? To a printer or on the screen?”. To make it really shine, printMessage(message) should output it in the new window!
Reuse namesOnce the whole is divided, the parts
need names.
There are already enough names.
One must know when to stop.

        Laozi (Tao Te Ching)
       Add a new variable only when absolutely necessary.
Instead, reuse existing names. Just write new values into them.
In a function try to use only variables passed as parameters.
That would make it really hard to identify what’s exactly in the variable now. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.
An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.
For instance:

      
        
        
          function ninjaFunction(elem) {
  // 20 lines of code working with elem

  elem = clone(elem);

  // 20 more lines, now working with the clone of the elem!
}
        
      
      
      A fellow programmer who wants to work with elem in the second half of the function will be surprised… Only during the debugging, after examining the code they will find out that they’re working with a clone!
Seen in code regularly. Deadly effective even against an experienced ninja.
Underscores for funPut underscores _ and __ before variable names. Like _name or __value. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.
You kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.
A smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.
Show your loveLet everyone see how magnificent your entities are! Names like superElement, megaFrame and niceItem will definitely enlighten a reader.
Indeed, from one hand, something is written: super.., mega.., nice.. But from the other hand – that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.
Overlap outer variablesWhen in the light, can’t see anything in the darkness.
When in the darkness, can see everything in the light.

        Guan Yin Zi
       Use same names for variables inside and outside a function. As simple. No efforts to invent new names.

      
        
        
          let user = authenticateUser();

function render() {
  let user = anotherValue();
  ...
  ...many lines...
  ...
  ... // <-- a programmer wants to work with user here and...
  ...
}
        
      
      
      A programmer who jumps inside the render will probably fail to notice that there’s a local user shadowing the outer one.
Then they’ll try to work with user assuming that it’s the external variable, the result of authenticateUser()… The trap is sprung! Hello, debugger…
Side-effects everywhere!There are functions that look like they don’t change anything. Like isReady(), checkPermission(), findTags()… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without “side-effects”.
A really beautiful trick is to add a “useful” action to them, besides the main task.
An expression of dazed surprise on the face of your colleague when they see a function named is.., check.. or find... changing something – will definitely broaden your boundaries of reason.
Another way to surprise is to return a non-standard result.
Show your original thinking! Let the call of checkPermission return not true/false, but a complex object with the results of the check.
Those developers who try to write if (checkPermission(..)), will wonder why it doesn’t work. Tell them: “Read the docs!”. And give this article.
Powerful functions!The great Tao flows everywhere,
both to the left and to the right.

        Laozi (Tao Te Ching)
       Don’t limit the function by what’s written in its name. Be broader.
For instance, a function validateEmail(email) could (besides checking the email for correctness) show an error message and ask to re-enter the email.
Additional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.
Joining several actions into one protects your code from reuse.
Imagine, another developer wants only to check the email, and not output any message. Your function  validateEmail(email) that does both will not suit them. So they won’t break your meditation by asking anything about it.
SummaryAll “pieces of advice” above are from the real code… Sometimes, written by experienced developers. Maybe even more experienced than you are ;)

Follow some of them, and your code will become full of surprises.
Follow many of them, and your code will become truly yours, no one would want to change it.
Follow all, and your code will become a valuable lesson for young developers looking for enlightenment.

Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nAutomated testing will be used in further tasks, and it’s also widely used in real projects.
Why do we need tests?When we write a function, we can usually imagine what it should do: which parameters give which results.
During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.
If something is wrong – then we fix the code, run again, check the result – and so on till it works.
But such manual “re-runs” are imperfect.
When testing a code by manual re-runs, it’s easy to miss something.
For instance, we’re creating a function f. Wrote some code, testing: f(1) works, but f(2) doesn’t work. We fix the code and now f(2) works. Looks complete? But we forgot to re-test f(1). That may lead to an error.
That’s very typical. When we develop something, we keep a lot of possible use cases in mind. But it’s hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.
Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.
Behavior Driven Development (BDD)Let’s start with a technique named Behavior Driven Development or, in short, BDD.
BDD is three things in one: tests AND documentation AND examples.
To understand BDD, we’ll examine a practical case of development.
Development of “pow”: the specLet’s say we want to make a function pow(x, n) that raises x to an integer power n. We assume that n≥0.
That task is just an example: there’s the ** operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.
Before creating the code of pow, we can imagine what the function should do and describe it.
Such description is called a specification or, in short, a spec, and contains descriptions of use cases together with tests for them, like this:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
  });

});
        
      
      
      A spec has three main building blocks that you can see above:

describe("title", function() { ... })

What functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.

it("use case description", function() { ... })

In the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.

assert.equal(value1, value2)

The code inside it block, if the implementation is correct, should execute without errors.
Functions assert.* are used to check whether pow works as expected. Right here we’re using one of them – assert.equal, it compares arguments and yields an error if they are not equal. Here it checks that the result of pow(2, 3) equals 8. There are other types of comparisons and checks, that we’ll add later.


The specification can be executed, and it will run the test specified in it block. We’ll see that later.
The development flowThe flow of development usually looks like this:

An initial spec is written, with tests for the most basic functionality.
An initial implementation is created.
To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
Now we have a working initial implementation with tests.
We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
Go to 3, update the implementation till tests give no errors.
Repeat steps 3-6 till the functionality is ready.

So, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.
Let’s see this development flow in our practical case.
The first step is already complete: we have an initial spec for pow. Now, before making the implementation, let’s use a few JavaScript libraries to run the tests, just to see that they are working (they will all fail).
The spec in actionHere in the tutorial we’ll be using the following JavaScript libraries for tests:

Mocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.
Chai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.
Sinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.

These libraries are suitable for both in-browser and server-side testing. Here we’ll consider the browser variant.
The full HTML page with these frameworks and pow spec:

      
        
        
          <!DOCTYPE html>
<html>
<head>
  <!-- add mocha css, to show results -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- add mocha framework code -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // minimal setup
  </script>
  <!-- add chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai has a lot of stuff, let's make assert global
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* function code is to be written, empty now */
    }
  </script>

  <!-- the script with tests (describe, it...) -->
  <script src="test.js"></script>

  <!-- the element with id="mocha" will contain test results -->
  <div id="mocha"></div>

  <!-- run tests! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
        
      
      
      The page can be divided into five parts:

The <head> – add third-party libraries and styles for tests.
The <script> with the function to test, in our case – with the code for pow.
The tests – in our case an external script test.js that has describe("pow", ...) from above.
The HTML element <div id="mocha"> will be used by Mocha to output results.
The tests are started by the command mocha.run().

The result:

    
        
      
      
    
  As of now, the test fails, there’s an error. That’s logical: we have an empty function code in pow, so pow(2,3) returns undefined instead of 8.
For the future, let’s note that there are more high-level test-runners, like karma and others, that make it easy to autorun many different tests.
Initial implementationLet’s make a simple implementation of pow, for tests to pass:

      
        
        
          function pow(x, n) {
  return 8; // :) we cheat!
}
        
      
      
      Wow, now it works!

    
        
      
      
    
  Improving the specWhat we’ve done is definitely a cheat. The function does not work: an attempt to calculate pow(3,4) would give an incorrect result, but tests pass.
…But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.
Let’s add one more test to check that pow(3, 4) = 81.
We can select one of two ways to organize the test here:


The first variant – add one more assert into the same it:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The second – make two tests:

      
        
        
          describe("pow", function() {

  it("2 raised to power 3 is 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3 raised to power 4 is 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The principal difference is that when assert triggers an error, the it block immediately terminates. So, in the first variant if the first assert fails, then we’ll never see the result of the second assert.
Making tests separate is useful to get more information about what’s going on, so the second variant is better.
And besides that, there’s one more rule that’s good to follow.
One test checks one thing.
If we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.
So let’s continue with the second variant.
The result:

    
        
      
      
    
  As we could expect, the second test failed. Sure, our function always returns 8, while the assert expects 81.
Improving the implementationLet’s write something more real for tests to pass:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      To be sure that the function works well, let’s test it for more values. Instead of writing it blocks manually, we can generate them in for:

      
        
        
          describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
        
      
      
      The result:

    
        
      
      
    
  Nested describeWe’re going to add even more tests. But before that let’s note that the helper function makeTest and for should be grouped together. We won’t need makeTest in other tests, it’s needed only in for: their common task is to check how pow raises into the given power.
Grouping is done with a nested describe:

      
        
        
          describe("pow", function() {

  describe("raises x to power 3", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} in the power 3 is ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... more tests to follow here, both describe and it can be added
});
        
      
      
      The nested describe defines a new “subgroup” of tests. In the output we can see the titled indentation:

    
        
      
      
    
  In the future we can add more it and describe on the top level with helper functions of their own, they won’t see makeTest.

            before/after and beforeEach/afterEach
            We can setup before/after functions that execute before/after running tests, and also beforeEach/afterEach functions that execute before/after every it.
For instance:

      
        
        
          describe("test", function() {

  before(() => alert("Testing started – before all tests"));
  after(() => alert("Testing finished – after all tests"));

  beforeEach(() => alert("Before a test – enter a test"));
  afterEach(() => alert("After a test – exit a test"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
        
      
      
      The running sequence will be:

      
        
        
          Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)
        
      
      
      Open the example in the sandbox.Usually, beforeEach/afterEach and before/after are used to perform initialization, zero out counters or do something else between the tests (or test groups).

Extending the specThe basic functionality of pow is complete. The first iteration of the development is done. When we’re done celebrating and drinking champagne – let’s go on and improve it.
As it was said, the function pow(x, n) is meant to work with positive integer values n.
To indicate a mathematical error, JavaScript functions usually return NaN. Let’s do the same for invalid values of n.
Let’s first add the behavior to the spec(!):

      
        
        
          describe("pow", function() {

  // ...

  it("for negative n the result is NaN", function() {
    assert.isNaN(pow(2, -1));
  });

  it("for non-integer n the result is NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
        
      
      
      The result with new tests:

    
        
      
      
    
  The newly added tests fail, because our implementation does not support them. That’s how BDD is done: first we write failing tests, and then make an implementation for them.

            Other assertions
            Please note the assertion assert.isNaN: it checks for NaN.
There are other assertions in Chai as well, for instance:

assert.equal(value1, value2) – checks the equality  value1 == value2.
assert.strictEqual(value1, value2) – checks the strict equality value1 === value2.
assert.notEqual, assert.notStrictEqual – inverse checks to the ones above.
assert.isTrue(value) – checks that value === true
assert.isFalse(value) – checks that value === false
…the full list is in the docs


So we should add a couple of lines to pow:

      
        
        
          function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      Now it works, all tests pass:

    
        
      
      
    
  Open the full final example in the sandbox.SummaryIn BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.
The spec can be used in three ways:

As Tests – they guarantee that the code works correctly.
As Docs – the titles of describe and it tell what the function does.
As Examples – the tests are actually working examples showing how a function can be used.

With the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.
That’s especially important in large projects when a function is used in many places. When we change such a function, there’s just no way to manually check if every place that uses it still works right.
Without tests, people have two ways:

To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.
Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.

Automatic testing helps to avoid these problems!
If the project is covered with tests, there’s just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.
Besides, a well-tested code has better architecture.
Naturally, that’s because auto-tested code is easier to modify and improve. But there’s also another reason.
To write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.
In real life that’s sometimes not that easy. Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. But in general writing tests makes development faster and more stable.
Later in the tutorial you will meet many tasks with tests baked-in. So you’ll see more practical examples.
Writing tests requires good JavaScript knowledge. But we’re just starting to learn it. So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.\n\nTutorialThe JavaScript languageCode qualityOctober 14, 2022Automated testing with MochaAutomated testing will be used in further tasks, and it’s also widely used in real projects.
Why do we need tests?When we write a function, we can usually imagine what it should do: which parameters give which results.
During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.
If something is wrong – then we fix the code, run again, check the result – and so on till it works.
But such manual “re-runs” are imperfect.
When testing a code by manual re-runs, it’s easy to miss something.
For instance, we’re creating a function f. Wrote some code, testing: f(1) works, but f(2) doesn’t work. We fix the code and now f(2) works. Looks complete? But we forgot to re-test f(1). That may lead to an error.
That’s very typical. When we develop something, we keep a lot of possible use cases in mind. But it’s hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.
Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.
Behavior Driven Development (BDD)Let’s start with a technique named Behavior Driven Development or, in short, BDD.
BDD is three things in one: tests AND documentation AND examples.
To understand BDD, we’ll examine a practical case of development.
Development of “pow”: the specLet’s say we want to make a function pow(x, n) that raises x to an integer power n. We assume that n≥0.
That task is just an example: there’s the ** operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.
Before creating the code of pow, we can imagine what the function should do and describe it.
Such description is called a specification or, in short, a spec, and contains descriptions of use cases together with tests for them, like this:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
  });

});
        
      
      
      A spec has three main building blocks that you can see above:

describe("title", function() { ... })

What functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.

it("use case description", function() { ... })

In the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.

assert.equal(value1, value2)

The code inside it block, if the implementation is correct, should execute without errors.
Functions assert.* are used to check whether pow works as expected. Right here we’re using one of them – assert.equal, it compares arguments and yields an error if they are not equal. Here it checks that the result of pow(2, 3) equals 8. There are other types of comparisons and checks, that we’ll add later.


The specification can be executed, and it will run the test specified in it block. We’ll see that later.
The development flowThe flow of development usually looks like this:

An initial spec is written, with tests for the most basic functionality.
An initial implementation is created.
To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
Now we have a working initial implementation with tests.
We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
Go to 3, update the implementation till tests give no errors.
Repeat steps 3-6 till the functionality is ready.

So, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.
Let’s see this development flow in our practical case.
The first step is already complete: we have an initial spec for pow. Now, before making the implementation, let’s use a few JavaScript libraries to run the tests, just to see that they are working (they will all fail).
The spec in actionHere in the tutorial we’ll be using the following JavaScript libraries for tests:

Mocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.
Chai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.
Sinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.

These libraries are suitable for both in-browser and server-side testing. Here we’ll consider the browser variant.
The full HTML page with these frameworks and pow spec:

      
        
        
          <!DOCTYPE html>
<html>
<head>
  <!-- add mocha css, to show results -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- add mocha framework code -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // minimal setup
  </script>
  <!-- add chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai has a lot of stuff, let's make assert global
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* function code is to be written, empty now */
    }
  </script>

  <!-- the script with tests (describe, it...) -->
  <script src="test.js"></script>

  <!-- the element with id="mocha" will contain test results -->
  <div id="mocha"></div>

  <!-- run tests! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
        
      
      
      The page can be divided into five parts:

The <head> – add third-party libraries and styles for tests.
The <script> with the function to test, in our case – with the code for pow.
The tests – in our case an external script test.js that has describe("pow", ...) from above.
The HTML element <div id="mocha"> will be used by Mocha to output results.
The tests are started by the command mocha.run().

The result:

    
        
      
      
    
  As of now, the test fails, there’s an error. That’s logical: we have an empty function code in pow, so pow(2,3) returns undefined instead of 8.
For the future, let’s note that there are more high-level test-runners, like karma and others, that make it easy to autorun many different tests.
Initial implementationLet’s make a simple implementation of pow, for tests to pass:

      
        
        
          function pow(x, n) {
  return 8; // :) we cheat!
}
        
      
      
      Wow, now it works!

    
        
      
      
    
  Improving the specWhat we’ve done is definitely a cheat. The function does not work: an attempt to calculate pow(3,4) would give an incorrect result, but tests pass.
…But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.
Let’s add one more test to check that pow(3, 4) = 81.
We can select one of two ways to organize the test here:


The first variant – add one more assert into the same it:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The second – make two tests:

      
        
        
          describe("pow", function() {

  it("2 raised to power 3 is 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3 raised to power 4 is 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The principal difference is that when assert triggers an error, the it block immediately terminates. So, in the first variant if the first assert fails, then we’ll never see the result of the second assert.
Making tests separate is useful to get more information about what’s going on, so the second variant is better.
And besides that, there’s one more rule that’s good to follow.
One test checks one thing.
If we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.
So let’s continue with the second variant.
The result:

    
        
      
      
    
  As we could expect, the second test failed. Sure, our function always returns 8, while the assert expects 81.
Improving the implementationLet’s write something more real for tests to pass:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      To be sure that the function works well, let’s test it for more values. Instead of writing it blocks manually, we can generate them in for:

      
        
        
          describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
        
      
      
      The result:

    
        
      
      
    
  Nested describeWe’re going to add even more tests. But before that let’s note that the helper function makeTest and for should be grouped together. We won’t need makeTest in other tests, it’s needed only in for: their common task is to check how pow raises into the given power.
Grouping is done with a nested describe:

      
        
        
          describe("pow", function() {

  describe("raises x to power 3", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} in the power 3 is ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... more tests to follow here, both describe and it can be added
});
        
      
      
      The nested describe defines a new “subgroup” of tests. In the output we can see the titled indentation:

    
        
      
      
    
  In the future we can add more it and describe on the top level with helper functions of their own, they won’t see makeTest.

            before/after and beforeEach/afterEach
            We can setup before/after functions that execute before/after running tests, and also beforeEach/afterEach functions that execute before/after every it.
For instance:

      
        
        
          describe("test", function() {

  before(() => alert("Testing started – before all tests"));
  after(() => alert("Testing finished – after all tests"));

  beforeEach(() => alert("Before a test – enter a test"));
  afterEach(() => alert("After a test – exit a test"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
        
      
      
      The running sequence will be:

      
        
        
          Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)
        
      
      
      Open the example in the sandbox.Usually, beforeEach/afterEach and before/after are used to perform initialization, zero out counters or do something else between the tests (or test groups).

Extending the specThe basic functionality of pow is complete. The first iteration of the development is done. When we’re done celebrating and drinking champagne – let’s go on and improve it.
As it was said, the function pow(x, n) is meant to work with positive integer values n.
To indicate a mathematical error, JavaScript functions usually return NaN. Let’s do the same for invalid values of n.
Let’s first add the behavior to the spec(!):

      
        
        
          describe("pow", function() {

  // ...

  it("for negative n the result is NaN", function() {
    assert.isNaN(pow(2, -1));
  });

  it("for non-integer n the result is NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
        
      
      
      The result with new tests:

    
        
      
      
    
  The newly added tests fail, because our implementation does not support them. That’s how BDD is done: first we write failing tests, and then make an implementation for them.

            Other assertions
            Please note the assertion assert.isNaN: it checks for NaN.
There are other assertions in Chai as well, for instance:

assert.equal(value1, value2) – checks the equality  value1 == value2.
assert.strictEqual(value1, value2) – checks the strict equality value1 === value2.
assert.notEqual, assert.notStrictEqual – inverse checks to the ones above.
assert.isTrue(value) – checks that value === true
assert.isFalse(value) – checks that value === false
…the full list is in the docs


So we should add a couple of lines to pow:

      
        
        
          function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      Now it works, all tests pass:

    
        
      
      
    
  Open the full final example in the sandbox.SummaryIn BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.
The spec can be used in three ways:

As Tests – they guarantee that the code works correctly.
As Docs – the titles of describe and it tell what the function does.
As Examples – the tests are actually working examples showing how a function can be used.

With the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.
That’s especially important in large projects when a function is used in many places. When we change such a function, there’s just no way to manually check if every place that uses it still works right.
Without tests, people have two ways:

To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.
Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.

Automatic testing helps to avoid these problems!
If the project is covered with tests, there’s just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.
Besides, a well-tested code has better architecture.
Naturally, that’s because auto-tested code is easier to modify and improve. But there’s also another reason.
To write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.
In real life that’s sometimes not that easy. Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. But in general writing tests makes development faster and more stable.
Later in the tutorial you will meet many tasks with tests baked-in. So you’ll see more practical examples.
Writing tests requires good JavaScript knowledge. But we’re just starting to learn it. So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.
TasksWhat's wrong in the test?importance: 5What’s wrong in the test of pow below?

      
        
        
          it("Raises x to the power n", function() {
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});
        
      
      
      P.S. Syntactically the test is correct and passes.
solutionThe test demonstrates one of the temptations a developer meets when writing tests.
What we have here is actually 3 tests, but layed out as a single function with 3 asserts.
Sometimes it’s easier to write this way, but if an error occurs, it’s much less obvious what went wrong.
If an error happens in the middle of a complex execution flow, then we’ll have to figure out the data at that point. We’ll actually have to debug the test.
It would be much better to break the test into multiple it blocks with clearly written inputs and outputs.
Like this:

      
        
        
          describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      We replaced the single it with describe and a group of it blocks. Now if something fails we would see clearly what the data was.
Also we can isolate a single test and run it in standalone mode by writing it.only instead of it:

      
        
        
          describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  // Mocha will run only this block
  it.only("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nAutomated testing will be used in further tasks, and it’s also widely used in real projects.
Why do we need tests?When we write a function, we can usually imagine what it should do: which parameters give which results.
During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.
If something is wrong – then we fix the code, run again, check the result – and so on till it works.
But such manual “re-runs” are imperfect.
When testing a code by manual re-runs, it’s easy to miss something.
For instance, we’re creating a function f. Wrote some code, testing: f(1) works, but f(2) doesn’t work. We fix the code and now f(2) works. Looks complete? But we forgot to re-test f(1). That may lead to an error.
That’s very typical. When we develop something, we keep a lot of possible use cases in mind. But it’s hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.
Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.
Behavior Driven Development (BDD)Let’s start with a technique named Behavior Driven Development or, in short, BDD.
BDD is three things in one: tests AND documentation AND examples.
To understand BDD, we’ll examine a practical case of development.
Development of “pow”: the specLet’s say we want to make a function pow(x, n) that raises x to an integer power n. We assume that n≥0.
That task is just an example: there’s the ** operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.
Before creating the code of pow, we can imagine what the function should do and describe it.
Such description is called a specification or, in short, a spec, and contains descriptions of use cases together with tests for them, like this:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
  });

});
        
      
      
      A spec has three main building blocks that you can see above:

describe("title", function() { ... })

What functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.

it("use case description", function() { ... })

In the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.

assert.equal(value1, value2)

The code inside it block, if the implementation is correct, should execute without errors.
Functions assert.* are used to check whether pow works as expected. Right here we’re using one of them – assert.equal, it compares arguments and yields an error if they are not equal. Here it checks that the result of pow(2, 3) equals 8. There are other types of comparisons and checks, that we’ll add later.


The specification can be executed, and it will run the test specified in it block. We’ll see that later.
The development flowThe flow of development usually looks like this:

An initial spec is written, with tests for the most basic functionality.
An initial implementation is created.
To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
Now we have a working initial implementation with tests.
We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
Go to 3, update the implementation till tests give no errors.
Repeat steps 3-6 till the functionality is ready.

So, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.
Let’s see this development flow in our practical case.
The first step is already complete: we have an initial spec for pow. Now, before making the implementation, let’s use a few JavaScript libraries to run the tests, just to see that they are working (they will all fail).
The spec in actionHere in the tutorial we’ll be using the following JavaScript libraries for tests:

Mocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.
Chai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.
Sinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.

These libraries are suitable for both in-browser and server-side testing. Here we’ll consider the browser variant.
The full HTML page with these frameworks and pow spec:

      
        
        
          <!DOCTYPE html>
<html>
<head>
  <!-- add mocha css, to show results -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- add mocha framework code -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // minimal setup
  </script>
  <!-- add chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai has a lot of stuff, let's make assert global
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* function code is to be written, empty now */
    }
  </script>

  <!-- the script with tests (describe, it...) -->
  <script src="test.js"></script>

  <!-- the element with id="mocha" will contain test results -->
  <div id="mocha"></div>

  <!-- run tests! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
        
      
      
      The page can be divided into five parts:

The <head> – add third-party libraries and styles for tests.
The <script> with the function to test, in our case – with the code for pow.
The tests – in our case an external script test.js that has describe("pow", ...) from above.
The HTML element <div id="mocha"> will be used by Mocha to output results.
The tests are started by the command mocha.run().

The result:

    
        
      
      
    
  As of now, the test fails, there’s an error. That’s logical: we have an empty function code in pow, so pow(2,3) returns undefined instead of 8.
For the future, let’s note that there are more high-level test-runners, like karma and others, that make it easy to autorun many different tests.
Initial implementationLet’s make a simple implementation of pow, for tests to pass:

      
        
        
          function pow(x, n) {
  return 8; // :) we cheat!
}
        
      
      
      Wow, now it works!

    
        
      
      
    
  Improving the specWhat we’ve done is definitely a cheat. The function does not work: an attempt to calculate pow(3,4) would give an incorrect result, but tests pass.
…But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.
Let’s add one more test to check that pow(3, 4) = 81.
We can select one of two ways to organize the test here:


The first variant – add one more assert into the same it:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The second – make two tests:

      
        
        
          describe("pow", function() {

  it("2 raised to power 3 is 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3 raised to power 4 is 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The principal difference is that when assert triggers an error, the it block immediately terminates. So, in the first variant if the first assert fails, then we’ll never see the result of the second assert.
Making tests separate is useful to get more information about what’s going on, so the second variant is better.
And besides that, there’s one more rule that’s good to follow.
One test checks one thing.
If we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.
So let’s continue with the second variant.
The result:

    
        
      
      
    
  As we could expect, the second test failed. Sure, our function always returns 8, while the assert expects 81.
Improving the implementationLet’s write something more real for tests to pass:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      To be sure that the function works well, let’s test it for more values. Instead of writing it blocks manually, we can generate them in for:

      
        
        
          describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
        
      
      
      The result:

    
        
      
      
    
  Nested describeWe’re going to add even more tests. But before that let’s note that the helper function makeTest and for should be grouped together. We won’t need makeTest in other tests, it’s needed only in for: their common task is to check how pow raises into the given power.
Grouping is done with a nested describe:

      
        
        
          describe("pow", function() {

  describe("raises x to power 3", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} in the power 3 is ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... more tests to follow here, both describe and it can be added
});
        
      
      
      The nested describe defines a new “subgroup” of tests. In the output we can see the titled indentation:

    
        
      
      
    
  In the future we can add more it and describe on the top level with helper functions of their own, they won’t see makeTest.

            before/after and beforeEach/afterEach
            We can setup before/after functions that execute before/after running tests, and also beforeEach/afterEach functions that execute before/after every it.
For instance:

      
        
        
          describe("test", function() {

  before(() => alert("Testing started – before all tests"));
  after(() => alert("Testing finished – after all tests"));

  beforeEach(() => alert("Before a test – enter a test"));
  afterEach(() => alert("After a test – exit a test"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
        
      
      
      The running sequence will be:

      
        
        
          Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)
        
      
      
      Open the example in the sandbox.Usually, beforeEach/afterEach and before/after are used to perform initialization, zero out counters or do something else between the tests (or test groups).

Extending the specThe basic functionality of pow is complete. The first iteration of the development is done. When we’re done celebrating and drinking champagne – let’s go on and improve it.
As it was said, the function pow(x, n) is meant to work with positive integer values n.
To indicate a mathematical error, JavaScript functions usually return NaN. Let’s do the same for invalid values of n.
Let’s first add the behavior to the spec(!):

      
        
        
          describe("pow", function() {

  // ...

  it("for negative n the result is NaN", function() {
    assert.isNaN(pow(2, -1));
  });

  it("for non-integer n the result is NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
        
      
      
      The result with new tests:

    
        
      
      
    
  The newly added tests fail, because our implementation does not support them. That’s how BDD is done: first we write failing tests, and then make an implementation for them.

            Other assertions
            Please note the assertion assert.isNaN: it checks for NaN.
There are other assertions in Chai as well, for instance:

assert.equal(value1, value2) – checks the equality  value1 == value2.
assert.strictEqual(value1, value2) – checks the strict equality value1 === value2.
assert.notEqual, assert.notStrictEqual – inverse checks to the ones above.
assert.isTrue(value) – checks that value === true
assert.isFalse(value) – checks that value === false
…the full list is in the docs


So we should add a couple of lines to pow:

      
        
        
          function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      Now it works, all tests pass:

    
        
      
      
    
  Open the full final example in the sandbox.SummaryIn BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.
The spec can be used in three ways:

As Tests – they guarantee that the code works correctly.
As Docs – the titles of describe and it tell what the function does.
As Examples – the tests are actually working examples showing how a function can be used.

With the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.
That’s especially important in large projects when a function is used in many places. When we change such a function, there’s just no way to manually check if every place that uses it still works right.
Without tests, people have two ways:

To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.
Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.

Automatic testing helps to avoid these problems!
If the project is covered with tests, there’s just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.
Besides, a well-tested code has better architecture.
Naturally, that’s because auto-tested code is easier to modify and improve. But there’s also another reason.
To write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.
In real life that’s sometimes not that easy. Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. But in general writing tests makes development faster and more stable.
Later in the tutorial you will meet many tasks with tests baked-in. So you’ll see more practical examples.
Writing tests requires good JavaScript knowledge. But we’re just starting to learn it. So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.
TasksWhat's wrong in the test?importance: 5What’s wrong in the test of pow below?

      
        
        
          it("Raises x to the power n", function() {
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});
        
      
      
      P.S. Syntactically the test is correct and passes.
solutionThe test demonstrates one of the temptations a developer meets when writing tests.
What we have here is actually 3 tests, but layed out as a single function with 3 asserts.
Sometimes it’s easier to write this way, but if an error occurs, it’s much less obvious what went wrong.
If an error happens in the middle of a complex execution flow, then we’ll have to figure out the data at that point. We’ll actually have to debug the test.
It would be much better to break the test into multiple it blocks with clearly written inputs and outputs.
Like this:

      
        
        
          describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      We replaced the single it with describe and a group of it blocks. Now if something fails we would see clearly what the data was.
Also we can isolate a single test and run it in standalone mode by writing it.only instead of it:

      
        
        
          describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  // Mocha will run only this block
  it.only("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});\n\nTutorialThe JavaScript languageCode qualityOctober 14, 2022Automated testing with MochaAutomated testing will be used in further tasks, and it’s also widely used in real projects.
Why do we need tests?When we write a function, we can usually imagine what it should do: which parameters give which results.
During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.
If something is wrong – then we fix the code, run again, check the result – and so on till it works.
But such manual “re-runs” are imperfect.
When testing a code by manual re-runs, it’s easy to miss something.
For instance, we’re creating a function f. Wrote some code, testing: f(1) works, but f(2) doesn’t work. We fix the code and now f(2) works. Looks complete? But we forgot to re-test f(1). That may lead to an error.
That’s very typical. When we develop something, we keep a lot of possible use cases in mind. But it’s hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.
Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.
Behavior Driven Development (BDD)Let’s start with a technique named Behavior Driven Development or, in short, BDD.
BDD is three things in one: tests AND documentation AND examples.
To understand BDD, we’ll examine a practical case of development.
Development of “pow”: the specLet’s say we want to make a function pow(x, n) that raises x to an integer power n. We assume that n≥0.
That task is just an example: there’s the ** operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.
Before creating the code of pow, we can imagine what the function should do and describe it.
Such description is called a specification or, in short, a spec, and contains descriptions of use cases together with tests for them, like this:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
  });

});
        
      
      
      A spec has three main building blocks that you can see above:

describe("title", function() { ... })

What functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.

it("use case description", function() { ... })

In the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.

assert.equal(value1, value2)

The code inside it block, if the implementation is correct, should execute without errors.
Functions assert.* are used to check whether pow works as expected. Right here we’re using one of them – assert.equal, it compares arguments and yields an error if they are not equal. Here it checks that the result of pow(2, 3) equals 8. There are other types of comparisons and checks, that we’ll add later.


The specification can be executed, and it will run the test specified in it block. We’ll see that later.
The development flowThe flow of development usually looks like this:

An initial spec is written, with tests for the most basic functionality.
An initial implementation is created.
To check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
Now we have a working initial implementation with tests.
We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
Go to 3, update the implementation till tests give no errors.
Repeat steps 3-6 till the functionality is ready.

So, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.
Let’s see this development flow in our practical case.
The first step is already complete: we have an initial spec for pow. Now, before making the implementation, let’s use a few JavaScript libraries to run the tests, just to see that they are working (they will all fail).
The spec in actionHere in the tutorial we’ll be using the following JavaScript libraries for tests:

Mocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.
Chai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.
Sinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.

These libraries are suitable for both in-browser and server-side testing. Here we’ll consider the browser variant.
The full HTML page with these frameworks and pow spec:

      
        
        
          <!DOCTYPE html>
<html>
<head>
  <!-- add mocha css, to show results -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- add mocha framework code -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // minimal setup
  </script>
  <!-- add chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai has a lot of stuff, let's make assert global
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* function code is to be written, empty now */
    }
  </script>

  <!-- the script with tests (describe, it...) -->
  <script src="test.js"></script>

  <!-- the element with id="mocha" will contain test results -->
  <div id="mocha"></div>

  <!-- run tests! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
        
      
      
      The page can be divided into five parts:

The <head> – add third-party libraries and styles for tests.
The <script> with the function to test, in our case – with the code for pow.
The tests – in our case an external script test.js that has describe("pow", ...) from above.
The HTML element <div id="mocha"> will be used by Mocha to output results.
The tests are started by the command mocha.run().

The result:

    
        
      
      
    
  As of now, the test fails, there’s an error. That’s logical: we have an empty function code in pow, so pow(2,3) returns undefined instead of 8.
For the future, let’s note that there are more high-level test-runners, like karma and others, that make it easy to autorun many different tests.
Initial implementationLet’s make a simple implementation of pow, for tests to pass:

      
        
        
          function pow(x, n) {
  return 8; // :) we cheat!
}
        
      
      
      Wow, now it works!

    
        
      
      
    
  Improving the specWhat we’ve done is definitely a cheat. The function does not work: an attempt to calculate pow(3,4) would give an incorrect result, but tests pass.
…But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.
Let’s add one more test to check that pow(3, 4) = 81.
We can select one of two ways to organize the test here:


The first variant – add one more assert into the same it:

      
        
        
          describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The second – make two tests:

      
        
        
          describe("pow", function() {

  it("2 raised to power 3 is 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3 raised to power 4 is 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

The principal difference is that when assert triggers an error, the it block immediately terminates. So, in the first variant if the first assert fails, then we’ll never see the result of the second assert.
Making tests separate is useful to get more information about what’s going on, so the second variant is better.
And besides that, there’s one more rule that’s good to follow.
One test checks one thing.
If we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.
So let’s continue with the second variant.
The result:

    
        
      
      
    
  As we could expect, the second test failed. Sure, our function always returns 8, while the assert expects 81.
Improving the implementationLet’s write something more real for tests to pass:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      To be sure that the function works well, let’s test it for more values. Instead of writing it blocks manually, we can generate them in for:

      
        
        
          describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
        
      
      
      The result:

    
        
      
      
    
  Nested describeWe’re going to add even more tests. But before that let’s note that the helper function makeTest and for should be grouped together. We won’t need makeTest in other tests, it’s needed only in for: their common task is to check how pow raises into the given power.
Grouping is done with a nested describe:

      
        
        
          describe("pow", function() {

  describe("raises x to power 3", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} in the power 3 is ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... more tests to follow here, both describe and it can be added
});
        
      
      
      The nested describe defines a new “subgroup” of tests. In the output we can see the titled indentation:

    
        
      
      
    
  In the future we can add more it and describe on the top level with helper functions of their own, they won’t see makeTest.

            before/after and beforeEach/afterEach
            We can setup before/after functions that execute before/after running tests, and also beforeEach/afterEach functions that execute before/after every it.
For instance:

      
        
        
          describe("test", function() {

  before(() => alert("Testing started – before all tests"));
  after(() => alert("Testing finished – after all tests"));

  beforeEach(() => alert("Before a test – enter a test"));
  afterEach(() => alert("After a test – exit a test"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
        
      
      
      The running sequence will be:

      
        
        
          Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)
        
      
      
      Open the example in the sandbox.Usually, beforeEach/afterEach and before/after are used to perform initialization, zero out counters or do something else between the tests (or test groups).

Extending the specThe basic functionality of pow is complete. The first iteration of the development is done. When we’re done celebrating and drinking champagne – let’s go on and improve it.
As it was said, the function pow(x, n) is meant to work with positive integer values n.
To indicate a mathematical error, JavaScript functions usually return NaN. Let’s do the same for invalid values of n.
Let’s first add the behavior to the spec(!):

      
        
        
          describe("pow", function() {

  // ...

  it("for negative n the result is NaN", function() {
    assert.isNaN(pow(2, -1));
  });

  it("for non-integer n the result is NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
        
      
      
      The result with new tests:

    
        
      
      
    
  The newly added tests fail, because our implementation does not support them. That’s how BDD is done: first we write failing tests, and then make an implementation for them.

            Other assertions
            Please note the assertion assert.isNaN: it checks for NaN.
There are other assertions in Chai as well, for instance:

assert.equal(value1, value2) – checks the equality  value1 == value2.
assert.strictEqual(value1, value2) – checks the strict equality value1 === value2.
assert.notEqual, assert.notStrictEqual – inverse checks to the ones above.
assert.isTrue(value) – checks that value === true
assert.isFalse(value) – checks that value === false
…the full list is in the docs


So we should add a couple of lines to pow:

      
        
        
          function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      Now it works, all tests pass:

    
        
      
      
    
  Open the full final example in the sandbox.SummaryIn BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.
The spec can be used in three ways:

As Tests – they guarantee that the code works correctly.
As Docs – the titles of describe and it tell what the function does.
As Examples – the tests are actually working examples showing how a function can be used.

With the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.
That’s especially important in large projects when a function is used in many places. When we change such a function, there’s just no way to manually check if every place that uses it still works right.
Without tests, people have two ways:

To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.
Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.

Automatic testing helps to avoid these problems!
If the project is covered with tests, there’s just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.
Besides, a well-tested code has better architecture.
Naturally, that’s because auto-tested code is easier to modify and improve. But there’s also another reason.
To write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.
In real life that’s sometimes not that easy. Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. But in general writing tests makes development faster and more stable.
Later in the tutorial you will meet many tasks with tests baked-in. So you’ll see more practical examples.
Writing tests requires good JavaScript knowledge. But we’re just starting to learn it. So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.
TasksWhat's wrong in the test?importance: 5What’s wrong in the test of pow below?

      
        
        
          it("Raises x to the power n", function() {
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});
        
      
      
      P.S. Syntactically the test is correct and passes.
solutionThe test demonstrates one of the temptations a developer meets when writing tests.
What we have here is actually 3 tests, but layed out as a single function with 3 asserts.
Sometimes it’s easier to write this way, but if an error occurs, it’s much less obvious what went wrong.
If an error happens in the middle of a complex execution flow, then we’ll have to figure out the data at that point. We’ll actually have to debug the test.
It would be much better to break the test into multiple it blocks with clearly written inputs and outputs.
Like this:

      
        
        
          describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      We replaced the single it with describe and a group of it blocks. Now if something fails we would see clearly what the data was.
Also we can isolate a single test and run it in standalone mode by writing it.only instead of it:

      
        
        
          describe("Raises x to power n", function() {
  it("5 in the power of 1 equals 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  // Mocha will run only this block
  it.only("5 in the power of 2 equals 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 in the power of 3 equals 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThe JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at https://tc39.github.io/ecma262/ and then progress to the specification.
Teams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.
So it’s quite common for an engine to implement only part of the standard.
A good page to see the current state of support for language features is https://compat-table.github.io/compat-table/es6/ (it’s big, we have a lot to study yet).
As programmers, we’d like to use most recent features. The more good stuff – the better!
On the other hand, how to make our modern code work on older engines that don’t understand recent features yet?
There are two tools for that:

Transpilers.
Polyfills.

Here, in this chapter, our purpose is to get the gist of how they work, and their place in web development.
TranspilersA transpiler is a special piece of software that translates source code to another source code. It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.
E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100.
A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.

      
        
        
          // before running the transpiler
height = height ?? 100;

// after running the transpiler
height = (height !== undefined && height !== null) ? height : 100;
        
      
      
      Now the rewritten code is suitable for older JavaScript engines.
Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.
Speaking of names, Babel is one of the most prominent transpilers out there.
Modern project build systems, such as webpack, provide a means to run a transpiler automatically on every code change, so it’s very easy to integrate into the development process.
PolyfillsNew language features may include not only syntax constructs and operators, but also built-in functions.
For example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.
In some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail.
As we’re talking about new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.
For this particular case, the polyfill for Math.trunc is a script that implements it, like this:

      
        
        
          if (!Math.trunc) { // if no such function
  // implement it
  Math.trunc = function(number) {
    // Math.ceil and Math.floor exist even in ancient JavaScript engines
    // they are covered later in the tutorial
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}
        
      
      
      JavaScript is a highly dynamic language. Scripts may add/modify any function, even built-in ones.
One interesting polyfill library is core-js, which supports a wide range of features and allows you to include only the ones you need.
SummaryIn this chapter we’d like to motivate you to study modern and even “bleeding-edge” language features, even if they aren’t yet well-supported by JavaScript engines.
Just don’t forget to use a transpiler (if using modern syntax or operators) and polyfills (to add functions that may be missing). They’ll ensure that the code works.
For example, later when you’re familiar with JavaScript, you can setup a code build system based on webpack with the babel-loader plugin.
Good resources that show the current state of support for various features:

https://compat-table.github.io/compat-table/es6/ – for pure JavaScript.
https://caniuse.com/ – for browser-related functions.

P.S. Google Chrome is usually the most up-to-date with language features, try it if a tutorial demo fails. Most tutorial demos work with any modern browser though.\n\nTutorialThe JavaScript languageCode qualityFebruary 4, 2025Polyfills and transpilersThe JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at https://tc39.github.io/ecma262/ and then progress to the specification.
Teams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.
So it’s quite common for an engine to implement only part of the standard.
A good page to see the current state of support for language features is https://compat-table.github.io/compat-table/es6/ (it’s big, we have a lot to study yet).
As programmers, we’d like to use most recent features. The more good stuff – the better!
On the other hand, how to make our modern code work on older engines that don’t understand recent features yet?
There are two tools for that:

Transpilers.
Polyfills.

Here, in this chapter, our purpose is to get the gist of how they work, and their place in web development.
TranspilersA transpiler is a special piece of software that translates source code to another source code. It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.
E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100.
A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.

      
        
        
          // before running the transpiler
height = height ?? 100;

// after running the transpiler
height = (height !== undefined && height !== null) ? height : 100;
        
      
      
      Now the rewritten code is suitable for older JavaScript engines.
Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.
Speaking of names, Babel is one of the most prominent transpilers out there.
Modern project build systems, such as webpack, provide a means to run a transpiler automatically on every code change, so it’s very easy to integrate into the development process.
PolyfillsNew language features may include not only syntax constructs and operators, but also built-in functions.
For example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.
In some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail.
As we’re talking about new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.
For this particular case, the polyfill for Math.trunc is a script that implements it, like this:

      
        
        
          if (!Math.trunc) { // if no such function
  // implement it
  Math.trunc = function(number) {
    // Math.ceil and Math.floor exist even in ancient JavaScript engines
    // they are covered later in the tutorial
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}
        
      
      
      JavaScript is a highly dynamic language. Scripts may add/modify any function, even built-in ones.
One interesting polyfill library is core-js, which supports a wide range of features and allows you to include only the ones you need.
SummaryIn this chapter we’d like to motivate you to study modern and even “bleeding-edge” language features, even if they aren’t yet well-supported by JavaScript engines.
Just don’t forget to use a transpiler (if using modern syntax or operators) and polyfills (to add functions that may be missing). They’ll ensure that the code works.
For example, later when you’re familiar with JavaScript, you can setup a code build system based on webpack with the babel-loader plugin.
Good resources that show the current state of support for various features:

https://compat-table.github.io/compat-table/es6/ – for pure JavaScript.
https://caniuse.com/ – for browser-related functions.

P.S. Google Chrome is usually the most up-to-date with language features, try it if a tutorial demo fails. Most tutorial demos work with any modern browser though.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThe JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at https://tc39.github.io/ecma262/ and then progress to the specification.
Teams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.
So it’s quite common for an engine to implement only part of the standard.
A good page to see the current state of support for language features is https://compat-table.github.io/compat-table/es6/ (it’s big, we have a lot to study yet).
As programmers, we’d like to use most recent features. The more good stuff – the better!
On the other hand, how to make our modern code work on older engines that don’t understand recent features yet?
There are two tools for that:

Transpilers.
Polyfills.

Here, in this chapter, our purpose is to get the gist of how they work, and their place in web development.
TranspilersA transpiler is a special piece of software that translates source code to another source code. It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.
E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100.
A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.

      
        
        
          // before running the transpiler
height = height ?? 100;

// after running the transpiler
height = (height !== undefined && height !== null) ? height : 100;
        
      
      
      Now the rewritten code is suitable for older JavaScript engines.
Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.
Speaking of names, Babel is one of the most prominent transpilers out there.
Modern project build systems, such as webpack, provide a means to run a transpiler automatically on every code change, so it’s very easy to integrate into the development process.
PolyfillsNew language features may include not only syntax constructs and operators, but also built-in functions.
For example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.
In some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail.
As we’re talking about new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.
For this particular case, the polyfill for Math.trunc is a script that implements it, like this:

      
        
        
          if (!Math.trunc) { // if no such function
  // implement it
  Math.trunc = function(number) {
    // Math.ceil and Math.floor exist even in ancient JavaScript engines
    // they are covered later in the tutorial
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}
        
      
      
      JavaScript is a highly dynamic language. Scripts may add/modify any function, even built-in ones.
One interesting polyfill library is core-js, which supports a wide range of features and allows you to include only the ones you need.
SummaryIn this chapter we’d like to motivate you to study modern and even “bleeding-edge” language features, even if they aren’t yet well-supported by JavaScript engines.
Just don’t forget to use a transpiler (if using modern syntax or operators) and polyfills (to add functions that may be missing). They’ll ensure that the code works.
For example, later when you’re familiar with JavaScript, you can setup a code build system based on webpack with the babel-loader plugin.
Good resources that show the current state of support for various features:

https://compat-table.github.io/compat-table/es6/ – for pure JavaScript.
https://caniuse.com/ – for browser-related functions.

P.S. Google Chrome is usually the most up-to-date with language features, try it if a tutorial demo fails. Most tutorial demos work with any modern browser though.\n\nTutorialThe JavaScript languageCode qualityFebruary 4, 2025Polyfills and transpilersThe JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at https://tc39.github.io/ecma262/ and then progress to the specification.
Teams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.
So it’s quite common for an engine to implement only part of the standard.
A good page to see the current state of support for language features is https://compat-table.github.io/compat-table/es6/ (it’s big, we have a lot to study yet).
As programmers, we’d like to use most recent features. The more good stuff – the better!
On the other hand, how to make our modern code work on older engines that don’t understand recent features yet?
There are two tools for that:

Transpilers.
Polyfills.

Here, in this chapter, our purpose is to get the gist of how they work, and their place in web development.
TranspilersA transpiler is a special piece of software that translates source code to another source code. It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.
E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100.
A transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.

      
        
        
          // before running the transpiler
height = height ?? 100;

// after running the transpiler
height = (height !== undefined && height !== null) ? height : 100;
        
      
      
      Now the rewritten code is suitable for older JavaScript engines.
Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.
Speaking of names, Babel is one of the most prominent transpilers out there.
Modern project build systems, such as webpack, provide a means to run a transpiler automatically on every code change, so it’s very easy to integrate into the development process.
PolyfillsNew language features may include not only syntax constructs and operators, but also built-in functions.
For example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.
In some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail.
As we’re talking about new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.
A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.
For this particular case, the polyfill for Math.trunc is a script that implements it, like this:

      
        
        
          if (!Math.trunc) { // if no such function
  // implement it
  Math.trunc = function(number) {
    // Math.ceil and Math.floor exist even in ancient JavaScript engines
    // they are covered later in the tutorial
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}
        
      
      
      JavaScript is a highly dynamic language. Scripts may add/modify any function, even built-in ones.
One interesting polyfill library is core-js, which supports a wide range of features and allows you to include only the ones you need.
SummaryIn this chapter we’d like to motivate you to study modern and even “bleeding-edge” language features, even if they aren’t yet well-supported by JavaScript engines.
Just don’t forget to use a transpiler (if using modern syntax or operators) and polyfills (to add functions that may be missing). They’ll ensure that the code works.
For example, later when you’re familiar with JavaScript, you can setup a code build system based on webpack with the babel-loader plugin.
Good resources that show the current state of support for various features:

https://compat-table.github.io/compat-table/es6/ – for pure JavaScript.
https://caniuse.com/ – for browser-related functions.

P.S. Google Chrome is usually the most up-to-date with language features, try it if a tutorial demo fails. Most tutorial demos work with any modern browser though.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTutorialThe JavaScript languageObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionPrevious lessonNext lessonShareTutorial map\n\nObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversion\n\nTutorialThe JavaScript languageObjects: the basicsObjectsObject references and copyingGarbage collectionObject methods, "this"Constructor, operator "new"Optional chaining '?.'Symbol typeObject to primitive conversionPrevious lessonNext lessonShareTutorial map\n\n\n\nAs we know from the chapter Data types, there are eight data types in JavaScript. Seven of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).
In contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.
An object can be created with figure brackets {…} with an optional list of properties. A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.
We can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It’s easy to find a file by its name or add/remove a file.

      
      
        
      
      An empty object (“empty cabinet”) can be created using one of two syntaxes:

      
        
        
          let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax
        
      
      
      
      
      
        
      
      Usually, the figure brackets {...} are used. That declaration is called an object literal.
Literals and propertiesWe can immediately put some properties into {...} as “key: value” pairs:

      
        
        
          let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};
        
      
      
      A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.
In the user object, there are two properties:

The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.

The resulting user object can be imagined as a cabinet with two signed files labeled “name” and “age”.

      
      
        
      
      We can add, remove and read files from it at any time.
Property values are accessible using the dot notation:

      
        
        
          // get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30
        
      
      
      The value can be of any type. Let’s add a boolean one:

      
        
        
          user.isAdmin = true;
        
      
      
      
      
      
        
      
      To remove a property, we can use the delete operator:

      
        
        
          delete user.age;
        
      
      
      
      
      
        
      
      We can also use multiword property names, but then they must be quoted:

      
        
        
          let user = {
  name: "John",
  age: 30,
  "likes birds": true  // multiword property name must be quoted
};
        
      
      
      
      
      
        
      
      The last property in the list may end with a comma:

      
        
        
          let user = {
  name: "John",
  age: 30,
}
        
      
      
      That is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.
Square bracketsFor multiword properties, the dot access doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          // this would give a syntax error
user.likes birds = true
        
      
      
      JavaScript doesn’t understand that. It thinks that we address user.likes, and then gives a syntax error when comes across unexpected birds.
The dot requires the key to be a valid variable identifier. That implies: contains no spaces, doesn’t start with a digit and doesn’t include special characters ($ and _ are allowed).
There’s an alternative “square bracket notation” that works with any string:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
        
      
      
      Now everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).
Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:

      
        
        
          let key = "likes birds";

// same as user["likes birds"] = true;
user[key] = true;
        
      
      
      Here, the variable key may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = prompt("What do you want to know about the user?", "name");

// access by variable
alert( user[key] ); // John (if enter "name")
        
      
      
      The dot notation cannot be used in a similar way:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
        
      
      
      Computed propertiesWe can use square brackets in an object literal, when creating an object. That’s called computed properties.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");

let bag = {
  [fruit]: 5, // the name of the property is taken from the variable fruit
};

alert( bag.apple ); // 5 if fruit="apple"
        
      
      
      The meaning of a computed property is simple: [fruit] means that the property name should be taken from fruit.
So, if a visitor enters "apple", bag will become {apple: 5}.
Essentially, that works the same as:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// take property name from the fruit variable
bag[fruit] = 5;
        
      
      
      …But looks nicer.
We can use more complex expressions inside square brackets:

      
        
        
          let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
        
      
      
      Square brackets are much more powerful than dot notation. They allow any property names and variables. But they are also more cumbersome to write.
So most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.
Property value shorthandIn real code, we often use existing variables as values for property names.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...other properties
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
        
      
      
      In the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there’s a special property value shorthand to make it shorter.
Instead of name:name we can just write name, like this:

      
        
        
          function makeUser(name, age) {
  return {
    name, // same as name: name
    age,  // same as age: age
    // ...
  };
}
        
      
      
      We can use both normal properties and shorthands in the same object:

      
        
        
          let user = {
  name,  // same as name:name
  age: 30
};
        
      
      
      Property names limitationsAs we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction:

      
        
        
          
            
          
          
            
          
        
        
          // these properties are all right
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
        
      
      
      In short, there are no limitations on property names. They can be any strings or symbols (a special type for identifiers, to be covered later).
Other types are automatically converted to strings.
For instance, a number 0 becomes a string "0" when used as a property key:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  0: "test" // same as "0": "test"
};

// both alerts access the same property (the number 0 is converted to string "0")
alert( obj["0"] ); // test
alert( obj[0] ); // test (same property)
        
      
      
      There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};
obj.__proto__ = 5; // assign a number
alert(obj.__proto__); // [object Object] - the value is an object, didn't work as intended
        
      
      
      As we see from the code, the assignment to a primitive 5 is ignored.
We’ll cover the special nature of __proto__ in subsequent chapters, and suggest the ways to fix such behavior.
Property existence test, “in” operatorA notable feature of objects in JavaScript, compared to many other languages, is that it’s possible to access any property. There will be no error if the property doesn’t exist!
Reading a non-existing property just returns undefined. So we can easily test whether the property exists:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

alert( user.noSuchProperty === undefined ); // true means "no such property"
        
      
      
      There’s also a special operator "in" for that.
The syntax is:

      
        
        
          "key" in object
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); // false, user.blabla doesn't exist
        
      
      
      Please note that on the left side of in there must be a property name. That’s usually a quoted string.
If we omit quotes, that means a variable should contain the actual name to be tested. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { age: 30 };

let key = "age";
alert( key in user ); // true, property "age" exists
        
      
      
      Why does the in operator exist? Isn’t it enough to compare against undefined?
Well, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but "in" works correctly.
It’s when an object property exists, but stores undefined:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  test: undefined
};

alert( obj.test ); // it's undefined, so - no such property?

alert( "test" in obj ); // true, the property does exist!
        
      
      
      In the code above, the property obj.test technically exists. So the in operator works right.
Situations like this happen very rarely, because undefined should not be explicitly assigned. We mostly use null for “unknown” or “empty” values. So the in operator is an exotic guest in the code.
The "for..in" loopTo walk over all keys of an object, there exists a special form of the loop: for..in. This is a completely different thing from the for(;;) construct that we studied before.
The syntax:

      
        
        
          for (key in object) {
  // executes the body for each key among object properties
}
        
      
      
      For instance, let’s output all properties of user:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // values for the keys
  alert( user[key] ); // John, 30, true
}
        
      
      
      Note that all “for” constructs allow us to declare the looping variable inside the loop, like let key here.
Also, we could use another variable name here instead of key. For instance, "for (let prop in obj)" is also widely used.
Ordered like an objectAre objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?
The short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.
As an example, let’s consider an object with the phone codes:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "49": "Germany",
  "41": "Switzerland",
  "44": "Great Britain",
  // ..,
  "1": "USA"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
        
      
      
      The object may be used to suggest a list of options to the user. If we’re making a site mainly for a German audience then we probably want 49 to be the first.
But if we run the code, we see a totally different picture:

USA (1) goes first
then Switzerland (41) and so on.

The phone codes go in the ascending sorted order, because they are integers. So we see 1, 41, 44, 49.

            Integer properties? What’s that?
            The “integer property” term here means a string that can be converted to-and-from an integer without a change.
So, "49" is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. But "+49" and "1.2" are not:

      
        
        
          
            
          
          
            
          
        
        
          // Number(...) explicitly converts to a number
// Math.trunc is a built-in function that removes the decimal part
alert( String(Math.trunc(Number("49"))) ); // "49", same, integer property
alert( String(Math.trunc(Number("+49"))) ); // "49", not same "+49" ⇒ not integer property
alert( String(Math.trunc(Number("1.2"))) ); // "1", not same "1.2" ⇒ not integer property
        
      
      
      
…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // add one more

// non-integer properties are listed in the creation order
for (let prop in user) {
  alert( prop ); // name, surname, age
}
        
      
      
      So, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. Adding a plus "+" sign before each code is enough.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "+49": "Germany",
  "+41": "Switzerland",
  "+44": "Great Britain",
  // ..,
  "+1": "USA"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
        
      
      
      Now it works as intended.
SummaryObjects are associative arrays with several special features.
They store properties (key-value pairs), where:

Property keys must be strings or symbols (usually strings).
Values can be of any type.

To access a property, we can use:

The dot notation: obj.property.
Square brackets notation obj["property"]. Square brackets allow taking the key from a variable, like obj[varWithKey].

Additional operators:

To delete a property: delete obj.prop.
To check if a property with the given key exists: "key" in obj.
To iterate over an object: for (let key in obj) loop.

What we’ve studied in this chapter is called a “plain object”, or just Object.
There are many other kinds of objects in JavaScript:

Array to store ordered data collections,
Date to store the information about the date and time,
Error to store the information about an error.
…And so on.

They have their special features that we’ll study later. Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. And they extend it in various ways.
Objects in JavaScript are very powerful. Here we’ve just scratched the surface of a topic that is really huge. We’ll be closely working with objects and learning more about them in further parts of the tutorial.\n\nTutorialThe JavaScript languageObjects: the basicsJune 19, 2022ObjectsAs we know from the chapter Data types, there are eight data types in JavaScript. Seven of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).
In contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.
An object can be created with figure brackets {…} with an optional list of properties. A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.
We can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It’s easy to find a file by its name or add/remove a file.

      
      
        
      
      An empty object (“empty cabinet”) can be created using one of two syntaxes:

      
        
        
          let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax
        
      
      
      
      
      
        
      
      Usually, the figure brackets {...} are used. That declaration is called an object literal.
Literals and propertiesWe can immediately put some properties into {...} as “key: value” pairs:

      
        
        
          let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};
        
      
      
      A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.
In the user object, there are two properties:

The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.

The resulting user object can be imagined as a cabinet with two signed files labeled “name” and “age”.

      
      
        
      
      We can add, remove and read files from it at any time.
Property values are accessible using the dot notation:

      
        
        
          // get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30
        
      
      
      The value can be of any type. Let’s add a boolean one:

      
        
        
          user.isAdmin = true;
        
      
      
      
      
      
        
      
      To remove a property, we can use the delete operator:

      
        
        
          delete user.age;
        
      
      
      
      
      
        
      
      We can also use multiword property names, but then they must be quoted:

      
        
        
          let user = {
  name: "John",
  age: 30,
  "likes birds": true  // multiword property name must be quoted
};
        
      
      
      
      
      
        
      
      The last property in the list may end with a comma:

      
        
        
          let user = {
  name: "John",
  age: 30,
}
        
      
      
      That is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.
Square bracketsFor multiword properties, the dot access doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          // this would give a syntax error
user.likes birds = true
        
      
      
      JavaScript doesn’t understand that. It thinks that we address user.likes, and then gives a syntax error when comes across unexpected birds.
The dot requires the key to be a valid variable identifier. That implies: contains no spaces, doesn’t start with a digit and doesn’t include special characters ($ and _ are allowed).
There’s an alternative “square bracket notation” that works with any string:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
        
      
      
      Now everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).
Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:

      
        
        
          let key = "likes birds";

// same as user["likes birds"] = true;
user[key] = true;
        
      
      
      Here, the variable key may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = prompt("What do you want to know about the user?", "name");

// access by variable
alert( user[key] ); // John (if enter "name")
        
      
      
      The dot notation cannot be used in a similar way:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
        
      
      
      Computed propertiesWe can use square brackets in an object literal, when creating an object. That’s called computed properties.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");

let bag = {
  [fruit]: 5, // the name of the property is taken from the variable fruit
};

alert( bag.apple ); // 5 if fruit="apple"
        
      
      
      The meaning of a computed property is simple: [fruit] means that the property name should be taken from fruit.
So, if a visitor enters "apple", bag will become {apple: 5}.
Essentially, that works the same as:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// take property name from the fruit variable
bag[fruit] = 5;
        
      
      
      …But looks nicer.
We can use more complex expressions inside square brackets:

      
        
        
          let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
        
      
      
      Square brackets are much more powerful than dot notation. They allow any property names and variables. But they are also more cumbersome to write.
So most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.
Property value shorthandIn real code, we often use existing variables as values for property names.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...other properties
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
        
      
      
      In the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there’s a special property value shorthand to make it shorter.
Instead of name:name we can just write name, like this:

      
        
        
          function makeUser(name, age) {
  return {
    name, // same as name: name
    age,  // same as age: age
    // ...
  };
}
        
      
      
      We can use both normal properties and shorthands in the same object:

      
        
        
          let user = {
  name,  // same as name:name
  age: 30
};
        
      
      
      Property names limitationsAs we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction:

      
        
        
          
            
          
          
            
          
        
        
          // these properties are all right
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
        
      
      
      In short, there are no limitations on property names. They can be any strings or symbols (a special type for identifiers, to be covered later).
Other types are automatically converted to strings.
For instance, a number 0 becomes a string "0" when used as a property key:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  0: "test" // same as "0": "test"
};

// both alerts access the same property (the number 0 is converted to string "0")
alert( obj["0"] ); // test
alert( obj[0] ); // test (same property)
        
      
      
      There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};
obj.__proto__ = 5; // assign a number
alert(obj.__proto__); // [object Object] - the value is an object, didn't work as intended
        
      
      
      As we see from the code, the assignment to a primitive 5 is ignored.
We’ll cover the special nature of __proto__ in subsequent chapters, and suggest the ways to fix such behavior.
Property existence test, “in” operatorA notable feature of objects in JavaScript, compared to many other languages, is that it’s possible to access any property. There will be no error if the property doesn’t exist!
Reading a non-existing property just returns undefined. So we can easily test whether the property exists:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

alert( user.noSuchProperty === undefined ); // true means "no such property"
        
      
      
      There’s also a special operator "in" for that.
The syntax is:

      
        
        
          "key" in object
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); // false, user.blabla doesn't exist
        
      
      
      Please note that on the left side of in there must be a property name. That’s usually a quoted string.
If we omit quotes, that means a variable should contain the actual name to be tested. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { age: 30 };

let key = "age";
alert( key in user ); // true, property "age" exists
        
      
      
      Why does the in operator exist? Isn’t it enough to compare against undefined?
Well, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but "in" works correctly.
It’s when an object property exists, but stores undefined:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  test: undefined
};

alert( obj.test ); // it's undefined, so - no such property?

alert( "test" in obj ); // true, the property does exist!
        
      
      
      In the code above, the property obj.test technically exists. So the in operator works right.
Situations like this happen very rarely, because undefined should not be explicitly assigned. We mostly use null for “unknown” or “empty” values. So the in operator is an exotic guest in the code.
The "for..in" loopTo walk over all keys of an object, there exists a special form of the loop: for..in. This is a completely different thing from the for(;;) construct that we studied before.
The syntax:

      
        
        
          for (key in object) {
  // executes the body for each key among object properties
}
        
      
      
      For instance, let’s output all properties of user:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // values for the keys
  alert( user[key] ); // John, 30, true
}
        
      
      
      Note that all “for” constructs allow us to declare the looping variable inside the loop, like let key here.
Also, we could use another variable name here instead of key. For instance, "for (let prop in obj)" is also widely used.
Ordered like an objectAre objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?
The short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.
As an example, let’s consider an object with the phone codes:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "49": "Germany",
  "41": "Switzerland",
  "44": "Great Britain",
  // ..,
  "1": "USA"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
        
      
      
      The object may be used to suggest a list of options to the user. If we’re making a site mainly for a German audience then we probably want 49 to be the first.
But if we run the code, we see a totally different picture:

USA (1) goes first
then Switzerland (41) and so on.

The phone codes go in the ascending sorted order, because they are integers. So we see 1, 41, 44, 49.

            Integer properties? What’s that?
            The “integer property” term here means a string that can be converted to-and-from an integer without a change.
So, "49" is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. But "+49" and "1.2" are not:

      
        
        
          
            
          
          
            
          
        
        
          // Number(...) explicitly converts to a number
// Math.trunc is a built-in function that removes the decimal part
alert( String(Math.trunc(Number("49"))) ); // "49", same, integer property
alert( String(Math.trunc(Number("+49"))) ); // "49", not same "+49" ⇒ not integer property
alert( String(Math.trunc(Number("1.2"))) ); // "1", not same "1.2" ⇒ not integer property
        
      
      
      
…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // add one more

// non-integer properties are listed in the creation order
for (let prop in user) {
  alert( prop ); // name, surname, age
}
        
      
      
      So, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. Adding a plus "+" sign before each code is enough.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "+49": "Germany",
  "+41": "Switzerland",
  "+44": "Great Britain",
  // ..,
  "+1": "USA"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
        
      
      
      Now it works as intended.
SummaryObjects are associative arrays with several special features.
They store properties (key-value pairs), where:

Property keys must be strings or symbols (usually strings).
Values can be of any type.

To access a property, we can use:

The dot notation: obj.property.
Square brackets notation obj["property"]. Square brackets allow taking the key from a variable, like obj[varWithKey].

Additional operators:

To delete a property: delete obj.prop.
To check if a property with the given key exists: "key" in obj.
To iterate over an object: for (let key in obj) loop.

What we’ve studied in this chapter is called a “plain object”, or just Object.
There are many other kinds of objects in JavaScript:

Array to store ordered data collections,
Date to store the information about the date and time,
Error to store the information about an error.
…And so on.

They have their special features that we’ll study later. Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. And they extend it in various ways.
Objects in JavaScript are very powerful. Here we’ve just scratched the surface of a topic that is really huge. We’ll be closely working with objects and learning more about them in further parts of the tutorial.
TasksHello, objectimportance: 5Write the code, one line for each action:

Create an empty object user.
Add the property name with the value John.
Add the property surname with the value Smith.
Change the value of the name to Pete.
Remove the property name from the object.

solution
      
        
        
          let user = {};
user.name = "John";
user.surname = "Smith";
user.name = "Pete";
delete user.name;
        
      
      
      Check for emptinessimportance: 5Write the function isEmpty(obj) which returns true if the object has no properties, false otherwise.
Should work like that:

      
        
        
          let schedule = {};

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "get up";

alert( isEmpty(schedule) ); // false
        
      
      
      Open a sandbox with tests.solutionJust loop over the object and return false immediately if there’s at least one property.

      
        
        
          function isEmpty(obj) {
  for (let key in obj) {
    // if the loop has started, there is a property
    return false;
  }
  return true;
}
        
      
      
      Open the solution with tests in a sandbox.Sum object propertiesimportance: 5We have an object storing salaries of our team:

      
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}
        
      
      
      Write the code to sum all salaries and store in the variable sum. Should be 390 in the example above.
If salaries is empty, then the result must be 0.
solution
      
        
        
          
            
          
          
            
          
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
};

let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}

alert(sum); // 390
        
      
      
      Multiply numeric property values by 2importance: 3Create a function multiplyNumeric(obj) that multiplies all numeric property values of obj by 2.
For instance:

      
        
        
          // before the call
let menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

multiplyNumeric(menu);

// after the call
menu = {
  width: 400,
  height: 600,
  title: "My menu"
};
        
      
      
      Please note that multiplyNumeric does not need to return anything. It should modify the object in-place.
P.S. Use typeof to check for a number here.
Open a sandbox with tests.solution
      
        
        
          function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2;
    }
  }
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nAs we know from the chapter Data types, there are eight data types in JavaScript. Seven of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).
In contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.
An object can be created with figure brackets {…} with an optional list of properties. A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.
We can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It’s easy to find a file by its name or add/remove a file.

      
      
        
      
      An empty object (“empty cabinet”) can be created using one of two syntaxes:

      
        
        
          let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax
        
      
      
      
      
      
        
      
      Usually, the figure brackets {...} are used. That declaration is called an object literal.
Literals and propertiesWe can immediately put some properties into {...} as “key: value” pairs:

      
        
        
          let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};
        
      
      
      A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.
In the user object, there are two properties:

The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.

The resulting user object can be imagined as a cabinet with two signed files labeled “name” and “age”.

      
      
        
      
      We can add, remove and read files from it at any time.
Property values are accessible using the dot notation:

      
        
        
          // get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30
        
      
      
      The value can be of any type. Let’s add a boolean one:

      
        
        
          user.isAdmin = true;
        
      
      
      
      
      
        
      
      To remove a property, we can use the delete operator:

      
        
        
          delete user.age;
        
      
      
      
      
      
        
      
      We can also use multiword property names, but then they must be quoted:

      
        
        
          let user = {
  name: "John",
  age: 30,
  "likes birds": true  // multiword property name must be quoted
};
        
      
      
      
      
      
        
      
      The last property in the list may end with a comma:

      
        
        
          let user = {
  name: "John",
  age: 30,
}
        
      
      
      That is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.
Square bracketsFor multiword properties, the dot access doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          // this would give a syntax error
user.likes birds = true
        
      
      
      JavaScript doesn’t understand that. It thinks that we address user.likes, and then gives a syntax error when comes across unexpected birds.
The dot requires the key to be a valid variable identifier. That implies: contains no spaces, doesn’t start with a digit and doesn’t include special characters ($ and _ are allowed).
There’s an alternative “square bracket notation” that works with any string:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
        
      
      
      Now everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).
Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:

      
        
        
          let key = "likes birds";

// same as user["likes birds"] = true;
user[key] = true;
        
      
      
      Here, the variable key may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = prompt("What do you want to know about the user?", "name");

// access by variable
alert( user[key] ); // John (if enter "name")
        
      
      
      The dot notation cannot be used in a similar way:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
        
      
      
      Computed propertiesWe can use square brackets in an object literal, when creating an object. That’s called computed properties.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");

let bag = {
  [fruit]: 5, // the name of the property is taken from the variable fruit
};

alert( bag.apple ); // 5 if fruit="apple"
        
      
      
      The meaning of a computed property is simple: [fruit] means that the property name should be taken from fruit.
So, if a visitor enters "apple", bag will become {apple: 5}.
Essentially, that works the same as:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// take property name from the fruit variable
bag[fruit] = 5;
        
      
      
      …But looks nicer.
We can use more complex expressions inside square brackets:

      
        
        
          let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
        
      
      
      Square brackets are much more powerful than dot notation. They allow any property names and variables. But they are also more cumbersome to write.
So most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.
Property value shorthandIn real code, we often use existing variables as values for property names.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...other properties
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
        
      
      
      In the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there’s a special property value shorthand to make it shorter.
Instead of name:name we can just write name, like this:

      
        
        
          function makeUser(name, age) {
  return {
    name, // same as name: name
    age,  // same as age: age
    // ...
  };
}
        
      
      
      We can use both normal properties and shorthands in the same object:

      
        
        
          let user = {
  name,  // same as name:name
  age: 30
};
        
      
      
      Property names limitationsAs we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction:

      
        
        
          
            
          
          
            
          
        
        
          // these properties are all right
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
        
      
      
      In short, there are no limitations on property names. They can be any strings or symbols (a special type for identifiers, to be covered later).
Other types are automatically converted to strings.
For instance, a number 0 becomes a string "0" when used as a property key:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  0: "test" // same as "0": "test"
};

// both alerts access the same property (the number 0 is converted to string "0")
alert( obj["0"] ); // test
alert( obj[0] ); // test (same property)
        
      
      
      There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};
obj.__proto__ = 5; // assign a number
alert(obj.__proto__); // [object Object] - the value is an object, didn't work as intended
        
      
      
      As we see from the code, the assignment to a primitive 5 is ignored.
We’ll cover the special nature of __proto__ in subsequent chapters, and suggest the ways to fix such behavior.
Property existence test, “in” operatorA notable feature of objects in JavaScript, compared to many other languages, is that it’s possible to access any property. There will be no error if the property doesn’t exist!
Reading a non-existing property just returns undefined. So we can easily test whether the property exists:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

alert( user.noSuchProperty === undefined ); // true means "no such property"
        
      
      
      There’s also a special operator "in" for that.
The syntax is:

      
        
        
          "key" in object
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); // false, user.blabla doesn't exist
        
      
      
      Please note that on the left side of in there must be a property name. That’s usually a quoted string.
If we omit quotes, that means a variable should contain the actual name to be tested. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { age: 30 };

let key = "age";
alert( key in user ); // true, property "age" exists
        
      
      
      Why does the in operator exist? Isn’t it enough to compare against undefined?
Well, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but "in" works correctly.
It’s when an object property exists, but stores undefined:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  test: undefined
};

alert( obj.test ); // it's undefined, so - no such property?

alert( "test" in obj ); // true, the property does exist!
        
      
      
      In the code above, the property obj.test technically exists. So the in operator works right.
Situations like this happen very rarely, because undefined should not be explicitly assigned. We mostly use null for “unknown” or “empty” values. So the in operator is an exotic guest in the code.
The "for..in" loopTo walk over all keys of an object, there exists a special form of the loop: for..in. This is a completely different thing from the for(;;) construct that we studied before.
The syntax:

      
        
        
          for (key in object) {
  // executes the body for each key among object properties
}
        
      
      
      For instance, let’s output all properties of user:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // values for the keys
  alert( user[key] ); // John, 30, true
}
        
      
      
      Note that all “for” constructs allow us to declare the looping variable inside the loop, like let key here.
Also, we could use another variable name here instead of key. For instance, "for (let prop in obj)" is also widely used.
Ordered like an objectAre objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?
The short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.
As an example, let’s consider an object with the phone codes:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "49": "Germany",
  "41": "Switzerland",
  "44": "Great Britain",
  // ..,
  "1": "USA"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
        
      
      
      The object may be used to suggest a list of options to the user. If we’re making a site mainly for a German audience then we probably want 49 to be the first.
But if we run the code, we see a totally different picture:

USA (1) goes first
then Switzerland (41) and so on.

The phone codes go in the ascending sorted order, because they are integers. So we see 1, 41, 44, 49.

            Integer properties? What’s that?
            The “integer property” term here means a string that can be converted to-and-from an integer without a change.
So, "49" is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. But "+49" and "1.2" are not:

      
        
        
          
            
          
          
            
          
        
        
          // Number(...) explicitly converts to a number
// Math.trunc is a built-in function that removes the decimal part
alert( String(Math.trunc(Number("49"))) ); // "49", same, integer property
alert( String(Math.trunc(Number("+49"))) ); // "49", not same "+49" ⇒ not integer property
alert( String(Math.trunc(Number("1.2"))) ); // "1", not same "1.2" ⇒ not integer property
        
      
      
      
…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // add one more

// non-integer properties are listed in the creation order
for (let prop in user) {
  alert( prop ); // name, surname, age
}
        
      
      
      So, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. Adding a plus "+" sign before each code is enough.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "+49": "Germany",
  "+41": "Switzerland",
  "+44": "Great Britain",
  // ..,
  "+1": "USA"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
        
      
      
      Now it works as intended.
SummaryObjects are associative arrays with several special features.
They store properties (key-value pairs), where:

Property keys must be strings or symbols (usually strings).
Values can be of any type.

To access a property, we can use:

The dot notation: obj.property.
Square brackets notation obj["property"]. Square brackets allow taking the key from a variable, like obj[varWithKey].

Additional operators:

To delete a property: delete obj.prop.
To check if a property with the given key exists: "key" in obj.
To iterate over an object: for (let key in obj) loop.

What we’ve studied in this chapter is called a “plain object”, or just Object.
There are many other kinds of objects in JavaScript:

Array to store ordered data collections,
Date to store the information about the date and time,
Error to store the information about an error.
…And so on.

They have their special features that we’ll study later. Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. And they extend it in various ways.
Objects in JavaScript are very powerful. Here we’ve just scratched the surface of a topic that is really huge. We’ll be closely working with objects and learning more about them in further parts of the tutorial.
TasksHello, objectimportance: 5Write the code, one line for each action:

Create an empty object user.
Add the property name with the value John.
Add the property surname with the value Smith.
Change the value of the name to Pete.
Remove the property name from the object.

solution
      
        
        
          let user = {};
user.name = "John";
user.surname = "Smith";
user.name = "Pete";
delete user.name;
        
      
      
      Check for emptinessimportance: 5Write the function isEmpty(obj) which returns true if the object has no properties, false otherwise.
Should work like that:

      
        
        
          let schedule = {};

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "get up";

alert( isEmpty(schedule) ); // false
        
      
      
      Open a sandbox with tests.solutionJust loop over the object and return false immediately if there’s at least one property.

      
        
        
          function isEmpty(obj) {
  for (let key in obj) {
    // if the loop has started, there is a property
    return false;
  }
  return true;
}
        
      
      
      Open the solution with tests in a sandbox.Sum object propertiesimportance: 5We have an object storing salaries of our team:

      
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}
        
      
      
      Write the code to sum all salaries and store in the variable sum. Should be 390 in the example above.
If salaries is empty, then the result must be 0.
solution
      
        
        
          
            
          
          
            
          
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
};

let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}

alert(sum); // 390
        
      
      
      Multiply numeric property values by 2importance: 3Create a function multiplyNumeric(obj) that multiplies all numeric property values of obj by 2.
For instance:

      
        
        
          // before the call
let menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

multiplyNumeric(menu);

// after the call
menu = {
  width: 400,
  height: 600,
  title: "My menu"
};
        
      
      
      Please note that multiplyNumeric does not need to return anything. It should modify the object in-place.
P.S. Use typeof to check for a number here.
Open a sandbox with tests.solution
      
        
        
          function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2;
    }
  }
}
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageObjects: the basicsJune 19, 2022ObjectsAs we know from the chapter Data types, there are eight data types in JavaScript. Seven of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).
In contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.
An object can be created with figure brackets {…} with an optional list of properties. A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.
We can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It’s easy to find a file by its name or add/remove a file.

      
      
        
      
      An empty object (“empty cabinet”) can be created using one of two syntaxes:

      
        
        
          let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax
        
      
      
      
      
      
        
      
      Usually, the figure brackets {...} are used. That declaration is called an object literal.
Literals and propertiesWe can immediately put some properties into {...} as “key: value” pairs:

      
        
        
          let user = {     // an object
  name: "John",  // by key "name" store value "John"
  age: 30        // by key "age" store value 30
};
        
      
      
      A property has a key (also known as “name” or “identifier”) before the colon ":" and a value to the right of it.
In the user object, there are two properties:

The first property has the name "name" and the value "John".
The second one has the name "age" and the value 30.

The resulting user object can be imagined as a cabinet with two signed files labeled “name” and “age”.

      
      
        
      
      We can add, remove and read files from it at any time.
Property values are accessible using the dot notation:

      
        
        
          // get property values of the object:
alert( user.name ); // John
alert( user.age ); // 30
        
      
      
      The value can be of any type. Let’s add a boolean one:

      
        
        
          user.isAdmin = true;
        
      
      
      
      
      
        
      
      To remove a property, we can use the delete operator:

      
        
        
          delete user.age;
        
      
      
      
      
      
        
      
      We can also use multiword property names, but then they must be quoted:

      
        
        
          let user = {
  name: "John",
  age: 30,
  "likes birds": true  // multiword property name must be quoted
};
        
      
      
      
      
      
        
      
      The last property in the list may end with a comma:

      
        
        
          let user = {
  name: "John",
  age: 30,
}
        
      
      
      That is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.
Square bracketsFor multiword properties, the dot access doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          // this would give a syntax error
user.likes birds = true
        
      
      
      JavaScript doesn’t understand that. It thinks that we address user.likes, and then gives a syntax error when comes across unexpected birds.
The dot requires the key to be a valid variable identifier. That implies: contains no spaces, doesn’t start with a digit and doesn’t include special characters ($ and _ are allowed).
There’s an alternative “square bracket notation” that works with any string:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
        
      
      
      Now everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).
Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:

      
        
        
          let key = "likes birds";

// same as user["likes birds"] = true;
user[key] = true;
        
      
      
      Here, the variable key may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = prompt("What do you want to know about the user?", "name");

// access by variable
alert( user[key] ); // John (if enter "name")
        
      
      
      The dot notation cannot be used in a similar way:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
        
      
      
      Computed propertiesWe can use square brackets in an object literal, when creating an object. That’s called computed properties.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");

let bag = {
  [fruit]: 5, // the name of the property is taken from the variable fruit
};

alert( bag.apple ); // 5 if fruit="apple"
        
      
      
      The meaning of a computed property is simple: [fruit] means that the property name should be taken from fruit.
So, if a visitor enters "apple", bag will become {apple: 5}.
Essentially, that works the same as:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// take property name from the fruit variable
bag[fruit] = 5;
        
      
      
      …But looks nicer.
We can use more complex expressions inside square brackets:

      
        
        
          let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
        
      
      
      Square brackets are much more powerful than dot notation. They allow any property names and variables. But they are also more cumbersome to write.
So most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.
Property value shorthandIn real code, we often use existing variables as values for property names.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...other properties
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
        
      
      
      In the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there’s a special property value shorthand to make it shorter.
Instead of name:name we can just write name, like this:

      
        
        
          function makeUser(name, age) {
  return {
    name, // same as name: name
    age,  // same as age: age
    // ...
  };
}
        
      
      
      We can use both normal properties and shorthands in the same object:

      
        
        
          let user = {
  name,  // same as name:name
  age: 30
};
        
      
      
      Property names limitationsAs we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.
But for an object property, there’s no such restriction:

      
        
        
          
            
          
          
            
          
        
        
          // these properties are all right
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
        
      
      
      In short, there are no limitations on property names. They can be any strings or symbols (a special type for identifiers, to be covered later).
Other types are automatically converted to strings.
For instance, a number 0 becomes a string "0" when used as a property key:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  0: "test" // same as "0": "test"
};

// both alerts access the same property (the number 0 is converted to string "0")
alert( obj["0"] ); // test
alert( obj[0] ); // test (same property)
        
      
      
      There’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};
obj.__proto__ = 5; // assign a number
alert(obj.__proto__); // [object Object] - the value is an object, didn't work as intended
        
      
      
      As we see from the code, the assignment to a primitive 5 is ignored.
We’ll cover the special nature of __proto__ in subsequent chapters, and suggest the ways to fix such behavior.
Property existence test, “in” operatorA notable feature of objects in JavaScript, compared to many other languages, is that it’s possible to access any property. There will be no error if the property doesn’t exist!
Reading a non-existing property just returns undefined. So we can easily test whether the property exists:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

alert( user.noSuchProperty === undefined ); // true means "no such property"
        
      
      
      There’s also a special operator "in" for that.
The syntax is:

      
        
        
          "key" in object
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age exists
alert( "blabla" in user ); // false, user.blabla doesn't exist
        
      
      
      Please note that on the left side of in there must be a property name. That’s usually a quoted string.
If we omit quotes, that means a variable should contain the actual name to be tested. For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = { age: 30 };

let key = "age";
alert( key in user ); // true, property "age" exists
        
      
      
      Why does the in operator exist? Isn’t it enough to compare against undefined?
Well, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but "in" works correctly.
It’s when an object property exists, but stores undefined:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  test: undefined
};

alert( obj.test ); // it's undefined, so - no such property?

alert( "test" in obj ); // true, the property does exist!
        
      
      
      In the code above, the property obj.test technically exists. So the in operator works right.
Situations like this happen very rarely, because undefined should not be explicitly assigned. We mostly use null for “unknown” or “empty” values. So the in operator is an exotic guest in the code.
The "for..in" loopTo walk over all keys of an object, there exists a special form of the loop: for..in. This is a completely different thing from the for(;;) construct that we studied before.
The syntax:

      
        
        
          for (key in object) {
  // executes the body for each key among object properties
}
        
      
      
      For instance, let’s output all properties of user:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // values for the keys
  alert( user[key] ); // John, 30, true
}
        
      
      
      Note that all “for” constructs allow us to declare the looping variable inside the loop, like let key here.
Also, we could use another variable name here instead of key. For instance, "for (let prop in obj)" is also widely used.
Ordered like an objectAre objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?
The short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.
As an example, let’s consider an object with the phone codes:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "49": "Germany",
  "41": "Switzerland",
  "44": "Great Britain",
  // ..,
  "1": "USA"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
        
      
      
      The object may be used to suggest a list of options to the user. If we’re making a site mainly for a German audience then we probably want 49 to be the first.
But if we run the code, we see a totally different picture:

USA (1) goes first
then Switzerland (41) and so on.

The phone codes go in the ascending sorted order, because they are integers. So we see 1, 41, 44, 49.

            Integer properties? What’s that?
            The “integer property” term here means a string that can be converted to-and-from an integer without a change.
So, "49" is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. But "+49" and "1.2" are not:

      
        
        
          
            
          
          
            
          
        
        
          // Number(...) explicitly converts to a number
// Math.trunc is a built-in function that removes the decimal part
alert( String(Math.trunc(Number("49"))) ); // "49", same, integer property
alert( String(Math.trunc(Number("+49"))) ); // "49", not same "+49" ⇒ not integer property
alert( String(Math.trunc(Number("1.2"))) ); // "1", not same "1.2" ⇒ not integer property
        
      
      
      
…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // add one more

// non-integer properties are listed in the creation order
for (let prop in user) {
  alert( prop ); // name, surname, age
}
        
      
      
      So, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. Adding a plus "+" sign before each code is enough.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "+49": "Germany",
  "+41": "Switzerland",
  "+44": "Great Britain",
  // ..,
  "+1": "USA"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
        
      
      
      Now it works as intended.
SummaryObjects are associative arrays with several special features.
They store properties (key-value pairs), where:

Property keys must be strings or symbols (usually strings).
Values can be of any type.

To access a property, we can use:

The dot notation: obj.property.
Square brackets notation obj["property"]. Square brackets allow taking the key from a variable, like obj[varWithKey].

Additional operators:

To delete a property: delete obj.prop.
To check if a property with the given key exists: "key" in obj.
To iterate over an object: for (let key in obj) loop.

What we’ve studied in this chapter is called a “plain object”, or just Object.
There are many other kinds of objects in JavaScript:

Array to store ordered data collections,
Date to store the information about the date and time,
Error to store the information about an error.
…And so on.

They have their special features that we’ll study later. Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. And they extend it in various ways.
Objects in JavaScript are very powerful. Here we’ve just scratched the surface of a topic that is really huge. We’ll be closely working with objects and learning more about them in further parts of the tutorial.
TasksHello, objectimportance: 5Write the code, one line for each action:

Create an empty object user.
Add the property name with the value John.
Add the property surname with the value Smith.
Change the value of the name to Pete.
Remove the property name from the object.

solution
      
        
        
          let user = {};
user.name = "John";
user.surname = "Smith";
user.name = "Pete";
delete user.name;
        
      
      
      Check for emptinessimportance: 5Write the function isEmpty(obj) which returns true if the object has no properties, false otherwise.
Should work like that:

      
        
        
          let schedule = {};

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "get up";

alert( isEmpty(schedule) ); // false
        
      
      
      Open a sandbox with tests.solutionJust loop over the object and return false immediately if there’s at least one property.

      
        
        
          function isEmpty(obj) {
  for (let key in obj) {
    // if the loop has started, there is a property
    return false;
  }
  return true;
}
        
      
      
      Open the solution with tests in a sandbox.Sum object propertiesimportance: 5We have an object storing salaries of our team:

      
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}
        
      
      
      Write the code to sum all salaries and store in the variable sum. Should be 390 in the example above.
If salaries is empty, then the result must be 0.
solution
      
        
        
          
            
          
          
            
          
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
};

let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}

alert(sum); // 390
        
      
      
      Multiply numeric property values by 2importance: 3Create a function multiplyNumeric(obj) that multiplies all numeric property values of obj by 2.
For instance:

      
        
        
          // before the call
let menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

multiplyNumeric(menu);

// after the call
menu = {
  width: 400,
  height: 600,
  title: "My menu"
};
        
      
      
      Please note that multiplyNumeric does not need to return anything. It should modify the object in-place.
P.S. Use typeof to check for a number here.
Open a sandbox with tests.solution
      
        
        
          function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2;
    }
  }
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nOne of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.
That’s easy to understand if we look a bit under the hood of what happens when we copy a value.
Let’s start with a primitive, such as a string.
Here we put a copy of message into phrase:

      
        
        
          let message = "Hello!";
let phrase = message;
        
      
      
      As a result we have two independent variables, each one storing the string "Hello!".

      
      
        
      
      Quite an obvious result, right?
Objects are not like that.
A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.
Let’s look at an example of such a variable:

      
        
        
          let user = {
  name: "John"
};
        
      
      
      And here’s how it’s actually stored in memory:

      
      
        
      
      The object is stored somewhere in memory (at the right of the picture), while the user variable (at the left) has a “reference” to it.
We may think of an object variable, such as user, like a sheet of paper with the address of the object on it.
When we perform actions with the object, e.g. take a property user.name, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.
Now here’s why it’s important.
When an object variable is copied, the reference is copied, but the object itself is not duplicated.
For instance:

      
        
        
          let user = { name: "John" };

let admin = user; // copy the reference
        
      
      
      Now we have two variables, each storing a reference to the same object:

      
      
        
      
      As you can see, there’s still one object, but now with two variables that reference it.
We can use either variable to access the object and modify its contents:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // changed by the "admin" reference

alert(user.name); // 'Pete', changes are seen from the "user" reference
        
      
      
      It’s as if we had a cabinet with two keys and used one of them (admin) to get into it and make changes. Then, if we later use another key (user), we are still opening the same cabinet and can access the changed contents.
Comparison by referenceTwo objects are equal only if they are the same object.
For instance, here a and b reference the same object, thus they are equal:

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = a; // copy the reference

alert( a == b ); // true, both variables reference the same object
alert( a === b ); // true
        
      
      
      And here two independent objects are not equal, even though they look alike (both are empty):

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = {}; // two independent objects

alert( a == b ); // false
        
      
      
      For comparisons like obj1 > obj2 or for a comparison against a primitive obj == 5, objects are converted to primitives. We’ll study how object conversions work very soon, but to tell the truth, such comparisons are needed very rarely – usually they appear as a result of a programming mistake.

            Const objects can be modified
            An important side effect of storing objects as references is that an object declared as const can be modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
        
      
      
      It might seem that the line (*) would cause an error, but it does not. The value of user is constant, it must always reference the same object, but properties of that object are free to change.
In other words, the const user gives an error only if we try to set user=... as a whole.
That said, if we really need to make constant object properties, it’s also possible, but using totally different methods. We’ll mention that in the chapter Property flags and descriptors.

Cloning and merging, Object.assignSo, copying an object variable creates one more reference to the same object.
But what if we need to duplicate an object?
We can create a new object and replicate the structure of the existing one, by iterating over its properties and copying them on the primitive level.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = {}; // the new empty object

// let's copy all user properties into it
for (let key in user) {
  clone[key] = user[key];
}

// now clone is a fully independent object with the same content
clone.name = "Pete"; // changed the data in it

alert( user.name ); // still John in the original object
        
      
      
      We can also use the method Object.assign.
The syntax is:

      
        
        
          Object.assign(dest, ...sources)
        
      
      
      
The first argument dest is a target object.
Further arguments is a list of source objects.

It copies the properties of all source objects into the target dest, and then returns it as the result.
For example, we have user object, let’s add a couple of permissions to it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// copies all properties from permissions1 and permissions2 into user
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
alert(user.name); // John
alert(user.canView); // true
alert(user.canEdit); // true
        
      
      
      If the copied property name already exists, it gets overwritten:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // now user = { name: "Pete" }
        
      
      
      We also can use Object.assign to perform a simple object cloning:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

alert(clone.name); // John
alert(clone.age); // 30
        
      
      
      Here it copies all properties of user into the empty object and returns it.
There are also other methods of cloning an object, e.g. using the spread syntax clone = {...user}, covered later in the tutorial.
Nested cloningUntil now we assumed that all properties of user are primitive. But properties can be references to other objects.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
        
      
      
      Now it’s not enough to copy clone.sizes = user.sizes, because user.sizes is an object, and will be copied by reference, so clone and user will share the same sizes:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, same object

// user and clone share sizes
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 60, get the result from the other one
        
      
      
      To fix that and make user and clone truly separate objects, we should use a cloning loop that examines each value of user[key] and, if it’s an object, then replicate its structure as well. That is called a “deep cloning” or “structured cloning”. There’s structuredClone method that implements deep cloning.
structuredCloneThe call structuredClone(object) clones the object with all nested properties.
Here’s how we can use it in our example:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = structuredClone(user);

alert( user.sizes === clone.sizes ); // false, different objects

// user and clone are totally unrelated now
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 50, not related
        
      
      
      The structuredClone method can clone most data types, such as objects, arrays, primitive values.
It also supports circular references, when an object property references the object itself (directly or via a chain or references).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
// let's create a circular reference:
// user.me references the user itself
user.me = user;

let clone = structuredClone(user);
alert(clone.me === clone); // true
        
      
      
      As you can see, clone.me references the clone, not the user! So the circular reference was cloned correctly as well.
Although, there are cases when structuredClone fails.
For instance, when an object has a function property:

      
        
        
          
            
          
          
            
          
        
        
          // error
structuredClone({
  f: function() {}
});
        
      
      
      Function properties aren’t supported.
To handle such complex cases we may need to use a combination of cloning methods, write custom code or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.
SummaryObjects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.
All operations via copied references (like adding/removing properties) are performed on the same single object.
To make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function structuredClone or use a custom cloning implementation, such as _.cloneDeep(obj).\n\nTutorialThe JavaScript languageObjects: the basicsOctober 1, 2022Object references and copyingOne of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.
That’s easy to understand if we look a bit under the hood of what happens when we copy a value.
Let’s start with a primitive, such as a string.
Here we put a copy of message into phrase:

      
        
        
          let message = "Hello!";
let phrase = message;
        
      
      
      As a result we have two independent variables, each one storing the string "Hello!".

      
      
        
      
      Quite an obvious result, right?
Objects are not like that.
A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.
Let’s look at an example of such a variable:

      
        
        
          let user = {
  name: "John"
};
        
      
      
      And here’s how it’s actually stored in memory:

      
      
        
      
      The object is stored somewhere in memory (at the right of the picture), while the user variable (at the left) has a “reference” to it.
We may think of an object variable, such as user, like a sheet of paper with the address of the object on it.
When we perform actions with the object, e.g. take a property user.name, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.
Now here’s why it’s important.
When an object variable is copied, the reference is copied, but the object itself is not duplicated.
For instance:

      
        
        
          let user = { name: "John" };

let admin = user; // copy the reference
        
      
      
      Now we have two variables, each storing a reference to the same object:

      
      
        
      
      As you can see, there’s still one object, but now with two variables that reference it.
We can use either variable to access the object and modify its contents:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // changed by the "admin" reference

alert(user.name); // 'Pete', changes are seen from the "user" reference
        
      
      
      It’s as if we had a cabinet with two keys and used one of them (admin) to get into it and make changes. Then, if we later use another key (user), we are still opening the same cabinet and can access the changed contents.
Comparison by referenceTwo objects are equal only if they are the same object.
For instance, here a and b reference the same object, thus they are equal:

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = a; // copy the reference

alert( a == b ); // true, both variables reference the same object
alert( a === b ); // true
        
      
      
      And here two independent objects are not equal, even though they look alike (both are empty):

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = {}; // two independent objects

alert( a == b ); // false
        
      
      
      For comparisons like obj1 > obj2 or for a comparison against a primitive obj == 5, objects are converted to primitives. We’ll study how object conversions work very soon, but to tell the truth, such comparisons are needed very rarely – usually they appear as a result of a programming mistake.

            Const objects can be modified
            An important side effect of storing objects as references is that an object declared as const can be modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
        
      
      
      It might seem that the line (*) would cause an error, but it does not. The value of user is constant, it must always reference the same object, but properties of that object are free to change.
In other words, the const user gives an error only if we try to set user=... as a whole.
That said, if we really need to make constant object properties, it’s also possible, but using totally different methods. We’ll mention that in the chapter Property flags and descriptors.

Cloning and merging, Object.assignSo, copying an object variable creates one more reference to the same object.
But what if we need to duplicate an object?
We can create a new object and replicate the structure of the existing one, by iterating over its properties and copying them on the primitive level.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = {}; // the new empty object

// let's copy all user properties into it
for (let key in user) {
  clone[key] = user[key];
}

// now clone is a fully independent object with the same content
clone.name = "Pete"; // changed the data in it

alert( user.name ); // still John in the original object
        
      
      
      We can also use the method Object.assign.
The syntax is:

      
        
        
          Object.assign(dest, ...sources)
        
      
      
      
The first argument dest is a target object.
Further arguments is a list of source objects.

It copies the properties of all source objects into the target dest, and then returns it as the result.
For example, we have user object, let’s add a couple of permissions to it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// copies all properties from permissions1 and permissions2 into user
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
alert(user.name); // John
alert(user.canView); // true
alert(user.canEdit); // true
        
      
      
      If the copied property name already exists, it gets overwritten:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // now user = { name: "Pete" }
        
      
      
      We also can use Object.assign to perform a simple object cloning:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

alert(clone.name); // John
alert(clone.age); // 30
        
      
      
      Here it copies all properties of user into the empty object and returns it.
There are also other methods of cloning an object, e.g. using the spread syntax clone = {...user}, covered later in the tutorial.
Nested cloningUntil now we assumed that all properties of user are primitive. But properties can be references to other objects.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
        
      
      
      Now it’s not enough to copy clone.sizes = user.sizes, because user.sizes is an object, and will be copied by reference, so clone and user will share the same sizes:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, same object

// user and clone share sizes
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 60, get the result from the other one
        
      
      
      To fix that and make user and clone truly separate objects, we should use a cloning loop that examines each value of user[key] and, if it’s an object, then replicate its structure as well. That is called a “deep cloning” or “structured cloning”. There’s structuredClone method that implements deep cloning.
structuredCloneThe call structuredClone(object) clones the object with all nested properties.
Here’s how we can use it in our example:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = structuredClone(user);

alert( user.sizes === clone.sizes ); // false, different objects

// user and clone are totally unrelated now
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 50, not related
        
      
      
      The structuredClone method can clone most data types, such as objects, arrays, primitive values.
It also supports circular references, when an object property references the object itself (directly or via a chain or references).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
// let's create a circular reference:
// user.me references the user itself
user.me = user;

let clone = structuredClone(user);
alert(clone.me === clone); // true
        
      
      
      As you can see, clone.me references the clone, not the user! So the circular reference was cloned correctly as well.
Although, there are cases when structuredClone fails.
For instance, when an object has a function property:

      
        
        
          
            
          
          
            
          
        
        
          // error
structuredClone({
  f: function() {}
});
        
      
      
      Function properties aren’t supported.
To handle such complex cases we may need to use a combination of cloning methods, write custom code or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.
SummaryObjects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.
All operations via copied references (like adding/removing properties) are performed on the same single object.
To make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function structuredClone or use a custom cloning implementation, such as _.cloneDeep(obj).
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nOne of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.
That’s easy to understand if we look a bit under the hood of what happens when we copy a value.
Let’s start with a primitive, such as a string.
Here we put a copy of message into phrase:

      
        
        
          let message = "Hello!";
let phrase = message;
        
      
      
      As a result we have two independent variables, each one storing the string "Hello!".

      
      
        
      
      Quite an obvious result, right?
Objects are not like that.
A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.
Let’s look at an example of such a variable:

      
        
        
          let user = {
  name: "John"
};
        
      
      
      And here’s how it’s actually stored in memory:

      
      
        
      
      The object is stored somewhere in memory (at the right of the picture), while the user variable (at the left) has a “reference” to it.
We may think of an object variable, such as user, like a sheet of paper with the address of the object on it.
When we perform actions with the object, e.g. take a property user.name, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.
Now here’s why it’s important.
When an object variable is copied, the reference is copied, but the object itself is not duplicated.
For instance:

      
        
        
          let user = { name: "John" };

let admin = user; // copy the reference
        
      
      
      Now we have two variables, each storing a reference to the same object:

      
      
        
      
      As you can see, there’s still one object, but now with two variables that reference it.
We can use either variable to access the object and modify its contents:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // changed by the "admin" reference

alert(user.name); // 'Pete', changes are seen from the "user" reference
        
      
      
      It’s as if we had a cabinet with two keys and used one of them (admin) to get into it and make changes. Then, if we later use another key (user), we are still opening the same cabinet and can access the changed contents.
Comparison by referenceTwo objects are equal only if they are the same object.
For instance, here a and b reference the same object, thus they are equal:

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = a; // copy the reference

alert( a == b ); // true, both variables reference the same object
alert( a === b ); // true
        
      
      
      And here two independent objects are not equal, even though they look alike (both are empty):

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = {}; // two independent objects

alert( a == b ); // false
        
      
      
      For comparisons like obj1 > obj2 or for a comparison against a primitive obj == 5, objects are converted to primitives. We’ll study how object conversions work very soon, but to tell the truth, such comparisons are needed very rarely – usually they appear as a result of a programming mistake.

            Const objects can be modified
            An important side effect of storing objects as references is that an object declared as const can be modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
        
      
      
      It might seem that the line (*) would cause an error, but it does not. The value of user is constant, it must always reference the same object, but properties of that object are free to change.
In other words, the const user gives an error only if we try to set user=... as a whole.
That said, if we really need to make constant object properties, it’s also possible, but using totally different methods. We’ll mention that in the chapter Property flags and descriptors.

Cloning and merging, Object.assignSo, copying an object variable creates one more reference to the same object.
But what if we need to duplicate an object?
We can create a new object and replicate the structure of the existing one, by iterating over its properties and copying them on the primitive level.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = {}; // the new empty object

// let's copy all user properties into it
for (let key in user) {
  clone[key] = user[key];
}

// now clone is a fully independent object with the same content
clone.name = "Pete"; // changed the data in it

alert( user.name ); // still John in the original object
        
      
      
      We can also use the method Object.assign.
The syntax is:

      
        
        
          Object.assign(dest, ...sources)
        
      
      
      
The first argument dest is a target object.
Further arguments is a list of source objects.

It copies the properties of all source objects into the target dest, and then returns it as the result.
For example, we have user object, let’s add a couple of permissions to it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// copies all properties from permissions1 and permissions2 into user
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
alert(user.name); // John
alert(user.canView); // true
alert(user.canEdit); // true
        
      
      
      If the copied property name already exists, it gets overwritten:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // now user = { name: "Pete" }
        
      
      
      We also can use Object.assign to perform a simple object cloning:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

alert(clone.name); // John
alert(clone.age); // 30
        
      
      
      Here it copies all properties of user into the empty object and returns it.
There are also other methods of cloning an object, e.g. using the spread syntax clone = {...user}, covered later in the tutorial.
Nested cloningUntil now we assumed that all properties of user are primitive. But properties can be references to other objects.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
        
      
      
      Now it’s not enough to copy clone.sizes = user.sizes, because user.sizes is an object, and will be copied by reference, so clone and user will share the same sizes:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, same object

// user and clone share sizes
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 60, get the result from the other one
        
      
      
      To fix that and make user and clone truly separate objects, we should use a cloning loop that examines each value of user[key] and, if it’s an object, then replicate its structure as well. That is called a “deep cloning” or “structured cloning”. There’s structuredClone method that implements deep cloning.
structuredCloneThe call structuredClone(object) clones the object with all nested properties.
Here’s how we can use it in our example:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = structuredClone(user);

alert( user.sizes === clone.sizes ); // false, different objects

// user and clone are totally unrelated now
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 50, not related
        
      
      
      The structuredClone method can clone most data types, such as objects, arrays, primitive values.
It also supports circular references, when an object property references the object itself (directly or via a chain or references).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
// let's create a circular reference:
// user.me references the user itself
user.me = user;

let clone = structuredClone(user);
alert(clone.me === clone); // true
        
      
      
      As you can see, clone.me references the clone, not the user! So the circular reference was cloned correctly as well.
Although, there are cases when structuredClone fails.
For instance, when an object has a function property:

      
        
        
          
            
          
          
            
          
        
        
          // error
structuredClone({
  f: function() {}
});
        
      
      
      Function properties aren’t supported.
To handle such complex cases we may need to use a combination of cloning methods, write custom code or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.
SummaryObjects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.
All operations via copied references (like adding/removing properties) are performed on the same single object.
To make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function structuredClone or use a custom cloning implementation, such as _.cloneDeep(obj).\n\nTutorialThe JavaScript languageObjects: the basicsOctober 1, 2022Object references and copyingOne of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.
That’s easy to understand if we look a bit under the hood of what happens when we copy a value.
Let’s start with a primitive, such as a string.
Here we put a copy of message into phrase:

      
        
        
          let message = "Hello!";
let phrase = message;
        
      
      
      As a result we have two independent variables, each one storing the string "Hello!".

      
      
        
      
      Quite an obvious result, right?
Objects are not like that.
A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.
Let’s look at an example of such a variable:

      
        
        
          let user = {
  name: "John"
};
        
      
      
      And here’s how it’s actually stored in memory:

      
      
        
      
      The object is stored somewhere in memory (at the right of the picture), while the user variable (at the left) has a “reference” to it.
We may think of an object variable, such as user, like a sheet of paper with the address of the object on it.
When we perform actions with the object, e.g. take a property user.name, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.
Now here’s why it’s important.
When an object variable is copied, the reference is copied, but the object itself is not duplicated.
For instance:

      
        
        
          let user = { name: "John" };

let admin = user; // copy the reference
        
      
      
      Now we have two variables, each storing a reference to the same object:

      
      
        
      
      As you can see, there’s still one object, but now with two variables that reference it.
We can use either variable to access the object and modify its contents:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // changed by the "admin" reference

alert(user.name); // 'Pete', changes are seen from the "user" reference
        
      
      
      It’s as if we had a cabinet with two keys and used one of them (admin) to get into it and make changes. Then, if we later use another key (user), we are still opening the same cabinet and can access the changed contents.
Comparison by referenceTwo objects are equal only if they are the same object.
For instance, here a and b reference the same object, thus they are equal:

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = a; // copy the reference

alert( a == b ); // true, both variables reference the same object
alert( a === b ); // true
        
      
      
      And here two independent objects are not equal, even though they look alike (both are empty):

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = {}; // two independent objects

alert( a == b ); // false
        
      
      
      For comparisons like obj1 > obj2 or for a comparison against a primitive obj == 5, objects are converted to primitives. We’ll study how object conversions work very soon, but to tell the truth, such comparisons are needed very rarely – usually they appear as a result of a programming mistake.

            Const objects can be modified
            An important side effect of storing objects as references is that an object declared as const can be modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
        
      
      
      It might seem that the line (*) would cause an error, but it does not. The value of user is constant, it must always reference the same object, but properties of that object are free to change.
In other words, the const user gives an error only if we try to set user=... as a whole.
That said, if we really need to make constant object properties, it’s also possible, but using totally different methods. We’ll mention that in the chapter Property flags and descriptors.

Cloning and merging, Object.assignSo, copying an object variable creates one more reference to the same object.
But what if we need to duplicate an object?
We can create a new object and replicate the structure of the existing one, by iterating over its properties and copying them on the primitive level.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = {}; // the new empty object

// let's copy all user properties into it
for (let key in user) {
  clone[key] = user[key];
}

// now clone is a fully independent object with the same content
clone.name = "Pete"; // changed the data in it

alert( user.name ); // still John in the original object
        
      
      
      We can also use the method Object.assign.
The syntax is:

      
        
        
          Object.assign(dest, ...sources)
        
      
      
      
The first argument dest is a target object.
Further arguments is a list of source objects.

It copies the properties of all source objects into the target dest, and then returns it as the result.
For example, we have user object, let’s add a couple of permissions to it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// copies all properties from permissions1 and permissions2 into user
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
alert(user.name); // John
alert(user.canView); // true
alert(user.canEdit); // true
        
      
      
      If the copied property name already exists, it gets overwritten:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // now user = { name: "Pete" }
        
      
      
      We also can use Object.assign to perform a simple object cloning:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

alert(clone.name); // John
alert(clone.age); // 30
        
      
      
      Here it copies all properties of user into the empty object and returns it.
There are also other methods of cloning an object, e.g. using the spread syntax clone = {...user}, covered later in the tutorial.
Nested cloningUntil now we assumed that all properties of user are primitive. But properties can be references to other objects.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
        
      
      
      Now it’s not enough to copy clone.sizes = user.sizes, because user.sizes is an object, and will be copied by reference, so clone and user will share the same sizes:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, same object

// user and clone share sizes
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 60, get the result from the other one
        
      
      
      To fix that and make user and clone truly separate objects, we should use a cloning loop that examines each value of user[key] and, if it’s an object, then replicate its structure as well. That is called a “deep cloning” or “structured cloning”. There’s structuredClone method that implements deep cloning.
structuredCloneThe call structuredClone(object) clones the object with all nested properties.
Here’s how we can use it in our example:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = structuredClone(user);

alert( user.sizes === clone.sizes ); // false, different objects

// user and clone are totally unrelated now
user.sizes.width = 60;    // change a property from one place
alert(clone.sizes.width); // 50, not related
        
      
      
      The structuredClone method can clone most data types, such as objects, arrays, primitive values.
It also supports circular references, when an object property references the object itself (directly or via a chain or references).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
// let's create a circular reference:
// user.me references the user itself
user.me = user;

let clone = structuredClone(user);
alert(clone.me === clone); // true
        
      
      
      As you can see, clone.me references the clone, not the user! So the circular reference was cloned correctly as well.
Although, there are cases when structuredClone fails.
For instance, when an object has a function property:

      
        
        
          
            
          
          
            
          
        
        
          // error
structuredClone({
  f: function() {}
});
        
      
      
      Function properties aren’t supported.
To handle such complex cases we may need to use a combination of cloning methods, write custom code or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.
SummaryObjects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.
All operations via copied references (like adding/removing properties) are performed on the same single object.
To make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function structuredClone or use a custom cloning implementation, such as _.cloneDeep(obj).
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nMemory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions… All that takes memory.
What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?
ReachabilityThe main concept of memory management in JavaScript is reachability.
Simply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.


There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.
For instance:

The currently executing function, its local variables and parameters.
Other functions on the current chain of nested calls, their local variables and parameters.
Global variables.
(there are some other, internal ones as well)

These values are called roots.


Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.
For instance, if there’s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.


There’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.
A simple exampleHere’s the simplest example:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};
        
      
      
      
      
      
        
      
      Here the arrow depicts an object reference. The global variable "user" references the object {name: "John"} (we’ll call it John for brevity). The "name" property of John stores a primitive, so it’s painted inside the object.
If the value of user is overwritten, the reference is lost:

      
        
        
          user = null;
        
      
      
      
      
      
        
      
      Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.
Two referencesNow let’s imagine we copied the reference from user to admin:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};

let admin = user;
        
      
      
      
      
      
        
      
      Now if we do the same:

      
        
        
          user = null;
        
      
      
      …Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.
Interlinked objectsNow a more complex example. The family:

      
        
        
          function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
        
      
      
      Function marry “marries” two objects by giving them references to each other and returns a new object that contains them both.
The resulting memory structure:

      
      
        
      
      As of now, all objects are reachable.
Now let’s remove two references:

      
        
        
          delete family.father;
delete family.mother.husband;
        
      
      
      
      
      
        
      
      It’s not enough to delete only one of these two references, because all objects would still be reachable.
But if we delete both, then we can see that John has no incoming reference any more:

      
      
        
      
      Outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.
After garbage collection:

      
      
        
      
      Unreachable islandIt is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.
The source object is the same as above. Then:

      
        
        
          family = null;
        
      
      
      The in-memory picture becomes:

      
      
        
      
      This example demonstrates how important the concept of reachability is.
It’s obvious that John and Ann are still linked, both have incoming references. But that’s not enough.
The former "family" object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.
Internal algorithmsThe basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:

The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

For instance, let our object structure look like this:

      
      
        
      
      We can clearly see an “unreachable island” to the right side. Now let’s see how “mark-and-sweep” garbage collector deals with it.
The first step marks the roots:

      
      
        
      
      Then we follow their references and mark referenced objects:

      
      
        
      
      …And continue to follow further references, while possible:

      
      
        
      
      Now the objects that could not be visited in the process are considered unreachable and will be removed:

      
      
        
      
      We can also imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. The unmarked ones are then removed.
That’s the concept of how garbage collection works. JavaScript engines apply many optimizations to make it run faster and not introduce any delays into the code execution.
Some of the optimizations:

Generational collection – objects are split into two sets: “new ones” and “old ones”. In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case. Those that survive for long enough, become “old” and are examined less often.
Incremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.
Idle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.

There exist other optimizations and flavours of garbage collection algorithms. As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what’s even more important, things change as engines develop, so studying deeper “in advance”, without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.
SummaryThe main things to know:

Garbage collection is performed automatically. We cannot force or prevent it.
Objects are retained in memory while they are reachable.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.

Modern engines implement advanced algorithms of garbage collection.
A general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) covers some of them.
If you are familiar with low-level programming, more detailed information about V8’s garbage collector is in the article A tour of V8: Garbage Collection.
The V8 blog also publishes articles about changes in memory management from time to time. Naturally, to learn more about garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of Vyacheslav Egorov who worked as one of the V8 engineers. I’m saying: “V8”, because it is best covered by articles on the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.
In-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you’re familiar with the language.\n\nTutorialThe JavaScript languageObjects: the basicsOctober 14, 2022Garbage collectionMemory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions… All that takes memory.
What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?
ReachabilityThe main concept of memory management in JavaScript is reachability.
Simply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.


There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.
For instance:

The currently executing function, its local variables and parameters.
Other functions on the current chain of nested calls, their local variables and parameters.
Global variables.
(there are some other, internal ones as well)

These values are called roots.


Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.
For instance, if there’s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.


There’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.
A simple exampleHere’s the simplest example:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};
        
      
      
      
      
      
        
      
      Here the arrow depicts an object reference. The global variable "user" references the object {name: "John"} (we’ll call it John for brevity). The "name" property of John stores a primitive, so it’s painted inside the object.
If the value of user is overwritten, the reference is lost:

      
        
        
          user = null;
        
      
      
      
      
      
        
      
      Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.
Two referencesNow let’s imagine we copied the reference from user to admin:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};

let admin = user;
        
      
      
      
      
      
        
      
      Now if we do the same:

      
        
        
          user = null;
        
      
      
      …Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.
Interlinked objectsNow a more complex example. The family:

      
        
        
          function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
        
      
      
      Function marry “marries” two objects by giving them references to each other and returns a new object that contains them both.
The resulting memory structure:

      
      
        
      
      As of now, all objects are reachable.
Now let’s remove two references:

      
        
        
          delete family.father;
delete family.mother.husband;
        
      
      
      
      
      
        
      
      It’s not enough to delete only one of these two references, because all objects would still be reachable.
But if we delete both, then we can see that John has no incoming reference any more:

      
      
        
      
      Outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.
After garbage collection:

      
      
        
      
      Unreachable islandIt is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.
The source object is the same as above. Then:

      
        
        
          family = null;
        
      
      
      The in-memory picture becomes:

      
      
        
      
      This example demonstrates how important the concept of reachability is.
It’s obvious that John and Ann are still linked, both have incoming references. But that’s not enough.
The former "family" object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.
Internal algorithmsThe basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:

The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

For instance, let our object structure look like this:

      
      
        
      
      We can clearly see an “unreachable island” to the right side. Now let’s see how “mark-and-sweep” garbage collector deals with it.
The first step marks the roots:

      
      
        
      
      Then we follow their references and mark referenced objects:

      
      
        
      
      …And continue to follow further references, while possible:

      
      
        
      
      Now the objects that could not be visited in the process are considered unreachable and will be removed:

      
      
        
      
      We can also imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. The unmarked ones are then removed.
That’s the concept of how garbage collection works. JavaScript engines apply many optimizations to make it run faster and not introduce any delays into the code execution.
Some of the optimizations:

Generational collection – objects are split into two sets: “new ones” and “old ones”. In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case. Those that survive for long enough, become “old” and are examined less often.
Incremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.
Idle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.

There exist other optimizations and flavours of garbage collection algorithms. As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what’s even more important, things change as engines develop, so studying deeper “in advance”, without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.
SummaryThe main things to know:

Garbage collection is performed automatically. We cannot force or prevent it.
Objects are retained in memory while they are reachable.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.

Modern engines implement advanced algorithms of garbage collection.
A general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) covers some of them.
If you are familiar with low-level programming, more detailed information about V8’s garbage collector is in the article A tour of V8: Garbage Collection.
The V8 blog also publishes articles about changes in memory management from time to time. Naturally, to learn more about garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of Vyacheslav Egorov who worked as one of the V8 engineers. I’m saying: “V8”, because it is best covered by articles on the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.
In-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you’re familiar with the language.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nMemory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions… All that takes memory.
What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?
ReachabilityThe main concept of memory management in JavaScript is reachability.
Simply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.


There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.
For instance:

The currently executing function, its local variables and parameters.
Other functions on the current chain of nested calls, their local variables and parameters.
Global variables.
(there are some other, internal ones as well)

These values are called roots.


Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.
For instance, if there’s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.


There’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.
A simple exampleHere’s the simplest example:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};
        
      
      
      
      
      
        
      
      Here the arrow depicts an object reference. The global variable "user" references the object {name: "John"} (we’ll call it John for brevity). The "name" property of John stores a primitive, so it’s painted inside the object.
If the value of user is overwritten, the reference is lost:

      
        
        
          user = null;
        
      
      
      
      
      
        
      
      Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.
Two referencesNow let’s imagine we copied the reference from user to admin:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};

let admin = user;
        
      
      
      
      
      
        
      
      Now if we do the same:

      
        
        
          user = null;
        
      
      
      …Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.
Interlinked objectsNow a more complex example. The family:

      
        
        
          function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
        
      
      
      Function marry “marries” two objects by giving them references to each other and returns a new object that contains them both.
The resulting memory structure:

      
      
        
      
      As of now, all objects are reachable.
Now let’s remove two references:

      
        
        
          delete family.father;
delete family.mother.husband;
        
      
      
      
      
      
        
      
      It’s not enough to delete only one of these two references, because all objects would still be reachable.
But if we delete both, then we can see that John has no incoming reference any more:

      
      
        
      
      Outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.
After garbage collection:

      
      
        
      
      Unreachable islandIt is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.
The source object is the same as above. Then:

      
        
        
          family = null;
        
      
      
      The in-memory picture becomes:

      
      
        
      
      This example demonstrates how important the concept of reachability is.
It’s obvious that John and Ann are still linked, both have incoming references. But that’s not enough.
The former "family" object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.
Internal algorithmsThe basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:

The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

For instance, let our object structure look like this:

      
      
        
      
      We can clearly see an “unreachable island” to the right side. Now let’s see how “mark-and-sweep” garbage collector deals with it.
The first step marks the roots:

      
      
        
      
      Then we follow their references and mark referenced objects:

      
      
        
      
      …And continue to follow further references, while possible:

      
      
        
      
      Now the objects that could not be visited in the process are considered unreachable and will be removed:

      
      
        
      
      We can also imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. The unmarked ones are then removed.
That’s the concept of how garbage collection works. JavaScript engines apply many optimizations to make it run faster and not introduce any delays into the code execution.
Some of the optimizations:

Generational collection – objects are split into two sets: “new ones” and “old ones”. In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case. Those that survive for long enough, become “old” and are examined less often.
Incremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.
Idle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.

There exist other optimizations and flavours of garbage collection algorithms. As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what’s even more important, things change as engines develop, so studying deeper “in advance”, without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.
SummaryThe main things to know:

Garbage collection is performed automatically. We cannot force or prevent it.
Objects are retained in memory while they are reachable.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.

Modern engines implement advanced algorithms of garbage collection.
A general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) covers some of them.
If you are familiar with low-level programming, more detailed information about V8’s garbage collector is in the article A tour of V8: Garbage Collection.
The V8 blog also publishes articles about changes in memory management from time to time. Naturally, to learn more about garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of Vyacheslav Egorov who worked as one of the V8 engineers. I’m saying: “V8”, because it is best covered by articles on the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.
In-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you’re familiar with the language.\n\nTutorialThe JavaScript languageObjects: the basicsOctober 14, 2022Garbage collectionMemory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions… All that takes memory.
What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?
ReachabilityThe main concept of memory management in JavaScript is reachability.
Simply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.


There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.
For instance:

The currently executing function, its local variables and parameters.
Other functions on the current chain of nested calls, their local variables and parameters.
Global variables.
(there are some other, internal ones as well)

These values are called roots.


Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.
For instance, if there’s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.


There’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.
A simple exampleHere’s the simplest example:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};
        
      
      
      
      
      
        
      
      Here the arrow depicts an object reference. The global variable "user" references the object {name: "John"} (we’ll call it John for brevity). The "name" property of John stores a primitive, so it’s painted inside the object.
If the value of user is overwritten, the reference is lost:

      
        
        
          user = null;
        
      
      
      
      
      
        
      
      Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.
Two referencesNow let’s imagine we copied the reference from user to admin:

      
        
        
          // user has a reference to the object
let user = {
  name: "John"
};

let admin = user;
        
      
      
      
      
      
        
      
      Now if we do the same:

      
        
        
          user = null;
        
      
      
      …Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.
Interlinked objectsNow a more complex example. The family:

      
        
        
          function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
        
      
      
      Function marry “marries” two objects by giving them references to each other and returns a new object that contains them both.
The resulting memory structure:

      
      
        
      
      As of now, all objects are reachable.
Now let’s remove two references:

      
        
        
          delete family.father;
delete family.mother.husband;
        
      
      
      
      
      
        
      
      It’s not enough to delete only one of these two references, because all objects would still be reachable.
But if we delete both, then we can see that John has no incoming reference any more:

      
      
        
      
      Outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.
After garbage collection:

      
      
        
      
      Unreachable islandIt is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.
The source object is the same as above. Then:

      
        
        
          family = null;
        
      
      
      The in-memory picture becomes:

      
      
        
      
      This example demonstrates how important the concept of reachability is.
It’s obvious that John and Ann are still linked, both have incoming references. But that’s not enough.
The former "family" object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.
Internal algorithmsThe basic garbage collection algorithm is called “mark-and-sweep”.
The following “garbage collection” steps are regularly performed:

The garbage collector takes roots and “marks” (remembers) them.
Then it visits and “marks” all references from them.
Then it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.
…And so on until every reachable (from the roots) references are visited.
All objects except marked ones are removed.

For instance, let our object structure look like this:

      
      
        
      
      We can clearly see an “unreachable island” to the right side. Now let’s see how “mark-and-sweep” garbage collector deals with it.
The first step marks the roots:

      
      
        
      
      Then we follow their references and mark referenced objects:

      
      
        
      
      …And continue to follow further references, while possible:

      
      
        
      
      Now the objects that could not be visited in the process are considered unreachable and will be removed:

      
      
        
      
      We can also imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. The unmarked ones are then removed.
That’s the concept of how garbage collection works. JavaScript engines apply many optimizations to make it run faster and not introduce any delays into the code execution.
Some of the optimizations:

Generational collection – objects are split into two sets: “new ones” and “old ones”. In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case. Those that survive for long enough, become “old” and are examined less often.
Incremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.
Idle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.

There exist other optimizations and flavours of garbage collection algorithms. As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what’s even more important, things change as engines develop, so studying deeper “in advance”, without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.
SummaryThe main things to know:

Garbage collection is performed automatically. We cannot force or prevent it.
Objects are retained in memory while they are reachable.
Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.

Modern engines implement advanced algorithms of garbage collection.
A general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) covers some of them.
If you are familiar with low-level programming, more detailed information about V8’s garbage collector is in the article A tour of V8: Garbage Collection.
The V8 blog also publishes articles about changes in memory management from time to time. Naturally, to learn more about garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of Vyacheslav Egorov who worked as one of the V8 engineers. I’m saying: “V8”, because it is best covered by articles on the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.
In-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you’re familiar with the language.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nObjects are usually created to represent entities of the real world, like users, orders and so on:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      And, in the real world, a user can act: select something from the shopping cart, login, logout etc.
Actions are represented in JavaScript by functions in properties.
Method examplesFor a start, let’s teach the user to say hello:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Hello!");
};

user.sayHi(); // Hello!
        
      
      
      Here we’ve just used a Function Expression to create a function and assign it to the property user.sayHi of the object.
Then we can call it as user.sayHi(). The user can now speak!
A function that is a property of an object is called its method.
So, here we’ve got a method sayHi of the object user.
Of course, we could use a pre-declared function as a method, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  // ...
};

// first, declare
function sayHi() {
  alert("Hello!");
}

// then add as a method
user.sayHi = sayHi;

user.sayHi(); // Hello!
        
      
      
      
            Object-oriented programming
            When we write our code using objects to represent entities, that’s called object-oriented programming, in short: “OOP”.
OOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch, and more.

Method shorthandThere exists a shorter syntax for methods in an object literal:

      
        
        
          // these objects do the same

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// method shorthand looks better, right?
user = {
  sayHi() { // same as "sayHi: function(){...}"
    alert("Hello");
  }
};
        
      
      
      As demonstrated, we can omit "function" and just write sayHi().
To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.
“this” in methodsIt’s common that an object method needs to access the information stored in the object to do its job.
For instance, the code inside user.sayHi() may need the name of the user.
To access the object, a method can use the this keyword.
The value of this is the object “before dot”, the one used to call the method.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" is the "current object"
    alert(this.name);
  }

};

user.sayHi(); // John
        
      
      
      Here during the execution of user.sayHi(), the value of this will be user.
Technically, it’s also possible to access the object without this, by referencing it via the outer variable:

      
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" instead of "this"
  }

};
        
      
      
      …But such code is unreliable. If we decide to copy user to another variable, e.g. admin = user and overwrite user with something else, then it will access the wrong object.
That’s demonstrated below:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // leads to an error
  }

};


let admin = user;
user = null; // overwrite to make things obvious

admin.sayHi(); // TypeError: Cannot read property 'name' of null
        
      
      
      If we used this.name instead of user.name inside the alert, then the code would work.
“this” is not boundIn JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.
There’s no syntax error in the following example:

      
        
        
          function sayHi() {
  alert( this.name );
}
        
      
      
      The value of this is evaluated during the run-time, depending on the context.
For instance, here the same function is assigned to two different objects and has different “this” in the calls:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// use the same function in two objects
user.f = sayHi;
admin.f = sayHi;

// these calls have different this
// "this" inside the function is the object "before the dot"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (dot or square brackets access the method – doesn't matter)
        
      
      
      The rule is simple: if obj.f() is called, then this is obj during the call of f. So it’s either user or admin in the example above.

            Calling without an object: this == undefined
            We can even call the function without an object at all:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(this);
}

sayHi(); // undefined
        
      
      
      In this case this is undefined in strict mode. If we try to access this.name, there will be an error.
In non-strict mode the value of this in such case will be the global object (window in a browser, we’ll get to it later in the chapter Global object). This is a historical behavior that "use strict" fixes.
Usually such call is a programming error. If there’s this inside a function, it expects to be called in an object context.


            The consequences of unbound this
            If you come from another programming language, then you are probably used to the idea of a “bound this”, where methods defined in an object always have this referencing that object.
In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.
The concept of run-time evaluated this has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.
Here our position is not to judge whether this language design decision is good or bad. We’ll understand how to work with it, how to get benefits and avoid problems.

Arrow functions have no “this”Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.
For instance, here arrow() uses this from the outer user.sayHi() method:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
        
      
      
      That’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate this, but rather to take it from the outer context. Later in the chapter Arrow functions revisited we’ll go more deeply into arrow functions.
Summary
Functions that are stored in object properties are called “methods”.
Methods allow objects to “act” like object.doSomething().
Methods can reference the object as this.

The value of this is defined at run-time.

When a function is declared, it may use this, but that this has no value until the function is called.
A function can be copied between objects.
When a function is called in the “method” syntax: object.method(), the value of this during the call is object.

Please note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.\n\nTutorialThe JavaScript languageObjects: the basicsMay 18, 2024Object methods, "this"Objects are usually created to represent entities of the real world, like users, orders and so on:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      And, in the real world, a user can act: select something from the shopping cart, login, logout etc.
Actions are represented in JavaScript by functions in properties.
Method examplesFor a start, let’s teach the user to say hello:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Hello!");
};

user.sayHi(); // Hello!
        
      
      
      Here we’ve just used a Function Expression to create a function and assign it to the property user.sayHi of the object.
Then we can call it as user.sayHi(). The user can now speak!
A function that is a property of an object is called its method.
So, here we’ve got a method sayHi of the object user.
Of course, we could use a pre-declared function as a method, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  // ...
};

// first, declare
function sayHi() {
  alert("Hello!");
}

// then add as a method
user.sayHi = sayHi;

user.sayHi(); // Hello!
        
      
      
      
            Object-oriented programming
            When we write our code using objects to represent entities, that’s called object-oriented programming, in short: “OOP”.
OOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch, and more.

Method shorthandThere exists a shorter syntax for methods in an object literal:

      
        
        
          // these objects do the same

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// method shorthand looks better, right?
user = {
  sayHi() { // same as "sayHi: function(){...}"
    alert("Hello");
  }
};
        
      
      
      As demonstrated, we can omit "function" and just write sayHi().
To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.
“this” in methodsIt’s common that an object method needs to access the information stored in the object to do its job.
For instance, the code inside user.sayHi() may need the name of the user.
To access the object, a method can use the this keyword.
The value of this is the object “before dot”, the one used to call the method.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" is the "current object"
    alert(this.name);
  }

};

user.sayHi(); // John
        
      
      
      Here during the execution of user.sayHi(), the value of this will be user.
Technically, it’s also possible to access the object without this, by referencing it via the outer variable:

      
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" instead of "this"
  }

};
        
      
      
      …But such code is unreliable. If we decide to copy user to another variable, e.g. admin = user and overwrite user with something else, then it will access the wrong object.
That’s demonstrated below:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // leads to an error
  }

};


let admin = user;
user = null; // overwrite to make things obvious

admin.sayHi(); // TypeError: Cannot read property 'name' of null
        
      
      
      If we used this.name instead of user.name inside the alert, then the code would work.
“this” is not boundIn JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.
There’s no syntax error in the following example:

      
        
        
          function sayHi() {
  alert( this.name );
}
        
      
      
      The value of this is evaluated during the run-time, depending on the context.
For instance, here the same function is assigned to two different objects and has different “this” in the calls:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// use the same function in two objects
user.f = sayHi;
admin.f = sayHi;

// these calls have different this
// "this" inside the function is the object "before the dot"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (dot or square brackets access the method – doesn't matter)
        
      
      
      The rule is simple: if obj.f() is called, then this is obj during the call of f. So it’s either user or admin in the example above.

            Calling without an object: this == undefined
            We can even call the function without an object at all:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(this);
}

sayHi(); // undefined
        
      
      
      In this case this is undefined in strict mode. If we try to access this.name, there will be an error.
In non-strict mode the value of this in such case will be the global object (window in a browser, we’ll get to it later in the chapter Global object). This is a historical behavior that "use strict" fixes.
Usually such call is a programming error. If there’s this inside a function, it expects to be called in an object context.


            The consequences of unbound this
            If you come from another programming language, then you are probably used to the idea of a “bound this”, where methods defined in an object always have this referencing that object.
In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.
The concept of run-time evaluated this has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.
Here our position is not to judge whether this language design decision is good or bad. We’ll understand how to work with it, how to get benefits and avoid problems.

Arrow functions have no “this”Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.
For instance, here arrow() uses this from the outer user.sayHi() method:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
        
      
      
      That’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate this, but rather to take it from the outer context. Later in the chapter Arrow functions revisited we’ll go more deeply into arrow functions.
Summary
Functions that are stored in object properties are called “methods”.
Methods allow objects to “act” like object.doSomething().
Methods can reference the object as this.

The value of this is defined at run-time.

When a function is declared, it may use this, but that this has no value until the function is called.
A function can be copied between objects.
When a function is called in the “method” syntax: object.method(), the value of this during the call is object.

Please note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.
TasksUsing "this" in object literalimportance: 5Here the function makeUser returns an object.
What is the result of accessing its ref? Why?

      
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // What's the result?
        
      
      
      solutionAnswer: an error.
Try it:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
        
      
      
      That’s because rules that set this do not look at object definition. Only the moment of call matters.
Here the value of this inside makeUser() is undefined, because it is called as a function, not as a method with “dot” syntax.
The value of this is one for the whole function, code blocks and object literals do not affect it.
So ref: this actually takes current this of the function.
We can rewrite the function and return the same this with undefined value:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(){
  return this; // this time there's no object literal
}

alert( makeUser().name ); // Error: Cannot read property 'name' of undefined
        
      
      
      As you can see the result of alert( makeUser().name ) is the same as the result of alert( user.ref.name ) from the previous example.
Here’s the opposite case:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();

alert( user.ref().name ); // John
        
      
      
      Now it works, because user.ref() is a method. And the value of this is set to the object before dot ..
Create a calculatorimportance: 5Create an object calculator with three methods:

read() prompts for two values and saves them as object properties with names a and b respectively.
sum() returns the sum of saved values.
mul() multiplies saved values and returns the result.


      
        
        
          let calculator = {
  // ... your code ...
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b;
  },

  read() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Open the solution with tests in a sandbox.Chainingimportance: 2There’s a ladder object that allows you to go up and down:

      
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // shows the current step
    alert( this.step );
  }
};
        
      
      
      Now, if we need to make several calls in sequence, we can do it like this:

      
        
        
          ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
ladder.down();
ladder.showStep(); // 0
        
      
      
      Modify the code of up, down, and showStep to make the calls chainable, like this:

      
        
        
          ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      Such an approach is widely used across JavaScript libraries.
Open a sandbox with tests.solutionThe solution is to return the object itself from every call.

      
        
        
          
            
          
          
            
          
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
};

ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      We also can write a single call per line. For long chains it’s more readable:

      
        
        
          ladder
  .up()
  .up()
  .down()
  .showStep() // 1
  .down()
  .showStep(); // 0
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nObjects are usually created to represent entities of the real world, like users, orders and so on:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      And, in the real world, a user can act: select something from the shopping cart, login, logout etc.
Actions are represented in JavaScript by functions in properties.
Method examplesFor a start, let’s teach the user to say hello:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Hello!");
};

user.sayHi(); // Hello!
        
      
      
      Here we’ve just used a Function Expression to create a function and assign it to the property user.sayHi of the object.
Then we can call it as user.sayHi(). The user can now speak!
A function that is a property of an object is called its method.
So, here we’ve got a method sayHi of the object user.
Of course, we could use a pre-declared function as a method, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  // ...
};

// first, declare
function sayHi() {
  alert("Hello!");
}

// then add as a method
user.sayHi = sayHi;

user.sayHi(); // Hello!
        
      
      
      
            Object-oriented programming
            When we write our code using objects to represent entities, that’s called object-oriented programming, in short: “OOP”.
OOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch, and more.

Method shorthandThere exists a shorter syntax for methods in an object literal:

      
        
        
          // these objects do the same

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// method shorthand looks better, right?
user = {
  sayHi() { // same as "sayHi: function(){...}"
    alert("Hello");
  }
};
        
      
      
      As demonstrated, we can omit "function" and just write sayHi().
To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.
“this” in methodsIt’s common that an object method needs to access the information stored in the object to do its job.
For instance, the code inside user.sayHi() may need the name of the user.
To access the object, a method can use the this keyword.
The value of this is the object “before dot”, the one used to call the method.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" is the "current object"
    alert(this.name);
  }

};

user.sayHi(); // John
        
      
      
      Here during the execution of user.sayHi(), the value of this will be user.
Technically, it’s also possible to access the object without this, by referencing it via the outer variable:

      
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" instead of "this"
  }

};
        
      
      
      …But such code is unreliable. If we decide to copy user to another variable, e.g. admin = user and overwrite user with something else, then it will access the wrong object.
That’s demonstrated below:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // leads to an error
  }

};


let admin = user;
user = null; // overwrite to make things obvious

admin.sayHi(); // TypeError: Cannot read property 'name' of null
        
      
      
      If we used this.name instead of user.name inside the alert, then the code would work.
“this” is not boundIn JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.
There’s no syntax error in the following example:

      
        
        
          function sayHi() {
  alert( this.name );
}
        
      
      
      The value of this is evaluated during the run-time, depending on the context.
For instance, here the same function is assigned to two different objects and has different “this” in the calls:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// use the same function in two objects
user.f = sayHi;
admin.f = sayHi;

// these calls have different this
// "this" inside the function is the object "before the dot"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (dot or square brackets access the method – doesn't matter)
        
      
      
      The rule is simple: if obj.f() is called, then this is obj during the call of f. So it’s either user or admin in the example above.

            Calling without an object: this == undefined
            We can even call the function without an object at all:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(this);
}

sayHi(); // undefined
        
      
      
      In this case this is undefined in strict mode. If we try to access this.name, there will be an error.
In non-strict mode the value of this in such case will be the global object (window in a browser, we’ll get to it later in the chapter Global object). This is a historical behavior that "use strict" fixes.
Usually such call is a programming error. If there’s this inside a function, it expects to be called in an object context.


            The consequences of unbound this
            If you come from another programming language, then you are probably used to the idea of a “bound this”, where methods defined in an object always have this referencing that object.
In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.
The concept of run-time evaluated this has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.
Here our position is not to judge whether this language design decision is good or bad. We’ll understand how to work with it, how to get benefits and avoid problems.

Arrow functions have no “this”Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.
For instance, here arrow() uses this from the outer user.sayHi() method:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
        
      
      
      That’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate this, but rather to take it from the outer context. Later in the chapter Arrow functions revisited we’ll go more deeply into arrow functions.
Summary
Functions that are stored in object properties are called “methods”.
Methods allow objects to “act” like object.doSomething().
Methods can reference the object as this.

The value of this is defined at run-time.

When a function is declared, it may use this, but that this has no value until the function is called.
A function can be copied between objects.
When a function is called in the “method” syntax: object.method(), the value of this during the call is object.

Please note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.
TasksUsing "this" in object literalimportance: 5Here the function makeUser returns an object.
What is the result of accessing its ref? Why?

      
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // What's the result?
        
      
      
      solutionAnswer: an error.
Try it:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
        
      
      
      That’s because rules that set this do not look at object definition. Only the moment of call matters.
Here the value of this inside makeUser() is undefined, because it is called as a function, not as a method with “dot” syntax.
The value of this is one for the whole function, code blocks and object literals do not affect it.
So ref: this actually takes current this of the function.
We can rewrite the function and return the same this with undefined value:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(){
  return this; // this time there's no object literal
}

alert( makeUser().name ); // Error: Cannot read property 'name' of undefined
        
      
      
      As you can see the result of alert( makeUser().name ) is the same as the result of alert( user.ref.name ) from the previous example.
Here’s the opposite case:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();

alert( user.ref().name ); // John
        
      
      
      Now it works, because user.ref() is a method. And the value of this is set to the object before dot ..
Create a calculatorimportance: 5Create an object calculator with three methods:

read() prompts for two values and saves them as object properties with names a and b respectively.
sum() returns the sum of saved values.
mul() multiplies saved values and returns the result.


      
        
        
          let calculator = {
  // ... your code ...
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b;
  },

  read() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Open the solution with tests in a sandbox.Chainingimportance: 2There’s a ladder object that allows you to go up and down:

      
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // shows the current step
    alert( this.step );
  }
};
        
      
      
      Now, if we need to make several calls in sequence, we can do it like this:

      
        
        
          ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
ladder.down();
ladder.showStep(); // 0
        
      
      
      Modify the code of up, down, and showStep to make the calls chainable, like this:

      
        
        
          ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      Such an approach is widely used across JavaScript libraries.
Open a sandbox with tests.solutionThe solution is to return the object itself from every call.

      
        
        
          
            
          
          
            
          
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
};

ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      We also can write a single call per line. For long chains it’s more readable:

      
        
        
          ladder
  .up()
  .up()
  .down()
  .showStep() // 1
  .down()
  .showStep(); // 0
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageObjects: the basicsMay 18, 2024Object methods, "this"Objects are usually created to represent entities of the real world, like users, orders and so on:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      And, in the real world, a user can act: select something from the shopping cart, login, logout etc.
Actions are represented in JavaScript by functions in properties.
Method examplesFor a start, let’s teach the user to say hello:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Hello!");
};

user.sayHi(); // Hello!
        
      
      
      Here we’ve just used a Function Expression to create a function and assign it to the property user.sayHi of the object.
Then we can call it as user.sayHi(). The user can now speak!
A function that is a property of an object is called its method.
So, here we’ve got a method sayHi of the object user.
Of course, we could use a pre-declared function as a method, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  // ...
};

// first, declare
function sayHi() {
  alert("Hello!");
}

// then add as a method
user.sayHi = sayHi;

user.sayHi(); // Hello!
        
      
      
      
            Object-oriented programming
            When we write our code using objects to represent entities, that’s called object-oriented programming, in short: “OOP”.
OOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch, and more.

Method shorthandThere exists a shorter syntax for methods in an object literal:

      
        
        
          // these objects do the same

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// method shorthand looks better, right?
user = {
  sayHi() { // same as "sayHi: function(){...}"
    alert("Hello");
  }
};
        
      
      
      As demonstrated, we can omit "function" and just write sayHi().
To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.
“this” in methodsIt’s common that an object method needs to access the information stored in the object to do its job.
For instance, the code inside user.sayHi() may need the name of the user.
To access the object, a method can use the this keyword.
The value of this is the object “before dot”, the one used to call the method.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" is the "current object"
    alert(this.name);
  }

};

user.sayHi(); // John
        
      
      
      Here during the execution of user.sayHi(), the value of this will be user.
Technically, it’s also possible to access the object without this, by referencing it via the outer variable:

      
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" instead of "this"
  }

};
        
      
      
      …But such code is unreliable. If we decide to copy user to another variable, e.g. admin = user and overwrite user with something else, then it will access the wrong object.
That’s demonstrated below:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // leads to an error
  }

};


let admin = user;
user = null; // overwrite to make things obvious

admin.sayHi(); // TypeError: Cannot read property 'name' of null
        
      
      
      If we used this.name instead of user.name inside the alert, then the code would work.
“this” is not boundIn JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.
There’s no syntax error in the following example:

      
        
        
          function sayHi() {
  alert( this.name );
}
        
      
      
      The value of this is evaluated during the run-time, depending on the context.
For instance, here the same function is assigned to two different objects and has different “this” in the calls:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// use the same function in two objects
user.f = sayHi;
admin.f = sayHi;

// these calls have different this
// "this" inside the function is the object "before the dot"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (dot or square brackets access the method – doesn't matter)
        
      
      
      The rule is simple: if obj.f() is called, then this is obj during the call of f. So it’s either user or admin in the example above.

            Calling without an object: this == undefined
            We can even call the function without an object at all:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(this);
}

sayHi(); // undefined
        
      
      
      In this case this is undefined in strict mode. If we try to access this.name, there will be an error.
In non-strict mode the value of this in such case will be the global object (window in a browser, we’ll get to it later in the chapter Global object). This is a historical behavior that "use strict" fixes.
Usually such call is a programming error. If there’s this inside a function, it expects to be called in an object context.


            The consequences of unbound this
            If you come from another programming language, then you are probably used to the idea of a “bound this”, where methods defined in an object always have this referencing that object.
In JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.
The concept of run-time evaluated this has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.
Here our position is not to judge whether this language design decision is good or bad. We’ll understand how to work with it, how to get benefits and avoid problems.

Arrow functions have no “this”Arrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.
For instance, here arrow() uses this from the outer user.sayHi() method:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
        
      
      
      That’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate this, but rather to take it from the outer context. Later in the chapter Arrow functions revisited we’ll go more deeply into arrow functions.
Summary
Functions that are stored in object properties are called “methods”.
Methods allow objects to “act” like object.doSomething().
Methods can reference the object as this.

The value of this is defined at run-time.

When a function is declared, it may use this, but that this has no value until the function is called.
A function can be copied between objects.
When a function is called in the “method” syntax: object.method(), the value of this during the call is object.

Please note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.
TasksUsing "this" in object literalimportance: 5Here the function makeUser returns an object.
What is the result of accessing its ref? Why?

      
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // What's the result?
        
      
      
      solutionAnswer: an error.
Try it:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
        
      
      
      That’s because rules that set this do not look at object definition. Only the moment of call matters.
Here the value of this inside makeUser() is undefined, because it is called as a function, not as a method with “dot” syntax.
The value of this is one for the whole function, code blocks and object literals do not affect it.
So ref: this actually takes current this of the function.
We can rewrite the function and return the same this with undefined value:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(){
  return this; // this time there's no object literal
}

alert( makeUser().name ); // Error: Cannot read property 'name' of undefined
        
      
      
      As you can see the result of alert( makeUser().name ) is the same as the result of alert( user.ref.name ) from the previous example.
Here’s the opposite case:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();

alert( user.ref().name ); // John
        
      
      
      Now it works, because user.ref() is a method. And the value of this is set to the object before dot ..
Create a calculatorimportance: 5Create an object calculator with three methods:

read() prompts for two values and saves them as object properties with names a and b respectively.
sum() returns the sum of saved values.
mul() multiplies saved values and returns the result.


      
        
        
          let calculator = {
  // ... your code ...
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b;
  },

  read() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Open the solution with tests in a sandbox.Chainingimportance: 2There’s a ladder object that allows you to go up and down:

      
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // shows the current step
    alert( this.step );
  }
};
        
      
      
      Now, if we need to make several calls in sequence, we can do it like this:

      
        
        
          ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
ladder.down();
ladder.showStep(); // 0
        
      
      
      Modify the code of up, down, and showStep to make the calls chainable, like this:

      
        
        
          ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      Such an approach is widely used across JavaScript libraries.
Open a sandbox with tests.solutionThe solution is to return the object itself from every call.

      
        
        
          
            
          
          
            
          
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
};

ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      We also can write a single call per line. For long chains it’s more readable:

      
        
        
          ladder
  .up()
  .up()
  .down()
  .showStep() // 1
  .down()
  .showStep(); // 0
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThe regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.
Constructor functionConstructor functions technically are regular functions. There are two conventions though:

They are named with capital letter first.
They should be executed only with "new" operator.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
        
      
      
      When a function is executed with new, it does the following steps:

A new empty object is created and assigned to this.
The function body executes. Usually it modifies this, adds new properties to it.
The value of this is returned.

In other words, new User(...) does something like:

      
        
        
          function User(name) {
  // this = {};  (implicitly)

  // add properties to this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitly)
}
        
      
      
      So let user = new User("Jack") gives the same result as:

      
        
        
          let user = {
  name: "Jack",
  isAdmin: false
};
        
      
      
      Now if we want to create other users, we can call new User("Ann"), new User("Alice") and so on. Much shorter than using literals every time, and also easy to read.
That’s the main purpose of constructors – to implement reusable object creation code.
Let’s note once again – technically, any function (except arrow functions, as they don’t have this) can be used as a constructor. It can be run with new, and it will execute the algorithm above. The “capital letter first” is a common agreement, to make it clear that a function is to be run with new.

            new function() { … }
            If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:

      
        
        
          // create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
        
      
      
      This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

Constructor mode test: new.target
            Advanced stuff
            The syntax from this section is rarely used, skip it unless you want to know everything.

Inside a function, we can check whether it was called with new or without it, using a special new.target property.
It is undefined for regular calls and equals the function if called with new:

      
        
        
          
            
          
          
            
          
        
        
          function User() {
  alert(new.target);
}

// without "new":
User(); // undefined

// with "new":
new User(); // function User { ... }
        
      
      
      That can be used inside the function to know whether it was called with new, “in constructor mode”, or without it, “in regular mode”.
We can also make both new and regular calls to do the same, like this:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  if (!new.target) { // if you run me without new
    return new User(name); // ...I will add new for you
  }

  this.name = name;
}

let john = User("John"); // redirects call to new User
alert(john.name); // John
        
      
      
      This approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without new, and it still works.
Probably not a good thing to use everywhere though, because omitting new makes it a bit less obvious what’s going on. With new we all know that the new object is being created.
Return from constructorsUsually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:

If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.

In other words, return with an object returns that object, in all other cases this is returned.
For instance, here return overrides this by returning an object:

      
        
        
          
            
          
          
            
          
        
        
          function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- returns this object
}

alert( new BigUser().name );  // Godzilla, got that object
        
      
      
      And here’s an example with an empty return (or we could place a primitive after it, doesn’t matter):

      
        
        
          
            
          
          
            
          
        
        
          function SmallUser() {

  this.name = "John";

  return; // <-- returns this
}

alert( new SmallUser().name );  // John
        
      
      
      Usually constructors don’t have a return statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.

            Omitting parentheses
            By the way, we can omit parentheses after new:

      
        
        
          let user = new User; // <-- no parentheses
// same as
let user = new User();
        
      
      
      Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

Methods in constructorUsing constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.
For instance, new User(name) below creates an object with the given name and the method sayHi:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // My name is: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
        
      
      
      To create complex objects, there’s a more advanced syntax, classes, that we’ll cover later.
Summary
Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.

We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.

            Objects, we’ll be back!
            In this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.
After we learn that, we return to objects and cover them in-depth in the chapters Prototypes, inheritance and Classes.\n\nTutorialThe JavaScript languageObjects: the basicsOctober 1, 2022Constructor, operator "new"The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.
Constructor functionConstructor functions technically are regular functions. There are two conventions though:

They are named with capital letter first.
They should be executed only with "new" operator.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
        
      
      
      When a function is executed with new, it does the following steps:

A new empty object is created and assigned to this.
The function body executes. Usually it modifies this, adds new properties to it.
The value of this is returned.

In other words, new User(...) does something like:

      
        
        
          function User(name) {
  // this = {};  (implicitly)

  // add properties to this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitly)
}
        
      
      
      So let user = new User("Jack") gives the same result as:

      
        
        
          let user = {
  name: "Jack",
  isAdmin: false
};
        
      
      
      Now if we want to create other users, we can call new User("Ann"), new User("Alice") and so on. Much shorter than using literals every time, and also easy to read.
That’s the main purpose of constructors – to implement reusable object creation code.
Let’s note once again – technically, any function (except arrow functions, as they don’t have this) can be used as a constructor. It can be run with new, and it will execute the algorithm above. The “capital letter first” is a common agreement, to make it clear that a function is to be run with new.

            new function() { … }
            If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:

      
        
        
          // create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
        
      
      
      This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

Constructor mode test: new.target
            Advanced stuff
            The syntax from this section is rarely used, skip it unless you want to know everything.

Inside a function, we can check whether it was called with new or without it, using a special new.target property.
It is undefined for regular calls and equals the function if called with new:

      
        
        
          
            
          
          
            
          
        
        
          function User() {
  alert(new.target);
}

// without "new":
User(); // undefined

// with "new":
new User(); // function User { ... }
        
      
      
      That can be used inside the function to know whether it was called with new, “in constructor mode”, or without it, “in regular mode”.
We can also make both new and regular calls to do the same, like this:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  if (!new.target) { // if you run me without new
    return new User(name); // ...I will add new for you
  }

  this.name = name;
}

let john = User("John"); // redirects call to new User
alert(john.name); // John
        
      
      
      This approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without new, and it still works.
Probably not a good thing to use everywhere though, because omitting new makes it a bit less obvious what’s going on. With new we all know that the new object is being created.
Return from constructorsUsually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:

If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.

In other words, return with an object returns that object, in all other cases this is returned.
For instance, here return overrides this by returning an object:

      
        
        
          
            
          
          
            
          
        
        
          function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- returns this object
}

alert( new BigUser().name );  // Godzilla, got that object
        
      
      
      And here’s an example with an empty return (or we could place a primitive after it, doesn’t matter):

      
        
        
          
            
          
          
            
          
        
        
          function SmallUser() {

  this.name = "John";

  return; // <-- returns this
}

alert( new SmallUser().name );  // John
        
      
      
      Usually constructors don’t have a return statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.

            Omitting parentheses
            By the way, we can omit parentheses after new:

      
        
        
          let user = new User; // <-- no parentheses
// same as
let user = new User();
        
      
      
      Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

Methods in constructorUsing constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.
For instance, new User(name) below creates an object with the given name and the method sayHi:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // My name is: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
        
      
      
      To create complex objects, there’s a more advanced syntax, classes, that we’ll cover later.
Summary
Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.

We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.

            Objects, we’ll be back!
            In this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.
After we learn that, we return to objects and cover them in-depth in the chapters Prototypes, inheritance and Classes.

TasksTwo functions – one objectimportance: 2Is it possible to create functions A and B so that new A() == new B()?

      
        
        
          function A() { ... }
function B() { ... }

let a = new A();
let b = new B();

alert( a == b ); // true
        
      
      
      If it is, then provide an example of their code.
solutionYes, it’s possible.
If a function returns an object then new returns it instead of this.
So they can, for instance, return the same externally defined object obj:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

function A() { return obj; }
function B() { return obj; }

alert( new A() == new B() ); // true
        
      
      
      Create new Calculatorimportance: 5Create a constructor function Calculator that creates objects with 3 methods:

read() prompts for two values and saves them as object properties with names a and b respectively.
sum() returns the sum of these properties.
mul() returns the multiplication product of these properties.

For instance:

      
        
        
          let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function Calculator() {

  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };

  this.sum = function() {
    return this.a + this.b;
  };

  this.mul = function() {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Open the solution with tests in a sandbox.Create new Accumulatorimportance: 5Create a constructor function Accumulator(startingValue).
Object that it creates should:

Store the “current value” in the property value. The starting value is set to the argument of the constructor startingValue.
The read() method should use prompt to read a new number and add it to value.

In other words, the value property is the sum of all user-entered values with the initial value  startingValue.
Here’s the demo of the code:

      
        
        
          let accumulator = new Accumulator(1); // initial value 1

accumulator.read(); // adds the user-entered value
accumulator.read(); // adds the user-entered value

alert(accumulator.value); // shows the sum of these values
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('How much to add?', 0);
  };

}

let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value);
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThe regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.
Constructor functionConstructor functions technically are regular functions. There are two conventions though:

They are named with capital letter first.
They should be executed only with "new" operator.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
        
      
      
      When a function is executed with new, it does the following steps:

A new empty object is created and assigned to this.
The function body executes. Usually it modifies this, adds new properties to it.
The value of this is returned.

In other words, new User(...) does something like:

      
        
        
          function User(name) {
  // this = {};  (implicitly)

  // add properties to this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitly)
}
        
      
      
      So let user = new User("Jack") gives the same result as:

      
        
        
          let user = {
  name: "Jack",
  isAdmin: false
};
        
      
      
      Now if we want to create other users, we can call new User("Ann"), new User("Alice") and so on. Much shorter than using literals every time, and also easy to read.
That’s the main purpose of constructors – to implement reusable object creation code.
Let’s note once again – technically, any function (except arrow functions, as they don’t have this) can be used as a constructor. It can be run with new, and it will execute the algorithm above. The “capital letter first” is a common agreement, to make it clear that a function is to be run with new.

            new function() { … }
            If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:

      
        
        
          // create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
        
      
      
      This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

Constructor mode test: new.target
            Advanced stuff
            The syntax from this section is rarely used, skip it unless you want to know everything.

Inside a function, we can check whether it was called with new or without it, using a special new.target property.
It is undefined for regular calls and equals the function if called with new:

      
        
        
          
            
          
          
            
          
        
        
          function User() {
  alert(new.target);
}

// without "new":
User(); // undefined

// with "new":
new User(); // function User { ... }
        
      
      
      That can be used inside the function to know whether it was called with new, “in constructor mode”, or without it, “in regular mode”.
We can also make both new and regular calls to do the same, like this:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  if (!new.target) { // if you run me without new
    return new User(name); // ...I will add new for you
  }

  this.name = name;
}

let john = User("John"); // redirects call to new User
alert(john.name); // John
        
      
      
      This approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without new, and it still works.
Probably not a good thing to use everywhere though, because omitting new makes it a bit less obvious what’s going on. With new we all know that the new object is being created.
Return from constructorsUsually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:

If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.

In other words, return with an object returns that object, in all other cases this is returned.
For instance, here return overrides this by returning an object:

      
        
        
          
            
          
          
            
          
        
        
          function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- returns this object
}

alert( new BigUser().name );  // Godzilla, got that object
        
      
      
      And here’s an example with an empty return (or we could place a primitive after it, doesn’t matter):

      
        
        
          
            
          
          
            
          
        
        
          function SmallUser() {

  this.name = "John";

  return; // <-- returns this
}

alert( new SmallUser().name );  // John
        
      
      
      Usually constructors don’t have a return statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.

            Omitting parentheses
            By the way, we can omit parentheses after new:

      
        
        
          let user = new User; // <-- no parentheses
// same as
let user = new User();
        
      
      
      Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

Methods in constructorUsing constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.
For instance, new User(name) below creates an object with the given name and the method sayHi:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // My name is: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
        
      
      
      To create complex objects, there’s a more advanced syntax, classes, that we’ll cover later.
Summary
Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.

We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.

            Objects, we’ll be back!
            In this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.
After we learn that, we return to objects and cover them in-depth in the chapters Prototypes, inheritance and Classes.

TasksTwo functions – one objectimportance: 2Is it possible to create functions A and B so that new A() == new B()?

      
        
        
          function A() { ... }
function B() { ... }

let a = new A();
let b = new B();

alert( a == b ); // true
        
      
      
      If it is, then provide an example of their code.
solutionYes, it’s possible.
If a function returns an object then new returns it instead of this.
So they can, for instance, return the same externally defined object obj:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

function A() { return obj; }
function B() { return obj; }

alert( new A() == new B() ); // true
        
      
      
      Create new Calculatorimportance: 5Create a constructor function Calculator that creates objects with 3 methods:

read() prompts for two values and saves them as object properties with names a and b respectively.
sum() returns the sum of these properties.
mul() returns the multiplication product of these properties.

For instance:

      
        
        
          let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function Calculator() {

  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };

  this.sum = function() {
    return this.a + this.b;
  };

  this.mul = function() {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Open the solution with tests in a sandbox.Create new Accumulatorimportance: 5Create a constructor function Accumulator(startingValue).
Object that it creates should:

Store the “current value” in the property value. The starting value is set to the argument of the constructor startingValue.
The read() method should use prompt to read a new number and add it to value.

In other words, the value property is the sum of all user-entered values with the initial value  startingValue.
Here’s the demo of the code:

      
        
        
          let accumulator = new Accumulator(1); // initial value 1

accumulator.read(); // adds the user-entered value
accumulator.read(); // adds the user-entered value

alert(accumulator.value); // shows the sum of these values
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('How much to add?', 0);
  };

}

let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value);
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageObjects: the basicsOctober 1, 2022Constructor, operator "new"The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.
That can be done using constructor functions and the "new" operator.
Constructor functionConstructor functions technically are regular functions. There are two conventions though:

They are named with capital letter first.
They should be executed only with "new" operator.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
        
      
      
      When a function is executed with new, it does the following steps:

A new empty object is created and assigned to this.
The function body executes. Usually it modifies this, adds new properties to it.
The value of this is returned.

In other words, new User(...) does something like:

      
        
        
          function User(name) {
  // this = {};  (implicitly)

  // add properties to this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitly)
}
        
      
      
      So let user = new User("Jack") gives the same result as:

      
        
        
          let user = {
  name: "Jack",
  isAdmin: false
};
        
      
      
      Now if we want to create other users, we can call new User("Ann"), new User("Alice") and so on. Much shorter than using literals every time, and also easy to read.
That’s the main purpose of constructors – to implement reusable object creation code.
Let’s note once again – technically, any function (except arrow functions, as they don’t have this) can be used as a constructor. It can be run with new, and it will execute the algorithm above. The “capital letter first” is a common agreement, to make it clear that a function is to be run with new.

            new function() { … }
            If we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:

      
        
        
          // create a function and immediately call it with new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};
        
      
      
      This constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.

Constructor mode test: new.target
            Advanced stuff
            The syntax from this section is rarely used, skip it unless you want to know everything.

Inside a function, we can check whether it was called with new or without it, using a special new.target property.
It is undefined for regular calls and equals the function if called with new:

      
        
        
          
            
          
          
            
          
        
        
          function User() {
  alert(new.target);
}

// without "new":
User(); // undefined

// with "new":
new User(); // function User { ... }
        
      
      
      That can be used inside the function to know whether it was called with new, “in constructor mode”, or without it, “in regular mode”.
We can also make both new and regular calls to do the same, like this:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  if (!new.target) { // if you run me without new
    return new User(name); // ...I will add new for you
  }

  this.name = name;
}

let john = User("John"); // redirects call to new User
alert(john.name); // John
        
      
      
      This approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without new, and it still works.
Probably not a good thing to use everywhere though, because omitting new makes it a bit less obvious what’s going on. With new we all know that the new object is being created.
Return from constructorsUsually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.
But if there is a return statement, then the rule is simple:

If return is called with an object, then the object is returned instead of this.
If return is called with a primitive, it’s ignored.

In other words, return with an object returns that object, in all other cases this is returned.
For instance, here return overrides this by returning an object:

      
        
        
          
            
          
          
            
          
        
        
          function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- returns this object
}

alert( new BigUser().name );  // Godzilla, got that object
        
      
      
      And here’s an example with an empty return (or we could place a primitive after it, doesn’t matter):

      
        
        
          
            
          
          
            
          
        
        
          function SmallUser() {

  this.name = "John";

  return; // <-- returns this
}

alert( new SmallUser().name );  // John
        
      
      
      Usually constructors don’t have a return statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.

            Omitting parentheses
            By the way, we can omit parentheses after new:

      
        
        
          let user = new User; // <-- no parentheses
// same as
let user = new User();
        
      
      
      Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

Methods in constructorUsing constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.
Of course, we can add to this not only properties, but methods as well.
For instance, new User(name) below creates an object with the given name and the method sayHi:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "My name is: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // My name is: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
        
      
      
      To create complex objects, there’s a more advanced syntax, classes, that we’ll cover later.
Summary
Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
Constructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.

We can use constructor functions to make multiple similar objects.
JavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.

            Objects, we’ll be back!
            In this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.
After we learn that, we return to objects and cover them in-depth in the chapters Prototypes, inheritance and Classes.

TasksTwo functions – one objectimportance: 2Is it possible to create functions A and B so that new A() == new B()?

      
        
        
          function A() { ... }
function B() { ... }

let a = new A();
let b = new B();

alert( a == b ); // true
        
      
      
      If it is, then provide an example of their code.
solutionYes, it’s possible.
If a function returns an object then new returns it instead of this.
So they can, for instance, return the same externally defined object obj:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

function A() { return obj; }
function B() { return obj; }

alert( new A() == new B() ); // true
        
      
      
      Create new Calculatorimportance: 5Create a constructor function Calculator that creates objects with 3 methods:

read() prompts for two values and saves them as object properties with names a and b respectively.
sum() returns the sum of these properties.
mul() returns the multiplication product of these properties.

For instance:

      
        
        
          let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function Calculator() {

  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };

  this.sum = function() {
    return this.a + this.b;
  };

  this.mul = function() {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Open the solution with tests in a sandbox.Create new Accumulatorimportance: 5Create a constructor function Accumulator(startingValue).
Object that it creates should:

Store the “current value” in the property value. The starting value is set to the argument of the constructor startingValue.
The read() method should use prompt to read a new number and add it to value.

In other words, the value property is the sum of all user-entered values with the initial value  startingValue.
Here’s the demo of the code:

      
        
        
          let accumulator = new Accumulator(1); // initial value 1

accumulator.read(); // adds the user-entered value
accumulator.read(); // adds the user-entered value

alert(accumulator.value); // shows the sum of these values
        
      
      
      Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('How much to add?', 0);
  };

}

let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value);
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nA recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn’t exist.
The “non-existing property” problemIf you’ve just started to read the tutorial and learn JavaScript, maybe the problem hasn’t touched you yet, but it’s quite common.
As an example, let’s say we have user objects that hold the information about our users.
Most of our users have addresses in user.address property, with the street user.address.street, but some did not provide them.
In such case, when we attempt to get user.address.street, and the user happens to be without an address, we get an error:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // a user without "address" property

alert(user.address.street); // Error!
        
      
      
      That’s the expected result. JavaScript works like this. As user.address is undefined, an attempt to get user.address.street fails with an error.
In many practical cases we’d prefer to get undefined instead of an error here (meaning “no street”).
…and another example. In Web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and it returns null when there’s no such element.

      
        
        
          
            
          
          
            
          
        
        
          // document.querySelector('.elem') is null if there's no element
let html = document.querySelector('.elem').innerHTML; // error if it's null
        
      
      
      Once again, if the element doesn’t exist, we’ll get an error accessing .innerHTML property of null. And in some cases, when the absence of the element is normal, we’d like to avoid the error and just accept html = null as the result.
How can we do this?
The obvious solution would be to check the value using if or the conditional operator ?, before accessing its property, like this:

      
        
        
          let user = {};

alert(user.address ? user.address.street : undefined);
        
      
      
      It works, there’s no error… But it’s quite inelegant. As you can see, the "user.address" appears twice in the code.
Here’s how the same would look for document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;
        
      
      
      We can see that the element search document.querySelector('.elem') is actually called twice here. Not good.
For more deeply nested properties, it becomes even uglier, as more repetitions are required.
E.g. let’s get user.address.street.name in a similar fashion.

      
        
        
          let user = {}; // user has no address

alert(user.address ? user.address.street ? user.address.street.name : null : null);
        
      
      
      That’s just awful, one may even have problems understanding such code.
There’s a little better way to write it, using the && operator:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user.address && user.address.street && user.address.street.name ); // undefined (no error)
        
      
      
      AND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.
As you can see, property names are still duplicated in the code. E.g. in the code above, user.address appears three times.
That’s why the optional chaining ?. was added to the language. To solve this problem once and for all!
Optional chainingThe optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.
Further in this article, for brevity, we’ll be saying that something “exists” if it’s not null and not undefined.
In other words, value?.prop:

works as value.prop, if value exists,
otherwise (when value is undefined/null) it returns undefined.

Here’s the safe way to access user.address.street using ?.:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user?.address?.street ); // undefined (no error)
        
      
      
      The code is short and clean, there’s no duplication at all.
Here’s an example with document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem')?.innerHTML; // will be undefined, if there's no element
        
      
      
      Reading the address with user?.address works even if user object doesn’t exist:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
        
      
      
      Please note: the ?. syntax makes optional the value before it, but not any further.
E.g. in user?.address.street.name the ?. allows user to safely be null/undefined (and returns undefined in that case), but that’s only for user. Further properties are accessed in a regular way. If we want some of them to be optional, then we’ll need to replace more . with ?..

            Don’t overuse the optional chaining
            We should use ?. only where it’s ok that something doesn’t exist.
For example, if according to our code logic user object must exist, but address is optional, then we should write user.address?.street, but not user?.address?.street.
Then, if user happens to be undefined, we’ll see a programming error about it and fix it. Otherwise, if we overuse ?., coding errors can be silenced where not appropriate, and become more difficult to debug.


            The variable before ?. must be declared
            If there’s no variable user at all, then user?.anything triggers an error:

      
        
        
          
            
          
          
            
          
        
        
          // ReferenceError: user is not defined
user?.address;
        
      
      
      The variable must be declared (e.g. let/const/var user or as a function parameter). The optional chaining works only for declared variables.

Short-circuitingAs it was said before, the ?. immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.
So, if there are any further function calls or operations to the right of ?., they won’t be made.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;
let x = 0;

user?.sayHi(x++); // no "user", so the execution doesn't reach sayHi call and x++

alert(x); // 0, value not incremented
        
      
      
      Other variants: ?.(), ?.[]The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
For example, ?.() is used to call a function that may not exist.
In the code below, some of our users have admin method, and some don’t:

      
        
        
          
            
          
          
            
          
        
        
          let userAdmin = {
  admin() {
    alert("I am admin");
  }
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // nothing happens (no such method)
        
      
      
      Here, in both lines we first use the dot (userAdmin.admin) to get admin property, because we assume that the user object exists, so it’s safe read from it.
Then ?.() checks the left part: if the admin function exists, then it runs (that’s so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.
The ?.[] syntax also works, if we’d like to use brackets [] to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.

      
        
        
          
            
          
          
            
          
        
        
          let key = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
        
      
      
      Also we can use ?. with delete:

      
        
        
          
            
          
          
            
          
        
        
          delete user?.name; // delete user.name if user exists
        
      
      
      
            We can use ?. for safe reading and deleting, but not writing
            The optional chaining ?. has no use on the left side of an assignment.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

user?.name = "John"; // Error, doesn't work
// because it evaluates to: undefined = "John"
        
      
      
      
SummaryThe optional chaining ?. syntax has three forms:

obj?.prop – returns obj.prop if obj exists, otherwise undefined.
obj?.[prop] – returns obj[prop] if obj exists, otherwise undefined.
obj.method?.() – calls obj.method() if obj.method exists, otherwise returns undefined.

As we can see, all of them are straightforward and simple to use. The ?. checks the left part for null/undefined and allows the evaluation to proceed if it’s not so.
A chain of ?. allows to safely access nested properties.
Still, we should apply ?. carefully, only where it’s acceptable, according to our code logic, that the left part doesn’t exist. So that it won’t hide programming errors from us, if they occur.\n\nTutorialThe JavaScript languageObjects: the basicsApril 14, 2022Optional chaining '?.'
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn’t exist.
The “non-existing property” problemIf you’ve just started to read the tutorial and learn JavaScript, maybe the problem hasn’t touched you yet, but it’s quite common.
As an example, let’s say we have user objects that hold the information about our users.
Most of our users have addresses in user.address property, with the street user.address.street, but some did not provide them.
In such case, when we attempt to get user.address.street, and the user happens to be without an address, we get an error:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // a user without "address" property

alert(user.address.street); // Error!
        
      
      
      That’s the expected result. JavaScript works like this. As user.address is undefined, an attempt to get user.address.street fails with an error.
In many practical cases we’d prefer to get undefined instead of an error here (meaning “no street”).
…and another example. In Web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and it returns null when there’s no such element.

      
        
        
          
            
          
          
            
          
        
        
          // document.querySelector('.elem') is null if there's no element
let html = document.querySelector('.elem').innerHTML; // error if it's null
        
      
      
      Once again, if the element doesn’t exist, we’ll get an error accessing .innerHTML property of null. And in some cases, when the absence of the element is normal, we’d like to avoid the error and just accept html = null as the result.
How can we do this?
The obvious solution would be to check the value using if or the conditional operator ?, before accessing its property, like this:

      
        
        
          let user = {};

alert(user.address ? user.address.street : undefined);
        
      
      
      It works, there’s no error… But it’s quite inelegant. As you can see, the "user.address" appears twice in the code.
Here’s how the same would look for document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;
        
      
      
      We can see that the element search document.querySelector('.elem') is actually called twice here. Not good.
For more deeply nested properties, it becomes even uglier, as more repetitions are required.
E.g. let’s get user.address.street.name in a similar fashion.

      
        
        
          let user = {}; // user has no address

alert(user.address ? user.address.street ? user.address.street.name : null : null);
        
      
      
      That’s just awful, one may even have problems understanding such code.
There’s a little better way to write it, using the && operator:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user.address && user.address.street && user.address.street.name ); // undefined (no error)
        
      
      
      AND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.
As you can see, property names are still duplicated in the code. E.g. in the code above, user.address appears three times.
That’s why the optional chaining ?. was added to the language. To solve this problem once and for all!
Optional chainingThe optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.
Further in this article, for brevity, we’ll be saying that something “exists” if it’s not null and not undefined.
In other words, value?.prop:

works as value.prop, if value exists,
otherwise (when value is undefined/null) it returns undefined.

Here’s the safe way to access user.address.street using ?.:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user?.address?.street ); // undefined (no error)
        
      
      
      The code is short and clean, there’s no duplication at all.
Here’s an example with document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem')?.innerHTML; // will be undefined, if there's no element
        
      
      
      Reading the address with user?.address works even if user object doesn’t exist:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
        
      
      
      Please note: the ?. syntax makes optional the value before it, but not any further.
E.g. in user?.address.street.name the ?. allows user to safely be null/undefined (and returns undefined in that case), but that’s only for user. Further properties are accessed in a regular way. If we want some of them to be optional, then we’ll need to replace more . with ?..

            Don’t overuse the optional chaining
            We should use ?. only where it’s ok that something doesn’t exist.
For example, if according to our code logic user object must exist, but address is optional, then we should write user.address?.street, but not user?.address?.street.
Then, if user happens to be undefined, we’ll see a programming error about it and fix it. Otherwise, if we overuse ?., coding errors can be silenced where not appropriate, and become more difficult to debug.


            The variable before ?. must be declared
            If there’s no variable user at all, then user?.anything triggers an error:

      
        
        
          
            
          
          
            
          
        
        
          // ReferenceError: user is not defined
user?.address;
        
      
      
      The variable must be declared (e.g. let/const/var user or as a function parameter). The optional chaining works only for declared variables.

Short-circuitingAs it was said before, the ?. immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.
So, if there are any further function calls or operations to the right of ?., they won’t be made.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;
let x = 0;

user?.sayHi(x++); // no "user", so the execution doesn't reach sayHi call and x++

alert(x); // 0, value not incremented
        
      
      
      Other variants: ?.(), ?.[]The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
For example, ?.() is used to call a function that may not exist.
In the code below, some of our users have admin method, and some don’t:

      
        
        
          
            
          
          
            
          
        
        
          let userAdmin = {
  admin() {
    alert("I am admin");
  }
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // nothing happens (no such method)
        
      
      
      Here, in both lines we first use the dot (userAdmin.admin) to get admin property, because we assume that the user object exists, so it’s safe read from it.
Then ?.() checks the left part: if the admin function exists, then it runs (that’s so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.
The ?.[] syntax also works, if we’d like to use brackets [] to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.

      
        
        
          
            
          
          
            
          
        
        
          let key = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
        
      
      
      Also we can use ?. with delete:

      
        
        
          
            
          
          
            
          
        
        
          delete user?.name; // delete user.name if user exists
        
      
      
      
            We can use ?. for safe reading and deleting, but not writing
            The optional chaining ?. has no use on the left side of an assignment.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

user?.name = "John"; // Error, doesn't work
// because it evaluates to: undefined = "John"
        
      
      
      
SummaryThe optional chaining ?. syntax has three forms:

obj?.prop – returns obj.prop if obj exists, otherwise undefined.
obj?.[prop] – returns obj[prop] if obj exists, otherwise undefined.
obj.method?.() – calls obj.method() if obj.method exists, otherwise returns undefined.

As we can see, all of them are straightforward and simple to use. The ?. checks the left part for null/undefined and allows the evaluation to proceed if it’s not so.
A chain of ?. allows to safely access nested properties.
Still, we should apply ?. carefully, only where it’s acceptable, according to our code logic, that the left part doesn’t exist. So that it won’t hide programming errors from us, if they occur.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nA recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn’t exist.
The “non-existing property” problemIf you’ve just started to read the tutorial and learn JavaScript, maybe the problem hasn’t touched you yet, but it’s quite common.
As an example, let’s say we have user objects that hold the information about our users.
Most of our users have addresses in user.address property, with the street user.address.street, but some did not provide them.
In such case, when we attempt to get user.address.street, and the user happens to be without an address, we get an error:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // a user without "address" property

alert(user.address.street); // Error!
        
      
      
      That’s the expected result. JavaScript works like this. As user.address is undefined, an attempt to get user.address.street fails with an error.
In many practical cases we’d prefer to get undefined instead of an error here (meaning “no street”).
…and another example. In Web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and it returns null when there’s no such element.

      
        
        
          
            
          
          
            
          
        
        
          // document.querySelector('.elem') is null if there's no element
let html = document.querySelector('.elem').innerHTML; // error if it's null
        
      
      
      Once again, if the element doesn’t exist, we’ll get an error accessing .innerHTML property of null. And in some cases, when the absence of the element is normal, we’d like to avoid the error and just accept html = null as the result.
How can we do this?
The obvious solution would be to check the value using if or the conditional operator ?, before accessing its property, like this:

      
        
        
          let user = {};

alert(user.address ? user.address.street : undefined);
        
      
      
      It works, there’s no error… But it’s quite inelegant. As you can see, the "user.address" appears twice in the code.
Here’s how the same would look for document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;
        
      
      
      We can see that the element search document.querySelector('.elem') is actually called twice here. Not good.
For more deeply nested properties, it becomes even uglier, as more repetitions are required.
E.g. let’s get user.address.street.name in a similar fashion.

      
        
        
          let user = {}; // user has no address

alert(user.address ? user.address.street ? user.address.street.name : null : null);
        
      
      
      That’s just awful, one may even have problems understanding such code.
There’s a little better way to write it, using the && operator:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user.address && user.address.street && user.address.street.name ); // undefined (no error)
        
      
      
      AND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.
As you can see, property names are still duplicated in the code. E.g. in the code above, user.address appears three times.
That’s why the optional chaining ?. was added to the language. To solve this problem once and for all!
Optional chainingThe optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.
Further in this article, for brevity, we’ll be saying that something “exists” if it’s not null and not undefined.
In other words, value?.prop:

works as value.prop, if value exists,
otherwise (when value is undefined/null) it returns undefined.

Here’s the safe way to access user.address.street using ?.:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user?.address?.street ); // undefined (no error)
        
      
      
      The code is short and clean, there’s no duplication at all.
Here’s an example with document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem')?.innerHTML; // will be undefined, if there's no element
        
      
      
      Reading the address with user?.address works even if user object doesn’t exist:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
        
      
      
      Please note: the ?. syntax makes optional the value before it, but not any further.
E.g. in user?.address.street.name the ?. allows user to safely be null/undefined (and returns undefined in that case), but that’s only for user. Further properties are accessed in a regular way. If we want some of them to be optional, then we’ll need to replace more . with ?..

            Don’t overuse the optional chaining
            We should use ?. only where it’s ok that something doesn’t exist.
For example, if according to our code logic user object must exist, but address is optional, then we should write user.address?.street, but not user?.address?.street.
Then, if user happens to be undefined, we’ll see a programming error about it and fix it. Otherwise, if we overuse ?., coding errors can be silenced where not appropriate, and become more difficult to debug.


            The variable before ?. must be declared
            If there’s no variable user at all, then user?.anything triggers an error:

      
        
        
          
            
          
          
            
          
        
        
          // ReferenceError: user is not defined
user?.address;
        
      
      
      The variable must be declared (e.g. let/const/var user or as a function parameter). The optional chaining works only for declared variables.

Short-circuitingAs it was said before, the ?. immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.
So, if there are any further function calls or operations to the right of ?., they won’t be made.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;
let x = 0;

user?.sayHi(x++); // no "user", so the execution doesn't reach sayHi call and x++

alert(x); // 0, value not incremented
        
      
      
      Other variants: ?.(), ?.[]The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
For example, ?.() is used to call a function that may not exist.
In the code below, some of our users have admin method, and some don’t:

      
        
        
          
            
          
          
            
          
        
        
          let userAdmin = {
  admin() {
    alert("I am admin");
  }
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // nothing happens (no such method)
        
      
      
      Here, in both lines we first use the dot (userAdmin.admin) to get admin property, because we assume that the user object exists, so it’s safe read from it.
Then ?.() checks the left part: if the admin function exists, then it runs (that’s so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.
The ?.[] syntax also works, if we’d like to use brackets [] to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.

      
        
        
          
            
          
          
            
          
        
        
          let key = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
        
      
      
      Also we can use ?. with delete:

      
        
        
          
            
          
          
            
          
        
        
          delete user?.name; // delete user.name if user exists
        
      
      
      
            We can use ?. for safe reading and deleting, but not writing
            The optional chaining ?. has no use on the left side of an assignment.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

user?.name = "John"; // Error, doesn't work
// because it evaluates to: undefined = "John"
        
      
      
      
SummaryThe optional chaining ?. syntax has three forms:

obj?.prop – returns obj.prop if obj exists, otherwise undefined.
obj?.[prop] – returns obj[prop] if obj exists, otherwise undefined.
obj.method?.() – calls obj.method() if obj.method exists, otherwise returns undefined.

As we can see, all of them are straightforward and simple to use. The ?. checks the left part for null/undefined and allows the evaluation to proceed if it’s not so.
A chain of ?. allows to safely access nested properties.
Still, we should apply ?. carefully, only where it’s acceptable, according to our code logic, that the left part doesn’t exist. So that it won’t hide programming errors from us, if they occur.\n\nTutorialThe JavaScript languageObjects: the basicsApril 14, 2022Optional chaining '?.'
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
The optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn’t exist.
The “non-existing property” problemIf you’ve just started to read the tutorial and learn JavaScript, maybe the problem hasn’t touched you yet, but it’s quite common.
As an example, let’s say we have user objects that hold the information about our users.
Most of our users have addresses in user.address property, with the street user.address.street, but some did not provide them.
In such case, when we attempt to get user.address.street, and the user happens to be without an address, we get an error:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // a user without "address" property

alert(user.address.street); // Error!
        
      
      
      That’s the expected result. JavaScript works like this. As user.address is undefined, an attempt to get user.address.street fails with an error.
In many practical cases we’d prefer to get undefined instead of an error here (meaning “no street”).
…and another example. In Web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and it returns null when there’s no such element.

      
        
        
          
            
          
          
            
          
        
        
          // document.querySelector('.elem') is null if there's no element
let html = document.querySelector('.elem').innerHTML; // error if it's null
        
      
      
      Once again, if the element doesn’t exist, we’ll get an error accessing .innerHTML property of null. And in some cases, when the absence of the element is normal, we’d like to avoid the error and just accept html = null as the result.
How can we do this?
The obvious solution would be to check the value using if or the conditional operator ?, before accessing its property, like this:

      
        
        
          let user = {};

alert(user.address ? user.address.street : undefined);
        
      
      
      It works, there’s no error… But it’s quite inelegant. As you can see, the "user.address" appears twice in the code.
Here’s how the same would look for document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;
        
      
      
      We can see that the element search document.querySelector('.elem') is actually called twice here. Not good.
For more deeply nested properties, it becomes even uglier, as more repetitions are required.
E.g. let’s get user.address.street.name in a similar fashion.

      
        
        
          let user = {}; // user has no address

alert(user.address ? user.address.street ? user.address.street.name : null : null);
        
      
      
      That’s just awful, one may even have problems understanding such code.
There’s a little better way to write it, using the && operator:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user.address && user.address.street && user.address.street.name ); // undefined (no error)
        
      
      
      AND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.
As you can see, property names are still duplicated in the code. E.g. in the code above, user.address appears three times.
That’s why the optional chaining ?. was added to the language. To solve this problem once and for all!
Optional chainingThe optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.
Further in this article, for brevity, we’ll be saying that something “exists” if it’s not null and not undefined.
In other words, value?.prop:

works as value.prop, if value exists,
otherwise (when value is undefined/null) it returns undefined.

Here’s the safe way to access user.address.street using ?.:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // user has no address

alert( user?.address?.street ); // undefined (no error)
        
      
      
      The code is short and clean, there’s no duplication at all.
Here’s an example with document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem')?.innerHTML; // will be undefined, if there's no element
        
      
      
      Reading the address with user?.address works even if user object doesn’t exist:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
        
      
      
      Please note: the ?. syntax makes optional the value before it, but not any further.
E.g. in user?.address.street.name the ?. allows user to safely be null/undefined (and returns undefined in that case), but that’s only for user. Further properties are accessed in a regular way. If we want some of them to be optional, then we’ll need to replace more . with ?..

            Don’t overuse the optional chaining
            We should use ?. only where it’s ok that something doesn’t exist.
For example, if according to our code logic user object must exist, but address is optional, then we should write user.address?.street, but not user?.address?.street.
Then, if user happens to be undefined, we’ll see a programming error about it and fix it. Otherwise, if we overuse ?., coding errors can be silenced where not appropriate, and become more difficult to debug.


            The variable before ?. must be declared
            If there’s no variable user at all, then user?.anything triggers an error:

      
        
        
          
            
          
          
            
          
        
        
          // ReferenceError: user is not defined
user?.address;
        
      
      
      The variable must be declared (e.g. let/const/var user or as a function parameter). The optional chaining works only for declared variables.

Short-circuitingAs it was said before, the ?. immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.
So, if there are any further function calls or operations to the right of ?., they won’t be made.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;
let x = 0;

user?.sayHi(x++); // no "user", so the execution doesn't reach sayHi call and x++

alert(x); // 0, value not incremented
        
      
      
      Other variants: ?.(), ?.[]The optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.
For example, ?.() is used to call a function that may not exist.
In the code below, some of our users have admin method, and some don’t:

      
        
        
          
            
          
          
            
          
        
        
          let userAdmin = {
  admin() {
    alert("I am admin");
  }
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // nothing happens (no such method)
        
      
      
      Here, in both lines we first use the dot (userAdmin.admin) to get admin property, because we assume that the user object exists, so it’s safe read from it.
Then ?.() checks the left part: if the admin function exists, then it runs (that’s so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.
The ?.[] syntax also works, if we’d like to use brackets [] to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.

      
        
        
          
            
          
          
            
          
        
        
          let key = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
        
      
      
      Also we can use ?. with delete:

      
        
        
          
            
          
          
            
          
        
        
          delete user?.name; // delete user.name if user exists
        
      
      
      
            We can use ?. for safe reading and deleting, but not writing
            The optional chaining ?. has no use on the left side of an assignment.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

user?.name = "John"; // Error, doesn't work
// because it evaluates to: undefined = "John"
        
      
      
      
SummaryThe optional chaining ?. syntax has three forms:

obj?.prop – returns obj.prop if obj exists, otherwise undefined.
obj?.[prop] – returns obj[prop] if obj exists, otherwise undefined.
obj.method?.() – calls obj.method() if obj.method exists, otherwise returns undefined.

As we can see, all of them are straightforward and simple to use. The ?. checks the left part for null/undefined and allows the evaluation to proceed if it’s not so.
A chain of ?. allows to safely access nested properties.
Still, we should apply ?. carefully, only where it’s acceptable, according to our code logic, that the left part doesn’t exist. So that it won’t hide programming errors from us, if they occur.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nBy specification, only two primitive types may serve as object property keys:

string type, or
symbol type.

Otherwise, if one uses another type, such as number, it’s autoconverted to string. So that obj[1] is the same as obj["1"], and obj[true] is the same as obj["true"].
Until now we’ve been using only strings.
Now let’s explore symbols, see what they can do for us.
SymbolsA “symbol” represents a unique identifier.
A value of this type can be created using Symbol():

      
        
        
          let id = Symbol();
        
      
      
      Upon creation, we can give symbols a description (also called a symbol name), mostly useful for debugging purposes:

      
        
        
          // id is a symbol with the description "id"
let id = Symbol("id");
        
      
      
      Symbols are guaranteed to be unique. Even if we create many symbols with exactly the same description, they are different values. The description is just a label that doesn’t affect anything.
For instance, here are two symbols with the same description – they are not equal:

      
        
        
          
            
          
          
            
          
        
        
          let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
        
      
      
      If you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. JavaScript symbols are different.
So, to summarize, a symbol is a “primitive unique value” with an optional description. Let’s see where we can use them.

            Symbols don’t auto-convert to a string
            Most values in JavaScript support implicit conversion to a string. For instance, we can alert almost any value, and it will work. Symbols are special. They don’t auto-convert.
For instance, this alert will show an error:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
        
      
      
      That’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not accidentally convert one into another.
If we really want to show a symbol, we need to explicitly call .toString() on it, like here:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works
        
      
      
      Or get symbol.description property to show the description only:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.description); // id
        
      
      
      
“Hidden” propertiesSymbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
For instance, if we’re working with user objects, that belong to a third-party code. We’d like to add identifiers to them.
Let’s use a symbol key for it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { // belongs to another code
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // we can access the data using the symbol as the key
        
      
      
      What’s the benefit of using Symbol("id") over a string "id"?
As user objects belong to another codebase, it’s unsafe to add fields to them, since we might affect pre-defined behavior in that other codebase. However, symbols cannot be accessed accidentally. The third-party code won’t be aware of newly defined symbols, so it’s safe to add symbols to the user objects.
Also, imagine that another script wants to have its own identifier inside user, for its own purposes.
Then that script can create its own Symbol("id"), like this:

      
        
        
          // ...
let id = Symbol("id");

user[id] = "Their id value";
        
      
      
      There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.
…But if we used a string "id" instead of a symbol for the same purpose, then there would be a conflict:

      
        
        
          let user = { name: "John" };

// Our script uses "id" property
user.id = "Our id value";

// ...Another script also wants "id" for its purposes...

user.id = "Their id value"
// Boom! overwritten by another script!
        
      
      
      Symbols in an object literalIf we want to use a symbol in an object literal {...}, we need square brackets around it.
Like this:

      
        
        
          let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
        
      
      
      That’s because we need the value from the variable id as the key, not the string “id”.
Symbols are skipped by for…inSymbolic properties do not participate in for..in loop.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name, age (no symbols)

// the direct access by the symbol works
alert( "Direct: " + user[id] ); // Direct: 123
        
      
      
      Object.keys(user) also ignores them. That’s a part of the general “hiding symbolic properties” principle. If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.
In contrast, Object.assign copies both string and symbol properties:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
        
      
      
      There’s no paradox here. That’s by design. The idea is that when we clone an object or merge objects, we usually want all properties to be copied (including symbols like id).
Global symbolsAs we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true
        
      
      
      Symbols inside the registry are called global symbols. If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.

            That sounds like Ruby
            In some programming languages, like Ruby, there’s a single symbol per name.
In JavaScript, as we can see, that’s true for global symbols.

Symbol.keyForWe have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // get symbol by name
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
        
      
      
      The Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol. So it doesn’t work for non-global symbols. If the symbol is not global, it won’t be able to find it and returns undefined.
That said, all symbols have the description property.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, not global

alert( localSymbol.description ); // name
        
      
      
      System symbolsThere exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.

For instance, Symbol.toPrimitive allows us to describe object to primitive conversion. We’ll see its use very soon.
Other symbols will also become familiar when we study the corresponding language features.
SummarySymbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.
Symbols have two main use cases:


“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.


There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.


Technically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods.\n\nTutorialThe JavaScript languageObjects: the basicsJune 27, 2022Symbol typeBy specification, only two primitive types may serve as object property keys:

string type, or
symbol type.

Otherwise, if one uses another type, such as number, it’s autoconverted to string. So that obj[1] is the same as obj["1"], and obj[true] is the same as obj["true"].
Until now we’ve been using only strings.
Now let’s explore symbols, see what they can do for us.
SymbolsA “symbol” represents a unique identifier.
A value of this type can be created using Symbol():

      
        
        
          let id = Symbol();
        
      
      
      Upon creation, we can give symbols a description (also called a symbol name), mostly useful for debugging purposes:

      
        
        
          // id is a symbol with the description "id"
let id = Symbol("id");
        
      
      
      Symbols are guaranteed to be unique. Even if we create many symbols with exactly the same description, they are different values. The description is just a label that doesn’t affect anything.
For instance, here are two symbols with the same description – they are not equal:

      
        
        
          
            
          
          
            
          
        
        
          let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
        
      
      
      If you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. JavaScript symbols are different.
So, to summarize, a symbol is a “primitive unique value” with an optional description. Let’s see where we can use them.

            Symbols don’t auto-convert to a string
            Most values in JavaScript support implicit conversion to a string. For instance, we can alert almost any value, and it will work. Symbols are special. They don’t auto-convert.
For instance, this alert will show an error:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
        
      
      
      That’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not accidentally convert one into another.
If we really want to show a symbol, we need to explicitly call .toString() on it, like here:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works
        
      
      
      Or get symbol.description property to show the description only:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.description); // id
        
      
      
      
“Hidden” propertiesSymbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
For instance, if we’re working with user objects, that belong to a third-party code. We’d like to add identifiers to them.
Let’s use a symbol key for it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { // belongs to another code
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // we can access the data using the symbol as the key
        
      
      
      What’s the benefit of using Symbol("id") over a string "id"?
As user objects belong to another codebase, it’s unsafe to add fields to them, since we might affect pre-defined behavior in that other codebase. However, symbols cannot be accessed accidentally. The third-party code won’t be aware of newly defined symbols, so it’s safe to add symbols to the user objects.
Also, imagine that another script wants to have its own identifier inside user, for its own purposes.
Then that script can create its own Symbol("id"), like this:

      
        
        
          // ...
let id = Symbol("id");

user[id] = "Their id value";
        
      
      
      There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.
…But if we used a string "id" instead of a symbol for the same purpose, then there would be a conflict:

      
        
        
          let user = { name: "John" };

// Our script uses "id" property
user.id = "Our id value";

// ...Another script also wants "id" for its purposes...

user.id = "Their id value"
// Boom! overwritten by another script!
        
      
      
      Symbols in an object literalIf we want to use a symbol in an object literal {...}, we need square brackets around it.
Like this:

      
        
        
          let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
        
      
      
      That’s because we need the value from the variable id as the key, not the string “id”.
Symbols are skipped by for…inSymbolic properties do not participate in for..in loop.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name, age (no symbols)

// the direct access by the symbol works
alert( "Direct: " + user[id] ); // Direct: 123
        
      
      
      Object.keys(user) also ignores them. That’s a part of the general “hiding symbolic properties” principle. If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.
In contrast, Object.assign copies both string and symbol properties:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
        
      
      
      There’s no paradox here. That’s by design. The idea is that when we clone an object or merge objects, we usually want all properties to be copied (including symbols like id).
Global symbolsAs we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true
        
      
      
      Symbols inside the registry are called global symbols. If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.

            That sounds like Ruby
            In some programming languages, like Ruby, there’s a single symbol per name.
In JavaScript, as we can see, that’s true for global symbols.

Symbol.keyForWe have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // get symbol by name
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
        
      
      
      The Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol. So it doesn’t work for non-global symbols. If the symbol is not global, it won’t be able to find it and returns undefined.
That said, all symbols have the description property.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, not global

alert( localSymbol.description ); // name
        
      
      
      System symbolsThere exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.

For instance, Symbol.toPrimitive allows us to describe object to primitive conversion. We’ll see its use very soon.
Other symbols will also become familiar when we study the corresponding language features.
SummarySymbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.
Symbols have two main use cases:


“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.


There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.


Technically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nBy specification, only two primitive types may serve as object property keys:

string type, or
symbol type.

Otherwise, if one uses another type, such as number, it’s autoconverted to string. So that obj[1] is the same as obj["1"], and obj[true] is the same as obj["true"].
Until now we’ve been using only strings.
Now let’s explore symbols, see what they can do for us.
SymbolsA “symbol” represents a unique identifier.
A value of this type can be created using Symbol():

      
        
        
          let id = Symbol();
        
      
      
      Upon creation, we can give symbols a description (also called a symbol name), mostly useful for debugging purposes:

      
        
        
          // id is a symbol with the description "id"
let id = Symbol("id");
        
      
      
      Symbols are guaranteed to be unique. Even if we create many symbols with exactly the same description, they are different values. The description is just a label that doesn’t affect anything.
For instance, here are two symbols with the same description – they are not equal:

      
        
        
          
            
          
          
            
          
        
        
          let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
        
      
      
      If you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. JavaScript symbols are different.
So, to summarize, a symbol is a “primitive unique value” with an optional description. Let’s see where we can use them.

            Symbols don’t auto-convert to a string
            Most values in JavaScript support implicit conversion to a string. For instance, we can alert almost any value, and it will work. Symbols are special. They don’t auto-convert.
For instance, this alert will show an error:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
        
      
      
      That’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not accidentally convert one into another.
If we really want to show a symbol, we need to explicitly call .toString() on it, like here:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works
        
      
      
      Or get symbol.description property to show the description only:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.description); // id
        
      
      
      
“Hidden” propertiesSymbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
For instance, if we’re working with user objects, that belong to a third-party code. We’d like to add identifiers to them.
Let’s use a symbol key for it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { // belongs to another code
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // we can access the data using the symbol as the key
        
      
      
      What’s the benefit of using Symbol("id") over a string "id"?
As user objects belong to another codebase, it’s unsafe to add fields to them, since we might affect pre-defined behavior in that other codebase. However, symbols cannot be accessed accidentally. The third-party code won’t be aware of newly defined symbols, so it’s safe to add symbols to the user objects.
Also, imagine that another script wants to have its own identifier inside user, for its own purposes.
Then that script can create its own Symbol("id"), like this:

      
        
        
          // ...
let id = Symbol("id");

user[id] = "Their id value";
        
      
      
      There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.
…But if we used a string "id" instead of a symbol for the same purpose, then there would be a conflict:

      
        
        
          let user = { name: "John" };

// Our script uses "id" property
user.id = "Our id value";

// ...Another script also wants "id" for its purposes...

user.id = "Their id value"
// Boom! overwritten by another script!
        
      
      
      Symbols in an object literalIf we want to use a symbol in an object literal {...}, we need square brackets around it.
Like this:

      
        
        
          let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
        
      
      
      That’s because we need the value from the variable id as the key, not the string “id”.
Symbols are skipped by for…inSymbolic properties do not participate in for..in loop.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name, age (no symbols)

// the direct access by the symbol works
alert( "Direct: " + user[id] ); // Direct: 123
        
      
      
      Object.keys(user) also ignores them. That’s a part of the general “hiding symbolic properties” principle. If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.
In contrast, Object.assign copies both string and symbol properties:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
        
      
      
      There’s no paradox here. That’s by design. The idea is that when we clone an object or merge objects, we usually want all properties to be copied (including symbols like id).
Global symbolsAs we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true
        
      
      
      Symbols inside the registry are called global symbols. If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.

            That sounds like Ruby
            In some programming languages, like Ruby, there’s a single symbol per name.
In JavaScript, as we can see, that’s true for global symbols.

Symbol.keyForWe have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // get symbol by name
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
        
      
      
      The Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol. So it doesn’t work for non-global symbols. If the symbol is not global, it won’t be able to find it and returns undefined.
That said, all symbols have the description property.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, not global

alert( localSymbol.description ); // name
        
      
      
      System symbolsThere exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.

For instance, Symbol.toPrimitive allows us to describe object to primitive conversion. We’ll see its use very soon.
Other symbols will also become familiar when we study the corresponding language features.
SummarySymbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.
Symbols have two main use cases:


“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.


There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.


Technically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods.\n\nTutorialThe JavaScript languageObjects: the basicsJune 27, 2022Symbol typeBy specification, only two primitive types may serve as object property keys:

string type, or
symbol type.

Otherwise, if one uses another type, such as number, it’s autoconverted to string. So that obj[1] is the same as obj["1"], and obj[true] is the same as obj["true"].
Until now we’ve been using only strings.
Now let’s explore symbols, see what they can do for us.
SymbolsA “symbol” represents a unique identifier.
A value of this type can be created using Symbol():

      
        
        
          let id = Symbol();
        
      
      
      Upon creation, we can give symbols a description (also called a symbol name), mostly useful for debugging purposes:

      
        
        
          // id is a symbol with the description "id"
let id = Symbol("id");
        
      
      
      Symbols are guaranteed to be unique. Even if we create many symbols with exactly the same description, they are different values. The description is just a label that doesn’t affect anything.
For instance, here are two symbols with the same description – they are not equal:

      
        
        
          
            
          
          
            
          
        
        
          let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
        
      
      
      If you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. JavaScript symbols are different.
So, to summarize, a symbol is a “primitive unique value” with an optional description. Let’s see where we can use them.

            Symbols don’t auto-convert to a string
            Most values in JavaScript support implicit conversion to a string. For instance, we can alert almost any value, and it will work. Symbols are special. They don’t auto-convert.
For instance, this alert will show an error:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
        
      
      
      That’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not accidentally convert one into another.
If we really want to show a symbol, we need to explicitly call .toString() on it, like here:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works
        
      
      
      Or get symbol.description property to show the description only:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.description); // id
        
      
      
      
“Hidden” propertiesSymbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.
For instance, if we’re working with user objects, that belong to a third-party code. We’d like to add identifiers to them.
Let’s use a symbol key for it:

      
        
        
          
            
          
          
            
          
        
        
          let user = { // belongs to another code
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // we can access the data using the symbol as the key
        
      
      
      What’s the benefit of using Symbol("id") over a string "id"?
As user objects belong to another codebase, it’s unsafe to add fields to them, since we might affect pre-defined behavior in that other codebase. However, symbols cannot be accessed accidentally. The third-party code won’t be aware of newly defined symbols, so it’s safe to add symbols to the user objects.
Also, imagine that another script wants to have its own identifier inside user, for its own purposes.
Then that script can create its own Symbol("id"), like this:

      
        
        
          // ...
let id = Symbol("id");

user[id] = "Their id value";
        
      
      
      There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.
…But if we used a string "id" instead of a symbol for the same purpose, then there would be a conflict:

      
        
        
          let user = { name: "John" };

// Our script uses "id" property
user.id = "Our id value";

// ...Another script also wants "id" for its purposes...

user.id = "Their id value"
// Boom! overwritten by another script!
        
      
      
      Symbols in an object literalIf we want to use a symbol in an object literal {...}, we need square brackets around it.
Like this:

      
        
        
          let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // not "id": 123
};
        
      
      
      That’s because we need the value from the variable id as the key, not the string “id”.
Symbols are skipped by for…inSymbolic properties do not participate in for..in loop.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name, age (no symbols)

// the direct access by the symbol works
alert( "Direct: " + user[id] ); // Direct: 123
        
      
      
      Object.keys(user) also ignores them. That’s a part of the general “hiding symbolic properties” principle. If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.
In contrast, Object.assign copies both string and symbol properties:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
        
      
      
      There’s no paradox here. That’s by design. The idea is that when we clone an object or merge objects, we usually want all properties to be copied (including symbols like id).
Global symbolsAs we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol "id" meaning exactly the same property.
To achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
In order to read (create if absent) a symbol from the registry, use Symbol.for(key).
That call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true
        
      
      
      Symbols inside the registry are called global symbols. If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.

            That sounds like Ruby
            In some programming languages, like Ruby, there’s a single symbol per name.
In JavaScript, as we can see, that’s true for global symbols.

Symbol.keyForWe have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // get symbol by name
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
        
      
      
      The Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol. So it doesn’t work for non-global symbols. If the symbol is not global, it won’t be able to find it and returns undefined.
That said, all symbols have the description property.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, not global

alert( localSymbol.description ); // name
        
      
      
      System symbolsThere exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.
They are listed in the specification in the Well-known symbols table:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…and so on.

For instance, Symbol.toPrimitive allows us to describe object to primitive conversion. We’ll see its use very soon.
Other symbols will also become familiar when we study the corresponding language features.
SummarySymbol is a primitive type for unique identifiers.
Symbols are created with Symbol() call with an optional description (name).
Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.
Symbols have two main use cases:


“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.
So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.


There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.


Technically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nWhat happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?
JavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.
That’s an important limitation: the result of obj1 + obj2 (or another math operation) can’t be another object!
E.g. we can’t make objects representing vectors or matrices (or achievements or whatever), add them and expect a “summed” object as the result. Such architectural feats are automatically “off the board”.
So, because we can’t technically do much here, there’s no maths with objects in real projects. When it happens, with rare exceptions, it’s because of a coding mistake.
In this chapter we’ll cover how an object converts to primitive and how to customize it.
We have two purposes:

It will allow us to understand what’s going on in case of coding mistakes, when such an operation happened accidentally.
There are exceptions, where such operations are possible and look good. E.g. subtracting or comparing dates (Date objects). We’ll come across them later.

Conversion rulesIn the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.

There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.
As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.

We can implement string and numeric conversion by ourselves, using special object methods.
Now let’s get into technical details, because it’s the only way to cover the topic in-depth.
HintsHow does JavaScript decide which conversion to apply?
There are three variants of type conversion, that happen in various situations. They’re called “hints”, as described in the specification:

"string"

For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:

      
        
        
          // output
alert(obj);

// using object as a property key
anotherObj[obj] = 123;
        
      
      
      
"number"

For an object-to-number conversion, like when we’re doing maths:

      
        
        
          // explicit conversion
let num = Number(obj);

// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;

// less/greater comparison
let greater = user1 > user2;
        
      
      
      Most built-in mathematical functions also include such conversion.

"default"

Occurs in rare cases when the operator is “not sure” what type to expect.
For instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). So if a binary plus gets an object as an argument, it uses the "default" hint to convert it.
Also, if an object is compared using == with a string, number or a symbol, it’s also unclear which conversion should be done, so the "default" hint is used.

      
        
        
          // binary plus uses the "default" hint
let total = obj1 + obj2;

// obj == number uses the "default" hint
if (user == 1) { ... };
        
      
      
      The greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the "number" hint, not "default". That’s for historical reasons.


In practice though, things are a bit simpler.
All built-in objects except for one case (Date object, we’ll learn it later) implement "default" conversion the same way as "number". And we probably should do the same.
Still, it’s important to know about all 3 hints, soon we’ll see why.
To do the conversion, JavaScript tries to find and call three object methods:

Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



Symbol.toPrimitiveLet’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method, like this:

      
        
        
          obj[Symbol.toPrimitive] = function(hint) {
  // here goes the code to convert this object to a primitive
  // it must return a primitive value
  // hint = one of "string", "number", "default"
};
        
      
      
      If the method Symbol.toPrimitive exists, it’s used for all hints, and no more methods are needed.
For instance, here user object implements it:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// conversions demo:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
        
      
      
      As we can see from the code, user becomes a self-descriptive string or a money amount, depending on the conversion. The single method user[Symbol.toPrimitive] handles all conversion cases.
toString/valueOfIf there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:

For the "string" hint: call toString method, and if it doesn’t exist or if it returns an object instead of a primitive value, then call valueOf (so toString has the priority for string conversions).
For other hints: call valueOf, and if it doesn’t exist or if it returns an object instead of a primitive value, then call toString (so valueOf has the priority for maths).

Methods toString and valueOf come from ancient times. They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. They provide an alternative “old-style” way to implement the conversion.
These methods must return a primitive value. If toString or valueOf returns an object, then it’s ignored (same as if there were no method).
By default, a plain object has following toString and valueOf methods:

The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

Here’s the demo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
        
      
      
      So if we try to use an object as a string, like in an alert or so, then by default we see [object Object].
The default valueOf is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don’t ask me why, that’s for historical reasons. So we can assume it doesn’t exist.
Let’s implement these methods to customize the conversion.
For instance, here user does the same as above using a combination of toString and valueOf instead of Symbol.toPrimitive:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  // for hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // for hint="number" or "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
        
      
      
      As we can see, the behavior is the same as the previous example with Symbol.toPrimitive.
Often we want a single “catch-all” place to handle all primitive conversions. In this case, we can implement toString only, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
        
      
      
      In the absence of Symbol.toPrimitive and valueOf, toString will handle all primitive conversions.
A conversion can return any primitive typeThe important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.
There is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint "number".
The only mandatory thing: these methods must return a primitive, not an object.

            Historical notes
            For historical reasons, if toString or valueOf returns an object, there’s no error, but such value is ignored (like if the method didn’t exist). That’s because in ancient times there was no good “error” concept in JavaScript.
In contrast, Symbol.toPrimitive is stricter, it must return a primitive, otherwise there will be an error.

Further conversionsAs we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.
If we pass an object as an argument, then there are two stages of calculations:

The object is converted to a primitive (using the rules described above).
If necessary for further calculations, the resulting primitive is also converted.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  // toString handles all conversions in the absence of other methods
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, object converted to primitive "2", then multiplication made it a number
        
      
      
      
The multiplication obj * 2 first converts the object to primitive (that’s a string "2").
Then "2" * 2 becomes 2 * 2 (the string is converted to number).

Binary plus will concatenate strings in the same situation, as it gladly accepts a string:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" ("2" + 2), conversion to primitive returned a string => concatenation
        
      
      
      SummaryThe object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.
There are 3 types (hints) of it:

"string" (for alert and other operations that need a string)
"number" (for maths)
"default" (few operators, usually objects implement it the same way as "number")

The specification describes explicitly which operator uses which hint.
The conversion algorithm is:

Call obj[Symbol.toPrimitive](hint) if the method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



All these methods must return a primitive to work (if defined).
In practice, it’s often enough to implement only obj.toString() as a “catch-all” method for string conversions that should return a “human-readable” representation of an object, for logging or debugging purposes.\n\nTutorialThe JavaScript languageObjects: the basicsMarch 31, 2024Object to primitive conversionWhat happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?
JavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.
That’s an important limitation: the result of obj1 + obj2 (or another math operation) can’t be another object!
E.g. we can’t make objects representing vectors or matrices (or achievements or whatever), add them and expect a “summed” object as the result. Such architectural feats are automatically “off the board”.
So, because we can’t technically do much here, there’s no maths with objects in real projects. When it happens, with rare exceptions, it’s because of a coding mistake.
In this chapter we’ll cover how an object converts to primitive and how to customize it.
We have two purposes:

It will allow us to understand what’s going on in case of coding mistakes, when such an operation happened accidentally.
There are exceptions, where such operations are possible and look good. E.g. subtracting or comparing dates (Date objects). We’ll come across them later.

Conversion rulesIn the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.

There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.
As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.

We can implement string and numeric conversion by ourselves, using special object methods.
Now let’s get into technical details, because it’s the only way to cover the topic in-depth.
HintsHow does JavaScript decide which conversion to apply?
There are three variants of type conversion, that happen in various situations. They’re called “hints”, as described in the specification:

"string"

For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:

      
        
        
          // output
alert(obj);

// using object as a property key
anotherObj[obj] = 123;
        
      
      
      
"number"

For an object-to-number conversion, like when we’re doing maths:

      
        
        
          // explicit conversion
let num = Number(obj);

// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;

// less/greater comparison
let greater = user1 > user2;
        
      
      
      Most built-in mathematical functions also include such conversion.

"default"

Occurs in rare cases when the operator is “not sure” what type to expect.
For instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). So if a binary plus gets an object as an argument, it uses the "default" hint to convert it.
Also, if an object is compared using == with a string, number or a symbol, it’s also unclear which conversion should be done, so the "default" hint is used.

      
        
        
          // binary plus uses the "default" hint
let total = obj1 + obj2;

// obj == number uses the "default" hint
if (user == 1) { ... };
        
      
      
      The greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the "number" hint, not "default". That’s for historical reasons.


In practice though, things are a bit simpler.
All built-in objects except for one case (Date object, we’ll learn it later) implement "default" conversion the same way as "number". And we probably should do the same.
Still, it’s important to know about all 3 hints, soon we’ll see why.
To do the conversion, JavaScript tries to find and call three object methods:

Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



Symbol.toPrimitiveLet’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method, like this:

      
        
        
          obj[Symbol.toPrimitive] = function(hint) {
  // here goes the code to convert this object to a primitive
  // it must return a primitive value
  // hint = one of "string", "number", "default"
};
        
      
      
      If the method Symbol.toPrimitive exists, it’s used for all hints, and no more methods are needed.
For instance, here user object implements it:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// conversions demo:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
        
      
      
      As we can see from the code, user becomes a self-descriptive string or a money amount, depending on the conversion. The single method user[Symbol.toPrimitive] handles all conversion cases.
toString/valueOfIf there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:

For the "string" hint: call toString method, and if it doesn’t exist or if it returns an object instead of a primitive value, then call valueOf (so toString has the priority for string conversions).
For other hints: call valueOf, and if it doesn’t exist or if it returns an object instead of a primitive value, then call toString (so valueOf has the priority for maths).

Methods toString and valueOf come from ancient times. They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. They provide an alternative “old-style” way to implement the conversion.
These methods must return a primitive value. If toString or valueOf returns an object, then it’s ignored (same as if there were no method).
By default, a plain object has following toString and valueOf methods:

The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

Here’s the demo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
        
      
      
      So if we try to use an object as a string, like in an alert or so, then by default we see [object Object].
The default valueOf is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don’t ask me why, that’s for historical reasons. So we can assume it doesn’t exist.
Let’s implement these methods to customize the conversion.
For instance, here user does the same as above using a combination of toString and valueOf instead of Symbol.toPrimitive:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  // for hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // for hint="number" or "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
        
      
      
      As we can see, the behavior is the same as the previous example with Symbol.toPrimitive.
Often we want a single “catch-all” place to handle all primitive conversions. In this case, we can implement toString only, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
        
      
      
      In the absence of Symbol.toPrimitive and valueOf, toString will handle all primitive conversions.
A conversion can return any primitive typeThe important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.
There is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint "number".
The only mandatory thing: these methods must return a primitive, not an object.

            Historical notes
            For historical reasons, if toString or valueOf returns an object, there’s no error, but such value is ignored (like if the method didn’t exist). That’s because in ancient times there was no good “error” concept in JavaScript.
In contrast, Symbol.toPrimitive is stricter, it must return a primitive, otherwise there will be an error.

Further conversionsAs we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.
If we pass an object as an argument, then there are two stages of calculations:

The object is converted to a primitive (using the rules described above).
If necessary for further calculations, the resulting primitive is also converted.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  // toString handles all conversions in the absence of other methods
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, object converted to primitive "2", then multiplication made it a number
        
      
      
      
The multiplication obj * 2 first converts the object to primitive (that’s a string "2").
Then "2" * 2 becomes 2 * 2 (the string is converted to number).

Binary plus will concatenate strings in the same situation, as it gladly accepts a string:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" ("2" + 2), conversion to primitive returned a string => concatenation
        
      
      
      SummaryThe object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.
There are 3 types (hints) of it:

"string" (for alert and other operations that need a string)
"number" (for maths)
"default" (few operators, usually objects implement it the same way as "number")

The specification describes explicitly which operator uses which hint.
The conversion algorithm is:

Call obj[Symbol.toPrimitive](hint) if the method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



All these methods must return a primitive to work (if defined).
In practice, it’s often enough to implement only obj.toString() as a “catch-all” method for string conversions that should return a “human-readable” representation of an object, for logging or debugging purposes.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nWhat happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?
JavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.
That’s an important limitation: the result of obj1 + obj2 (or another math operation) can’t be another object!
E.g. we can’t make objects representing vectors or matrices (or achievements or whatever), add them and expect a “summed” object as the result. Such architectural feats are automatically “off the board”.
So, because we can’t technically do much here, there’s no maths with objects in real projects. When it happens, with rare exceptions, it’s because of a coding mistake.
In this chapter we’ll cover how an object converts to primitive and how to customize it.
We have two purposes:

It will allow us to understand what’s going on in case of coding mistakes, when such an operation happened accidentally.
There are exceptions, where such operations are possible and look good. E.g. subtracting or comparing dates (Date objects). We’ll come across them later.

Conversion rulesIn the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.

There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.
As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.

We can implement string and numeric conversion by ourselves, using special object methods.
Now let’s get into technical details, because it’s the only way to cover the topic in-depth.
HintsHow does JavaScript decide which conversion to apply?
There are three variants of type conversion, that happen in various situations. They’re called “hints”, as described in the specification:

"string"

For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:

      
        
        
          // output
alert(obj);

// using object as a property key
anotherObj[obj] = 123;
        
      
      
      
"number"

For an object-to-number conversion, like when we’re doing maths:

      
        
        
          // explicit conversion
let num = Number(obj);

// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;

// less/greater comparison
let greater = user1 > user2;
        
      
      
      Most built-in mathematical functions also include such conversion.

"default"

Occurs in rare cases when the operator is “not sure” what type to expect.
For instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). So if a binary plus gets an object as an argument, it uses the "default" hint to convert it.
Also, if an object is compared using == with a string, number or a symbol, it’s also unclear which conversion should be done, so the "default" hint is used.

      
        
        
          // binary plus uses the "default" hint
let total = obj1 + obj2;

// obj == number uses the "default" hint
if (user == 1) { ... };
        
      
      
      The greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the "number" hint, not "default". That’s for historical reasons.


In practice though, things are a bit simpler.
All built-in objects except for one case (Date object, we’ll learn it later) implement "default" conversion the same way as "number". And we probably should do the same.
Still, it’s important to know about all 3 hints, soon we’ll see why.
To do the conversion, JavaScript tries to find and call three object methods:

Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



Symbol.toPrimitiveLet’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method, like this:

      
        
        
          obj[Symbol.toPrimitive] = function(hint) {
  // here goes the code to convert this object to a primitive
  // it must return a primitive value
  // hint = one of "string", "number", "default"
};
        
      
      
      If the method Symbol.toPrimitive exists, it’s used for all hints, and no more methods are needed.
For instance, here user object implements it:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// conversions demo:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
        
      
      
      As we can see from the code, user becomes a self-descriptive string or a money amount, depending on the conversion. The single method user[Symbol.toPrimitive] handles all conversion cases.
toString/valueOfIf there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:

For the "string" hint: call toString method, and if it doesn’t exist or if it returns an object instead of a primitive value, then call valueOf (so toString has the priority for string conversions).
For other hints: call valueOf, and if it doesn’t exist or if it returns an object instead of a primitive value, then call toString (so valueOf has the priority for maths).

Methods toString and valueOf come from ancient times. They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. They provide an alternative “old-style” way to implement the conversion.
These methods must return a primitive value. If toString or valueOf returns an object, then it’s ignored (same as if there were no method).
By default, a plain object has following toString and valueOf methods:

The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

Here’s the demo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
        
      
      
      So if we try to use an object as a string, like in an alert or so, then by default we see [object Object].
The default valueOf is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don’t ask me why, that’s for historical reasons. So we can assume it doesn’t exist.
Let’s implement these methods to customize the conversion.
For instance, here user does the same as above using a combination of toString and valueOf instead of Symbol.toPrimitive:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  // for hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // for hint="number" or "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
        
      
      
      As we can see, the behavior is the same as the previous example with Symbol.toPrimitive.
Often we want a single “catch-all” place to handle all primitive conversions. In this case, we can implement toString only, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
        
      
      
      In the absence of Symbol.toPrimitive and valueOf, toString will handle all primitive conversions.
A conversion can return any primitive typeThe important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.
There is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint "number".
The only mandatory thing: these methods must return a primitive, not an object.

            Historical notes
            For historical reasons, if toString or valueOf returns an object, there’s no error, but such value is ignored (like if the method didn’t exist). That’s because in ancient times there was no good “error” concept in JavaScript.
In contrast, Symbol.toPrimitive is stricter, it must return a primitive, otherwise there will be an error.

Further conversionsAs we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.
If we pass an object as an argument, then there are two stages of calculations:

The object is converted to a primitive (using the rules described above).
If necessary for further calculations, the resulting primitive is also converted.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  // toString handles all conversions in the absence of other methods
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, object converted to primitive "2", then multiplication made it a number
        
      
      
      
The multiplication obj * 2 first converts the object to primitive (that’s a string "2").
Then "2" * 2 becomes 2 * 2 (the string is converted to number).

Binary plus will concatenate strings in the same situation, as it gladly accepts a string:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" ("2" + 2), conversion to primitive returned a string => concatenation
        
      
      
      SummaryThe object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.
There are 3 types (hints) of it:

"string" (for alert and other operations that need a string)
"number" (for maths)
"default" (few operators, usually objects implement it the same way as "number")

The specification describes explicitly which operator uses which hint.
The conversion algorithm is:

Call obj[Symbol.toPrimitive](hint) if the method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



All these methods must return a primitive to work (if defined).
In practice, it’s often enough to implement only obj.toString() as a “catch-all” method for string conversions that should return a “human-readable” representation of an object, for logging or debugging purposes.\n\nTutorialThe JavaScript languageObjects: the basicsMarch 31, 2024Object to primitive conversionWhat happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?
JavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).
In case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.
That’s an important limitation: the result of obj1 + obj2 (or another math operation) can’t be another object!
E.g. we can’t make objects representing vectors or matrices (or achievements or whatever), add them and expect a “summed” object as the result. Such architectural feats are automatically “off the board”.
So, because we can’t technically do much here, there’s no maths with objects in real projects. When it happens, with rare exceptions, it’s because of a coding mistake.
In this chapter we’ll cover how an object converts to primitive and how to customize it.
We have two purposes:

It will allow us to understand what’s going on in case of coding mistakes, when such an operation happened accidentally.
There are exceptions, where such operations are possible and look good. E.g. subtracting or comparing dates (Date objects). We’ll come across them later.

Conversion rulesIn the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.

There’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.
The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.
As for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.

We can implement string and numeric conversion by ourselves, using special object methods.
Now let’s get into technical details, because it’s the only way to cover the topic in-depth.
HintsHow does JavaScript decide which conversion to apply?
There are three variants of type conversion, that happen in various situations. They’re called “hints”, as described in the specification:

"string"

For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:

      
        
        
          // output
alert(obj);

// using object as a property key
anotherObj[obj] = 123;
        
      
      
      
"number"

For an object-to-number conversion, like when we’re doing maths:

      
        
        
          // explicit conversion
let num = Number(obj);

// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;

// less/greater comparison
let greater = user1 > user2;
        
      
      
      Most built-in mathematical functions also include such conversion.

"default"

Occurs in rare cases when the operator is “not sure” what type to expect.
For instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). So if a binary plus gets an object as an argument, it uses the "default" hint to convert it.
Also, if an object is compared using == with a string, number or a symbol, it’s also unclear which conversion should be done, so the "default" hint is used.

      
        
        
          // binary plus uses the "default" hint
let total = obj1 + obj2;

// obj == number uses the "default" hint
if (user == 1) { ... };
        
      
      
      The greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the "number" hint, not "default". That’s for historical reasons.


In practice though, things are a bit simpler.
All built-in objects except for one case (Date object, we’ll learn it later) implement "default" conversion the same way as "number". And we probably should do the same.
Still, it’s important to know about all 3 hints, soon we’ll see why.
To do the conversion, JavaScript tries to find and call three object methods:

Call obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



Symbol.toPrimitiveLet’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method, like this:

      
        
        
          obj[Symbol.toPrimitive] = function(hint) {
  // here goes the code to convert this object to a primitive
  // it must return a primitive value
  // hint = one of "string", "number", "default"
};
        
      
      
      If the method Symbol.toPrimitive exists, it’s used for all hints, and no more methods are needed.
For instance, here user object implements it:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// conversions demo:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
        
      
      
      As we can see from the code, user becomes a self-descriptive string or a money amount, depending on the conversion. The single method user[Symbol.toPrimitive] handles all conversion cases.
toString/valueOfIf there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:

For the "string" hint: call toString method, and if it doesn’t exist or if it returns an object instead of a primitive value, then call valueOf (so toString has the priority for string conversions).
For other hints: call valueOf, and if it doesn’t exist or if it returns an object instead of a primitive value, then call toString (so valueOf has the priority for maths).

Methods toString and valueOf come from ancient times. They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. They provide an alternative “old-style” way to implement the conversion.
These methods must return a primitive value. If toString or valueOf returns an object, then it’s ignored (same as if there were no method).
By default, a plain object has following toString and valueOf methods:

The toString method returns a string "[object Object]".
The valueOf method returns the object itself.

Here’s the demo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
        
      
      
      So if we try to use an object as a string, like in an alert or so, then by default we see [object Object].
The default valueOf is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don’t ask me why, that’s for historical reasons. So we can assume it doesn’t exist.
Let’s implement these methods to customize the conversion.
For instance, here user does the same as above using a combination of toString and valueOf instead of Symbol.toPrimitive:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  // for hint="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // for hint="number" or "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
        
      
      
      As we can see, the behavior is the same as the previous example with Symbol.toPrimitive.
Often we want a single “catch-all” place to handle all primitive conversions. In this case, we can implement toString only, like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
        
      
      
      In the absence of Symbol.toPrimitive and valueOf, toString will handle all primitive conversions.
A conversion can return any primitive typeThe important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.
There is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint "number".
The only mandatory thing: these methods must return a primitive, not an object.

            Historical notes
            For historical reasons, if toString or valueOf returns an object, there’s no error, but such value is ignored (like if the method didn’t exist). That’s because in ancient times there was no good “error” concept in JavaScript.
In contrast, Symbol.toPrimitive is stricter, it must return a primitive, otherwise there will be an error.

Further conversionsAs we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.
If we pass an object as an argument, then there are two stages of calculations:

The object is converted to a primitive (using the rules described above).
If necessary for further calculations, the resulting primitive is also converted.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  // toString handles all conversions in the absence of other methods
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, object converted to primitive "2", then multiplication made it a number
        
      
      
      
The multiplication obj * 2 first converts the object to primitive (that’s a string "2").
Then "2" * 2 becomes 2 * 2 (the string is converted to number).

Binary plus will concatenate strings in the same situation, as it gladly accepts a string:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" ("2" + 2), conversion to primitive returned a string => concatenation
        
      
      
      SummaryThe object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.
There are 3 types (hints) of it:

"string" (for alert and other operations that need a string)
"number" (for maths)
"default" (few operators, usually objects implement it the same way as "number")

The specification describes explicitly which operator uses which hint.
The conversion algorithm is:

Call obj[Symbol.toPrimitive](hint) if the method exists,
Otherwise if hint is "string"

try calling obj.toString() or obj.valueOf(), whatever exists.


Otherwise if hint is "number" or "default"

try calling obj.valueOf() or obj.toString(), whatever exists.



All these methods must return a primitive to work (if defined).
In practice, it’s often enough to implement only obj.toString() as a “catch-all” method for string conversions that should return a “human-readable” representation of an object, for logging or debugging purposes.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTutorialThe JavaScript languageData typesMore data structures and more in-depth study of the types.
Methods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONPrevious lessonNext lessonShareTutorial map\n\nMore data structures and more in-depth study of the types.
Methods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSON\n\nTutorialThe JavaScript languageData typesMore data structures and more in-depth study of the types.
Methods of primitivesNumbersStringsArraysArray methodsIterablesMap and SetWeakMap and WeakSetObject.keys, values, entriesDestructuring assignmentDate and timeJSON methods, toJSONPrevious lessonNext lessonShareTutorial map\n\n\n\nJavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such. We will study those soon, but first we’ll see how it works because, of course, primitives are not objects (and here we will make it even clearer).
Let’s look at the key distinctions between primitives and objects.
A primitive

Is a value of a primitive type.
There are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

An object

Is capable of storing multiple values as properties.
Can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.

One of the best things about objects is that we can store a function as one of its properties.

      
        
        
          
            
          
          
            
          
        
        
          let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
        
      
      
      So here we’ve made an object john with the method sayHi.
Many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.
But, these features come with a cost!
Objects are “heavier” than primitives. They require additional resources to support the internal machinery.
A primitive as an objectHere’s the paradox faced by the creator of JavaScript:

There are many things one would want to do with a primitive, like a string or a number. It would be great to access them using methods.
Primitives must be as fast and lightweight as possible.

The solution looks a little bit awkward, but here it is:

Primitives are still primitive. A single value, as desired.
The language allows access to methods and properties of strings, numbers, booleans and symbols.
In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.

The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.
For instance, there exists a string method str.toUpperCase() that returns a capitalized str.
Here’s how it works:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

alert( str.toUpperCase() ); // HELLO
        
      
      
      Simple, right? Here’s what actually happens in str.toUpperCase():

The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
That method runs and returns a new string (shown by alert).
The special object is destroyed, leaving the primitive str alone.

So primitives can provide methods, but they still remain lightweight.
The JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.
A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:

      
        
        
          
            
          
          
            
          
        
        
          let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
        
      
      
      We’ll see more specific methods in chapters Numbers and Strings.

            Constructors String/Number/Boolean are for internal use only
            Some languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false).
In JavaScript, that’s also possible for historical reasons, but highly unrecommended. Things will go crazy in several places.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
        
      
      
      Objects are always truthy in if, so here the alert will show up:

      
        
        
          
            
          
          
            
          
        
        
          let zero = new Number(0);

if (zero) { // zero is true, because it's an object
  alert( "zero is truthy!?!" );
}
        
      
      
      On the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).
For example, this is entirely valid:

      
        
        
          let num = Number("123"); // convert a string to number
        
      
      
      

            null/undefined have no methods
            The special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods. In a sense, they are “the most primitive”.
An attempt to access a property of such value would give the error:

      
        
        
          
            
          
          
            
          
        
        
          alert(null.test); // error
        
      
      
      
Summary
Primitives except null and undefined provide many helpful methods. We will study those in the upcoming chapters.
Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.\n\nTutorialThe JavaScript languageData typesJune 12, 2022Methods of primitivesJavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such. We will study those soon, but first we’ll see how it works because, of course, primitives are not objects (and here we will make it even clearer).
Let’s look at the key distinctions between primitives and objects.
A primitive

Is a value of a primitive type.
There are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

An object

Is capable of storing multiple values as properties.
Can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.

One of the best things about objects is that we can store a function as one of its properties.

      
        
        
          
            
          
          
            
          
        
        
          let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
        
      
      
      So here we’ve made an object john with the method sayHi.
Many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.
But, these features come with a cost!
Objects are “heavier” than primitives. They require additional resources to support the internal machinery.
A primitive as an objectHere’s the paradox faced by the creator of JavaScript:

There are many things one would want to do with a primitive, like a string or a number. It would be great to access them using methods.
Primitives must be as fast and lightweight as possible.

The solution looks a little bit awkward, but here it is:

Primitives are still primitive. A single value, as desired.
The language allows access to methods and properties of strings, numbers, booleans and symbols.
In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.

The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.
For instance, there exists a string method str.toUpperCase() that returns a capitalized str.
Here’s how it works:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

alert( str.toUpperCase() ); // HELLO
        
      
      
      Simple, right? Here’s what actually happens in str.toUpperCase():

The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
That method runs and returns a new string (shown by alert).
The special object is destroyed, leaving the primitive str alone.

So primitives can provide methods, but they still remain lightweight.
The JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.
A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:

      
        
        
          
            
          
          
            
          
        
        
          let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
        
      
      
      We’ll see more specific methods in chapters Numbers and Strings.

            Constructors String/Number/Boolean are for internal use only
            Some languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false).
In JavaScript, that’s also possible for historical reasons, but highly unrecommended. Things will go crazy in several places.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
        
      
      
      Objects are always truthy in if, so here the alert will show up:

      
        
        
          
            
          
          
            
          
        
        
          let zero = new Number(0);

if (zero) { // zero is true, because it's an object
  alert( "zero is truthy!?!" );
}
        
      
      
      On the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).
For example, this is entirely valid:

      
        
        
          let num = Number("123"); // convert a string to number
        
      
      
      

            null/undefined have no methods
            The special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods. In a sense, they are “the most primitive”.
An attempt to access a property of such value would give the error:

      
        
        
          
            
          
          
            
          
        
        
          alert(null.test); // error
        
      
      
      
Summary
Primitives except null and undefined provide many helpful methods. We will study those in the upcoming chapters.
Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.

TasksCan I add a string property?importance: 5Consider the following code:

      
        
        
          let str = "Hello";

str.test = 5;

alert(str.test);
        
      
      
      What do you think, will it work? What will be shown?
solutionTry running it:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

str.test = 5; // (*)

alert(str.test);
        
      
      
      Depending on whether you have use strict or not, the result may be:

undefined (no strict mode)
An error (strict mode).

Why? Let’s replay what’s happening at line (*):

When a property of str is accessed, a “wrapper object” is created.
In strict mode, writing into it is an error.
Otherwise, the operation with the property is carried on, the object gets the test property, but after that the “wrapper object” disappears, so in the last line str has no trace of the property.

This example clearly shows that primitives are not objects.
They can’t store additional data.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nJavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such. We will study those soon, but first we’ll see how it works because, of course, primitives are not objects (and here we will make it even clearer).
Let’s look at the key distinctions between primitives and objects.
A primitive

Is a value of a primitive type.
There are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

An object

Is capable of storing multiple values as properties.
Can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.

One of the best things about objects is that we can store a function as one of its properties.

      
        
        
          
            
          
          
            
          
        
        
          let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
        
      
      
      So here we’ve made an object john with the method sayHi.
Many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.
But, these features come with a cost!
Objects are “heavier” than primitives. They require additional resources to support the internal machinery.
A primitive as an objectHere’s the paradox faced by the creator of JavaScript:

There are many things one would want to do with a primitive, like a string or a number. It would be great to access them using methods.
Primitives must be as fast and lightweight as possible.

The solution looks a little bit awkward, but here it is:

Primitives are still primitive. A single value, as desired.
The language allows access to methods and properties of strings, numbers, booleans and symbols.
In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.

The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.
For instance, there exists a string method str.toUpperCase() that returns a capitalized str.
Here’s how it works:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

alert( str.toUpperCase() ); // HELLO
        
      
      
      Simple, right? Here’s what actually happens in str.toUpperCase():

The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
That method runs and returns a new string (shown by alert).
The special object is destroyed, leaving the primitive str alone.

So primitives can provide methods, but they still remain lightweight.
The JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.
A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:

      
        
        
          
            
          
          
            
          
        
        
          let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
        
      
      
      We’ll see more specific methods in chapters Numbers and Strings.

            Constructors String/Number/Boolean are for internal use only
            Some languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false).
In JavaScript, that’s also possible for historical reasons, but highly unrecommended. Things will go crazy in several places.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
        
      
      
      Objects are always truthy in if, so here the alert will show up:

      
        
        
          
            
          
          
            
          
        
        
          let zero = new Number(0);

if (zero) { // zero is true, because it's an object
  alert( "zero is truthy!?!" );
}
        
      
      
      On the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).
For example, this is entirely valid:

      
        
        
          let num = Number("123"); // convert a string to number
        
      
      
      

            null/undefined have no methods
            The special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods. In a sense, they are “the most primitive”.
An attempt to access a property of such value would give the error:

      
        
        
          
            
          
          
            
          
        
        
          alert(null.test); // error
        
      
      
      
Summary
Primitives except null and undefined provide many helpful methods. We will study those in the upcoming chapters.
Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.

TasksCan I add a string property?importance: 5Consider the following code:

      
        
        
          let str = "Hello";

str.test = 5;

alert(str.test);
        
      
      
      What do you think, will it work? What will be shown?
solutionTry running it:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

str.test = 5; // (*)

alert(str.test);
        
      
      
      Depending on whether you have use strict or not, the result may be:

undefined (no strict mode)
An error (strict mode).

Why? Let’s replay what’s happening at line (*):

When a property of str is accessed, a “wrapper object” is created.
In strict mode, writing into it is an error.
Otherwise, the operation with the property is carried on, the object gets the test property, but after that the “wrapper object” disappears, so in the last line str has no trace of the property.

This example clearly shows that primitives are not objects.
They can’t store additional data.\n\nTutorialThe JavaScript languageData typesJune 12, 2022Methods of primitivesJavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such. We will study those soon, but first we’ll see how it works because, of course, primitives are not objects (and here we will make it even clearer).
Let’s look at the key distinctions between primitives and objects.
A primitive

Is a value of a primitive type.
There are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.

An object

Is capable of storing multiple values as properties.
Can be created with {}, for instance: {name: "John", age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.

One of the best things about objects is that we can store a function as one of its properties.

      
        
        
          
            
          
          
            
          
        
        
          let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
        
      
      
      So here we’ve made an object john with the method sayHi.
Many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.
But, these features come with a cost!
Objects are “heavier” than primitives. They require additional resources to support the internal machinery.
A primitive as an objectHere’s the paradox faced by the creator of JavaScript:

There are many things one would want to do with a primitive, like a string or a number. It would be great to access them using methods.
Primitives must be as fast and lightweight as possible.

The solution looks a little bit awkward, but here it is:

Primitives are still primitive. A single value, as desired.
The language allows access to methods and properties of strings, numbers, booleans and symbols.
In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.

The “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.
For instance, there exists a string method str.toUpperCase() that returns a capitalized str.
Here’s how it works:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

alert( str.toUpperCase() ); // HELLO
        
      
      
      Simple, right? Here’s what actually happens in str.toUpperCase():

The string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().
That method runs and returns a new string (shown by alert).
The special object is destroyed, leaving the primitive str alone.

So primitives can provide methods, but they still remain lightweight.
The JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.
A number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:

      
        
        
          
            
          
          
            
          
        
        
          let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
        
      
      
      We’ll see more specific methods in chapters Numbers and Strings.

            Constructors String/Number/Boolean are for internal use only
            Some languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false).
In JavaScript, that’s also possible for historical reasons, but highly unrecommended. Things will go crazy in several places.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
        
      
      
      Objects are always truthy in if, so here the alert will show up:

      
        
        
          
            
          
          
            
          
        
        
          let zero = new Number(0);

if (zero) { // zero is true, because it's an object
  alert( "zero is truthy!?!" );
}
        
      
      
      On the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).
For example, this is entirely valid:

      
        
        
          let num = Number("123"); // convert a string to number
        
      
      
      

            null/undefined have no methods
            The special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods. In a sense, they are “the most primitive”.
An attempt to access a property of such value would give the error:

      
        
        
          
            
          
          
            
          
        
        
          alert(null.test); // error
        
      
      
      
Summary
Primitives except null and undefined provide many helpful methods. We will study those in the upcoming chapters.
Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.

TasksCan I add a string property?importance: 5Consider the following code:

      
        
        
          let str = "Hello";

str.test = 5;

alert(str.test);
        
      
      
      What do you think, will it work? What will be shown?
solutionTry running it:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

str.test = 5; // (*)

alert(str.test);
        
      
      
      Depending on whether you have use strict or not, the result may be:

undefined (no strict mode)
An error (strict mode).

Why? Let’s replay what’s happening at line (*):

When a property of str is accessed, a “wrapper object” is created.
In strict mode, writing into it is an error.
Otherwise, the operation with the property is carried on, the object gets the test property, but after that the “wrapper object” disappears, so in the last line str has no trace of the property.

This example clearly shows that primitives are not objects.
They can’t store additional data.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nIn modern JavaScript, there are two types of numbers:


Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.


BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in a few special areas, we devote them to a special chapter BigInt.


So here we’ll talk about regular numbers. Let’s expand our knowledge of them.
More ways to write a numberImagine we need to write 1 billion. The obvious way is:

      
        
        
          let billion = 1000000000;
        
      
      
      We also can use underscore _ as the separator:

      
        
        
          let billion = 1_000_000_000;
        
      
      
      Here the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.
In real life though, we try to avoid writing long sequences of zeroes. We’re too lazy for that. We’ll try to write something like "1bn" for a billion or "7.3bn" for 7 billion 300 million. The same is true for most large numbers.
In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:

      
        
        
          
            
          
          
            
          
        
        
          let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)
        
      
      
      In other words, e multiplies the number by 1 with the given zeroes count.

      
        
        
          1e3 === 1 * 1000; // e3 means *1000
1.23e6 === 1.23 * 1000000; // e6 means *1000000
        
      
      
      Now let’s write something very small. Say, 1 microsecond (one-millionth of a second):

      
        
        
          let mсs = 0.000001;
        
      
      
      Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:

      
        
        
          let mcs = 1e-6; // five zeroes to the left from 1
        
      
      
      If we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.
In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

      
        
        
          // -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001

// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123

// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times
        
      
      
      Hex, binary and octal numbersHexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
        
      
      
      Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
        
      
      
      There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt (which we will see later in this chapter).
toString(base)The method num.toString(base) returns a string representation of num in the numeral system with the given base.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
        
      
      
      The base can vary from 2 to 36. By default, it’s 10.
Common use cases for this are:


base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.


base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.


base=36 is the maximum, digits can be 0..9 or A..Z. The whole Latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example, to make a short url. Can simply represent it in the numeral system with base 36:

      
        
        
          
            
          
          
            
          
        
        
          alert( 123456..toString(36) ); // 2n9c
        
      
      
      


            Two dots to call a method
            Please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.
If we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now uses the method.
Also could write (123456).toString(36).

RoundingOne of the most used operations when working with numbers is rounding.
There are several built-in functions for rounding:

Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4. In the middle cases 3.5 rounds up to 4, and -3.5 rounds up to -3.
Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

Here’s the table to summarize the differences between them:




Math.floor
Math.ceil
Math.round
Math.trunc




3.1
3
4
3
3


3.5
3
4
4
3


3.6
3
4
4
3


-1.1
-2
-1
-1
-1


-1.5
-2
-1
-1
-1


-1.6
-2
-1
-2
-1



These functions cover all of the possible ways to deal with the decimal part of a number. But what if we’d like to round the number to n-th digit after the decimal?
For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.
There are two ways to do so:


Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.

      
        
        
          
            
          
          
            
          
        
        
          let num = 1.23456;

alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
        
      
      
      

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
        
      
      
      This rounds up or down to the nearest value, similar to Math.round:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
        
      
      
      Please note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
        
      
      
      We can convert it to a number using the unary plus or a Number() call, e.g. write +num.toFixed(5).


Imprecise calculationsInternally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.
If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1e500 ); // Infinity
        
      
      
      What may be a little less obvious, but happens quite often, is the loss of precision.
Consider this (falsy!) equality test:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 == 0.3 ); // false
        
      
      
      That’s right, if we check whether the sum of 0.1 and 0.2 is 0.3, we get false.
Strange! What is it then if not 0.3?

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 ); // 0.30000000000000004
        
      
      
      Ouch! Imagine you’re making an e-shopping site and the visitor puts $0.10 and $0.20 goods into their cart. The order total will be $0.30000000000000004. That would surprise anyone.
But why does this happen?
A number is stored in memory in its binary form, a sequence of bits – ones and zeroes. But fractions like 0.1, 0.2 that look simple in the decimal numeric system are actually unending fractions in their binary form.

      
        
        
          
            
          
          
            
          
        
        
          alert(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(0.2.toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101
        
      
      
      What is 0.1? It is one divided by ten 1/10, one-tenth. In the decimal numeral system, such numbers are easily representable. Compare it to one-third: 1/3. It becomes an endless fraction 0.33333(3).
So, division by powers 10 is guaranteed to work well in the decimal system, but division by 3 is not. For the same reason, in the binary numeral system, the division by powers of 2 is guaranteed to work, but 1/10 becomes an endless binary fraction.
There’s just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.
The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists.
We can see this in action:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1.toFixed(20) ); // 0.10000000000000000555
        
      
      
      And when we sum two numbers, their “precision losses” add up.
That’s why 0.1 + 0.2 is not exactly 0.3.

            Not only JavaScript
            The same issue exists in many other programming languages.
PHP, Java, C, Perl, and Ruby give exactly the same result, because they are based on the same numeric format.

Can we work around the problem? Sure, the most reliable method is to round the result with the help of a method toFixed(n):

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
        
      
      
      Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. That’s actually convenient if we have an e-shopping and need to show $0.30. For other cases, we can use the unary plus to coerce it into a number:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
        
      
      
      We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:

      
        
        
          
            
          
          
            
          
        
        
          alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        
      
      
      So, the multiply/divide approach reduces the error, but doesn’t remove it totally.
Sometimes we could try to evade fractions at all. Like if we’re dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut “tails” when needed.

            The funny thing
            Try running this:

      
        
        
          
            
          
          
            
          
        
        
          // Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000
        
      
      
      This suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. So the least significant digits disappear.
JavaScript doesn’t trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.


            Two zeroes
            Another funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.
That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.
In most cases, the distinction is unnoticeable, because operators are suited to treat them as the same.

Tests: isFinite and isNaNRemember these two special numeric values?

Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
NaN represents an error.

They belong to the type number, but are not “normal” numbers, so there are special functions to check for them:


isNaN(value) converts its argument to a number and then tests it for being NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
        
      
      
      But do we need this function? Can’t we just use the comparison === NaN? Unfortunately not. The value NaN is unique in that it does not equal anything, including itself:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN === NaN ); // false
        
      
      
      

isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity
        
      
      
      

Sometimes isFinite is used to validate whether a string value is a regular number:

      
        
        
          
            
          
          
            
          
        
        
          let num = +prompt("Enter a number", '');

// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num) );
        
      
      
      Please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

            Number.isNaN and Number.isFinite
            Number.isNaN and Number.isFinite methods are the more “strict” versions of isNaN and isFinite functions. They do not autoconvert their argument into a number, but check if it belongs to the number type instead.


Number.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Note the difference:
alert( Number.isNaN("str") ); // false, because "str" belongs to the string type, not the number type
alert( isNaN("str") ); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion
        
      
      
      

Number.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); // false
alert( Number.isFinite(2 / 0) ); // false

// Note the difference:
alert( Number.isFinite("123") ); // false, because "123" belongs to the string type, not the number type
alert( isFinite("123") ); // true, because isFinite converts string "123" into a number 123
        
      
      
      

In a way, Number.isNaN and Number.isFinite are simpler and more straightforward than isNaN and isFinite functions. In practice though, isNaN and isFinite are mostly used, as they’re shorter to write.


            Comparison with Object.is
            There is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:

It works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.
Values 0 and -0 are different: Object.is(0, -0) === false, technically that’s correct because internally the number has a sign bit that may be different even if all other bits are zeroes.

In all other cases, Object.is(a, b) is the same as a === b.
We mention Object.is here, because it’s often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

parseInt and parseFloatNumeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:

      
        
        
          
            
          
          
            
          
        
        
          alert( +"100px" ); // NaN
        
      
      
      The sole exception is spaces at the beginning or at the end of the string, as they are ignored.
But in real life, we often have values in units, like "100px" or "12pt" in CSS. Also in many countries, the currency symbol goes after the amount, so we have "19€" and would like to extract a numeric value out of that.
That’s what parseInt and parseFloat are for.
They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The function parseInt returns an integer, whilst parseFloat will return a floating-point number:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading
        
      
      
      There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('a123') ); // NaN, the first symbol stops the process
        
      
      
      
            The second argument of parseInt(str, radix)
            The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works

alert( parseInt('2n9c', 36) ); // 123456
        
      
      
      
Other math functionsJavaScript has a built-in Math object which contains a small library of mathematical functions and constants.
A few examples:

Math.random()

Returns a random number from 0 to 1 (not including 1).

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (any random numbers)
        
      
      
      
Math.max(a, b, c...) and Math.min(a, b, c...)

Returns the greatest and smallest from the arbitrary number of arguments.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
        
      
      
      
Math.pow(n, power)

Returns n raised to the given power.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
        
      
      
      

There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.
SummaryTo write numbers with many zeroes:

Append "e" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.
A negative number after "e" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).

For different numeral systems:

Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.
parseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.
num.toString(base) converts a number to a string in the numeral system with the given base.

For regular number tests:

isNaN(value) converts its argument to a number and then tests it for being NaN
Number.isNaN(value) checks whether its argument belongs to the number type, and if so, tests it for being NaN
isFinite(value) converts its argument to a number and then tests it for not being NaN/Infinity/-Infinity
Number.isFinite(value) checks whether its argument belongs to the number type, and if so, tests it for not being NaN/Infinity/-Infinity

For converting values like 12pt and 100px to a number:

Use parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).
Make sure to remember there’s a loss of precision when working with fractions.

More mathematical functions:

See the Math object when you need them. The library is very small but can cover basic needs.\n\nTutorialThe JavaScript languageData typesDecember 18, 2024NumbersIn modern JavaScript, there are two types of numbers:


Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.


BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in a few special areas, we devote them to a special chapter BigInt.


So here we’ll talk about regular numbers. Let’s expand our knowledge of them.
More ways to write a numberImagine we need to write 1 billion. The obvious way is:

      
        
        
          let billion = 1000000000;
        
      
      
      We also can use underscore _ as the separator:

      
        
        
          let billion = 1_000_000_000;
        
      
      
      Here the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.
In real life though, we try to avoid writing long sequences of zeroes. We’re too lazy for that. We’ll try to write something like "1bn" for a billion or "7.3bn" for 7 billion 300 million. The same is true for most large numbers.
In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:

      
        
        
          
            
          
          
            
          
        
        
          let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)
        
      
      
      In other words, e multiplies the number by 1 with the given zeroes count.

      
        
        
          1e3 === 1 * 1000; // e3 means *1000
1.23e6 === 1.23 * 1000000; // e6 means *1000000
        
      
      
      Now let’s write something very small. Say, 1 microsecond (one-millionth of a second):

      
        
        
          let mсs = 0.000001;
        
      
      
      Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:

      
        
        
          let mcs = 1e-6; // five zeroes to the left from 1
        
      
      
      If we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.
In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

      
        
        
          // -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001

// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123

// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times
        
      
      
      Hex, binary and octal numbersHexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
        
      
      
      Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
        
      
      
      There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt (which we will see later in this chapter).
toString(base)The method num.toString(base) returns a string representation of num in the numeral system with the given base.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
        
      
      
      The base can vary from 2 to 36. By default, it’s 10.
Common use cases for this are:


base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.


base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.


base=36 is the maximum, digits can be 0..9 or A..Z. The whole Latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example, to make a short url. Can simply represent it in the numeral system with base 36:

      
        
        
          
            
          
          
            
          
        
        
          alert( 123456..toString(36) ); // 2n9c
        
      
      
      


            Two dots to call a method
            Please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.
If we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now uses the method.
Also could write (123456).toString(36).

RoundingOne of the most used operations when working with numbers is rounding.
There are several built-in functions for rounding:

Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4. In the middle cases 3.5 rounds up to 4, and -3.5 rounds up to -3.
Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

Here’s the table to summarize the differences between them:




Math.floor
Math.ceil
Math.round
Math.trunc




3.1
3
4
3
3


3.5
3
4
4
3


3.6
3
4
4
3


-1.1
-2
-1
-1
-1


-1.5
-2
-1
-1
-1


-1.6
-2
-1
-2
-1



These functions cover all of the possible ways to deal with the decimal part of a number. But what if we’d like to round the number to n-th digit after the decimal?
For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.
There are two ways to do so:


Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.

      
        
        
          
            
          
          
            
          
        
        
          let num = 1.23456;

alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
        
      
      
      

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
        
      
      
      This rounds up or down to the nearest value, similar to Math.round:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
        
      
      
      Please note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
        
      
      
      We can convert it to a number using the unary plus or a Number() call, e.g. write +num.toFixed(5).


Imprecise calculationsInternally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.
If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1e500 ); // Infinity
        
      
      
      What may be a little less obvious, but happens quite often, is the loss of precision.
Consider this (falsy!) equality test:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 == 0.3 ); // false
        
      
      
      That’s right, if we check whether the sum of 0.1 and 0.2 is 0.3, we get false.
Strange! What is it then if not 0.3?

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 ); // 0.30000000000000004
        
      
      
      Ouch! Imagine you’re making an e-shopping site and the visitor puts $0.10 and $0.20 goods into their cart. The order total will be $0.30000000000000004. That would surprise anyone.
But why does this happen?
A number is stored in memory in its binary form, a sequence of bits – ones and zeroes. But fractions like 0.1, 0.2 that look simple in the decimal numeric system are actually unending fractions in their binary form.

      
        
        
          
            
          
          
            
          
        
        
          alert(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(0.2.toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101
        
      
      
      What is 0.1? It is one divided by ten 1/10, one-tenth. In the decimal numeral system, such numbers are easily representable. Compare it to one-third: 1/3. It becomes an endless fraction 0.33333(3).
So, division by powers 10 is guaranteed to work well in the decimal system, but division by 3 is not. For the same reason, in the binary numeral system, the division by powers of 2 is guaranteed to work, but 1/10 becomes an endless binary fraction.
There’s just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.
The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists.
We can see this in action:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1.toFixed(20) ); // 0.10000000000000000555
        
      
      
      And when we sum two numbers, their “precision losses” add up.
That’s why 0.1 + 0.2 is not exactly 0.3.

            Not only JavaScript
            The same issue exists in many other programming languages.
PHP, Java, C, Perl, and Ruby give exactly the same result, because they are based on the same numeric format.

Can we work around the problem? Sure, the most reliable method is to round the result with the help of a method toFixed(n):

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
        
      
      
      Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. That’s actually convenient if we have an e-shopping and need to show $0.30. For other cases, we can use the unary plus to coerce it into a number:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
        
      
      
      We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:

      
        
        
          
            
          
          
            
          
        
        
          alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        
      
      
      So, the multiply/divide approach reduces the error, but doesn’t remove it totally.
Sometimes we could try to evade fractions at all. Like if we’re dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut “tails” when needed.

            The funny thing
            Try running this:

      
        
        
          
            
          
          
            
          
        
        
          // Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000
        
      
      
      This suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. So the least significant digits disappear.
JavaScript doesn’t trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.


            Two zeroes
            Another funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.
That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.
In most cases, the distinction is unnoticeable, because operators are suited to treat them as the same.

Tests: isFinite and isNaNRemember these two special numeric values?

Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
NaN represents an error.

They belong to the type number, but are not “normal” numbers, so there are special functions to check for them:


isNaN(value) converts its argument to a number and then tests it for being NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
        
      
      
      But do we need this function? Can’t we just use the comparison === NaN? Unfortunately not. The value NaN is unique in that it does not equal anything, including itself:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN === NaN ); // false
        
      
      
      

isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity
        
      
      
      

Sometimes isFinite is used to validate whether a string value is a regular number:

      
        
        
          
            
          
          
            
          
        
        
          let num = +prompt("Enter a number", '');

// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num) );
        
      
      
      Please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

            Number.isNaN and Number.isFinite
            Number.isNaN and Number.isFinite methods are the more “strict” versions of isNaN and isFinite functions. They do not autoconvert their argument into a number, but check if it belongs to the number type instead.


Number.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Note the difference:
alert( Number.isNaN("str") ); // false, because "str" belongs to the string type, not the number type
alert( isNaN("str") ); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion
        
      
      
      

Number.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); // false
alert( Number.isFinite(2 / 0) ); // false

// Note the difference:
alert( Number.isFinite("123") ); // false, because "123" belongs to the string type, not the number type
alert( isFinite("123") ); // true, because isFinite converts string "123" into a number 123
        
      
      
      

In a way, Number.isNaN and Number.isFinite are simpler and more straightforward than isNaN and isFinite functions. In practice though, isNaN and isFinite are mostly used, as they’re shorter to write.


            Comparison with Object.is
            There is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:

It works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.
Values 0 and -0 are different: Object.is(0, -0) === false, technically that’s correct because internally the number has a sign bit that may be different even if all other bits are zeroes.

In all other cases, Object.is(a, b) is the same as a === b.
We mention Object.is here, because it’s often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

parseInt and parseFloatNumeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:

      
        
        
          
            
          
          
            
          
        
        
          alert( +"100px" ); // NaN
        
      
      
      The sole exception is spaces at the beginning or at the end of the string, as they are ignored.
But in real life, we often have values in units, like "100px" or "12pt" in CSS. Also in many countries, the currency symbol goes after the amount, so we have "19€" and would like to extract a numeric value out of that.
That’s what parseInt and parseFloat are for.
They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The function parseInt returns an integer, whilst parseFloat will return a floating-point number:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading
        
      
      
      There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('a123') ); // NaN, the first symbol stops the process
        
      
      
      
            The second argument of parseInt(str, radix)
            The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works

alert( parseInt('2n9c', 36) ); // 123456
        
      
      
      
Other math functionsJavaScript has a built-in Math object which contains a small library of mathematical functions and constants.
A few examples:

Math.random()

Returns a random number from 0 to 1 (not including 1).

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (any random numbers)
        
      
      
      
Math.max(a, b, c...) and Math.min(a, b, c...)

Returns the greatest and smallest from the arbitrary number of arguments.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
        
      
      
      
Math.pow(n, power)

Returns n raised to the given power.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
        
      
      
      

There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.
SummaryTo write numbers with many zeroes:

Append "e" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.
A negative number after "e" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).

For different numeral systems:

Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.
parseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.
num.toString(base) converts a number to a string in the numeral system with the given base.

For regular number tests:

isNaN(value) converts its argument to a number and then tests it for being NaN
Number.isNaN(value) checks whether its argument belongs to the number type, and if so, tests it for being NaN
isFinite(value) converts its argument to a number and then tests it for not being NaN/Infinity/-Infinity
Number.isFinite(value) checks whether its argument belongs to the number type, and if so, tests it for not being NaN/Infinity/-Infinity

For converting values like 12pt and 100px to a number:

Use parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).
Make sure to remember there’s a loss of precision when working with fractions.

More mathematical functions:

See the Math object when you need them. The library is very small but can cover basic needs.

TasksSum numbers from the visitorimportance: 5Create a script that prompts the visitor to enter two numbers and then shows their sum.
Run the demoP.S. There is a gotcha with types.
solution
      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("The first number?", "");
let b = +prompt("The second number?", "");

alert( a + b );
        
      
      
      Note the unary plus + before prompt. It immediately converts the value to a number.
Otherwise, a and b would be string their sum would be their concatenation, that is: "1" + "2" = "12".
Why 6.35.toFixed(1) == 6.3?importance: 4According to the documentation Math.round and toFixed both round to the nearest number: 0..4 lead down while 5..9 lead up.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(1) ); // 1.4
        
      
      
      In the similar example below, why is 6.35 rounded to 6.3, not 6.4?

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(1) ); // 6.3
        
      
      
      How to round 6.35 the right way?
solutionInternally the decimal fraction 6.35 is an endless binary. As always in such cases, it is stored with a precision loss.
Let’s see:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(20) ); // 6.34999999999999964473
        
      
      
      The precision loss can cause both increase and decrease of a number. In this particular case the number becomes a tiny bit less, that’s why it rounded down.
And what’s for 1.35?

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(20) ); // 1.35000000000000008882
        
      
      
      Here the precision loss made the number a little bit greater, so it rounded up.
How can we fix the problem with 6.35 if we want it to be rounded the right way?
We should bring it closer to an integer prior to rounding:

      
        
        
          
            
          
          
            
          
        
        
          alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
        
      
      
      Note that 63.5 has no precision loss at all. That’s because the decimal part 0.5 is actually 1/2. Fractions divided by powers of 2 are exactly represented in the binary system, now we can round it:

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
        
      
      
      Repeat until the input is a numberimportance: 5Create a function readNumber which prompts for a number until the visitor enters a valid numeric value.
The resulting value must be returned as a number.
The visitor can also stop the process by entering an empty line or pressing “CANCEL”. In that case, the function should return null.
Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function readNumber() {
  let num;

  do {
    num = prompt("Enter a number please?", 0);
  } while ( !isFinite(num) );

  if (num === null || num === '') return null;

  return +num;
}

alert(`Read: ${readNumber()}`);
        
      
      
      The solution is a little bit more intricate that it could be because we need to handle null/empty lines.
So we actually accept the input until it is a “regular number”. Both null (cancel) and empty line also fit that condition, because in numeric form they are 0.
After we stopped, we need to treat null and empty line specially (return null), because converting them to a number would return 0.
Open the solution with tests in a sandbox.An occasional infinite loopimportance: 4This loop is infinite. It never ends. Why?

      
        
        
          let i = 0;
while (i != 10) {
  i += 0.2;
}
        
      
      
      solutionThat’s because i would never equal 10.
Run it to see the real values of i:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) alert( i );
}
        
      
      
      None of them is exactly 10.
Such things happen because of the precision losses when adding fractions like 0.2.
Conclusion: evade equality checks when working with decimal fractions.
A random number from min to maximportance: 2The built-in function Math.random() creates a random value from 0 to 1 (not including 1).
Write the function random(min, max) to generate a random floating-point number from min to max (not including max).
Examples of its work:

      
        
        
          alert( random(1, 5) ); // 1.2345623452
alert( random(1, 5) ); // 3.7894332423
alert( random(1, 5) ); // 4.3435234525
        
      
      
      solutionWe need to “map” all values from the interval 0…1 into values from min to max.
That can be done in two stages:

If we multiply a random number from 0…1 by max-min, then the interval of possible values increases 0..1 to 0..max-min.
Now if we add min, the possible interval becomes from min to max.

The function:

      
        
        
          
            
          
          
            
          
        
        
          function random(min, max) {
  return min + Math.random() * (max - min);
}

alert( random(1, 5) );
alert( random(1, 5) );
alert( random(1, 5) );
        
      
      
      A random integer from min to maximportance: 2Create a function randomInteger(min, max) that generates a random integer number from min to max including both min and max as possible values.
Any number from the interval min..max must appear with the same probability.
Examples of its work:

      
        
        
          alert( randomInteger(1, 5) ); // 1
alert( randomInteger(1, 5) ); // 3
alert( randomInteger(1, 5) ); // 5
        
      
      
      You can use the solution of the previous task as the base.
solutionThe simple but wrong solutionThe simple but wrong solutionThe simplest, but wrong solution would be to generate a value from min to max and round it:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  let rand = min + Math.random() * (max - min);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      The function works, but it is incorrect. The probability to get edge values min and max is two times less than any other.
If you run the example above many times, you would easily see that 2 appears the most often.
That happens because Math.round() gets random numbers from the interval 1..3 and rounds them as follows:

      
        
        
          values from 1    ... to 1.4999999999  become 1
values from 1.5  ... to 2.4999999999  become 2
values from 2.5  ... to 2.9999999999  become 3
        
      
      
      Now we can clearly see that 1 gets twice less values than 2. And the same with 3.
The correct solutionThe correct solutionThere are many correct solutions to the task. One of them is to adjust interval borders. To ensure the same intervals, we can generate values from 0.5 to 3.5, thus adding the required probabilities to the edges:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // now rand is from  (min-0.5) to (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      An alternative way could be to use Math.floor for a random number from min to max+1:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // here rand is from min to (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      Now all intervals are mapped this way:

      
        
        
          values from 1  ... to 1.9999999999  become 1
values from 2  ... to 2.9999999999  become 2
values from 3  ... to 3.9999999999  become 3
        
      
      
      All intervals have the same length, making the final distribution uniform.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nIn modern JavaScript, there are two types of numbers:


Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.


BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in a few special areas, we devote them to a special chapter BigInt.


So here we’ll talk about regular numbers. Let’s expand our knowledge of them.
More ways to write a numberImagine we need to write 1 billion. The obvious way is:

      
        
        
          let billion = 1000000000;
        
      
      
      We also can use underscore _ as the separator:

      
        
        
          let billion = 1_000_000_000;
        
      
      
      Here the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.
In real life though, we try to avoid writing long sequences of zeroes. We’re too lazy for that. We’ll try to write something like "1bn" for a billion or "7.3bn" for 7 billion 300 million. The same is true for most large numbers.
In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:

      
        
        
          
            
          
          
            
          
        
        
          let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)
        
      
      
      In other words, e multiplies the number by 1 with the given zeroes count.

      
        
        
          1e3 === 1 * 1000; // e3 means *1000
1.23e6 === 1.23 * 1000000; // e6 means *1000000
        
      
      
      Now let’s write something very small. Say, 1 microsecond (one-millionth of a second):

      
        
        
          let mсs = 0.000001;
        
      
      
      Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:

      
        
        
          let mcs = 1e-6; // five zeroes to the left from 1
        
      
      
      If we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.
In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

      
        
        
          // -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001

// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123

// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times
        
      
      
      Hex, binary and octal numbersHexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
        
      
      
      Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
        
      
      
      There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt (which we will see later in this chapter).
toString(base)The method num.toString(base) returns a string representation of num in the numeral system with the given base.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
        
      
      
      The base can vary from 2 to 36. By default, it’s 10.
Common use cases for this are:


base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.


base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.


base=36 is the maximum, digits can be 0..9 or A..Z. The whole Latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example, to make a short url. Can simply represent it in the numeral system with base 36:

      
        
        
          
            
          
          
            
          
        
        
          alert( 123456..toString(36) ); // 2n9c
        
      
      
      


            Two dots to call a method
            Please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.
If we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now uses the method.
Also could write (123456).toString(36).

RoundingOne of the most used operations when working with numbers is rounding.
There are several built-in functions for rounding:

Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4. In the middle cases 3.5 rounds up to 4, and -3.5 rounds up to -3.
Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

Here’s the table to summarize the differences between them:




Math.floor
Math.ceil
Math.round
Math.trunc




3.1
3
4
3
3


3.5
3
4
4
3


3.6
3
4
4
3


-1.1
-2
-1
-1
-1


-1.5
-2
-1
-1
-1


-1.6
-2
-1
-2
-1



These functions cover all of the possible ways to deal with the decimal part of a number. But what if we’d like to round the number to n-th digit after the decimal?
For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.
There are two ways to do so:


Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.

      
        
        
          
            
          
          
            
          
        
        
          let num = 1.23456;

alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
        
      
      
      

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
        
      
      
      This rounds up or down to the nearest value, similar to Math.round:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
        
      
      
      Please note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
        
      
      
      We can convert it to a number using the unary plus or a Number() call, e.g. write +num.toFixed(5).


Imprecise calculationsInternally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.
If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1e500 ); // Infinity
        
      
      
      What may be a little less obvious, but happens quite often, is the loss of precision.
Consider this (falsy!) equality test:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 == 0.3 ); // false
        
      
      
      That’s right, if we check whether the sum of 0.1 and 0.2 is 0.3, we get false.
Strange! What is it then if not 0.3?

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 ); // 0.30000000000000004
        
      
      
      Ouch! Imagine you’re making an e-shopping site and the visitor puts $0.10 and $0.20 goods into their cart. The order total will be $0.30000000000000004. That would surprise anyone.
But why does this happen?
A number is stored in memory in its binary form, a sequence of bits – ones and zeroes. But fractions like 0.1, 0.2 that look simple in the decimal numeric system are actually unending fractions in their binary form.

      
        
        
          
            
          
          
            
          
        
        
          alert(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(0.2.toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101
        
      
      
      What is 0.1? It is one divided by ten 1/10, one-tenth. In the decimal numeral system, such numbers are easily representable. Compare it to one-third: 1/3. It becomes an endless fraction 0.33333(3).
So, division by powers 10 is guaranteed to work well in the decimal system, but division by 3 is not. For the same reason, in the binary numeral system, the division by powers of 2 is guaranteed to work, but 1/10 becomes an endless binary fraction.
There’s just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.
The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists.
We can see this in action:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1.toFixed(20) ); // 0.10000000000000000555
        
      
      
      And when we sum two numbers, their “precision losses” add up.
That’s why 0.1 + 0.2 is not exactly 0.3.

            Not only JavaScript
            The same issue exists in many other programming languages.
PHP, Java, C, Perl, and Ruby give exactly the same result, because they are based on the same numeric format.

Can we work around the problem? Sure, the most reliable method is to round the result with the help of a method toFixed(n):

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
        
      
      
      Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. That’s actually convenient if we have an e-shopping and need to show $0.30. For other cases, we can use the unary plus to coerce it into a number:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
        
      
      
      We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:

      
        
        
          
            
          
          
            
          
        
        
          alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        
      
      
      So, the multiply/divide approach reduces the error, but doesn’t remove it totally.
Sometimes we could try to evade fractions at all. Like if we’re dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut “tails” when needed.

            The funny thing
            Try running this:

      
        
        
          
            
          
          
            
          
        
        
          // Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000
        
      
      
      This suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. So the least significant digits disappear.
JavaScript doesn’t trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.


            Two zeroes
            Another funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.
That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.
In most cases, the distinction is unnoticeable, because operators are suited to treat them as the same.

Tests: isFinite and isNaNRemember these two special numeric values?

Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
NaN represents an error.

They belong to the type number, but are not “normal” numbers, so there are special functions to check for them:


isNaN(value) converts its argument to a number and then tests it for being NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
        
      
      
      But do we need this function? Can’t we just use the comparison === NaN? Unfortunately not. The value NaN is unique in that it does not equal anything, including itself:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN === NaN ); // false
        
      
      
      

isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity
        
      
      
      

Sometimes isFinite is used to validate whether a string value is a regular number:

      
        
        
          
            
          
          
            
          
        
        
          let num = +prompt("Enter a number", '');

// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num) );
        
      
      
      Please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

            Number.isNaN and Number.isFinite
            Number.isNaN and Number.isFinite methods are the more “strict” versions of isNaN and isFinite functions. They do not autoconvert their argument into a number, but check if it belongs to the number type instead.


Number.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Note the difference:
alert( Number.isNaN("str") ); // false, because "str" belongs to the string type, not the number type
alert( isNaN("str") ); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion
        
      
      
      

Number.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); // false
alert( Number.isFinite(2 / 0) ); // false

// Note the difference:
alert( Number.isFinite("123") ); // false, because "123" belongs to the string type, not the number type
alert( isFinite("123") ); // true, because isFinite converts string "123" into a number 123
        
      
      
      

In a way, Number.isNaN and Number.isFinite are simpler and more straightforward than isNaN and isFinite functions. In practice though, isNaN and isFinite are mostly used, as they’re shorter to write.


            Comparison with Object.is
            There is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:

It works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.
Values 0 and -0 are different: Object.is(0, -0) === false, technically that’s correct because internally the number has a sign bit that may be different even if all other bits are zeroes.

In all other cases, Object.is(a, b) is the same as a === b.
We mention Object.is here, because it’s often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

parseInt and parseFloatNumeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:

      
        
        
          
            
          
          
            
          
        
        
          alert( +"100px" ); // NaN
        
      
      
      The sole exception is spaces at the beginning or at the end of the string, as they are ignored.
But in real life, we often have values in units, like "100px" or "12pt" in CSS. Also in many countries, the currency symbol goes after the amount, so we have "19€" and would like to extract a numeric value out of that.
That’s what parseInt and parseFloat are for.
They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The function parseInt returns an integer, whilst parseFloat will return a floating-point number:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading
        
      
      
      There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('a123') ); // NaN, the first symbol stops the process
        
      
      
      
            The second argument of parseInt(str, radix)
            The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works

alert( parseInt('2n9c', 36) ); // 123456
        
      
      
      
Other math functionsJavaScript has a built-in Math object which contains a small library of mathematical functions and constants.
A few examples:

Math.random()

Returns a random number from 0 to 1 (not including 1).

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (any random numbers)
        
      
      
      
Math.max(a, b, c...) and Math.min(a, b, c...)

Returns the greatest and smallest from the arbitrary number of arguments.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
        
      
      
      
Math.pow(n, power)

Returns n raised to the given power.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
        
      
      
      

There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.
SummaryTo write numbers with many zeroes:

Append "e" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.
A negative number after "e" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).

For different numeral systems:

Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.
parseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.
num.toString(base) converts a number to a string in the numeral system with the given base.

For regular number tests:

isNaN(value) converts its argument to a number and then tests it for being NaN
Number.isNaN(value) checks whether its argument belongs to the number type, and if so, tests it for being NaN
isFinite(value) converts its argument to a number and then tests it for not being NaN/Infinity/-Infinity
Number.isFinite(value) checks whether its argument belongs to the number type, and if so, tests it for not being NaN/Infinity/-Infinity

For converting values like 12pt and 100px to a number:

Use parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).
Make sure to remember there’s a loss of precision when working with fractions.

More mathematical functions:

See the Math object when you need them. The library is very small but can cover basic needs.

TasksSum numbers from the visitorimportance: 5Create a script that prompts the visitor to enter two numbers and then shows their sum.
Run the demoP.S. There is a gotcha with types.
solution
      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("The first number?", "");
let b = +prompt("The second number?", "");

alert( a + b );
        
      
      
      Note the unary plus + before prompt. It immediately converts the value to a number.
Otherwise, a and b would be string their sum would be their concatenation, that is: "1" + "2" = "12".
Why 6.35.toFixed(1) == 6.3?importance: 4According to the documentation Math.round and toFixed both round to the nearest number: 0..4 lead down while 5..9 lead up.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(1) ); // 1.4
        
      
      
      In the similar example below, why is 6.35 rounded to 6.3, not 6.4?

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(1) ); // 6.3
        
      
      
      How to round 6.35 the right way?
solutionInternally the decimal fraction 6.35 is an endless binary. As always in such cases, it is stored with a precision loss.
Let’s see:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(20) ); // 6.34999999999999964473
        
      
      
      The precision loss can cause both increase and decrease of a number. In this particular case the number becomes a tiny bit less, that’s why it rounded down.
And what’s for 1.35?

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(20) ); // 1.35000000000000008882
        
      
      
      Here the precision loss made the number a little bit greater, so it rounded up.
How can we fix the problem with 6.35 if we want it to be rounded the right way?
We should bring it closer to an integer prior to rounding:

      
        
        
          
            
          
          
            
          
        
        
          alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
        
      
      
      Note that 63.5 has no precision loss at all. That’s because the decimal part 0.5 is actually 1/2. Fractions divided by powers of 2 are exactly represented in the binary system, now we can round it:

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
        
      
      
      Repeat until the input is a numberimportance: 5Create a function readNumber which prompts for a number until the visitor enters a valid numeric value.
The resulting value must be returned as a number.
The visitor can also stop the process by entering an empty line or pressing “CANCEL”. In that case, the function should return null.
Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function readNumber() {
  let num;

  do {
    num = prompt("Enter a number please?", 0);
  } while ( !isFinite(num) );

  if (num === null || num === '') return null;

  return +num;
}

alert(`Read: ${readNumber()}`);
        
      
      
      The solution is a little bit more intricate that it could be because we need to handle null/empty lines.
So we actually accept the input until it is a “regular number”. Both null (cancel) and empty line also fit that condition, because in numeric form they are 0.
After we stopped, we need to treat null and empty line specially (return null), because converting them to a number would return 0.
Open the solution with tests in a sandbox.An occasional infinite loopimportance: 4This loop is infinite. It never ends. Why?

      
        
        
          let i = 0;
while (i != 10) {
  i += 0.2;
}
        
      
      
      solutionThat’s because i would never equal 10.
Run it to see the real values of i:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) alert( i );
}
        
      
      
      None of them is exactly 10.
Such things happen because of the precision losses when adding fractions like 0.2.
Conclusion: evade equality checks when working with decimal fractions.
A random number from min to maximportance: 2The built-in function Math.random() creates a random value from 0 to 1 (not including 1).
Write the function random(min, max) to generate a random floating-point number from min to max (not including max).
Examples of its work:

      
        
        
          alert( random(1, 5) ); // 1.2345623452
alert( random(1, 5) ); // 3.7894332423
alert( random(1, 5) ); // 4.3435234525
        
      
      
      solutionWe need to “map” all values from the interval 0…1 into values from min to max.
That can be done in two stages:

If we multiply a random number from 0…1 by max-min, then the interval of possible values increases 0..1 to 0..max-min.
Now if we add min, the possible interval becomes from min to max.

The function:

      
        
        
          
            
          
          
            
          
        
        
          function random(min, max) {
  return min + Math.random() * (max - min);
}

alert( random(1, 5) );
alert( random(1, 5) );
alert( random(1, 5) );
        
      
      
      A random integer from min to maximportance: 2Create a function randomInteger(min, max) that generates a random integer number from min to max including both min and max as possible values.
Any number from the interval min..max must appear with the same probability.
Examples of its work:

      
        
        
          alert( randomInteger(1, 5) ); // 1
alert( randomInteger(1, 5) ); // 3
alert( randomInteger(1, 5) ); // 5
        
      
      
      You can use the solution of the previous task as the base.
solutionThe simple but wrong solutionThe simple but wrong solutionThe simplest, but wrong solution would be to generate a value from min to max and round it:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  let rand = min + Math.random() * (max - min);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      The function works, but it is incorrect. The probability to get edge values min and max is two times less than any other.
If you run the example above many times, you would easily see that 2 appears the most often.
That happens because Math.round() gets random numbers from the interval 1..3 and rounds them as follows:

      
        
        
          values from 1    ... to 1.4999999999  become 1
values from 1.5  ... to 2.4999999999  become 2
values from 2.5  ... to 2.9999999999  become 3
        
      
      
      Now we can clearly see that 1 gets twice less values than 2. And the same with 3.
The correct solutionThe correct solutionThere are many correct solutions to the task. One of them is to adjust interval borders. To ensure the same intervals, we can generate values from 0.5 to 3.5, thus adding the required probabilities to the edges:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // now rand is from  (min-0.5) to (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      An alternative way could be to use Math.floor for a random number from min to max+1:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // here rand is from min to (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      Now all intervals are mapped this way:

      
        
        
          values from 1  ... to 1.9999999999  become 1
values from 2  ... to 2.9999999999  become 2
values from 3  ... to 3.9999999999  become 3
        
      
      
      All intervals have the same length, making the final distribution uniform.\n\nTutorialThe JavaScript languageData typesDecember 18, 2024NumbersIn modern JavaScript, there are two types of numbers:


Regular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.


BigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in a few special areas, we devote them to a special chapter BigInt.


So here we’ll talk about regular numbers. Let’s expand our knowledge of them.
More ways to write a numberImagine we need to write 1 billion. The obvious way is:

      
        
        
          let billion = 1000000000;
        
      
      
      We also can use underscore _ as the separator:

      
        
        
          let billion = 1_000_000_000;
        
      
      
      Here the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.
In real life though, we try to avoid writing long sequences of zeroes. We’re too lazy for that. We’ll try to write something like "1bn" for a billion or "7.3bn" for 7 billion 300 million. The same is true for most large numbers.
In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:

      
        
        
          
            
          
          
            
          
        
        
          let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)
        
      
      
      In other words, e multiplies the number by 1 with the given zeroes count.

      
        
        
          1e3 === 1 * 1000; // e3 means *1000
1.23e6 === 1.23 * 1000000; // e6 means *1000000
        
      
      
      Now let’s write something very small. Say, 1 microsecond (one-millionth of a second):

      
        
        
          let mсs = 0.000001;
        
      
      
      Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:

      
        
        
          let mcs = 1e-6; // five zeroes to the left from 1
        
      
      
      If we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.
In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

      
        
        
          // -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001

// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123

// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times
        
      
      
      Hex, binary and octal numbersHexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
        
      
      
      Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
        
      
      
      There are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt (which we will see later in this chapter).
toString(base)The method num.toString(base) returns a string representation of num in the numeral system with the given base.
For example:

      
        
        
          
            
          
          
            
          
        
        
          let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
        
      
      
      The base can vary from 2 to 36. By default, it’s 10.
Common use cases for this are:


base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.


base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.


base=36 is the maximum, digits can be 0..9 or A..Z. The whole Latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example, to make a short url. Can simply represent it in the numeral system with base 36:

      
        
        
          
            
          
          
            
          
        
        
          alert( 123456..toString(36) ); // 2n9c
        
      
      
      


            Two dots to call a method
            Please note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.
If we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now uses the method.
Also could write (123456).toString(36).

RoundingOne of the most used operations when working with numbers is rounding.
There are several built-in functions for rounding:

Math.floor
Rounds down: 3.1 becomes 3, and -1.1 becomes -2.
Math.ceil
Rounds up: 3.1 becomes 4, and -1.1 becomes -1.
Math.round
Rounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4. In the middle cases 3.5 rounds up to 4, and -3.5 rounds up to -3.
Math.trunc (not supported by Internet Explorer)
Removes anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.

Here’s the table to summarize the differences between them:




Math.floor
Math.ceil
Math.round
Math.trunc




3.1
3
4
3
3


3.5
3
4
4
3


3.6
3
4
4
3


-1.1
-2
-1
-1
-1


-1.5
-2
-1
-1
-1


-1.6
-2
-1
-2
-1



These functions cover all of the possible ways to deal with the decimal part of a number. But what if we’d like to round the number to n-th digit after the decimal?
For instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.
There are two ways to do so:


Multiply-and-divide.
For example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.

      
        
        
          
            
          
          
            
          
        
        
          let num = 1.23456;

alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
        
      
      
      

The method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
        
      
      
      This rounds up or down to the nearest value, similar to Math.round:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
        
      
      
      Please note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
        
      
      
      We can convert it to a number using the unary plus or a Number() call, e.g. write +num.toFixed(5).


Imprecise calculationsInternally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.
If a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1e500 ); // Infinity
        
      
      
      What may be a little less obvious, but happens quite often, is the loss of precision.
Consider this (falsy!) equality test:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 == 0.3 ); // false
        
      
      
      That’s right, if we check whether the sum of 0.1 and 0.2 is 0.3, we get false.
Strange! What is it then if not 0.3?

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 ); // 0.30000000000000004
        
      
      
      Ouch! Imagine you’re making an e-shopping site and the visitor puts $0.10 and $0.20 goods into their cart. The order total will be $0.30000000000000004. That would surprise anyone.
But why does this happen?
A number is stored in memory in its binary form, a sequence of bits – ones and zeroes. But fractions like 0.1, 0.2 that look simple in the decimal numeric system are actually unending fractions in their binary form.

      
        
        
          
            
          
          
            
          
        
        
          alert(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(0.2.toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101
        
      
      
      What is 0.1? It is one divided by ten 1/10, one-tenth. In the decimal numeral system, such numbers are easily representable. Compare it to one-third: 1/3. It becomes an endless fraction 0.33333(3).
So, division by powers 10 is guaranteed to work well in the decimal system, but division by 3 is not. For the same reason, in the binary numeral system, the division by powers of 2 is guaranteed to work, but 1/10 becomes an endless binary fraction.
There’s just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.
The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists.
We can see this in action:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1.toFixed(20) ); // 0.10000000000000000555
        
      
      
      And when we sum two numbers, their “precision losses” add up.
That’s why 0.1 + 0.2 is not exactly 0.3.

            Not only JavaScript
            The same issue exists in many other programming languages.
PHP, Java, C, Perl, and Ruby give exactly the same result, because they are based on the same numeric format.

Can we work around the problem? Sure, the most reliable method is to round the result with the help of a method toFixed(n):

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
        
      
      
      Please note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. That’s actually convenient if we have an e-shopping and need to show $0.30. For other cases, we can use the unary plus to coerce it into a number:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
        
      
      
      We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:

      
        
        
          
            
          
          
            
          
        
        
          alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        
      
      
      So, the multiply/divide approach reduces the error, but doesn’t remove it totally.
Sometimes we could try to evade fractions at all. Like if we’re dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut “tails” when needed.

            The funny thing
            Try running this:

      
        
        
          
            
          
          
            
          
        
        
          // Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000
        
      
      
      This suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. So the least significant digits disappear.
JavaScript doesn’t trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.


            Two zeroes
            Another funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.
That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.
In most cases, the distinction is unnoticeable, because operators are suited to treat them as the same.

Tests: isFinite and isNaNRemember these two special numeric values?

Infinity (and -Infinity) is a special numeric value that is greater (less) than anything.
NaN represents an error.

They belong to the type number, but are not “normal” numbers, so there are special functions to check for them:


isNaN(value) converts its argument to a number and then tests it for being NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
        
      
      
      But do we need this function? Can’t we just use the comparison === NaN? Unfortunately not. The value NaN is unique in that it does not equal anything, including itself:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN === NaN ); // false
        
      
      
      

isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity
        
      
      
      

Sometimes isFinite is used to validate whether a string value is a regular number:

      
        
        
          
            
          
          
            
          
        
        
          let num = +prompt("Enter a number", '');

// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num) );
        
      
      
      Please note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.

            Number.isNaN and Number.isFinite
            Number.isNaN and Number.isFinite methods are the more “strict” versions of isNaN and isFinite functions. They do not autoconvert their argument into a number, but check if it belongs to the number type instead.


Number.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Note the difference:
alert( Number.isNaN("str") ); // false, because "str" belongs to the string type, not the number type
alert( isNaN("str") ); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion
        
      
      
      

Number.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case, it returns false.

      
        
        
          
            
          
          
            
          
        
        
          alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); // false
alert( Number.isFinite(2 / 0) ); // false

// Note the difference:
alert( Number.isFinite("123") ); // false, because "123" belongs to the string type, not the number type
alert( isFinite("123") ); // true, because isFinite converts string "123" into a number 123
        
      
      
      

In a way, Number.isNaN and Number.isFinite are simpler and more straightforward than isNaN and isFinite functions. In practice though, isNaN and isFinite are mostly used, as they’re shorter to write.


            Comparison with Object.is
            There is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:

It works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.
Values 0 and -0 are different: Object.is(0, -0) === false, technically that’s correct because internally the number has a sign bit that may be different even if all other bits are zeroes.

In all other cases, Object.is(a, b) is the same as a === b.
We mention Object.is here, because it’s often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).

parseInt and parseFloatNumeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:

      
        
        
          
            
          
          
            
          
        
        
          alert( +"100px" ); // NaN
        
      
      
      The sole exception is spaces at the beginning or at the end of the string, as they are ignored.
But in real life, we often have values in units, like "100px" or "12pt" in CSS. Also in many countries, the currency symbol goes after the amount, so we have "19€" and would like to extract a numeric value out of that.
That’s what parseInt and parseFloat are for.
They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The function parseInt returns an integer, whilst parseFloat will return a floating-point number:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading
        
      
      
      There are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('a123') ); // NaN, the first symbol stops the process
        
      
      
      
            The second argument of parseInt(str, radix)
            The parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works

alert( parseInt('2n9c', 36) ); // 123456
        
      
      
      
Other math functionsJavaScript has a built-in Math object which contains a small library of mathematical functions and constants.
A few examples:

Math.random()

Returns a random number from 0 to 1 (not including 1).

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (any random numbers)
        
      
      
      
Math.max(a, b, c...) and Math.min(a, b, c...)

Returns the greatest and smallest from the arbitrary number of arguments.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
        
      
      
      
Math.pow(n, power)

Returns n raised to the given power.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
        
      
      
      

There are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.
SummaryTo write numbers with many zeroes:

Append "e" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.
A negative number after "e" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).

For different numeral systems:

Can write numbers directly in hex (0x), octal (0o) and binary (0b) systems.
parseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.
num.toString(base) converts a number to a string in the numeral system with the given base.

For regular number tests:

isNaN(value) converts its argument to a number and then tests it for being NaN
Number.isNaN(value) checks whether its argument belongs to the number type, and if so, tests it for being NaN
isFinite(value) converts its argument to a number and then tests it for not being NaN/Infinity/-Infinity
Number.isFinite(value) checks whether its argument belongs to the number type, and if so, tests it for not being NaN/Infinity/-Infinity

For converting values like 12pt and 100px to a number:

Use parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

Round using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).
Make sure to remember there’s a loss of precision when working with fractions.

More mathematical functions:

See the Math object when you need them. The library is very small but can cover basic needs.

TasksSum numbers from the visitorimportance: 5Create a script that prompts the visitor to enter two numbers and then shows their sum.
Run the demoP.S. There is a gotcha with types.
solution
      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("The first number?", "");
let b = +prompt("The second number?", "");

alert( a + b );
        
      
      
      Note the unary plus + before prompt. It immediately converts the value to a number.
Otherwise, a and b would be string their sum would be their concatenation, that is: "1" + "2" = "12".
Why 6.35.toFixed(1) == 6.3?importance: 4According to the documentation Math.round and toFixed both round to the nearest number: 0..4 lead down while 5..9 lead up.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(1) ); // 1.4
        
      
      
      In the similar example below, why is 6.35 rounded to 6.3, not 6.4?

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(1) ); // 6.3
        
      
      
      How to round 6.35 the right way?
solutionInternally the decimal fraction 6.35 is an endless binary. As always in such cases, it is stored with a precision loss.
Let’s see:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(20) ); // 6.34999999999999964473
        
      
      
      The precision loss can cause both increase and decrease of a number. In this particular case the number becomes a tiny bit less, that’s why it rounded down.
And what’s for 1.35?

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(20) ); // 1.35000000000000008882
        
      
      
      Here the precision loss made the number a little bit greater, so it rounded up.
How can we fix the problem with 6.35 if we want it to be rounded the right way?
We should bring it closer to an integer prior to rounding:

      
        
        
          
            
          
          
            
          
        
        
          alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
        
      
      
      Note that 63.5 has no precision loss at all. That’s because the decimal part 0.5 is actually 1/2. Fractions divided by powers of 2 are exactly represented in the binary system, now we can round it:

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.round(6.35 * 10) / 10 ); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
        
      
      
      Repeat until the input is a numberimportance: 5Create a function readNumber which prompts for a number until the visitor enters a valid numeric value.
The resulting value must be returned as a number.
The visitor can also stop the process by entering an empty line or pressing “CANCEL”. In that case, the function should return null.
Run the demoOpen a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function readNumber() {
  let num;

  do {
    num = prompt("Enter a number please?", 0);
  } while ( !isFinite(num) );

  if (num === null || num === '') return null;

  return +num;
}

alert(`Read: ${readNumber()}`);
        
      
      
      The solution is a little bit more intricate that it could be because we need to handle null/empty lines.
So we actually accept the input until it is a “regular number”. Both null (cancel) and empty line also fit that condition, because in numeric form they are 0.
After we stopped, we need to treat null and empty line specially (return null), because converting them to a number would return 0.
Open the solution with tests in a sandbox.An occasional infinite loopimportance: 4This loop is infinite. It never ends. Why?

      
        
        
          let i = 0;
while (i != 10) {
  i += 0.2;
}
        
      
      
      solutionThat’s because i would never equal 10.
Run it to see the real values of i:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) alert( i );
}
        
      
      
      None of them is exactly 10.
Such things happen because of the precision losses when adding fractions like 0.2.
Conclusion: evade equality checks when working with decimal fractions.
A random number from min to maximportance: 2The built-in function Math.random() creates a random value from 0 to 1 (not including 1).
Write the function random(min, max) to generate a random floating-point number from min to max (not including max).
Examples of its work:

      
        
        
          alert( random(1, 5) ); // 1.2345623452
alert( random(1, 5) ); // 3.7894332423
alert( random(1, 5) ); // 4.3435234525
        
      
      
      solutionWe need to “map” all values from the interval 0…1 into values from min to max.
That can be done in two stages:

If we multiply a random number from 0…1 by max-min, then the interval of possible values increases 0..1 to 0..max-min.
Now if we add min, the possible interval becomes from min to max.

The function:

      
        
        
          
            
          
          
            
          
        
        
          function random(min, max) {
  return min + Math.random() * (max - min);
}

alert( random(1, 5) );
alert( random(1, 5) );
alert( random(1, 5) );
        
      
      
      A random integer from min to maximportance: 2Create a function randomInteger(min, max) that generates a random integer number from min to max including both min and max as possible values.
Any number from the interval min..max must appear with the same probability.
Examples of its work:

      
        
        
          alert( randomInteger(1, 5) ); // 1
alert( randomInteger(1, 5) ); // 3
alert( randomInteger(1, 5) ); // 5
        
      
      
      You can use the solution of the previous task as the base.
solutionThe simple but wrong solutionThe simple but wrong solutionThe simplest, but wrong solution would be to generate a value from min to max and round it:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  let rand = min + Math.random() * (max - min);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      The function works, but it is incorrect. The probability to get edge values min and max is two times less than any other.
If you run the example above many times, you would easily see that 2 appears the most often.
That happens because Math.round() gets random numbers from the interval 1..3 and rounds them as follows:

      
        
        
          values from 1    ... to 1.4999999999  become 1
values from 1.5  ... to 2.4999999999  become 2
values from 2.5  ... to 2.9999999999  become 3
        
      
      
      Now we can clearly see that 1 gets twice less values than 2. And the same with 3.
The correct solutionThe correct solutionThere are many correct solutions to the task. One of them is to adjust interval borders. To ensure the same intervals, we can generate values from 0.5 to 3.5, thus adding the required probabilities to the edges:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // now rand is from  (min-0.5) to (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      An alternative way could be to use Math.floor for a random number from min to max+1:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // here rand is from min to (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      Now all intervals are mapped this way:

      
        
        
          values from 1  ... to 1.9999999999  become 1
values from 2  ... to 2.9999999999  become 2
values from 3  ... to 3.9999999999  become 3
        
      
      
      All intervals have the same length, making the final distribution uniform.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nIn JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
QuotesLet’s recall the kinds of quotes.
Strings can be enclosed within either single quotes, double quotes or backticks:

      
        
        
          let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
        
      
      
      Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
        
      
      
      Another advantage of using backticks is that they allow a string to span multiple lines:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
        
      
      
      Looks natural, right? But single or double quotes do not work this way.
If we use them and try to use multiple lines, there’ll be an error:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";
        
      
      
      Single and double quotes come from ancient times of language creation, when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.
Backticks also allow us to specify a “template function” before the first backtick. The syntax is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. This feature is called “tagged templates”, it’s rarely seen, but you can read about it in the MDN: Template literals.
Special charactersIt is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \n, which denotes a line break:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // a multiline list of guests, same as above
        
      
      
      As a simpler example, these two lines are equal, just written differently:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "Hello\nWorld"; // two lines using a "newline symbol"

// two lines using a normal newline and backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true
        
      
      
      There are other, less common special characters:



Character
Description




\n
New line


\r
In Windows text files a combination of two characters \r\n represents a new break, while on non-Windows OS it’s just \n. That’s for historical reasons, most Windows software also understands \n.


\', \", \`
Quotes


\\
Backslash


\t
Tab


\b, \f, \v
Backspace, Form Feed, Vertical Tab – mentioned for completeness, coming from old times, not used nowadays (you can forget them right now).



As you can see, all special characters start with a backslash character \. It is also called an “escape character”.
Because it’s so special, if we need to show an actual backslash \ within the string, we need to double it:

      
        
        
          
            
          
          
            
          
        
        
          alert( `The backslash: \\` ); // The backslash: \
        
      
      
      So-called “escaped” quotes \', \", \` are used to insert a quote into the same-quoted string.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'I\'m the Walrus!' ); // I'm the Walrus!
        
      
      
      As you can see, we have to prepend the inner quote by the backslash \', because otherwise it would indicate the string end.
Of course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or backticks instead:

      
        
        
          
            
          
          
            
          
        
        
          alert( "I'm the Walrus!" ); // I'm the Walrus!
        
      
      
      Besides these special characters, there’s also a special notation for Unicode codes \u…, it’s rarely used and is covered in the optional chapter about Unicode.
String lengthThe length property has the string length:

      
        
        
          
            
          
          
            
          
        
        
          alert( `My\n`.length ); // 3
        
      
      
      Note that \n is a single “special” character, so the length is indeed 3.

            length is a property
            People with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn’t work.
Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it. Not .length(), but .length.

Accessing charactersTo get a character at position pos, use square brackets [pos] or call the method str.at(pos). The first character starts from the zero position:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

// the first character
alert( str[0] ); // H
alert( str.at(0) ); // H

// the last character
alert( str[str.length - 1] ); // o
alert( str.at(-1) );
        
      
      
      As you can see, the .at(pos) method has a benefit of allowing negative position. If pos is negative, then it’s counted from the end of the string.
So .at(-1) means the last character, and .at(-2) is the one before it, etc.
The square brackets always return undefined for negative indexes, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
        
      
      
      We can also iterate over characters using for..of:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
}
        
      
      
      Strings are immutableStrings can’t be changed in JavaScript. It is impossible to change a character.
Let’s try it to show that it doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // doesn't work
        
      
      
      The usual workaround is to create a whole new string and assign it to str instead of the old one.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str = 'h' + str[1]; // replace the string

alert( str ); // hi
        
      
      
      In the following sections we’ll see more examples of this.
Changing the caseMethods toLowerCase() and toUpperCase() change the case:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
        
      
      
      Or, if we want a single character lowercased:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'[0].toLowerCase() ); // 'i'
        
      
      
      Searching for a substringThere are multiple ways to look for a substring within a string.
str.indexOfThe first method is str.indexOf(substr, pos).
It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive

alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)
        
      
      
      The optional second parameter allows us to start searching from a given position.
For instance, the first occurrence of "id" is at position 1. To look for the next occurrence, let’s start the search from position 2:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
        
      
      
      If we’re interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // let's look for it

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // continue the search from the next position
}
        
      
      
      The same algorithm can be layed out shorter:

      
        
        
          
            
          
          
            
          
        
        
          let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
        
      
      
      
            str.lastIndexOf(substr, position)
            There is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.
It would list the occurrences in the reverse order.

There is a slight inconvenience with indexOf in the if test. We can’t put it in the if like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("We found it"); // doesn't work!
}
        
      
      
      The alert in the example above doesn’t show because str.indexOf("Widget") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.
So, we should actually check for -1, like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("We found it"); // works now!
}
        
      
      
      includes, startsWith, endsWithThe more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.
It’s the right choice if we need to test for the match, but don’t need its position:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
        
      
      
      The optional second argument of str.includes is the position to start searching from:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, from position 3 there is no "id"
        
      
      
      The methods str.startsWith and str.endsWith do exactly what they say:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid"
alert( "Widget".endsWith("get") ); // true, "Widget" ends with "get"
        
      
      
      Getting a substringThere are 3 methods in JavaScript to get a substring: substring, substr and slice.

str.slice(start [, end])

Returns the part of the string from start to (but not including) end.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0
        
      
      
      If there is no second argument, then slice goes till the end of the string:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(2) ); // 'ringify', from the 2nd position till the end
        
      
      
      Negative values for start/end are also possible. They mean the position is counted from the string end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // 'gif'
        
      
      
      
str.substring(start [, end])

Returns the part of the string between start and end (not including end).
This is almost the same as slice, but it allows start to be greater than end (in this case it simply swaps start and end values).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// these are same for substring
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ...but not for slice:
alert( str.slice(2, 6) ); // "ring" (the same)
alert( str.slice(6, 2) ); // "" (an empty string)
        
      
      
      Negative arguments are (unlike slice) not supported, they are treated as 0.

str.substr(start [, length])

Returns the part of the string from start, with the given length.
In contrast with the previous methods, this one allows us to specify the length instead of the ending position:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(2, 4) ); // 'ring', from the 2nd position get 4 characters
        
      
      
      The first argument may be negative, to count from the end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi', from the 4th position get 2 characters
        
      
      
      This method resides in the Annex B of the language specification. It means that only browser-hosted Javascript engines should support it, and it’s not recommended to use it. In practice, it’s supported everywhere.


Let’s recap these methods to avoid any confusion:



method
selects…
negatives




slice(start, end)
from start to end (not including end)
allows negatives


substring(start, end)
between start and end (not including end)
negative values mean 0


substr(start, length)
from start get length characters
allows negative start




            Which one to choose?
            All of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.
Of the other two variants, slice is a little bit more flexible, it allows negative arguments and shorter to write.
So, for practical use it’s enough to remember only slice.

Comparing stringsAs we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.
Although, there are some oddities.


A lowercase letter is always greater than the uppercase:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'a' > 'Z' ); // true
        
      
      
      

Letters with diacritical marks are “out of order”:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich' > 'Zealand' ); // true
        
      
      
      This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list.


To understand what happens, we should be aware that strings in Javascript are encoded using UTF-16. That is: each character has a corresponding numeric code.
There are special methods that allow to get the character for the code and back:

str.codePointAt(pos)

Returns a decimal number representing the code for the character at position pos:

      
        
        
          
            
          
          
            
          
        
        
          // different case letters have different codes
alert( "Z".codePointAt(0) ); // 90
alert( "z".codePointAt(0) ); // 122
alert( "z".codePointAt(0).toString(16) ); // 7a (if we need a hexadecimal value)
        
      
      
      
String.fromCodePoint(code)

Creates a character by its numeric code

      
        
        
          
            
          
          
            
          
        
        
          alert( String.fromCodePoint(90) ); // Z
alert( String.fromCodePoint(0x5a) ); // Z (we can also use a hex value as an argument)
        
      
      
      

Now let’s see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:

      
        
        
          
            
          
          
            
          
        
        
          let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// Output:
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
        
      
      
      See? Capital characters go first, then a few special ones, then lowercase characters, and Ö near the end of the output.
Now it becomes obvious why a > Z.
The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

All lowercase letters go after uppercase letters because their codes are greater.
Some letters like Ö stand apart from the main alphabet. Here, its code is greater than anything from a to z.

Correct comparisonsThe “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.
So, the browser needs to know the language to compare.
Luckily, modern browsers support the internationalization standard ECMA-402.
It provides a special method to compare strings in different languages, following their rules.
The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:

Returns a negative number if str is less than str2.
Returns a positive number if str is greater than str2.
Returns 0 if they are equivalent.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich'.localeCompare('Zealand') ); // -1
        
      
      
      This method actually has two additional arguments specified in the documentation, which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sensitivity or should "a" and "á" be treated as the same etc.
Summary
There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${…}.
We can use special characters, such as a line break \n.
To get a character, use: [] or at method.
To get a substring, use: slice or substring.
To lowercase/uppercase a string, use: toLowerCase/toUpperCase.
To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.
To compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.

There are several other helpful methods in strings:

str.trim() – removes (“trims”) spaces from the beginning and end of the string.
str.repeat(n) – repeats the string n times.
…and more to be found in the manual.

Strings also have methods for doing search/replace with regular expressions. But that’s big topic, so it’s explained in a separate tutorial section Regular expressions.
Also, as of now it’s important to know that strings are based on Unicode encoding, and hence there’re issues with comparisons. There’s more about Unicode in the chapter Unicode, String internals.\n\nTutorialThe JavaScript languageData typesJanuary 17, 2024StringsIn JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
QuotesLet’s recall the kinds of quotes.
Strings can be enclosed within either single quotes, double quotes or backticks:

      
        
        
          let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
        
      
      
      Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
        
      
      
      Another advantage of using backticks is that they allow a string to span multiple lines:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
        
      
      
      Looks natural, right? But single or double quotes do not work this way.
If we use them and try to use multiple lines, there’ll be an error:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";
        
      
      
      Single and double quotes come from ancient times of language creation, when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.
Backticks also allow us to specify a “template function” before the first backtick. The syntax is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. This feature is called “tagged templates”, it’s rarely seen, but you can read about it in the MDN: Template literals.
Special charactersIt is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \n, which denotes a line break:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // a multiline list of guests, same as above
        
      
      
      As a simpler example, these two lines are equal, just written differently:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "Hello\nWorld"; // two lines using a "newline symbol"

// two lines using a normal newline and backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true
        
      
      
      There are other, less common special characters:



Character
Description




\n
New line


\r
In Windows text files a combination of two characters \r\n represents a new break, while on non-Windows OS it’s just \n. That’s for historical reasons, most Windows software also understands \n.


\', \", \`
Quotes


\\
Backslash


\t
Tab


\b, \f, \v
Backspace, Form Feed, Vertical Tab – mentioned for completeness, coming from old times, not used nowadays (you can forget them right now).



As you can see, all special characters start with a backslash character \. It is also called an “escape character”.
Because it’s so special, if we need to show an actual backslash \ within the string, we need to double it:

      
        
        
          
            
          
          
            
          
        
        
          alert( `The backslash: \\` ); // The backslash: \
        
      
      
      So-called “escaped” quotes \', \", \` are used to insert a quote into the same-quoted string.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'I\'m the Walrus!' ); // I'm the Walrus!
        
      
      
      As you can see, we have to prepend the inner quote by the backslash \', because otherwise it would indicate the string end.
Of course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or backticks instead:

      
        
        
          
            
          
          
            
          
        
        
          alert( "I'm the Walrus!" ); // I'm the Walrus!
        
      
      
      Besides these special characters, there’s also a special notation for Unicode codes \u…, it’s rarely used and is covered in the optional chapter about Unicode.
String lengthThe length property has the string length:

      
        
        
          
            
          
          
            
          
        
        
          alert( `My\n`.length ); // 3
        
      
      
      Note that \n is a single “special” character, so the length is indeed 3.

            length is a property
            People with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn’t work.
Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it. Not .length(), but .length.

Accessing charactersTo get a character at position pos, use square brackets [pos] or call the method str.at(pos). The first character starts from the zero position:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

// the first character
alert( str[0] ); // H
alert( str.at(0) ); // H

// the last character
alert( str[str.length - 1] ); // o
alert( str.at(-1) );
        
      
      
      As you can see, the .at(pos) method has a benefit of allowing negative position. If pos is negative, then it’s counted from the end of the string.
So .at(-1) means the last character, and .at(-2) is the one before it, etc.
The square brackets always return undefined for negative indexes, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
        
      
      
      We can also iterate over characters using for..of:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
}
        
      
      
      Strings are immutableStrings can’t be changed in JavaScript. It is impossible to change a character.
Let’s try it to show that it doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // doesn't work
        
      
      
      The usual workaround is to create a whole new string and assign it to str instead of the old one.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str = 'h' + str[1]; // replace the string

alert( str ); // hi
        
      
      
      In the following sections we’ll see more examples of this.
Changing the caseMethods toLowerCase() and toUpperCase() change the case:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
        
      
      
      Or, if we want a single character lowercased:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'[0].toLowerCase() ); // 'i'
        
      
      
      Searching for a substringThere are multiple ways to look for a substring within a string.
str.indexOfThe first method is str.indexOf(substr, pos).
It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive

alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)
        
      
      
      The optional second parameter allows us to start searching from a given position.
For instance, the first occurrence of "id" is at position 1. To look for the next occurrence, let’s start the search from position 2:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
        
      
      
      If we’re interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // let's look for it

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // continue the search from the next position
}
        
      
      
      The same algorithm can be layed out shorter:

      
        
        
          
            
          
          
            
          
        
        
          let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
        
      
      
      
            str.lastIndexOf(substr, position)
            There is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.
It would list the occurrences in the reverse order.

There is a slight inconvenience with indexOf in the if test. We can’t put it in the if like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("We found it"); // doesn't work!
}
        
      
      
      The alert in the example above doesn’t show because str.indexOf("Widget") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.
So, we should actually check for -1, like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("We found it"); // works now!
}
        
      
      
      includes, startsWith, endsWithThe more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.
It’s the right choice if we need to test for the match, but don’t need its position:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
        
      
      
      The optional second argument of str.includes is the position to start searching from:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, from position 3 there is no "id"
        
      
      
      The methods str.startsWith and str.endsWith do exactly what they say:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid"
alert( "Widget".endsWith("get") ); // true, "Widget" ends with "get"
        
      
      
      Getting a substringThere are 3 methods in JavaScript to get a substring: substring, substr and slice.

str.slice(start [, end])

Returns the part of the string from start to (but not including) end.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0
        
      
      
      If there is no second argument, then slice goes till the end of the string:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(2) ); // 'ringify', from the 2nd position till the end
        
      
      
      Negative values for start/end are also possible. They mean the position is counted from the string end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // 'gif'
        
      
      
      
str.substring(start [, end])

Returns the part of the string between start and end (not including end).
This is almost the same as slice, but it allows start to be greater than end (in this case it simply swaps start and end values).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// these are same for substring
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ...but not for slice:
alert( str.slice(2, 6) ); // "ring" (the same)
alert( str.slice(6, 2) ); // "" (an empty string)
        
      
      
      Negative arguments are (unlike slice) not supported, they are treated as 0.

str.substr(start [, length])

Returns the part of the string from start, with the given length.
In contrast with the previous methods, this one allows us to specify the length instead of the ending position:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(2, 4) ); // 'ring', from the 2nd position get 4 characters
        
      
      
      The first argument may be negative, to count from the end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi', from the 4th position get 2 characters
        
      
      
      This method resides in the Annex B of the language specification. It means that only browser-hosted Javascript engines should support it, and it’s not recommended to use it. In practice, it’s supported everywhere.


Let’s recap these methods to avoid any confusion:



method
selects…
negatives




slice(start, end)
from start to end (not including end)
allows negatives


substring(start, end)
between start and end (not including end)
negative values mean 0


substr(start, length)
from start get length characters
allows negative start




            Which one to choose?
            All of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.
Of the other two variants, slice is a little bit more flexible, it allows negative arguments and shorter to write.
So, for practical use it’s enough to remember only slice.

Comparing stringsAs we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.
Although, there are some oddities.


A lowercase letter is always greater than the uppercase:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'a' > 'Z' ); // true
        
      
      
      

Letters with diacritical marks are “out of order”:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich' > 'Zealand' ); // true
        
      
      
      This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list.


To understand what happens, we should be aware that strings in Javascript are encoded using UTF-16. That is: each character has a corresponding numeric code.
There are special methods that allow to get the character for the code and back:

str.codePointAt(pos)

Returns a decimal number representing the code for the character at position pos:

      
        
        
          
            
          
          
            
          
        
        
          // different case letters have different codes
alert( "Z".codePointAt(0) ); // 90
alert( "z".codePointAt(0) ); // 122
alert( "z".codePointAt(0).toString(16) ); // 7a (if we need a hexadecimal value)
        
      
      
      
String.fromCodePoint(code)

Creates a character by its numeric code

      
        
        
          
            
          
          
            
          
        
        
          alert( String.fromCodePoint(90) ); // Z
alert( String.fromCodePoint(0x5a) ); // Z (we can also use a hex value as an argument)
        
      
      
      

Now let’s see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:

      
        
        
          
            
          
          
            
          
        
        
          let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// Output:
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
        
      
      
      See? Capital characters go first, then a few special ones, then lowercase characters, and Ö near the end of the output.
Now it becomes obvious why a > Z.
The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

All lowercase letters go after uppercase letters because their codes are greater.
Some letters like Ö stand apart from the main alphabet. Here, its code is greater than anything from a to z.

Correct comparisonsThe “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.
So, the browser needs to know the language to compare.
Luckily, modern browsers support the internationalization standard ECMA-402.
It provides a special method to compare strings in different languages, following their rules.
The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:

Returns a negative number if str is less than str2.
Returns a positive number if str is greater than str2.
Returns 0 if they are equivalent.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich'.localeCompare('Zealand') ); // -1
        
      
      
      This method actually has two additional arguments specified in the documentation, which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sensitivity or should "a" and "á" be treated as the same etc.
Summary
There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${…}.
We can use special characters, such as a line break \n.
To get a character, use: [] or at method.
To get a substring, use: slice or substring.
To lowercase/uppercase a string, use: toLowerCase/toUpperCase.
To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.
To compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.

There are several other helpful methods in strings:

str.trim() – removes (“trims”) spaces from the beginning and end of the string.
str.repeat(n) – repeats the string n times.
…and more to be found in the manual.

Strings also have methods for doing search/replace with regular expressions. But that’s big topic, so it’s explained in a separate tutorial section Regular expressions.
Also, as of now it’s important to know that strings are based on Unicode encoding, and hence there’re issues with comparisons. There’s more about Unicode in the chapter Unicode, String internals.
TasksUppercase the first characterimportance: 5Write a function ucFirst(str) that returns the string str with the uppercased first character, for instance:

      
        
        
          ucFirst("john") == "John";
        
      
      
      Open a sandbox with tests.solutionWe can’t “replace” the first character, because strings in JavaScript are immutable.
But we can make a new string based on the existing one, with the uppercased first character:

      
        
        
          let newStr = str[0].toUpperCase() + str.slice(1);
        
      
      
      There’s a small problem though. If str is empty, then str[0] is undefined, and as undefined doesn’t have the toUpperCase() method, we’ll get an error.
The easiest way out is to add a test for an empty string, like this:

      
        
        
          
            
          
          
            
          
        
        
          function ucFirst(str) {
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("john") ); // John
        
      
      
      Open the solution with tests in a sandbox.Check for spamimportance: 5Write a function checkSpam(str) that returns true if str contains ‘viagra’ or ‘XXX’, otherwise false.
The function must be case-insensitive:

      
        
        
          checkSpam('buy ViAgRA now') == true
checkSpam('free xxxxx') == true
checkSpam("innocent rabbit") == false
        
      
      
      Open a sandbox with tests.solutionTo make the search case-insensitive, let’s bring the string to lower case and then search:

      
        
        
          
            
          
          
            
          
        
        
          function checkSpam(str) {
  let lowerStr = str.toLowerCase();

  return lowerStr.includes('viagra') || lowerStr.includes('xxx');
}

alert( checkSpam('buy ViAgRA now') );
alert( checkSpam('free xxxxx') );
alert( checkSpam("innocent rabbit") );
        
      
      
      Open the solution with tests in a sandbox.Truncate the textimportance: 5Create a function truncate(str, maxlength) that checks the length of the str and, if it exceeds maxlength – replaces the end of str with the ellipsis character "…", to make its length equal to maxlength.
The result of the function should be the truncated (if needed) string.
For instance:

      
        
        
          truncate("What I'd like to tell on this topic is:", 20) == "What I'd like to te…"

truncate("Hi everyone!", 20) == "Hi everyone!"
        
      
      
      Open a sandbox with tests.solutionThe maximal length must be maxlength, so we need to cut it a little shorter, to give space for the ellipsis.
Note that there is actually a single Unicode character for an ellipsis. That’s not three dots.

      
        
        
          
            
          
          
            
          
        
        
          function truncate(str, maxlength) {
  return (str.length > maxlength) ?
    str.slice(0, maxlength - 1) + '…' : str;
}
        
      
      
      Open the solution with tests in a sandbox.Extract the moneyimportance: 4We have a cost in the form "$120". That is: the dollar sign goes first, and then the number.
Create a function extractCurrencyValue(str) that would extract the numeric value from such string and return it.
The example:

      
        
        
          alert( extractCurrencyValue('$120') === 120 ); // true
        
      
      
      Open a sandbox with tests.solution
      
        
        
          function extractCurrencyValue(str) {
  return +str.slice(1);
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nIn JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
QuotesLet’s recall the kinds of quotes.
Strings can be enclosed within either single quotes, double quotes or backticks:

      
        
        
          let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
        
      
      
      Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
        
      
      
      Another advantage of using backticks is that they allow a string to span multiple lines:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
        
      
      
      Looks natural, right? But single or double quotes do not work this way.
If we use them and try to use multiple lines, there’ll be an error:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";
        
      
      
      Single and double quotes come from ancient times of language creation, when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.
Backticks also allow us to specify a “template function” before the first backtick. The syntax is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. This feature is called “tagged templates”, it’s rarely seen, but you can read about it in the MDN: Template literals.
Special charactersIt is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \n, which denotes a line break:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // a multiline list of guests, same as above
        
      
      
      As a simpler example, these two lines are equal, just written differently:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "Hello\nWorld"; // two lines using a "newline symbol"

// two lines using a normal newline and backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true
        
      
      
      There are other, less common special characters:



Character
Description




\n
New line


\r
In Windows text files a combination of two characters \r\n represents a new break, while on non-Windows OS it’s just \n. That’s for historical reasons, most Windows software also understands \n.


\', \", \`
Quotes


\\
Backslash


\t
Tab


\b, \f, \v
Backspace, Form Feed, Vertical Tab – mentioned for completeness, coming from old times, not used nowadays (you can forget them right now).



As you can see, all special characters start with a backslash character \. It is also called an “escape character”.
Because it’s so special, if we need to show an actual backslash \ within the string, we need to double it:

      
        
        
          
            
          
          
            
          
        
        
          alert( `The backslash: \\` ); // The backslash: \
        
      
      
      So-called “escaped” quotes \', \", \` are used to insert a quote into the same-quoted string.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'I\'m the Walrus!' ); // I'm the Walrus!
        
      
      
      As you can see, we have to prepend the inner quote by the backslash \', because otherwise it would indicate the string end.
Of course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or backticks instead:

      
        
        
          
            
          
          
            
          
        
        
          alert( "I'm the Walrus!" ); // I'm the Walrus!
        
      
      
      Besides these special characters, there’s also a special notation for Unicode codes \u…, it’s rarely used and is covered in the optional chapter about Unicode.
String lengthThe length property has the string length:

      
        
        
          
            
          
          
            
          
        
        
          alert( `My\n`.length ); // 3
        
      
      
      Note that \n is a single “special” character, so the length is indeed 3.

            length is a property
            People with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn’t work.
Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it. Not .length(), but .length.

Accessing charactersTo get a character at position pos, use square brackets [pos] or call the method str.at(pos). The first character starts from the zero position:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

// the first character
alert( str[0] ); // H
alert( str.at(0) ); // H

// the last character
alert( str[str.length - 1] ); // o
alert( str.at(-1) );
        
      
      
      As you can see, the .at(pos) method has a benefit of allowing negative position. If pos is negative, then it’s counted from the end of the string.
So .at(-1) means the last character, and .at(-2) is the one before it, etc.
The square brackets always return undefined for negative indexes, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
        
      
      
      We can also iterate over characters using for..of:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
}
        
      
      
      Strings are immutableStrings can’t be changed in JavaScript. It is impossible to change a character.
Let’s try it to show that it doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // doesn't work
        
      
      
      The usual workaround is to create a whole new string and assign it to str instead of the old one.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str = 'h' + str[1]; // replace the string

alert( str ); // hi
        
      
      
      In the following sections we’ll see more examples of this.
Changing the caseMethods toLowerCase() and toUpperCase() change the case:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
        
      
      
      Or, if we want a single character lowercased:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'[0].toLowerCase() ); // 'i'
        
      
      
      Searching for a substringThere are multiple ways to look for a substring within a string.
str.indexOfThe first method is str.indexOf(substr, pos).
It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive

alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)
        
      
      
      The optional second parameter allows us to start searching from a given position.
For instance, the first occurrence of "id" is at position 1. To look for the next occurrence, let’s start the search from position 2:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
        
      
      
      If we’re interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // let's look for it

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // continue the search from the next position
}
        
      
      
      The same algorithm can be layed out shorter:

      
        
        
          
            
          
          
            
          
        
        
          let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
        
      
      
      
            str.lastIndexOf(substr, position)
            There is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.
It would list the occurrences in the reverse order.

There is a slight inconvenience with indexOf in the if test. We can’t put it in the if like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("We found it"); // doesn't work!
}
        
      
      
      The alert in the example above doesn’t show because str.indexOf("Widget") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.
So, we should actually check for -1, like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("We found it"); // works now!
}
        
      
      
      includes, startsWith, endsWithThe more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.
It’s the right choice if we need to test for the match, but don’t need its position:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
        
      
      
      The optional second argument of str.includes is the position to start searching from:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, from position 3 there is no "id"
        
      
      
      The methods str.startsWith and str.endsWith do exactly what they say:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid"
alert( "Widget".endsWith("get") ); // true, "Widget" ends with "get"
        
      
      
      Getting a substringThere are 3 methods in JavaScript to get a substring: substring, substr and slice.

str.slice(start [, end])

Returns the part of the string from start to (but not including) end.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0
        
      
      
      If there is no second argument, then slice goes till the end of the string:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(2) ); // 'ringify', from the 2nd position till the end
        
      
      
      Negative values for start/end are also possible. They mean the position is counted from the string end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // 'gif'
        
      
      
      
str.substring(start [, end])

Returns the part of the string between start and end (not including end).
This is almost the same as slice, but it allows start to be greater than end (in this case it simply swaps start and end values).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// these are same for substring
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ...but not for slice:
alert( str.slice(2, 6) ); // "ring" (the same)
alert( str.slice(6, 2) ); // "" (an empty string)
        
      
      
      Negative arguments are (unlike slice) not supported, they are treated as 0.

str.substr(start [, length])

Returns the part of the string from start, with the given length.
In contrast with the previous methods, this one allows us to specify the length instead of the ending position:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(2, 4) ); // 'ring', from the 2nd position get 4 characters
        
      
      
      The first argument may be negative, to count from the end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi', from the 4th position get 2 characters
        
      
      
      This method resides in the Annex B of the language specification. It means that only browser-hosted Javascript engines should support it, and it’s not recommended to use it. In practice, it’s supported everywhere.


Let’s recap these methods to avoid any confusion:



method
selects…
negatives




slice(start, end)
from start to end (not including end)
allows negatives


substring(start, end)
between start and end (not including end)
negative values mean 0


substr(start, length)
from start get length characters
allows negative start




            Which one to choose?
            All of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.
Of the other two variants, slice is a little bit more flexible, it allows negative arguments and shorter to write.
So, for practical use it’s enough to remember only slice.

Comparing stringsAs we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.
Although, there are some oddities.


A lowercase letter is always greater than the uppercase:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'a' > 'Z' ); // true
        
      
      
      

Letters with diacritical marks are “out of order”:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich' > 'Zealand' ); // true
        
      
      
      This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list.


To understand what happens, we should be aware that strings in Javascript are encoded using UTF-16. That is: each character has a corresponding numeric code.
There are special methods that allow to get the character for the code and back:

str.codePointAt(pos)

Returns a decimal number representing the code for the character at position pos:

      
        
        
          
            
          
          
            
          
        
        
          // different case letters have different codes
alert( "Z".codePointAt(0) ); // 90
alert( "z".codePointAt(0) ); // 122
alert( "z".codePointAt(0).toString(16) ); // 7a (if we need a hexadecimal value)
        
      
      
      
String.fromCodePoint(code)

Creates a character by its numeric code

      
        
        
          
            
          
          
            
          
        
        
          alert( String.fromCodePoint(90) ); // Z
alert( String.fromCodePoint(0x5a) ); // Z (we can also use a hex value as an argument)
        
      
      
      

Now let’s see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:

      
        
        
          
            
          
          
            
          
        
        
          let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// Output:
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
        
      
      
      See? Capital characters go first, then a few special ones, then lowercase characters, and Ö near the end of the output.
Now it becomes obvious why a > Z.
The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

All lowercase letters go after uppercase letters because their codes are greater.
Some letters like Ö stand apart from the main alphabet. Here, its code is greater than anything from a to z.

Correct comparisonsThe “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.
So, the browser needs to know the language to compare.
Luckily, modern browsers support the internationalization standard ECMA-402.
It provides a special method to compare strings in different languages, following their rules.
The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:

Returns a negative number if str is less than str2.
Returns a positive number if str is greater than str2.
Returns 0 if they are equivalent.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich'.localeCompare('Zealand') ); // -1
        
      
      
      This method actually has two additional arguments specified in the documentation, which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sensitivity or should "a" and "á" be treated as the same etc.
Summary
There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${…}.
We can use special characters, such as a line break \n.
To get a character, use: [] or at method.
To get a substring, use: slice or substring.
To lowercase/uppercase a string, use: toLowerCase/toUpperCase.
To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.
To compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.

There are several other helpful methods in strings:

str.trim() – removes (“trims”) spaces from the beginning and end of the string.
str.repeat(n) – repeats the string n times.
…and more to be found in the manual.

Strings also have methods for doing search/replace with regular expressions. But that’s big topic, so it’s explained in a separate tutorial section Regular expressions.
Also, as of now it’s important to know that strings are based on Unicode encoding, and hence there’re issues with comparisons. There’s more about Unicode in the chapter Unicode, String internals.
TasksUppercase the first characterimportance: 5Write a function ucFirst(str) that returns the string str with the uppercased first character, for instance:

      
        
        
          ucFirst("john") == "John";
        
      
      
      Open a sandbox with tests.solutionWe can’t “replace” the first character, because strings in JavaScript are immutable.
But we can make a new string based on the existing one, with the uppercased first character:

      
        
        
          let newStr = str[0].toUpperCase() + str.slice(1);
        
      
      
      There’s a small problem though. If str is empty, then str[0] is undefined, and as undefined doesn’t have the toUpperCase() method, we’ll get an error.
The easiest way out is to add a test for an empty string, like this:

      
        
        
          
            
          
          
            
          
        
        
          function ucFirst(str) {
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("john") ); // John
        
      
      
      Open the solution with tests in a sandbox.Check for spamimportance: 5Write a function checkSpam(str) that returns true if str contains ‘viagra’ or ‘XXX’, otherwise false.
The function must be case-insensitive:

      
        
        
          checkSpam('buy ViAgRA now') == true
checkSpam('free xxxxx') == true
checkSpam("innocent rabbit") == false
        
      
      
      Open a sandbox with tests.solutionTo make the search case-insensitive, let’s bring the string to lower case and then search:

      
        
        
          
            
          
          
            
          
        
        
          function checkSpam(str) {
  let lowerStr = str.toLowerCase();

  return lowerStr.includes('viagra') || lowerStr.includes('xxx');
}

alert( checkSpam('buy ViAgRA now') );
alert( checkSpam('free xxxxx') );
alert( checkSpam("innocent rabbit") );
        
      
      
      Open the solution with tests in a sandbox.Truncate the textimportance: 5Create a function truncate(str, maxlength) that checks the length of the str and, if it exceeds maxlength – replaces the end of str with the ellipsis character "…", to make its length equal to maxlength.
The result of the function should be the truncated (if needed) string.
For instance:

      
        
        
          truncate("What I'd like to tell on this topic is:", 20) == "What I'd like to te…"

truncate("Hi everyone!", 20) == "Hi everyone!"
        
      
      
      Open a sandbox with tests.solutionThe maximal length must be maxlength, so we need to cut it a little shorter, to give space for the ellipsis.
Note that there is actually a single Unicode character for an ellipsis. That’s not three dots.

      
        
        
          
            
          
          
            
          
        
        
          function truncate(str, maxlength) {
  return (str.length > maxlength) ?
    str.slice(0, maxlength - 1) + '…' : str;
}
        
      
      
      Open the solution with tests in a sandbox.Extract the moneyimportance: 4We have a cost in the form "$120". That is: the dollar sign goes first, and then the number.
Create a function extractCurrencyValue(str) that would extract the numeric value from such string and return it.
The example:

      
        
        
          alert( extractCurrencyValue('$120') === 120 ); // true
        
      
      
      Open a sandbox with tests.solution
      
        
        
          function extractCurrencyValue(str) {
  return +str.slice(1);
}
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageData typesJanuary 17, 2024StringsIn JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
QuotesLet’s recall the kinds of quotes.
Strings can be enclosed within either single quotes, double quotes or backticks:

      
        
        
          let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
        
      
      
      Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
        
      
      
      Another advantage of using backticks is that they allow a string to span multiple lines:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
        
      
      
      Looks natural, right? But single or double quotes do not work this way.
If we use them and try to use multiple lines, there’ll be an error:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";
        
      
      
      Single and double quotes come from ancient times of language creation, when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.
Backticks also allow us to specify a “template function” before the first backtick. The syntax is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. This feature is called “tagged templates”, it’s rarely seen, but you can read about it in the MDN: Template literals.
Special charactersIt is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \n, which denotes a line break:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // a multiline list of guests, same as above
        
      
      
      As a simpler example, these two lines are equal, just written differently:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "Hello\nWorld"; // two lines using a "newline symbol"

// two lines using a normal newline and backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true
        
      
      
      There are other, less common special characters:



Character
Description




\n
New line


\r
In Windows text files a combination of two characters \r\n represents a new break, while on non-Windows OS it’s just \n. That’s for historical reasons, most Windows software also understands \n.


\', \", \`
Quotes


\\
Backslash


\t
Tab


\b, \f, \v
Backspace, Form Feed, Vertical Tab – mentioned for completeness, coming from old times, not used nowadays (you can forget them right now).



As you can see, all special characters start with a backslash character \. It is also called an “escape character”.
Because it’s so special, if we need to show an actual backslash \ within the string, we need to double it:

      
        
        
          
            
          
          
            
          
        
        
          alert( `The backslash: \\` ); // The backslash: \
        
      
      
      So-called “escaped” quotes \', \", \` are used to insert a quote into the same-quoted string.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'I\'m the Walrus!' ); // I'm the Walrus!
        
      
      
      As you can see, we have to prepend the inner quote by the backslash \', because otherwise it would indicate the string end.
Of course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or backticks instead:

      
        
        
          
            
          
          
            
          
        
        
          alert( "I'm the Walrus!" ); // I'm the Walrus!
        
      
      
      Besides these special characters, there’s also a special notation for Unicode codes \u…, it’s rarely used and is covered in the optional chapter about Unicode.
String lengthThe length property has the string length:

      
        
        
          
            
          
          
            
          
        
        
          alert( `My\n`.length ); // 3
        
      
      
      Note that \n is a single “special” character, so the length is indeed 3.

            length is a property
            People with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn’t work.
Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it. Not .length(), but .length.

Accessing charactersTo get a character at position pos, use square brackets [pos] or call the method str.at(pos). The first character starts from the zero position:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

// the first character
alert( str[0] ); // H
alert( str.at(0) ); // H

// the last character
alert( str[str.length - 1] ); // o
alert( str.at(-1) );
        
      
      
      As you can see, the .at(pos) method has a benefit of allowing negative position. If pos is negative, then it’s counted from the end of the string.
So .at(-1) means the last character, and .at(-2) is the one before it, etc.
The square brackets always return undefined for negative indexes, for instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hello`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
        
      
      
      We can also iterate over characters using for..of:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
}
        
      
      
      Strings are immutableStrings can’t be changed in JavaScript. It is impossible to change a character.
Let’s try it to show that it doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str[0] = 'h'; // error
alert( str[0] ); // doesn't work
        
      
      
      The usual workaround is to create a whole new string and assign it to str instead of the old one.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hi';

str = 'h' + str[1]; // replace the string

alert( str ); // hi
        
      
      
      In the following sections we’ll see more examples of this.
Changing the caseMethods toLowerCase() and toUpperCase() change the case:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
        
      
      
      Or, if we want a single character lowercased:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Interface'[0].toLowerCase() ); // 'i'
        
      
      
      Searching for a substringThere are multiple ways to look for a substring within a string.
str.indexOfThe first method is str.indexOf(substr, pos).
It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive

alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)
        
      
      
      The optional second parameter allows us to start searching from a given position.
For instance, the first occurrence of "id" is at position 1. To look for the next occurrence, let’s start the search from position 2:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
        
      
      
      If we’re interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // let's look for it

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // continue the search from the next position
}
        
      
      
      The same algorithm can be layed out shorter:

      
        
        
          
            
          
          
            
          
        
        
          let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
        
      
      
      
            str.lastIndexOf(substr, position)
            There is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.
It would list the occurrences in the reverse order.

There is a slight inconvenience with indexOf in the if test. We can’t put it in the if like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("We found it"); // doesn't work!
}
        
      
      
      The alert in the example above doesn’t show because str.indexOf("Widget") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.
So, we should actually check for -1, like this:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("We found it"); // works now!
}
        
      
      
      includes, startsWith, endsWithThe more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.
It’s the right choice if we need to test for the match, but don’t need its position:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
        
      
      
      The optional second argument of str.includes is the position to start searching from:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, from position 3 there is no "id"
        
      
      
      The methods str.startsWith and str.endsWith do exactly what they say:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid"
alert( "Widget".endsWith("get") ); // true, "Widget" ends with "get"
        
      
      
      Getting a substringThere are 3 methods in JavaScript to get a substring: substring, substr and slice.

str.slice(start [, end])

Returns the part of the string from start to (but not including) end.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0
        
      
      
      If there is no second argument, then slice goes till the end of the string:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(2) ); // 'ringify', from the 2nd position till the end
        
      
      
      Negative values for start/end are also possible. They mean the position is counted from the string end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // 'gif'
        
      
      
      
str.substring(start [, end])

Returns the part of the string between start and end (not including end).
This is almost the same as slice, but it allows start to be greater than end (in this case it simply swaps start and end values).
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// these are same for substring
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ...but not for slice:
alert( str.slice(2, 6) ); // "ring" (the same)
alert( str.slice(6, 2) ); // "" (an empty string)
        
      
      
      Negative arguments are (unlike slice) not supported, they are treated as 0.

str.substr(start [, length])

Returns the part of the string from start, with the given length.
In contrast with the previous methods, this one allows us to specify the length instead of the ending position:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(2, 4) ); // 'ring', from the 2nd position get 4 characters
        
      
      
      The first argument may be negative, to count from the end:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi', from the 4th position get 2 characters
        
      
      
      This method resides in the Annex B of the language specification. It means that only browser-hosted Javascript engines should support it, and it’s not recommended to use it. In practice, it’s supported everywhere.


Let’s recap these methods to avoid any confusion:



method
selects…
negatives




slice(start, end)
from start to end (not including end)
allows negatives


substring(start, end)
between start and end (not including end)
negative values mean 0


substr(start, length)
from start get length characters
allows negative start




            Which one to choose?
            All of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.
Of the other two variants, slice is a little bit more flexible, it allows negative arguments and shorter to write.
So, for practical use it’s enough to remember only slice.

Comparing stringsAs we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.
Although, there are some oddities.


A lowercase letter is always greater than the uppercase:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'a' > 'Z' ); // true
        
      
      
      

Letters with diacritical marks are “out of order”:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich' > 'Zealand' ); // true
        
      
      
      This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list.


To understand what happens, we should be aware that strings in Javascript are encoded using UTF-16. That is: each character has a corresponding numeric code.
There are special methods that allow to get the character for the code and back:

str.codePointAt(pos)

Returns a decimal number representing the code for the character at position pos:

      
        
        
          
            
          
          
            
          
        
        
          // different case letters have different codes
alert( "Z".codePointAt(0) ); // 90
alert( "z".codePointAt(0) ); // 122
alert( "z".codePointAt(0).toString(16) ); // 7a (if we need a hexadecimal value)
        
      
      
      
String.fromCodePoint(code)

Creates a character by its numeric code

      
        
        
          
            
          
          
            
          
        
        
          alert( String.fromCodePoint(90) ); // Z
alert( String.fromCodePoint(0x5a) ); // Z (we can also use a hex value as an argument)
        
      
      
      

Now let’s see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:

      
        
        
          
            
          
          
            
          
        
        
          let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// Output:
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
        
      
      
      See? Capital characters go first, then a few special ones, then lowercase characters, and Ö near the end of the output.
Now it becomes obvious why a > Z.
The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

All lowercase letters go after uppercase letters because their codes are greater.
Some letters like Ö stand apart from the main alphabet. Here, its code is greater than anything from a to z.

Correct comparisonsThe “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.
So, the browser needs to know the language to compare.
Luckily, modern browsers support the internationalization standard ECMA-402.
It provides a special method to compare strings in different languages, following their rules.
The call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:

Returns a negative number if str is less than str2.
Returns a positive number if str is greater than str2.
Returns 0 if they are equivalent.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Österreich'.localeCompare('Zealand') ); // -1
        
      
      
      This method actually has two additional arguments specified in the documentation, which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sensitivity or should "a" and "á" be treated as the same etc.
Summary
There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${…}.
We can use special characters, such as a line break \n.
To get a character, use: [] or at method.
To get a substring, use: slice or substring.
To lowercase/uppercase a string, use: toLowerCase/toUpperCase.
To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.
To compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.

There are several other helpful methods in strings:

str.trim() – removes (“trims”) spaces from the beginning and end of the string.
str.repeat(n) – repeats the string n times.
…and more to be found in the manual.

Strings also have methods for doing search/replace with regular expressions. But that’s big topic, so it’s explained in a separate tutorial section Regular expressions.
Also, as of now it’s important to know that strings are based on Unicode encoding, and hence there’re issues with comparisons. There’s more about Unicode in the chapter Unicode, String internals.
TasksUppercase the first characterimportance: 5Write a function ucFirst(str) that returns the string str with the uppercased first character, for instance:

      
        
        
          ucFirst("john") == "John";
        
      
      
      Open a sandbox with tests.solutionWe can’t “replace” the first character, because strings in JavaScript are immutable.
But we can make a new string based on the existing one, with the uppercased first character:

      
        
        
          let newStr = str[0].toUpperCase() + str.slice(1);
        
      
      
      There’s a small problem though. If str is empty, then str[0] is undefined, and as undefined doesn’t have the toUpperCase() method, we’ll get an error.
The easiest way out is to add a test for an empty string, like this:

      
        
        
          
            
          
          
            
          
        
        
          function ucFirst(str) {
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("john") ); // John
        
      
      
      Open the solution with tests in a sandbox.Check for spamimportance: 5Write a function checkSpam(str) that returns true if str contains ‘viagra’ or ‘XXX’, otherwise false.
The function must be case-insensitive:

      
        
        
          checkSpam('buy ViAgRA now') == true
checkSpam('free xxxxx') == true
checkSpam("innocent rabbit") == false
        
      
      
      Open a sandbox with tests.solutionTo make the search case-insensitive, let’s bring the string to lower case and then search:

      
        
        
          
            
          
          
            
          
        
        
          function checkSpam(str) {
  let lowerStr = str.toLowerCase();

  return lowerStr.includes('viagra') || lowerStr.includes('xxx');
}

alert( checkSpam('buy ViAgRA now') );
alert( checkSpam('free xxxxx') );
alert( checkSpam("innocent rabbit") );
        
      
      
      Open the solution with tests in a sandbox.Truncate the textimportance: 5Create a function truncate(str, maxlength) that checks the length of the str and, if it exceeds maxlength – replaces the end of str with the ellipsis character "…", to make its length equal to maxlength.
The result of the function should be the truncated (if needed) string.
For instance:

      
        
        
          truncate("What I'd like to tell on this topic is:", 20) == "What I'd like to te…"

truncate("Hi everyone!", 20) == "Hi everyone!"
        
      
      
      Open a sandbox with tests.solutionThe maximal length must be maxlength, so we need to cut it a little shorter, to give space for the ellipsis.
Note that there is actually a single Unicode character for an ellipsis. That’s not three dots.

      
        
        
          
            
          
          
            
          
        
        
          function truncate(str, maxlength) {
  return (str.length > maxlength) ?
    str.slice(0, maxlength - 1) + '…' : str;
}
        
      
      
      Open the solution with tests in a sandbox.Extract the moneyimportance: 4We have a cost in the form "$120". That is: the dollar sign goes first, and then the number.
Create a function extractCurrencyValue(str) that would extract the numeric value from such string and return it.
The example:

      
        
        
          alert( extractCurrencyValue('$120') === 120 ); // true
        
      
      
      Open a sandbox with tests.solution
      
        
        
          function extractCurrencyValue(str) {
  return +str.slice(1);
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nObjects allow you to store keyed collections of values. That’s fine.
But quite often we find that we need an ordered collection, where we have a 1st, a 2nd, a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.
It is not convenient to use an object here, because it provides no methods to manage the order of elements. We can’t insert a new property “between” the existing ones. Objects are just not meant for such use.
There exists a special data structure named Array, to store ordered collections.
DeclarationThere are two syntaxes for creating an empty array:

      
        
        
          let arr = new Array();
let arr = [];
        
      
      
      Almost all the time, the second syntax is used. We can supply initial elements in the brackets:

      
        
        
          let fruits = ["Apple", "Orange", "Plum"];
        
      
      
      Array elements are numbered, starting with zero.
We can get an element by its number in square brackets:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
        
      
      
      We can replace an element:

      
        
        
          fruits[2] = 'Pear'; // now ["Apple", "Orange", "Pear"]
        
      
      
      …Or add a new one to the array:

      
        
        
          fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]
        
      
      
      The total count of the elements in the array is its length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
        
      
      
      We can also use alert to show the whole array.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
        
      
      
      An array can store elements of any type.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// get the object at index 1 and then show its name
alert( arr[1].name ); // John

// get the function at index 3 and run it
arr[3](); // hello
        
      
      
      
            Trailing comma
            An array, just like an object, may end with a comma:

      
        
        
          let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
        
      
      
      The “trailing comma” style makes it easier to insert/remove items, because all lines become alike.

Get last elements with “at”
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
Let’s say we want the last element of the array.
Some programming languages allow the use of negative indexes for the same purpose, like fruits[-1].
Although, in JavaScript it won’t work. The result will be undefined, because the index in square brackets is treated literally.
We can explicitly calculate the last element index and then access it: fruits[fruits.length - 1].

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[fruits.length-1] ); // Plum
        
      
      
      A bit cumbersome, isn’t it? We need to write the variable name twice.
Luckily, there’s a shorter syntax: fruits.at(-1):

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// same as fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
        
      
      
      In other words, arr.at(i):

is exactly the same as arr[i], if i >= 0.
for negative values of i, it steps back from the end of the array.

Methods pop/push, shift/unshiftA queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:

push appends an element to the end.
shift get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.


      
      
        
      
      Arrays support both operations.
In practice we need it very often. For example, a queue of messages that need to be shown on-screen.
There’s another use case for arrays – the data structure named stack.
It supports two operations:

push adds an element to the end.
pop takes an element from the end.

So new elements are added or taken always from the “end”.
A stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:

      
      
        
      
      For stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).
Arrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements, both to/from the beginning or the end.
In computer science, the data structure that allows this, is called deque.
Methods that work with the end of the array:

pop

Extracts the last element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // remove "Pear" and alert it

alert( fruits ); // Apple, Orange
        
      
      
      Both fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.

push

Append the element to the end of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
        
      
      
      The call fruits.push(...) is equal to fruits[fruits.length] = ....


Methods that work with the beginning of the array:

shift

Extracts the first element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // remove Apple and alert it

alert( fruits ); // Orange, Pear
        
      
      
      
unshift

Add the element to the beginning of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
        
      
      
      

Methods push and unshift can add multiple elements at once:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
        
      
      
      InternalsAn array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That’s essentially the same as obj[key], where arr is the object, while numbers are used as keys.
They extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it’s still an object.
Remember, there are only eight basic data types in JavaScript (see the Data types chapter for more info). Array is an object and thus behaves like an object.
For instance, it is copied by reference:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Banana"]

let arr = fruits; // copy by reference (two variables reference the same array)

alert( arr === fruits ); // true

arr.push("Pear"); // modify the array by reference

alert( fruits ); // Banana, Pear - 2 items now
        
      
      
      …But what makes arrays really special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.
But they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object.
For instance, technically we can do this:

      
        
        
          let fruits = []; // make an array

fruits[99999] = 5; // assign a property with the index far greater than its length

fruits.age = 25; // create a property with an arbitrary name
        
      
      
      That’s possible, because arrays are objects at their base. We can add any properties to them.
But the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.
The ways to misuse an array:

Add a non-numeric property like arr.test = 5.
Make holes, like: add arr[0] and then arr[1000] (and nothing between them).
Fill the array in the reverse order, like arr[1000], arr[999] and so on.

Please think of arrays as special structures to work with the ordered data. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object {}.
PerformanceMethods push/pop run fast, while shift/unshift are slow.

      
      
        
      
      Why is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:

      
        
        
          fruits.shift(); // take 1 element from the start
        
      
      
      It’s not enough to take and remove the element with the index 0. Other elements need to be renumbered as well.
The shift operation must do 3 things:

Remove the element with the index 0.
Move all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.
Update the length property.


      
      
        
      
      The more elements in the array, the more time to move them, more in-memory operations.
The similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.
And what’s with push/pop? They do not need to move anything. To extract an element from the end, the pop method cleans the index and shortens length.
The actions for the pop operation:

      
        
        
          fruits.pop(); // take 1 element from the end
        
      
      
      
      
      
        
      
      The pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast.
The similar thing with the push method.
LoopsOne of the oldest ways to cycle array items is the for loop over indexes:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
        
      
      
      But for arrays there is another form of loop, for..of:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}
        
      
      
      The for..of doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter.
Technically, because arrays are objects, it is also possible to use for..in:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
        
      
      
      But that’s actually a bad idea. There are potential problems with it:


The loop for..in iterates over all properties, not only the numeric ones.
There are so-called “array-like” objects in the browser and in other environments, that look like arrays. That is, they have length and indexes properties, but they may also have other non-numeric properties and methods, which we usually don’t need. The for..in loop will list them though. So if we need to work with array-like objects, then these “extra” properties can become a problem.


The for..in loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it’s still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.


Generally, we shouldn’t use for..in for arrays.
A word about “length”The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.
For instance, a single element with a large index gives a big length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
        
      
      
      Note that we usually don’t use arrays like that.
Another interesting thing about the length property is that it’s writable.
If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here’s the example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

arr.length = 2; // truncate to 2 elements
alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not return
        
      
      
      So, the simplest way to clear the array is: arr.length = 0;.
new Array()There is one more syntax to create an array:

      
        
        
          let arr = new Array("Apple", "Pear", "etc");
        
      
      
      It’s rarely used, because square brackets [] are shorter. Also, there’s a tricky feature with it.
If new Array is called with a single argument which is a number, then it creates an array without items, but with the given length.
Let’s see how one can shoot themselves in the foot:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Array(2); // will it create an array of [2] ?

alert( arr[0] ); // undefined! no elements.

alert( arr.length ); // length 2
        
      
      
      To avoid such surprises, we usually use square brackets, unless we really know what we’re doing.
Multidimensional arraysArrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:

      
        
        
          
            
          
          
            
          
        
        
          let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[0][1] ); // 2, the second value of the first inner array
        
      
      
      toStringArrays have their own implementation of toString method that returns a comma-separated list of elements.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
        
      
      
      Also, let’s try this:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
        
      
      
      Arrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes "1" and [1,2] becomes "1,2".
When the binary plus "+" operator adds something to a string, it converts it to a string as well, so the next step looks like this:

      
        
        
          
            
          
          
            
          
        
        
          alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
        
      
      
      Don’t compare arrays with ==Arrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.
This operator has no special treatment for arrays, it works with them as with any objects.
Let’s recall the rules:

Two objects are equal == only if they’re references to the same object.
If one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.
…With an exception of null and undefined that equal == each other and nothing else.

The strict comparison === is even simpler, as it doesn’t convert types.
So, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] == [] ); // false
alert( [0] == [0] ); // false
        
      
      
      These arrays are technically different objects. So they aren’t equal. The == operator doesn’t do item-by-item comparison.
Comparison with primitives may give seemingly strange results as well:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == [] ); // true

alert('0' == [] ); // false
        
      
      
      Here, in both cases, we compare a primitive with an array object. So the array [] gets converted to primitive for the purpose of comparison and becomes an empty string ''.
Then the comparison process goes on with the primitives, as described in the chapter Type Conversions:

      
        
        
          
            
          
          
            
          
        
        
          // after [] was converted to ''
alert( 0 == '' ); // true, as '' becomes converted to number 0

alert('0' == '' ); // false, no type conversion, different strings
        
      
      
      So, how to compare arrays?
That’s simple: don’t use the == operator. Instead, compare them item-by-item in a loop or using iteration methods explained in the next chapter.
SummaryArray is a special kind of object, suited to storing and managing ordered data items.
The declaration:

      
        
        
          // square brackets (usual)
let arr = [item1, item2...];

// new Array (exceptionally rare)
let arr = new Array(item1, item2...);
        
      
      
      The call to new Array(number) creates an array with the given length, but without elements.

The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.
If we shorten length manually, the array is truncated.

Getting the elements:

we can get element by its index, like arr[0]
also we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].

We can use an array as a deque with the following operations:

push(...items) adds items to the end.
pop() removes the element from the end and returns it.
shift() removes the element from the beginning and returns it.
unshift(...items) adds items to the beginning.

To loop over the elements of the array:

for (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.
for (let item of arr) – the modern syntax for items only,
for (let i in arr) – never use.

To compare arrays, don’t use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it’s not what we usually want.
Instead you can use for..of loop to compare arrays item-by-item.
We will continue with arrays and study more methods to add, remove, extract elements and sort arrays in the next chapter Array methods.\n\nTutorialThe JavaScript languageData typesJune 8, 2024ArraysObjects allow you to store keyed collections of values. That’s fine.
But quite often we find that we need an ordered collection, where we have a 1st, a 2nd, a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.
It is not convenient to use an object here, because it provides no methods to manage the order of elements. We can’t insert a new property “between” the existing ones. Objects are just not meant for such use.
There exists a special data structure named Array, to store ordered collections.
DeclarationThere are two syntaxes for creating an empty array:

      
        
        
          let arr = new Array();
let arr = [];
        
      
      
      Almost all the time, the second syntax is used. We can supply initial elements in the brackets:

      
        
        
          let fruits = ["Apple", "Orange", "Plum"];
        
      
      
      Array elements are numbered, starting with zero.
We can get an element by its number in square brackets:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
        
      
      
      We can replace an element:

      
        
        
          fruits[2] = 'Pear'; // now ["Apple", "Orange", "Pear"]
        
      
      
      …Or add a new one to the array:

      
        
        
          fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]
        
      
      
      The total count of the elements in the array is its length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
        
      
      
      We can also use alert to show the whole array.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
        
      
      
      An array can store elements of any type.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// get the object at index 1 and then show its name
alert( arr[1].name ); // John

// get the function at index 3 and run it
arr[3](); // hello
        
      
      
      
            Trailing comma
            An array, just like an object, may end with a comma:

      
        
        
          let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
        
      
      
      The “trailing comma” style makes it easier to insert/remove items, because all lines become alike.

Get last elements with “at”
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
Let’s say we want the last element of the array.
Some programming languages allow the use of negative indexes for the same purpose, like fruits[-1].
Although, in JavaScript it won’t work. The result will be undefined, because the index in square brackets is treated literally.
We can explicitly calculate the last element index and then access it: fruits[fruits.length - 1].

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[fruits.length-1] ); // Plum
        
      
      
      A bit cumbersome, isn’t it? We need to write the variable name twice.
Luckily, there’s a shorter syntax: fruits.at(-1):

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// same as fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
        
      
      
      In other words, arr.at(i):

is exactly the same as arr[i], if i >= 0.
for negative values of i, it steps back from the end of the array.

Methods pop/push, shift/unshiftA queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:

push appends an element to the end.
shift get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.


      
      
        
      
      Arrays support both operations.
In practice we need it very often. For example, a queue of messages that need to be shown on-screen.
There’s another use case for arrays – the data structure named stack.
It supports two operations:

push adds an element to the end.
pop takes an element from the end.

So new elements are added or taken always from the “end”.
A stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:

      
      
        
      
      For stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).
Arrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements, both to/from the beginning or the end.
In computer science, the data structure that allows this, is called deque.
Methods that work with the end of the array:

pop

Extracts the last element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // remove "Pear" and alert it

alert( fruits ); // Apple, Orange
        
      
      
      Both fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.

push

Append the element to the end of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
        
      
      
      The call fruits.push(...) is equal to fruits[fruits.length] = ....


Methods that work with the beginning of the array:

shift

Extracts the first element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // remove Apple and alert it

alert( fruits ); // Orange, Pear
        
      
      
      
unshift

Add the element to the beginning of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
        
      
      
      

Methods push and unshift can add multiple elements at once:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
        
      
      
      InternalsAn array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That’s essentially the same as obj[key], where arr is the object, while numbers are used as keys.
They extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it’s still an object.
Remember, there are only eight basic data types in JavaScript (see the Data types chapter for more info). Array is an object and thus behaves like an object.
For instance, it is copied by reference:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Banana"]

let arr = fruits; // copy by reference (two variables reference the same array)

alert( arr === fruits ); // true

arr.push("Pear"); // modify the array by reference

alert( fruits ); // Banana, Pear - 2 items now
        
      
      
      …But what makes arrays really special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.
But they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object.
For instance, technically we can do this:

      
        
        
          let fruits = []; // make an array

fruits[99999] = 5; // assign a property with the index far greater than its length

fruits.age = 25; // create a property with an arbitrary name
        
      
      
      That’s possible, because arrays are objects at their base. We can add any properties to them.
But the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.
The ways to misuse an array:

Add a non-numeric property like arr.test = 5.
Make holes, like: add arr[0] and then arr[1000] (and nothing between them).
Fill the array in the reverse order, like arr[1000], arr[999] and so on.

Please think of arrays as special structures to work with the ordered data. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object {}.
PerformanceMethods push/pop run fast, while shift/unshift are slow.

      
      
        
      
      Why is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:

      
        
        
          fruits.shift(); // take 1 element from the start
        
      
      
      It’s not enough to take and remove the element with the index 0. Other elements need to be renumbered as well.
The shift operation must do 3 things:

Remove the element with the index 0.
Move all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.
Update the length property.


      
      
        
      
      The more elements in the array, the more time to move them, more in-memory operations.
The similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.
And what’s with push/pop? They do not need to move anything. To extract an element from the end, the pop method cleans the index and shortens length.
The actions for the pop operation:

      
        
        
          fruits.pop(); // take 1 element from the end
        
      
      
      
      
      
        
      
      The pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast.
The similar thing with the push method.
LoopsOne of the oldest ways to cycle array items is the for loop over indexes:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
        
      
      
      But for arrays there is another form of loop, for..of:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}
        
      
      
      The for..of doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter.
Technically, because arrays are objects, it is also possible to use for..in:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
        
      
      
      But that’s actually a bad idea. There are potential problems with it:


The loop for..in iterates over all properties, not only the numeric ones.
There are so-called “array-like” objects in the browser and in other environments, that look like arrays. That is, they have length and indexes properties, but they may also have other non-numeric properties and methods, which we usually don’t need. The for..in loop will list them though. So if we need to work with array-like objects, then these “extra” properties can become a problem.


The for..in loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it’s still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.


Generally, we shouldn’t use for..in for arrays.
A word about “length”The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.
For instance, a single element with a large index gives a big length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
        
      
      
      Note that we usually don’t use arrays like that.
Another interesting thing about the length property is that it’s writable.
If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here’s the example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

arr.length = 2; // truncate to 2 elements
alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not return
        
      
      
      So, the simplest way to clear the array is: arr.length = 0;.
new Array()There is one more syntax to create an array:

      
        
        
          let arr = new Array("Apple", "Pear", "etc");
        
      
      
      It’s rarely used, because square brackets [] are shorter. Also, there’s a tricky feature with it.
If new Array is called with a single argument which is a number, then it creates an array without items, but with the given length.
Let’s see how one can shoot themselves in the foot:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Array(2); // will it create an array of [2] ?

alert( arr[0] ); // undefined! no elements.

alert( arr.length ); // length 2
        
      
      
      To avoid such surprises, we usually use square brackets, unless we really know what we’re doing.
Multidimensional arraysArrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:

      
        
        
          
            
          
          
            
          
        
        
          let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[0][1] ); // 2, the second value of the first inner array
        
      
      
      toStringArrays have their own implementation of toString method that returns a comma-separated list of elements.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
        
      
      
      Also, let’s try this:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
        
      
      
      Arrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes "1" and [1,2] becomes "1,2".
When the binary plus "+" operator adds something to a string, it converts it to a string as well, so the next step looks like this:

      
        
        
          
            
          
          
            
          
        
        
          alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
        
      
      
      Don’t compare arrays with ==Arrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.
This operator has no special treatment for arrays, it works with them as with any objects.
Let’s recall the rules:

Two objects are equal == only if they’re references to the same object.
If one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.
…With an exception of null and undefined that equal == each other and nothing else.

The strict comparison === is even simpler, as it doesn’t convert types.
So, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] == [] ); // false
alert( [0] == [0] ); // false
        
      
      
      These arrays are technically different objects. So they aren’t equal. The == operator doesn’t do item-by-item comparison.
Comparison with primitives may give seemingly strange results as well:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == [] ); // true

alert('0' == [] ); // false
        
      
      
      Here, in both cases, we compare a primitive with an array object. So the array [] gets converted to primitive for the purpose of comparison and becomes an empty string ''.
Then the comparison process goes on with the primitives, as described in the chapter Type Conversions:

      
        
        
          
            
          
          
            
          
        
        
          // after [] was converted to ''
alert( 0 == '' ); // true, as '' becomes converted to number 0

alert('0' == '' ); // false, no type conversion, different strings
        
      
      
      So, how to compare arrays?
That’s simple: don’t use the == operator. Instead, compare them item-by-item in a loop or using iteration methods explained in the next chapter.
SummaryArray is a special kind of object, suited to storing and managing ordered data items.
The declaration:

      
        
        
          // square brackets (usual)
let arr = [item1, item2...];

// new Array (exceptionally rare)
let arr = new Array(item1, item2...);
        
      
      
      The call to new Array(number) creates an array with the given length, but without elements.

The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.
If we shorten length manually, the array is truncated.

Getting the elements:

we can get element by its index, like arr[0]
also we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].

We can use an array as a deque with the following operations:

push(...items) adds items to the end.
pop() removes the element from the end and returns it.
shift() removes the element from the beginning and returns it.
unshift(...items) adds items to the beginning.

To loop over the elements of the array:

for (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.
for (let item of arr) – the modern syntax for items only,
for (let i in arr) – never use.

To compare arrays, don’t use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it’s not what we usually want.
Instead you can use for..of loop to compare arrays item-by-item.
We will continue with arrays and study more methods to add, remove, extract elements and sort arrays in the next chapter Array methods.
TasksIs array copied?importance: 3What is this code going to show?

      
        
        
          let fruits = ["Apples", "Pear", "Orange"];

// push a new value into the "copy"
let shoppingCart = fruits;
shoppingCart.push("Banana");

// what's in fruits?
alert( fruits.length ); // ?
        
      
      
      solutionThe result is 4:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apples", "Pear", "Orange"];

let shoppingCart = fruits;

shoppingCart.push("Banana");

alert( fruits.length ); // 4
        
      
      
      That’s because arrays are objects. So both shoppingCart and fruits are the references to the same array.
Array operations.importance: 5Let’s try 5 array operations.

Create an array styles with items “Jazz” and “Blues”.
Append “Rock-n-Roll” to the end.
Replace the value in the middle with “Classics”. Your code for finding the middle value should work for any arrays with odd length.
Strip off the first value of the array and show it.
Prepend Rap and Reggae to the array.

The array in the process:

      
        
        
          Jazz, Blues
Jazz, Blues, Rock-n-Roll
Jazz, Classics, Rock-n-Roll
Classics, Rock-n-Roll
Rap, Reggae, Classics, Rock-n-Roll
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let styles = ["Jazz", "Blues"];
styles.push("Rock-n-Roll");
styles[Math.floor((styles.length - 1) / 2)] = "Classics";
alert( styles.shift() );
styles.unshift("Rap", "Reggae");
        
      
      
      Calling in an array contextimportance: 5What is the result? Why?

      
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
});

arr[2](); // ?
        
      
      
      solutionThe call arr[2]() is syntactically the good old obj[method](), in the role of obj we have arr, and in the role of method we have 2.
So we have a call of the function arr[2] as an object method. Naturally, it receives this referencing the object arr and outputs the array:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // a,b,function(){...}
        
      
      
      The array has 3 values: initially it had two, plus the function.
Sum input numbersimportance: 4Write the function sumInput() that:

Asks the user for values using prompt and stores the values in the array.
Finishes asking when the user enters a non-numeric value, an empty string, or presses “Cancel”.
Calculates and returns the sum of array items.

P.S. A zero 0 is a valid number, please don’t stop the input on zero.
Run the demosolutionPlease note the subtle, but important detail of the solution. We don’t convert value to number instantly after prompt, because after value = +value we would not be able to tell an empty string (stop sign) from the zero (valid number). We do it later instead.

      
        
        
          
            
          
          
            
          
        
        
          function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("A number please?", 0);

    // should we cancel?
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
        
      
      
      A maximal subarrayimportance: 2The input is an array of numbers, e.g. arr = [1, -2, 3, 4, -9, 6].
The task is: find the contiguous subarray of arr with the maximal sum of items.
Write the function getMaxSubSum(arr) that will return that sum.
For instance:

      
        
        
          getMaxSubSum([-1, 2, 3, -9]) == 5 (the sum of highlighted items)
getMaxSubSum([2, -1, 2, 3, -9]) == 6
getMaxSubSum([-1, 2, 3, -9, 11]) == 11
getMaxSubSum([-2, -1, 1, 2]) == 3
getMaxSubSum([100, -9, 2, -3, 5]) == 100
getMaxSubSum([1, 2, 3]) == 6 (take all)
        
      
      
      If all items are negative, it means that we take none (the subarray is empty), so the sum is zero:

      
        
        
          getMaxSubSum([-1, -2, -3]) = 0
        
      
      
      Please try to think of a fast solution: O(n2) or even O(n) if you can.
Open a sandbox with tests.solutionSlow solutionSlow solutionWe can calculate all possible subsums.
The simplest way is to take every element and calculate sums of all subarrays starting from it.
For instance, for [-1, 2, 3, -9, 11]:

      
        
        
          // Starting from -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Starting from 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Starting from 3:
3
3 + (-9)
3 + (-9) + 11

// Starting from -9
-9
-9 + 11

// Starting from 11
11
        
      
      
      The code is actually a nested loop: the external loop over array elements, and the internal counts subsums starting with the current element.

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0; // if we take no elements, zero will be returned

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
        
      
      
      The solution has a time complexity of O(n2). In other words, if we increase the array size 2 times, the algorithm will work 4 times longer.
For big arrays (1000, 10000 or more items) such algorithms can lead to serious sluggishness.
Fast solutionFast solutionLet’s walk the array and keep the current partial sum of elements in the variable s. If s becomes negative at some point, then assign s=0. The maximum of all such s will be the answer.
If the description is too vague, please see the code, it’s short enough:

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;

  for (let item of arr) { // for each item of arr
    partialSum += item; // add it to partialSum
    maxSum = Math.max(maxSum, partialSum); // remember the maximum
    if (partialSum < 0) partialSum = 0; // zero if negative
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
        
      
      
      The algorithm requires exactly 1 array pass, so the time complexity is O(n).
You can find more detailed information about the algorithm here: Maximum subarray problem. If it’s still not obvious why that works, then please trace the algorithm on the examples above, see how it works, that’s better than any words.
Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nObjects allow you to store keyed collections of values. That’s fine.
But quite often we find that we need an ordered collection, where we have a 1st, a 2nd, a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.
It is not convenient to use an object here, because it provides no methods to manage the order of elements. We can’t insert a new property “between” the existing ones. Objects are just not meant for such use.
There exists a special data structure named Array, to store ordered collections.
DeclarationThere are two syntaxes for creating an empty array:

      
        
        
          let arr = new Array();
let arr = [];
        
      
      
      Almost all the time, the second syntax is used. We can supply initial elements in the brackets:

      
        
        
          let fruits = ["Apple", "Orange", "Plum"];
        
      
      
      Array elements are numbered, starting with zero.
We can get an element by its number in square brackets:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
        
      
      
      We can replace an element:

      
        
        
          fruits[2] = 'Pear'; // now ["Apple", "Orange", "Pear"]
        
      
      
      …Or add a new one to the array:

      
        
        
          fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]
        
      
      
      The total count of the elements in the array is its length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
        
      
      
      We can also use alert to show the whole array.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
        
      
      
      An array can store elements of any type.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// get the object at index 1 and then show its name
alert( arr[1].name ); // John

// get the function at index 3 and run it
arr[3](); // hello
        
      
      
      
            Trailing comma
            An array, just like an object, may end with a comma:

      
        
        
          let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
        
      
      
      The “trailing comma” style makes it easier to insert/remove items, because all lines become alike.

Get last elements with “at”
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
Let’s say we want the last element of the array.
Some programming languages allow the use of negative indexes for the same purpose, like fruits[-1].
Although, in JavaScript it won’t work. The result will be undefined, because the index in square brackets is treated literally.
We can explicitly calculate the last element index and then access it: fruits[fruits.length - 1].

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[fruits.length-1] ); // Plum
        
      
      
      A bit cumbersome, isn’t it? We need to write the variable name twice.
Luckily, there’s a shorter syntax: fruits.at(-1):

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// same as fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
        
      
      
      In other words, arr.at(i):

is exactly the same as arr[i], if i >= 0.
for negative values of i, it steps back from the end of the array.

Methods pop/push, shift/unshiftA queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:

push appends an element to the end.
shift get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.


      
      
        
      
      Arrays support both operations.
In practice we need it very often. For example, a queue of messages that need to be shown on-screen.
There’s another use case for arrays – the data structure named stack.
It supports two operations:

push adds an element to the end.
pop takes an element from the end.

So new elements are added or taken always from the “end”.
A stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:

      
      
        
      
      For stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).
Arrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements, both to/from the beginning or the end.
In computer science, the data structure that allows this, is called deque.
Methods that work with the end of the array:

pop

Extracts the last element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // remove "Pear" and alert it

alert( fruits ); // Apple, Orange
        
      
      
      Both fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.

push

Append the element to the end of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
        
      
      
      The call fruits.push(...) is equal to fruits[fruits.length] = ....


Methods that work with the beginning of the array:

shift

Extracts the first element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // remove Apple and alert it

alert( fruits ); // Orange, Pear
        
      
      
      
unshift

Add the element to the beginning of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
        
      
      
      

Methods push and unshift can add multiple elements at once:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
        
      
      
      InternalsAn array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That’s essentially the same as obj[key], where arr is the object, while numbers are used as keys.
They extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it’s still an object.
Remember, there are only eight basic data types in JavaScript (see the Data types chapter for more info). Array is an object and thus behaves like an object.
For instance, it is copied by reference:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Banana"]

let arr = fruits; // copy by reference (two variables reference the same array)

alert( arr === fruits ); // true

arr.push("Pear"); // modify the array by reference

alert( fruits ); // Banana, Pear - 2 items now
        
      
      
      …But what makes arrays really special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.
But they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object.
For instance, technically we can do this:

      
        
        
          let fruits = []; // make an array

fruits[99999] = 5; // assign a property with the index far greater than its length

fruits.age = 25; // create a property with an arbitrary name
        
      
      
      That’s possible, because arrays are objects at their base. We can add any properties to them.
But the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.
The ways to misuse an array:

Add a non-numeric property like arr.test = 5.
Make holes, like: add arr[0] and then arr[1000] (and nothing between them).
Fill the array in the reverse order, like arr[1000], arr[999] and so on.

Please think of arrays as special structures to work with the ordered data. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object {}.
PerformanceMethods push/pop run fast, while shift/unshift are slow.

      
      
        
      
      Why is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:

      
        
        
          fruits.shift(); // take 1 element from the start
        
      
      
      It’s not enough to take and remove the element with the index 0. Other elements need to be renumbered as well.
The shift operation must do 3 things:

Remove the element with the index 0.
Move all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.
Update the length property.


      
      
        
      
      The more elements in the array, the more time to move them, more in-memory operations.
The similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.
And what’s with push/pop? They do not need to move anything. To extract an element from the end, the pop method cleans the index and shortens length.
The actions for the pop operation:

      
        
        
          fruits.pop(); // take 1 element from the end
        
      
      
      
      
      
        
      
      The pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast.
The similar thing with the push method.
LoopsOne of the oldest ways to cycle array items is the for loop over indexes:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
        
      
      
      But for arrays there is another form of loop, for..of:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}
        
      
      
      The for..of doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter.
Technically, because arrays are objects, it is also possible to use for..in:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
        
      
      
      But that’s actually a bad idea. There are potential problems with it:


The loop for..in iterates over all properties, not only the numeric ones.
There are so-called “array-like” objects in the browser and in other environments, that look like arrays. That is, they have length and indexes properties, but they may also have other non-numeric properties and methods, which we usually don’t need. The for..in loop will list them though. So if we need to work with array-like objects, then these “extra” properties can become a problem.


The for..in loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it’s still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.


Generally, we shouldn’t use for..in for arrays.
A word about “length”The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.
For instance, a single element with a large index gives a big length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
        
      
      
      Note that we usually don’t use arrays like that.
Another interesting thing about the length property is that it’s writable.
If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here’s the example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

arr.length = 2; // truncate to 2 elements
alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not return
        
      
      
      So, the simplest way to clear the array is: arr.length = 0;.
new Array()There is one more syntax to create an array:

      
        
        
          let arr = new Array("Apple", "Pear", "etc");
        
      
      
      It’s rarely used, because square brackets [] are shorter. Also, there’s a tricky feature with it.
If new Array is called with a single argument which is a number, then it creates an array without items, but with the given length.
Let’s see how one can shoot themselves in the foot:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Array(2); // will it create an array of [2] ?

alert( arr[0] ); // undefined! no elements.

alert( arr.length ); // length 2
        
      
      
      To avoid such surprises, we usually use square brackets, unless we really know what we’re doing.
Multidimensional arraysArrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:

      
        
        
          
            
          
          
            
          
        
        
          let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[0][1] ); // 2, the second value of the first inner array
        
      
      
      toStringArrays have their own implementation of toString method that returns a comma-separated list of elements.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
        
      
      
      Also, let’s try this:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
        
      
      
      Arrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes "1" and [1,2] becomes "1,2".
When the binary plus "+" operator adds something to a string, it converts it to a string as well, so the next step looks like this:

      
        
        
          
            
          
          
            
          
        
        
          alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
        
      
      
      Don’t compare arrays with ==Arrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.
This operator has no special treatment for arrays, it works with them as with any objects.
Let’s recall the rules:

Two objects are equal == only if they’re references to the same object.
If one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.
…With an exception of null and undefined that equal == each other and nothing else.

The strict comparison === is even simpler, as it doesn’t convert types.
So, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] == [] ); // false
alert( [0] == [0] ); // false
        
      
      
      These arrays are technically different objects. So they aren’t equal. The == operator doesn’t do item-by-item comparison.
Comparison with primitives may give seemingly strange results as well:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == [] ); // true

alert('0' == [] ); // false
        
      
      
      Here, in both cases, we compare a primitive with an array object. So the array [] gets converted to primitive for the purpose of comparison and becomes an empty string ''.
Then the comparison process goes on with the primitives, as described in the chapter Type Conversions:

      
        
        
          
            
          
          
            
          
        
        
          // after [] was converted to ''
alert( 0 == '' ); // true, as '' becomes converted to number 0

alert('0' == '' ); // false, no type conversion, different strings
        
      
      
      So, how to compare arrays?
That’s simple: don’t use the == operator. Instead, compare them item-by-item in a loop or using iteration methods explained in the next chapter.
SummaryArray is a special kind of object, suited to storing and managing ordered data items.
The declaration:

      
        
        
          // square brackets (usual)
let arr = [item1, item2...];

// new Array (exceptionally rare)
let arr = new Array(item1, item2...);
        
      
      
      The call to new Array(number) creates an array with the given length, but without elements.

The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.
If we shorten length manually, the array is truncated.

Getting the elements:

we can get element by its index, like arr[0]
also we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].

We can use an array as a deque with the following operations:

push(...items) adds items to the end.
pop() removes the element from the end and returns it.
shift() removes the element from the beginning and returns it.
unshift(...items) adds items to the beginning.

To loop over the elements of the array:

for (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.
for (let item of arr) – the modern syntax for items only,
for (let i in arr) – never use.

To compare arrays, don’t use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it’s not what we usually want.
Instead you can use for..of loop to compare arrays item-by-item.
We will continue with arrays and study more methods to add, remove, extract elements and sort arrays in the next chapter Array methods.
TasksIs array copied?importance: 3What is this code going to show?

      
        
        
          let fruits = ["Apples", "Pear", "Orange"];

// push a new value into the "copy"
let shoppingCart = fruits;
shoppingCart.push("Banana");

// what's in fruits?
alert( fruits.length ); // ?
        
      
      
      solutionThe result is 4:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apples", "Pear", "Orange"];

let shoppingCart = fruits;

shoppingCart.push("Banana");

alert( fruits.length ); // 4
        
      
      
      That’s because arrays are objects. So both shoppingCart and fruits are the references to the same array.
Array operations.importance: 5Let’s try 5 array operations.

Create an array styles with items “Jazz” and “Blues”.
Append “Rock-n-Roll” to the end.
Replace the value in the middle with “Classics”. Your code for finding the middle value should work for any arrays with odd length.
Strip off the first value of the array and show it.
Prepend Rap and Reggae to the array.

The array in the process:

      
        
        
          Jazz, Blues
Jazz, Blues, Rock-n-Roll
Jazz, Classics, Rock-n-Roll
Classics, Rock-n-Roll
Rap, Reggae, Classics, Rock-n-Roll
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let styles = ["Jazz", "Blues"];
styles.push("Rock-n-Roll");
styles[Math.floor((styles.length - 1) / 2)] = "Classics";
alert( styles.shift() );
styles.unshift("Rap", "Reggae");
        
      
      
      Calling in an array contextimportance: 5What is the result? Why?

      
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
});

arr[2](); // ?
        
      
      
      solutionThe call arr[2]() is syntactically the good old obj[method](), in the role of obj we have arr, and in the role of method we have 2.
So we have a call of the function arr[2] as an object method. Naturally, it receives this referencing the object arr and outputs the array:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // a,b,function(){...}
        
      
      
      The array has 3 values: initially it had two, plus the function.
Sum input numbersimportance: 4Write the function sumInput() that:

Asks the user for values using prompt and stores the values in the array.
Finishes asking when the user enters a non-numeric value, an empty string, or presses “Cancel”.
Calculates and returns the sum of array items.

P.S. A zero 0 is a valid number, please don’t stop the input on zero.
Run the demosolutionPlease note the subtle, but important detail of the solution. We don’t convert value to number instantly after prompt, because after value = +value we would not be able to tell an empty string (stop sign) from the zero (valid number). We do it later instead.

      
        
        
          
            
          
          
            
          
        
        
          function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("A number please?", 0);

    // should we cancel?
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
        
      
      
      A maximal subarrayimportance: 2The input is an array of numbers, e.g. arr = [1, -2, 3, 4, -9, 6].
The task is: find the contiguous subarray of arr with the maximal sum of items.
Write the function getMaxSubSum(arr) that will return that sum.
For instance:

      
        
        
          getMaxSubSum([-1, 2, 3, -9]) == 5 (the sum of highlighted items)
getMaxSubSum([2, -1, 2, 3, -9]) == 6
getMaxSubSum([-1, 2, 3, -9, 11]) == 11
getMaxSubSum([-2, -1, 1, 2]) == 3
getMaxSubSum([100, -9, 2, -3, 5]) == 100
getMaxSubSum([1, 2, 3]) == 6 (take all)
        
      
      
      If all items are negative, it means that we take none (the subarray is empty), so the sum is zero:

      
        
        
          getMaxSubSum([-1, -2, -3]) = 0
        
      
      
      Please try to think of a fast solution: O(n2) or even O(n) if you can.
Open a sandbox with tests.solutionSlow solutionSlow solutionWe can calculate all possible subsums.
The simplest way is to take every element and calculate sums of all subarrays starting from it.
For instance, for [-1, 2, 3, -9, 11]:

      
        
        
          // Starting from -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Starting from 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Starting from 3:
3
3 + (-9)
3 + (-9) + 11

// Starting from -9
-9
-9 + 11

// Starting from 11
11
        
      
      
      The code is actually a nested loop: the external loop over array elements, and the internal counts subsums starting with the current element.

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0; // if we take no elements, zero will be returned

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
        
      
      
      The solution has a time complexity of O(n2). In other words, if we increase the array size 2 times, the algorithm will work 4 times longer.
For big arrays (1000, 10000 or more items) such algorithms can lead to serious sluggishness.
Fast solutionFast solutionLet’s walk the array and keep the current partial sum of elements in the variable s. If s becomes negative at some point, then assign s=0. The maximum of all such s will be the answer.
If the description is too vague, please see the code, it’s short enough:

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;

  for (let item of arr) { // for each item of arr
    partialSum += item; // add it to partialSum
    maxSum = Math.max(maxSum, partialSum); // remember the maximum
    if (partialSum < 0) partialSum = 0; // zero if negative
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
        
      
      
      The algorithm requires exactly 1 array pass, so the time complexity is O(n).
You can find more detailed information about the algorithm here: Maximum subarray problem. If it’s still not obvious why that works, then please trace the algorithm on the examples above, see how it works, that’s better than any words.
Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageData typesJune 8, 2024ArraysObjects allow you to store keyed collections of values. That’s fine.
But quite often we find that we need an ordered collection, where we have a 1st, a 2nd, a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.
It is not convenient to use an object here, because it provides no methods to manage the order of elements. We can’t insert a new property “between” the existing ones. Objects are just not meant for such use.
There exists a special data structure named Array, to store ordered collections.
DeclarationThere are two syntaxes for creating an empty array:

      
        
        
          let arr = new Array();
let arr = [];
        
      
      
      Almost all the time, the second syntax is used. We can supply initial elements in the brackets:

      
        
        
          let fruits = ["Apple", "Orange", "Plum"];
        
      
      
      Array elements are numbered, starting with zero.
We can get an element by its number in square brackets:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
        
      
      
      We can replace an element:

      
        
        
          fruits[2] = 'Pear'; // now ["Apple", "Orange", "Pear"]
        
      
      
      …Or add a new one to the array:

      
        
        
          fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]
        
      
      
      The total count of the elements in the array is its length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
        
      
      
      We can also use alert to show the whole array.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
        
      
      
      An array can store elements of any type.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// get the object at index 1 and then show its name
alert( arr[1].name ); // John

// get the function at index 3 and run it
arr[3](); // hello
        
      
      
      
            Trailing comma
            An array, just like an object, may end with a comma:

      
        
        
          let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
        
      
      
      The “trailing comma” style makes it easier to insert/remove items, because all lines become alike.

Get last elements with “at”
            A recent addition
            
            This is a recent addition to the language.
            Old browsers may need polyfills.
            
Let’s say we want the last element of the array.
Some programming languages allow the use of negative indexes for the same purpose, like fruits[-1].
Although, in JavaScript it won’t work. The result will be undefined, because the index in square brackets is treated literally.
We can explicitly calculate the last element index and then access it: fruits[fruits.length - 1].

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[fruits.length-1] ); // Plum
        
      
      
      A bit cumbersome, isn’t it? We need to write the variable name twice.
Luckily, there’s a shorter syntax: fruits.at(-1):

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// same as fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
        
      
      
      In other words, arr.at(i):

is exactly the same as arr[i], if i >= 0.
for negative values of i, it steps back from the end of the array.

Methods pop/push, shift/unshiftA queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:

push appends an element to the end.
shift get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.


      
      
        
      
      Arrays support both operations.
In practice we need it very often. For example, a queue of messages that need to be shown on-screen.
There’s another use case for arrays – the data structure named stack.
It supports two operations:

push adds an element to the end.
pop takes an element from the end.

So new elements are added or taken always from the “end”.
A stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:

      
      
        
      
      For stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).
Arrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements, both to/from the beginning or the end.
In computer science, the data structure that allows this, is called deque.
Methods that work with the end of the array:

pop

Extracts the last element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // remove "Pear" and alert it

alert( fruits ); // Apple, Orange
        
      
      
      Both fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.

push

Append the element to the end of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
        
      
      
      The call fruits.push(...) is equal to fruits[fruits.length] = ....


Methods that work with the beginning of the array:

shift

Extracts the first element of the array and returns it:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // remove Apple and alert it

alert( fruits ); // Orange, Pear
        
      
      
      
unshift

Add the element to the beginning of the array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
        
      
      
      

Methods push and unshift can add multiple elements at once:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
        
      
      
      InternalsAn array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That’s essentially the same as obj[key], where arr is the object, while numbers are used as keys.
They extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it’s still an object.
Remember, there are only eight basic data types in JavaScript (see the Data types chapter for more info). Array is an object and thus behaves like an object.
For instance, it is copied by reference:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Banana"]

let arr = fruits; // copy by reference (two variables reference the same array)

alert( arr === fruits ); // true

arr.push("Pear"); // modify the array by reference

alert( fruits ); // Banana, Pear - 2 items now
        
      
      
      …But what makes arrays really special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.
But they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object.
For instance, technically we can do this:

      
        
        
          let fruits = []; // make an array

fruits[99999] = 5; // assign a property with the index far greater than its length

fruits.age = 25; // create a property with an arbitrary name
        
      
      
      That’s possible, because arrays are objects at their base. We can add any properties to them.
But the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.
The ways to misuse an array:

Add a non-numeric property like arr.test = 5.
Make holes, like: add arr[0] and then arr[1000] (and nothing between them).
Fill the array in the reverse order, like arr[1000], arr[999] and so on.

Please think of arrays as special structures to work with the ordered data. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object {}.
PerformanceMethods push/pop run fast, while shift/unshift are slow.

      
      
        
      
      Why is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:

      
        
        
          fruits.shift(); // take 1 element from the start
        
      
      
      It’s not enough to take and remove the element with the index 0. Other elements need to be renumbered as well.
The shift operation must do 3 things:

Remove the element with the index 0.
Move all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.
Update the length property.


      
      
        
      
      The more elements in the array, the more time to move them, more in-memory operations.
The similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.
And what’s with push/pop? They do not need to move anything. To extract an element from the end, the pop method cleans the index and shortens length.
The actions for the pop operation:

      
        
        
          fruits.pop(); // take 1 element from the end
        
      
      
      
      
      
        
      
      The pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast.
The similar thing with the push method.
LoopsOne of the oldest ways to cycle array items is the for loop over indexes:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
        
      
      
      But for arrays there is another form of loop, for..of:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}
        
      
      
      The for..of doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter.
Technically, because arrays are objects, it is also possible to use for..in:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
        
      
      
      But that’s actually a bad idea. There are potential problems with it:


The loop for..in iterates over all properties, not only the numeric ones.
There are so-called “array-like” objects in the browser and in other environments, that look like arrays. That is, they have length and indexes properties, but they may also have other non-numeric properties and methods, which we usually don’t need. The for..in loop will list them though. So if we need to work with array-like objects, then these “extra” properties can become a problem.


The for..in loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it’s still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.


Generally, we shouldn’t use for..in for arrays.
A word about “length”The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.
For instance, a single element with a large index gives a big length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
        
      
      
      Note that we usually don’t use arrays like that.
Another interesting thing about the length property is that it’s writable.
If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here’s the example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

arr.length = 2; // truncate to 2 elements
alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not return
        
      
      
      So, the simplest way to clear the array is: arr.length = 0;.
new Array()There is one more syntax to create an array:

      
        
        
          let arr = new Array("Apple", "Pear", "etc");
        
      
      
      It’s rarely used, because square brackets [] are shorter. Also, there’s a tricky feature with it.
If new Array is called with a single argument which is a number, then it creates an array without items, but with the given length.
Let’s see how one can shoot themselves in the foot:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Array(2); // will it create an array of [2] ?

alert( arr[0] ); // undefined! no elements.

alert( arr.length ); // length 2
        
      
      
      To avoid such surprises, we usually use square brackets, unless we really know what we’re doing.
Multidimensional arraysArrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:

      
        
        
          
            
          
          
            
          
        
        
          let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[0][1] ); // 2, the second value of the first inner array
        
      
      
      toStringArrays have their own implementation of toString method that returns a comma-separated list of elements.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
        
      
      
      Also, let’s try this:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
        
      
      
      Arrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes "1" and [1,2] becomes "1,2".
When the binary plus "+" operator adds something to a string, it converts it to a string as well, so the next step looks like this:

      
        
        
          
            
          
          
            
          
        
        
          alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
        
      
      
      Don’t compare arrays with ==Arrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.
This operator has no special treatment for arrays, it works with them as with any objects.
Let’s recall the rules:

Two objects are equal == only if they’re references to the same object.
If one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.
…With an exception of null and undefined that equal == each other and nothing else.

The strict comparison === is even simpler, as it doesn’t convert types.
So, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.
For example:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] == [] ); // false
alert( [0] == [0] ); // false
        
      
      
      These arrays are technically different objects. So they aren’t equal. The == operator doesn’t do item-by-item comparison.
Comparison with primitives may give seemingly strange results as well:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == [] ); // true

alert('0' == [] ); // false
        
      
      
      Here, in both cases, we compare a primitive with an array object. So the array [] gets converted to primitive for the purpose of comparison and becomes an empty string ''.
Then the comparison process goes on with the primitives, as described in the chapter Type Conversions:

      
        
        
          
            
          
          
            
          
        
        
          // after [] was converted to ''
alert( 0 == '' ); // true, as '' becomes converted to number 0

alert('0' == '' ); // false, no type conversion, different strings
        
      
      
      So, how to compare arrays?
That’s simple: don’t use the == operator. Instead, compare them item-by-item in a loop or using iteration methods explained in the next chapter.
SummaryArray is a special kind of object, suited to storing and managing ordered data items.
The declaration:

      
        
        
          // square brackets (usual)
let arr = [item1, item2...];

// new Array (exceptionally rare)
let arr = new Array(item1, item2...);
        
      
      
      The call to new Array(number) creates an array with the given length, but without elements.

The length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.
If we shorten length manually, the array is truncated.

Getting the elements:

we can get element by its index, like arr[0]
also we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].

We can use an array as a deque with the following operations:

push(...items) adds items to the end.
pop() removes the element from the end and returns it.
shift() removes the element from the beginning and returns it.
unshift(...items) adds items to the beginning.

To loop over the elements of the array:

for (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.
for (let item of arr) – the modern syntax for items only,
for (let i in arr) – never use.

To compare arrays, don’t use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it’s not what we usually want.
Instead you can use for..of loop to compare arrays item-by-item.
We will continue with arrays and study more methods to add, remove, extract elements and sort arrays in the next chapter Array methods.
TasksIs array copied?importance: 3What is this code going to show?

      
        
        
          let fruits = ["Apples", "Pear", "Orange"];

// push a new value into the "copy"
let shoppingCart = fruits;
shoppingCart.push("Banana");

// what's in fruits?
alert( fruits.length ); // ?
        
      
      
      solutionThe result is 4:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apples", "Pear", "Orange"];

let shoppingCart = fruits;

shoppingCart.push("Banana");

alert( fruits.length ); // 4
        
      
      
      That’s because arrays are objects. So both shoppingCart and fruits are the references to the same array.
Array operations.importance: 5Let’s try 5 array operations.

Create an array styles with items “Jazz” and “Blues”.
Append “Rock-n-Roll” to the end.
Replace the value in the middle with “Classics”. Your code for finding the middle value should work for any arrays with odd length.
Strip off the first value of the array and show it.
Prepend Rap and Reggae to the array.

The array in the process:

      
        
        
          Jazz, Blues
Jazz, Blues, Rock-n-Roll
Jazz, Classics, Rock-n-Roll
Classics, Rock-n-Roll
Rap, Reggae, Classics, Rock-n-Roll
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let styles = ["Jazz", "Blues"];
styles.push("Rock-n-Roll");
styles[Math.floor((styles.length - 1) / 2)] = "Classics";
alert( styles.shift() );
styles.unshift("Rap", "Reggae");
        
      
      
      Calling in an array contextimportance: 5What is the result? Why?

      
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
});

arr[2](); // ?
        
      
      
      solutionThe call arr[2]() is syntactically the good old obj[method](), in the role of obj we have arr, and in the role of method we have 2.
So we have a call of the function arr[2] as an object method. Naturally, it receives this referencing the object arr and outputs the array:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // a,b,function(){...}
        
      
      
      The array has 3 values: initially it had two, plus the function.
Sum input numbersimportance: 4Write the function sumInput() that:

Asks the user for values using prompt and stores the values in the array.
Finishes asking when the user enters a non-numeric value, an empty string, or presses “Cancel”.
Calculates and returns the sum of array items.

P.S. A zero 0 is a valid number, please don’t stop the input on zero.
Run the demosolutionPlease note the subtle, but important detail of the solution. We don’t convert value to number instantly after prompt, because after value = +value we would not be able to tell an empty string (stop sign) from the zero (valid number). We do it later instead.

      
        
        
          
            
          
          
            
          
        
        
          function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("A number please?", 0);

    // should we cancel?
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
        
      
      
      A maximal subarrayimportance: 2The input is an array of numbers, e.g. arr = [1, -2, 3, 4, -9, 6].
The task is: find the contiguous subarray of arr with the maximal sum of items.
Write the function getMaxSubSum(arr) that will return that sum.
For instance:

      
        
        
          getMaxSubSum([-1, 2, 3, -9]) == 5 (the sum of highlighted items)
getMaxSubSum([2, -1, 2, 3, -9]) == 6
getMaxSubSum([-1, 2, 3, -9, 11]) == 11
getMaxSubSum([-2, -1, 1, 2]) == 3
getMaxSubSum([100, -9, 2, -3, 5]) == 100
getMaxSubSum([1, 2, 3]) == 6 (take all)
        
      
      
      If all items are negative, it means that we take none (the subarray is empty), so the sum is zero:

      
        
        
          getMaxSubSum([-1, -2, -3]) = 0
        
      
      
      Please try to think of a fast solution: O(n2) or even O(n) if you can.
Open a sandbox with tests.solutionSlow solutionSlow solutionWe can calculate all possible subsums.
The simplest way is to take every element and calculate sums of all subarrays starting from it.
For instance, for [-1, 2, 3, -9, 11]:

      
        
        
          // Starting from -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Starting from 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Starting from 3:
3
3 + (-9)
3 + (-9) + 11

// Starting from -9
-9
-9 + 11

// Starting from 11
11
        
      
      
      The code is actually a nested loop: the external loop over array elements, and the internal counts subsums starting with the current element.

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0; // if we take no elements, zero will be returned

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
        
      
      
      The solution has a time complexity of O(n2). In other words, if we increase the array size 2 times, the algorithm will work 4 times longer.
For big arrays (1000, 10000 or more items) such algorithms can lead to serious sluggishness.
Fast solutionFast solutionLet’s walk the array and keep the current partial sum of elements in the variable s. If s becomes negative at some point, then assign s=0. The maximum of all such s will be the answer.
If the description is too vague, please see the code, it’s short enough:

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;

  for (let item of arr) { // for each item of arr
    partialSum += item; // add it to partialSum
    maxSum = Math.max(maxSum, partialSum); // remember the maximum
    if (partialSum < 0) partialSum = 0; // zero if negative
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
        
      
      
      The algorithm requires exactly 1 array pass, so the time complexity is O(n).
You can find more detailed information about the algorithm here: Maximum subarray problem. If it’s still not obvious why that works, then please trace the algorithm on the examples above, see how it works, that’s better than any words.
Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nArrays provide a lot of methods. To make things easier, in this chapter, they are split into groups.
Add/remove itemsWe already know methods that add and remove items from the beginning or the end:

arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.

Here are a few others.
spliceHow to delete an element from the array?
The arrays are objects, so we can try to use delete:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "go", "home"];

delete arr[1]; // remove "go"

alert( arr[1] ); // undefined

// now arr = ["I",  , "home"];
alert( arr.length ); // 3
        
      
      
      The element was removed, but the array still has 3 elements, we can see that arr.length == 3.
That’s natural, because delete obj.key removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of the elements to shift and occupy the freed place. We expect to have a shorter array now.
So, special methods should be used.
The arr.splice method is a Swiss army knife for arrays. It can do everything: insert, remove and replace elements.
The syntax is:

      
        
        
          arr.splice(start[, deleteCount, elem1, ..., elemN])
        
      
      
      It modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.
This method is easy to grasp by examples.
Let’s start with the deletion:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // from index 1 remove 1 element

alert( arr ); // ["I", "JavaScript"]
        
      
      
      Easy, right? Starting from the index 1 it removed 1 element.
In the next example, we remove 3 elements and replace them with the other two:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
        
      
      
      Here we can see that splice returns the array of removed elements:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- array of removed elements
        
      
      
      The splice method is also able to insert the elements without any removals. For that, we need to set deleteCount to 0:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
        
      
      
      
            Negative indexes allowed
            Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
        
      
      
      
sliceThe method arr.slice is much simpler than the similar-looking arr.splice.
The syntax is:

      
        
        
          arr.slice([start], [end])
        
      
      
      It returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.
It’s similar to a string method str.slice, but instead of substrings, it makes subarrays.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)

alert( arr.slice(-2) ); // s,t (copy from -2 till the end)
        
      
      
      We can also call it without arguments: arr.slice() creates a copy of arr. That’s often used to obtain a copy for further transformations that should not affect the original array.
concatThe method arr.concat creates a new array that includes values from other arrays and additional items.
The syntax is:

      
        
        
          arr.concat(arg1, arg2...)
        
      
      
      It accepts any number of arguments – either arrays or values.
The result is a new array containing items from arr, then arg1, arg2 etc.
If an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

// create an array from: arr and [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// create an array from: arr and [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// create an array from: arr and [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
        
      
      
      Normally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
        
      
      
      …But if an array-like object has a special Symbol.isConcatSpreadable property, then it’s treated as an array by concat: its elements are added instead:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
        
      
      
      Iterate: forEachThe arr.forEach method allows to run a function for every element of the array.
The syntax:

      
        
        
          arr.forEach(function(item, index, array) {
  // ... do something with an item
});
        
      
      
      For instance, this shows each element of the array:

      
        
        
          
            
          
          
            
          
        
        
          // for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
        
      
      
      And this code is more elaborate about their positions in the target array:

      
        
        
          
            
          
          
            
          
        
        
          ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
        
      
      
      The result of the function (if it returns any) is thrown away and ignored.
Searching in arrayNow let’s cover methods that search in an array.
indexOf/lastIndexOf and includesThe methods arr.indexOf and arr.includes have the similar syntax and do essentially the same as their string counterparts, but operate on items instead of characters:

arr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.
arr.includes(item, from) – looks for item starting from index from, returns true if found.

Usually, these methods are used with only one argument: the item to search. By default, the search is from the beginning.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
        
      
      
      Please note that indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.
If we want to check if item exists in the array and don’t need the index, then arr.includes is preferred.
The method arr.lastIndexOf is the same as indexOf, but looks for from right to left.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ['Apple', 'Orange', 'Apple']

alert( fruits.indexOf('Apple') ); // 0 (first Apple)
alert( fruits.lastIndexOf('Apple') ); // 2 (last Apple)
        
      
      
      
            The includes method handles NaN correctly
            A minor, but noteworthy feature of includes is that it correctly handles NaN, unlike indexOf:

      
        
        
          
            
          
          
            
          
        
        
          const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (wrong, should be 0)
alert( arr.includes(NaN) );// true (correct)
        
      
      
      That’s because includes was added to JavaScript much later and uses the more up-to-date comparison algorithm internally.

find and findIndex/findLastIndexImagine we have an array of objects. How do we find an object with a specific condition?
Here the arr.find(fn) method comes in handy.
The syntax is:

      
        
        
          let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});
        
      
      
      The function is called for elements of the array, one after another:

item is the element.
index is its index.
array is the array itself.

If it returns true, the search is stopped, the item is returned. If nothing is found, undefined is returned.
For example, we have an array of users, each with the fields id and name. Let’s find the one with id == 1:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
        
      
      
      In real life, arrays of objects are a common thing, so the find method is very useful.
Note that in the example we provide to find the function item => item.id == 1 with one argument. That’s typical, other arguments of this function are rarely used.
The arr.findIndex method has the same syntax but returns the index where the element was found instead of the element itself. The value of -1 is returned if nothing is found.
The arr.findLastIndex method is like findIndex, but searches from right to left, similar to lastIndexOf.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"},
  {id: 4, name: "John"}
];

// Find the index of the first John
alert(users.findIndex(user => user.name == 'John')); // 0

// Find the index of the last John
alert(users.findLastIndex(user => user.name == 'John')); // 3
        
      
      
      filterThe find method looks for a single (first) element that makes the function return true.
If there may be many, we can use arr.filter(fn).
The syntax is similar to find, but filter returns an array of all matching elements:

      
        
        
          let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
        
      
      
      Transform an arrayLet’s move on to methods that transform and reorder an array.
mapThe arr.map method is one of the most useful and often used.
It calls the function for each element of the array and returns the array of results.
The syntax is:

      
        
        
          let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
        
      
      
      For instance, here we transform each element into its length:

      
        
        
          
            
          
          
            
          
        
        
          let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
        
      
      
      sort(fn)The call to arr.sort() sorts the array in place, changing its element order.
It also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

// the method reorders the content of arr
arr.sort();

alert( arr );  // 1, 15, 2
        
      
      
      Did you notice anything strange in the outcome?
The order became 1, 15, 2. Incorrect. But why?
The items are sorted as strings by default.
Literally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed "2" > "15".
To use our own sorting order, we need to supply a function as the argument of arr.sort().
The function should compare two arbitrary values and return:

      
        
        
          function compare(a, b) {
  if (a > b) return 1; // if the first value is greater than the second
  if (a == b) return 0; // if values are equal
  if (a < b) return -1; // if the first value is less than the second
}
        
      
      
      For instance, to sort as numbers:

      
        
        
          
            
          
          
            
          
        
        
          function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
        
      
      
      Now it works as intended.
Let’s step aside and think about what’s happening. The arr can be an array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.
The arr.sort(fn) method implements a generic sorting algorithm. We don’t need to care how it internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.
By the way, if we ever want to know which elements are compared – nothing prevents us from alerting them:

      
        
        
          
            
          
          
            
          
        
        
          [1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
        
      
      
      The algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.

            A comparison function may return any number
            Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.
That allows to write shorter functions:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
        
      
      
      

            Arrow functions for the best
            Remember arrow functions? We can use them here for neater sorting:

      
        
        
          arr.sort( (a, b) => a - b );
        
      
      
      This works exactly the same as the longer version above.


            Use localeCompare for strings
            Remember strings comparison algorithm? It compares letters by their codes by default.
For many alphabets, it’s better to use str.localeCompare method to correctly sort letters, such as Ö.
For example, let’s sort a few countries in German:

      
        
        
          
            
          
          
            
          
        
        
          let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)
        
      
      
      
reverseThe method arr.reverse reverses the order of elements in arr.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
        
      
      
      It also returns the array arr after the reversal.
split and joinHere’s the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: John, Pete, Mary. But for us an array of names would be much more comfortable than a single string. How to get it?
The str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim.
In the example below, we split by a comma followed by a space:

      
        
        
          
            
          
          
            
          
        
        
          let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
        
      
      
      The split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:

      
        
        
          
            
          
          
            
          
        
        
          let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
        
      
      
      
            Split into letters
            The call to split(s) with an empty s would split the string into an array of letters:

      
        
        
          
            
          
          
            
          
        
        
          let str = "test";

alert( str.split('') ); // t,e,s,t
        
      
      
      
The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ;

alert( str ); // Bilbo;Gandalf;Nazgul
        
      
      
      reduce/reduceRightWhen we need to iterate over an array – we can use forEach, for or for..of.
When we need to iterate and return the data for each element – we can use map.
The methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.
The syntax is:

      
        
        
          let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
        
      
      
      The function is applied to all array elements one after another and “carries on” its result to the next call.
Arguments:

accumulator – is the result of the previous function call, equals initial the first time (if initial is provided).
item – is the current array item.
index – is its position.
array – is the array.

As the function is applied, the result of the previous function call is passed to the next one as the first argument.
So, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end, it becomes the result of reduce.
Sounds complicated?
The easiest way to grasp that is by example.
Here we get a sum of an array in one line:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
        
      
      
      The function passed to reduce uses only 2 arguments, that’s typically enough.
Let’s see the details of what’s going on.

On the first run, sum is the initial value (the last argument of reduce), equals 0, and current is the first array element, equals 1. So the function result is 1.
On the second run, sum = 1, we add the second array element (2) to it and return.
On the 3rd run, sum = 3 and we add one more element to it, and so on…

The calculation flow:

      
      
        
      
      Or in the form of a table, where each row represents a function call on the next array element:




sum
current
result




the first call
0
1
1


the second call
1
2
3


the third call
3
3
6


the fourth call
6
4
10


the fifth call
10
5
15



Here we can clearly see how the result of the previous call becomes the first argument of the next one.
We also can omit the initial value:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

// removed initial value from reduce (no 0)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
        
      
      
      The result is the same. That’s because if there’s no initial, then reduce takes the first element of the array as the initial value and starts the iteration from the 2nd element.
The calculation table is the same as above, minus the first row.
But such use requires an extreme care. If the array is empty, then reduce call without initial value gives an error.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [];

// Error: Reduce of empty array with no initial value
// if the initial value existed, reduce would return it for the empty arr.
arr.reduce((sum, current) => sum + current);
        
      
      
      So it’s advised to always specify the initial value.
The method arr.reduceRight does the same but goes from right to left.
Array.isArrayArrays do not form a separate language type. They are based on objects.
So typeof does not help to distinguish a plain object from an array:

      
        
        
          
            
          
          
            
          
        
        
          alert(typeof {}); // object
alert(typeof []); // object (same)
        
      
      
      …But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns true if the value is an array, and false otherwise.

      
        
        
          
            
          
          
            
          
        
        
          alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
        
      
      
      Most methods support “thisArg”Almost all array methods that call functions – like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.
That parameter is not explained in the sections above, because it’s rarely used. But for completeness, we have to cover it.
Here’s the full syntax of these methods:

      
        
        
          arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
        
      
      
      The value of thisArg parameter becomes this for func.
For example, here we use a method of army object as a filter, and thisArg passes the context:

      
        
        
          
            
          
          
            
          
        
        
          let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
        
      
      
      If in the example above we used users.filter(army.canJoin), then army.canJoin would be called as a standalone function, with this=undefined, thus leading to an instant error.
A call to users.filter(army.canJoin, army) can be replaced with users.filter(user => army.canJoin(user)), that does the same. The latter is used more often, as it’s a bit easier to understand for most people.
SummaryA cheat sheet of array methods:


To add/remove elements:

push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.
slice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.



To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, and return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.



To iterate over elements:

forEach(func) – calls func for every element, does not return anything.



To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.



Additionally:

Array.isArray(value) checks value for being an array, if so returns true, otherwise false.



Please note that methods sort, reverse and splice modify the array itself.
These methods are the most used ones, they cover 99% of use cases. But there are few others:


arr.some(fn)/arr.every(fn) check the array.
The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.
These methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.
We can use every to compare arrays:

      
        
        
          
            
          
          
            
          
        
        
          function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
        
      
      
      

arr.fill(value, start, end) – fills the array with repeating value from index start to end.


arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).


arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.


For the full list, see the manual.
At first sight, it may seem that there are so many methods, quite difficult to remember. But actually, that’s much easier.
Look through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.
Afterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you’ll automatically remember the methods, without specific efforts from your side.\n\nTutorialThe JavaScript languageData typesDecember 31, 2023Array methodsArrays provide a lot of methods. To make things easier, in this chapter, they are split into groups.
Add/remove itemsWe already know methods that add and remove items from the beginning or the end:

arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.

Here are a few others.
spliceHow to delete an element from the array?
The arrays are objects, so we can try to use delete:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "go", "home"];

delete arr[1]; // remove "go"

alert( arr[1] ); // undefined

// now arr = ["I",  , "home"];
alert( arr.length ); // 3
        
      
      
      The element was removed, but the array still has 3 elements, we can see that arr.length == 3.
That’s natural, because delete obj.key removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of the elements to shift and occupy the freed place. We expect to have a shorter array now.
So, special methods should be used.
The arr.splice method is a Swiss army knife for arrays. It can do everything: insert, remove and replace elements.
The syntax is:

      
        
        
          arr.splice(start[, deleteCount, elem1, ..., elemN])
        
      
      
      It modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.
This method is easy to grasp by examples.
Let’s start with the deletion:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // from index 1 remove 1 element

alert( arr ); // ["I", "JavaScript"]
        
      
      
      Easy, right? Starting from the index 1 it removed 1 element.
In the next example, we remove 3 elements and replace them with the other two:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
        
      
      
      Here we can see that splice returns the array of removed elements:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- array of removed elements
        
      
      
      The splice method is also able to insert the elements without any removals. For that, we need to set deleteCount to 0:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
        
      
      
      
            Negative indexes allowed
            Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
        
      
      
      
sliceThe method arr.slice is much simpler than the similar-looking arr.splice.
The syntax is:

      
        
        
          arr.slice([start], [end])
        
      
      
      It returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.
It’s similar to a string method str.slice, but instead of substrings, it makes subarrays.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)

alert( arr.slice(-2) ); // s,t (copy from -2 till the end)
        
      
      
      We can also call it without arguments: arr.slice() creates a copy of arr. That’s often used to obtain a copy for further transformations that should not affect the original array.
concatThe method arr.concat creates a new array that includes values from other arrays and additional items.
The syntax is:

      
        
        
          arr.concat(arg1, arg2...)
        
      
      
      It accepts any number of arguments – either arrays or values.
The result is a new array containing items from arr, then arg1, arg2 etc.
If an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

// create an array from: arr and [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// create an array from: arr and [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// create an array from: arr and [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
        
      
      
      Normally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
        
      
      
      …But if an array-like object has a special Symbol.isConcatSpreadable property, then it’s treated as an array by concat: its elements are added instead:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
        
      
      
      Iterate: forEachThe arr.forEach method allows to run a function for every element of the array.
The syntax:

      
        
        
          arr.forEach(function(item, index, array) {
  // ... do something with an item
});
        
      
      
      For instance, this shows each element of the array:

      
        
        
          
            
          
          
            
          
        
        
          // for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
        
      
      
      And this code is more elaborate about their positions in the target array:

      
        
        
          
            
          
          
            
          
        
        
          ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
        
      
      
      The result of the function (if it returns any) is thrown away and ignored.
Searching in arrayNow let’s cover methods that search in an array.
indexOf/lastIndexOf and includesThe methods arr.indexOf and arr.includes have the similar syntax and do essentially the same as their string counterparts, but operate on items instead of characters:

arr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.
arr.includes(item, from) – looks for item starting from index from, returns true if found.

Usually, these methods are used with only one argument: the item to search. By default, the search is from the beginning.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
        
      
      
      Please note that indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.
If we want to check if item exists in the array and don’t need the index, then arr.includes is preferred.
The method arr.lastIndexOf is the same as indexOf, but looks for from right to left.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ['Apple', 'Orange', 'Apple']

alert( fruits.indexOf('Apple') ); // 0 (first Apple)
alert( fruits.lastIndexOf('Apple') ); // 2 (last Apple)
        
      
      
      
            The includes method handles NaN correctly
            A minor, but noteworthy feature of includes is that it correctly handles NaN, unlike indexOf:

      
        
        
          
            
          
          
            
          
        
        
          const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (wrong, should be 0)
alert( arr.includes(NaN) );// true (correct)
        
      
      
      That’s because includes was added to JavaScript much later and uses the more up-to-date comparison algorithm internally.

find and findIndex/findLastIndexImagine we have an array of objects. How do we find an object with a specific condition?
Here the arr.find(fn) method comes in handy.
The syntax is:

      
        
        
          let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});
        
      
      
      The function is called for elements of the array, one after another:

item is the element.
index is its index.
array is the array itself.

If it returns true, the search is stopped, the item is returned. If nothing is found, undefined is returned.
For example, we have an array of users, each with the fields id and name. Let’s find the one with id == 1:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
        
      
      
      In real life, arrays of objects are a common thing, so the find method is very useful.
Note that in the example we provide to find the function item => item.id == 1 with one argument. That’s typical, other arguments of this function are rarely used.
The arr.findIndex method has the same syntax but returns the index where the element was found instead of the element itself. The value of -1 is returned if nothing is found.
The arr.findLastIndex method is like findIndex, but searches from right to left, similar to lastIndexOf.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"},
  {id: 4, name: "John"}
];

// Find the index of the first John
alert(users.findIndex(user => user.name == 'John')); // 0

// Find the index of the last John
alert(users.findLastIndex(user => user.name == 'John')); // 3
        
      
      
      filterThe find method looks for a single (first) element that makes the function return true.
If there may be many, we can use arr.filter(fn).
The syntax is similar to find, but filter returns an array of all matching elements:

      
        
        
          let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
        
      
      
      Transform an arrayLet’s move on to methods that transform and reorder an array.
mapThe arr.map method is one of the most useful and often used.
It calls the function for each element of the array and returns the array of results.
The syntax is:

      
        
        
          let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
        
      
      
      For instance, here we transform each element into its length:

      
        
        
          
            
          
          
            
          
        
        
          let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
        
      
      
      sort(fn)The call to arr.sort() sorts the array in place, changing its element order.
It also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

// the method reorders the content of arr
arr.sort();

alert( arr );  // 1, 15, 2
        
      
      
      Did you notice anything strange in the outcome?
The order became 1, 15, 2. Incorrect. But why?
The items are sorted as strings by default.
Literally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed "2" > "15".
To use our own sorting order, we need to supply a function as the argument of arr.sort().
The function should compare two arbitrary values and return:

      
        
        
          function compare(a, b) {
  if (a > b) return 1; // if the first value is greater than the second
  if (a == b) return 0; // if values are equal
  if (a < b) return -1; // if the first value is less than the second
}
        
      
      
      For instance, to sort as numbers:

      
        
        
          
            
          
          
            
          
        
        
          function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
        
      
      
      Now it works as intended.
Let’s step aside and think about what’s happening. The arr can be an array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.
The arr.sort(fn) method implements a generic sorting algorithm. We don’t need to care how it internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.
By the way, if we ever want to know which elements are compared – nothing prevents us from alerting them:

      
        
        
          
            
          
          
            
          
        
        
          [1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
        
      
      
      The algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.

            A comparison function may return any number
            Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.
That allows to write shorter functions:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
        
      
      
      

            Arrow functions for the best
            Remember arrow functions? We can use them here for neater sorting:

      
        
        
          arr.sort( (a, b) => a - b );
        
      
      
      This works exactly the same as the longer version above.


            Use localeCompare for strings
            Remember strings comparison algorithm? It compares letters by their codes by default.
For many alphabets, it’s better to use str.localeCompare method to correctly sort letters, such as Ö.
For example, let’s sort a few countries in German:

      
        
        
          
            
          
          
            
          
        
        
          let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)
        
      
      
      
reverseThe method arr.reverse reverses the order of elements in arr.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
        
      
      
      It also returns the array arr after the reversal.
split and joinHere’s the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: John, Pete, Mary. But for us an array of names would be much more comfortable than a single string. How to get it?
The str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim.
In the example below, we split by a comma followed by a space:

      
        
        
          
            
          
          
            
          
        
        
          let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
        
      
      
      The split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:

      
        
        
          
            
          
          
            
          
        
        
          let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
        
      
      
      
            Split into letters
            The call to split(s) with an empty s would split the string into an array of letters:

      
        
        
          
            
          
          
            
          
        
        
          let str = "test";

alert( str.split('') ); // t,e,s,t
        
      
      
      
The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ;

alert( str ); // Bilbo;Gandalf;Nazgul
        
      
      
      reduce/reduceRightWhen we need to iterate over an array – we can use forEach, for or for..of.
When we need to iterate and return the data for each element – we can use map.
The methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.
The syntax is:

      
        
        
          let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
        
      
      
      The function is applied to all array elements one after another and “carries on” its result to the next call.
Arguments:

accumulator – is the result of the previous function call, equals initial the first time (if initial is provided).
item – is the current array item.
index – is its position.
array – is the array.

As the function is applied, the result of the previous function call is passed to the next one as the first argument.
So, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end, it becomes the result of reduce.
Sounds complicated?
The easiest way to grasp that is by example.
Here we get a sum of an array in one line:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
        
      
      
      The function passed to reduce uses only 2 arguments, that’s typically enough.
Let’s see the details of what’s going on.

On the first run, sum is the initial value (the last argument of reduce), equals 0, and current is the first array element, equals 1. So the function result is 1.
On the second run, sum = 1, we add the second array element (2) to it and return.
On the 3rd run, sum = 3 and we add one more element to it, and so on…

The calculation flow:

      
      
        
      
      Or in the form of a table, where each row represents a function call on the next array element:




sum
current
result




the first call
0
1
1


the second call
1
2
3


the third call
3
3
6


the fourth call
6
4
10


the fifth call
10
5
15



Here we can clearly see how the result of the previous call becomes the first argument of the next one.
We also can omit the initial value:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

// removed initial value from reduce (no 0)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
        
      
      
      The result is the same. That’s because if there’s no initial, then reduce takes the first element of the array as the initial value and starts the iteration from the 2nd element.
The calculation table is the same as above, minus the first row.
But such use requires an extreme care. If the array is empty, then reduce call without initial value gives an error.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [];

// Error: Reduce of empty array with no initial value
// if the initial value existed, reduce would return it for the empty arr.
arr.reduce((sum, current) => sum + current);
        
      
      
      So it’s advised to always specify the initial value.
The method arr.reduceRight does the same but goes from right to left.
Array.isArrayArrays do not form a separate language type. They are based on objects.
So typeof does not help to distinguish a plain object from an array:

      
        
        
          
            
          
          
            
          
        
        
          alert(typeof {}); // object
alert(typeof []); // object (same)
        
      
      
      …But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns true if the value is an array, and false otherwise.

      
        
        
          
            
          
          
            
          
        
        
          alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
        
      
      
      Most methods support “thisArg”Almost all array methods that call functions – like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.
That parameter is not explained in the sections above, because it’s rarely used. But for completeness, we have to cover it.
Here’s the full syntax of these methods:

      
        
        
          arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
        
      
      
      The value of thisArg parameter becomes this for func.
For example, here we use a method of army object as a filter, and thisArg passes the context:

      
        
        
          
            
          
          
            
          
        
        
          let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
        
      
      
      If in the example above we used users.filter(army.canJoin), then army.canJoin would be called as a standalone function, with this=undefined, thus leading to an instant error.
A call to users.filter(army.canJoin, army) can be replaced with users.filter(user => army.canJoin(user)), that does the same. The latter is used more often, as it’s a bit easier to understand for most people.
SummaryA cheat sheet of array methods:


To add/remove elements:

push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.
slice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.



To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, and return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.



To iterate over elements:

forEach(func) – calls func for every element, does not return anything.



To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.



Additionally:

Array.isArray(value) checks value for being an array, if so returns true, otherwise false.



Please note that methods sort, reverse and splice modify the array itself.
These methods are the most used ones, they cover 99% of use cases. But there are few others:


arr.some(fn)/arr.every(fn) check the array.
The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.
These methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.
We can use every to compare arrays:

      
        
        
          
            
          
          
            
          
        
        
          function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
        
      
      
      

arr.fill(value, start, end) – fills the array with repeating value from index start to end.


arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).


arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.


For the full list, see the manual.
At first sight, it may seem that there are so many methods, quite difficult to remember. But actually, that’s much easier.
Look through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.
Afterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you’ll automatically remember the methods, without specific efforts from your side.
TasksTranslate border-left-width to borderLeftWidthimportance: 5Write the function camelize(str) that changes dash-separated words like “my-short-string” into camel-cased “myShortString”.
That is: removes all dashes, each word after dash becomes uppercased.
Examples:

      
        
        
          camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
        
      
      
      P.S. Hint: use split to split the string into an array, transform it and join back.
Open a sandbox with tests.solution
      
        
        
          function camelize(str) {
  return str
    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
    .map(
      // capitalizes first letters of all array items except the first one
      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
    )
    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
}
        
      
      
      Open the solution with tests in a sandbox.Filter rangeimportance: 4Write a function filterRange(arr, a, b) that gets an array arr, looks for elements with values higher or equal to a and lower or equal to b and return a result as an array.
The function should not modify the array. It should return the new array.
For instance:

      
        
        
          let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (matching values)

alert( arr ); // 5,3,8,1 (not modified)
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function filterRange(arr, a, b) {
  // added brackets around the expression for better readability
  return arr.filter(item => (a <= item && item <= b));
}

let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (matching values)

alert( arr ); // 5,3,8,1 (not modified)
        
      
      
      Open the solution with tests in a sandbox.Filter range "in place"importance: 4Write a function filterRangeInPlace(arr, a, b) that gets an array arr and removes from it all values except those that are between a and b. The test is: a ≤ arr[i] ≤ b.
The function should only modify the array. It should not return anything.
For instance:

      
        
        
          let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4

alert( arr ); // [3, 1]
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function filterRangeInPlace(arr, a, b) {

  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    // remove if outside of the interval
    if (val < a || val > b) {
      arr.splice(i, 1);
      i--;
    }
  }

}

let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4

alert( arr ); // [3, 1]
        
      
      
      Open the solution with tests in a sandbox.Sort in decreasing orderimportance: 4
      
        
        
          let arr = [5, 2, 1, -10, 8];

// ... your code to sort it in decreasing order

alert( arr ); // 8, 5, 2, 1, -10
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let arr = [5, 2, 1, -10, 8];

arr.sort((a, b) => b - a);

alert( arr );
        
      
      
      Copy and sort arrayimportance: 5We have an array of strings arr. We’d like to have a sorted copy of it, but keep arr unmodified.
Create a function copySorted(arr) that returns such a copy.

      
        
        
          let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (no changes)
        
      
      
      solutionWe can use slice() to make a copy and run the sort on it:

      
        
        
          
            
          
          
            
          
        
        
          function copySorted(arr) {
  return arr.slice().sort();
}

let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted );
alert( arr );
        
      
      
      Create an extendable calculatorimportance: 5Create a constructor function Calculator that creates “extendable” calculator objects.
The task consists of two parts.


First, implement the method calculate(str) that takes a string like "1 + 2" in the format “NUMBER operator NUMBER” (space-delimited) and returns the result. Should understand plus + and minus -.
Usage example:

      
        
        
          let calc = new Calculator;

alert( calc.calculate("3 + 7") ); // 10
        
      
      
      

Then add the method addMethod(name, func) that teaches the calculator a new operation. It takes the operator name and the two-argument function func(a,b) that implements it.
For instance, let’s add the multiplication *, division / and power **:

      
        
        
          let powerCalc = new Calculator;
powerCalc.addMethod("*", (a, b) => a * b);
powerCalc.addMethod("/", (a, b) => a / b);
powerCalc.addMethod("**", (a, b) => a ** b);

let result = powerCalc.calculate("2 ** 3");
alert( result ); // 8
        
      
      
      


No parentheses or complex expressions in this task.
The numbers and the operator are delimited with exactly one space.
There may be error handling if you’d like to add it.

Open a sandbox with tests.solution
Please note how methods are stored. They are simply added to this.methods property.
All tests and numeric conversions are done in the calculate method. In future it may be extended to support more complex expressions.


      
        
        
          function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
        
      
      
      Open the solution with tests in a sandbox.Map to namesimportance: 5You have an array of user objects, each one has user.name. Write the code that converts it into an array of names.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = /* ... your code */

alert( names ); // John, Pete, Mary
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = users.map(item => item.name);

alert( names ); // John, Pete, Mary
        
      
      
      Map to objectsimportance: 5You have an array of user objects, each one has name, surname and id.
Write the code to create another array from it, of objects with id and fullName, where fullName is generated from name and surname.
For instance:

      
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = /* ... your code ... */

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith
        
      
      
      So, actually you need to map one array of objects to another. Try using => here. There’s a small catch.
solution
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith
        
      
      
      Please note that in the arrow functions we need to use additional brackets.
We can’t write like this:

      
        
        
          let usersMapped = users.map(user => {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});
        
      
      
      As we remember, there are two arrow functions: without body value => expr and with body value => {...}.
Here JavaScript would treat { as the start of function body, not the start of the object. The workaround is to wrap them in the “normal” brackets:

      
        
        
          let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
        
      
      
      Now fine.
Sort users by ageimportance: 5Write the function sortByAge(users) that gets an array of objects with the age property and sorts them by age.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function sortByAge(arr) {
  arr.sort((a, b) => a.age - b.age);
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now sorted is: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      Shuffle an arrayimportance: 3Write the function shuffle(array) that shuffles (randomly reorders) elements of the array.
Multiple runs of shuffle may lead to different orders of elements. For instance:

      
        
        
          let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
        
      
      
      All element orders should have an equal probability. For instance, [1,2,3] can be reordered as [1,2,3] or [1,3,2] or [3,1,2] etc, with equal probability of each case.
solutionThe simple solution could be:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
        
      
      
      That somewhat works, because Math.random() - 0.5 is a random number that may be positive or negative, so the sorting function reorders elements randomly.
But because the sorting function is not meant to be used this way, not all permutations have the same probability.
For instance, consider the code below. It runs shuffle 1000000 times and counts appearances of all possible results:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      An example result (depends on JS engine):

      
        
        
          123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
        
      
      
      We can see the bias clearly: 123 and 213 appear much more often than others.
The result of the code may vary between JavaScript engines, but we can already see that the approach is unreliable.
Why it doesn’t work? Generally speaking, sort is a “black box”: we throw an array and a comparison function into it and expect the array to be sorted. But due to the utter randomness of the comparison the black box goes mad, and how exactly it goes mad depends on the concrete implementation that differs between engines.
There are other good ways to do the task. For instance, there’s a great algorithm called Fisher-Yates shuffle. The idea is to walk the array in the reverse order and swap each element with a random one before it:

      
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i

    // swap elements array[i] and array[j]
    // we use "destructuring assignment" syntax to achieve that
    // you'll find more details about that syntax in later chapters
    // same can be written as:
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}
        
      
      
      Let’s test it the same way:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      The example output:

      
        
        
          123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
        
      
      
      Looks good now: all permutations appear with the same probability.
Also, performance-wise the Fisher-Yates algorithm is much better, there’s no “sorting” overhead.
Get average ageimportance: 4Write the function getAverageAge(users) that gets an array of objects with property age and returns the average age.
The formula for the average is (age1 + age2 + ... + ageN) / N.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function getAverageAge(users) {
  return users.reduce((prev, user) => prev + user.age, 0) / users.length;
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // 28
        
      
      
      Filter unique array membersimportance: 4Let arr be an array.
Create a function unique(arr) that should return an array with unique items of arr.
For instance:

      
        
        
          function unique(arr) {
  /* your code */
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      Open a sandbox with tests.solutionLet’s walk the array items:

For each item we’ll check if the resulting array already has that item.
If it is so, then ignore, otherwise add to results.


      
        
        
          
            
          
          
            
          
        
        
          function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      The code works, but there’s a potential performance problem in it.
The method result.includes(str) internally walks the array result and compares each element against str to find the match.
So if there are 100 elements in result and no one matches str, then it will walk the whole result and do exactly 100 comparisons. And if result is large, like 10000, then there would be 10000 comparisons.
That’s not a problem by itself, because JavaScript engines are very fast, so walk 10000 array is a matter of microseconds.
But we do such test for each element of arr, in the for loop.
So if arr.length is 10000 we’ll have something like 10000*10000 = 100 millions of comparisons. That’s a lot.
So the solution is only good for small arrays.
Further in the chapter Map and Set we’ll see how to optimize it.
Open the solution with tests in a sandbox.Create keyed object from arrayimportance: 4Let’s say we received an array of users in the form {id:..., name:..., age:... }.
Create a function groupById(arr) that creates an object from it, with id as the key, and array items as values.
For example:

      
        
        
          let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

/*
// after the call we should have:

usersById = {
  john: {id: 'john', name: "John Smith", age: 20},
  ann: {id: 'ann', name: "Ann Smith", age: 24},
  pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/
        
      
      
      Such function is really handy when working with server data.
In this task we assume that id is unique. There may be no two array items with the same id.
Please use array .reduce method in the solution.
Open a sandbox with tests.solution
      
        
        
          function groupById(array) {
  return array.reduce((obj, value) => {
    obj[value.id] = value;
    return obj;
  }, {})
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nArrays provide a lot of methods. To make things easier, in this chapter, they are split into groups.
Add/remove itemsWe already know methods that add and remove items from the beginning or the end:

arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.

Here are a few others.
spliceHow to delete an element from the array?
The arrays are objects, so we can try to use delete:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "go", "home"];

delete arr[1]; // remove "go"

alert( arr[1] ); // undefined

// now arr = ["I",  , "home"];
alert( arr.length ); // 3
        
      
      
      The element was removed, but the array still has 3 elements, we can see that arr.length == 3.
That’s natural, because delete obj.key removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of the elements to shift and occupy the freed place. We expect to have a shorter array now.
So, special methods should be used.
The arr.splice method is a Swiss army knife for arrays. It can do everything: insert, remove and replace elements.
The syntax is:

      
        
        
          arr.splice(start[, deleteCount, elem1, ..., elemN])
        
      
      
      It modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.
This method is easy to grasp by examples.
Let’s start with the deletion:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // from index 1 remove 1 element

alert( arr ); // ["I", "JavaScript"]
        
      
      
      Easy, right? Starting from the index 1 it removed 1 element.
In the next example, we remove 3 elements and replace them with the other two:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
        
      
      
      Here we can see that splice returns the array of removed elements:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- array of removed elements
        
      
      
      The splice method is also able to insert the elements without any removals. For that, we need to set deleteCount to 0:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
        
      
      
      
            Negative indexes allowed
            Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
        
      
      
      
sliceThe method arr.slice is much simpler than the similar-looking arr.splice.
The syntax is:

      
        
        
          arr.slice([start], [end])
        
      
      
      It returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.
It’s similar to a string method str.slice, but instead of substrings, it makes subarrays.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)

alert( arr.slice(-2) ); // s,t (copy from -2 till the end)
        
      
      
      We can also call it without arguments: arr.slice() creates a copy of arr. That’s often used to obtain a copy for further transformations that should not affect the original array.
concatThe method arr.concat creates a new array that includes values from other arrays and additional items.
The syntax is:

      
        
        
          arr.concat(arg1, arg2...)
        
      
      
      It accepts any number of arguments – either arrays or values.
The result is a new array containing items from arr, then arg1, arg2 etc.
If an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

// create an array from: arr and [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// create an array from: arr and [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// create an array from: arr and [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
        
      
      
      Normally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
        
      
      
      …But if an array-like object has a special Symbol.isConcatSpreadable property, then it’s treated as an array by concat: its elements are added instead:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
        
      
      
      Iterate: forEachThe arr.forEach method allows to run a function for every element of the array.
The syntax:

      
        
        
          arr.forEach(function(item, index, array) {
  // ... do something with an item
});
        
      
      
      For instance, this shows each element of the array:

      
        
        
          
            
          
          
            
          
        
        
          // for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
        
      
      
      And this code is more elaborate about their positions in the target array:

      
        
        
          
            
          
          
            
          
        
        
          ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
        
      
      
      The result of the function (if it returns any) is thrown away and ignored.
Searching in arrayNow let’s cover methods that search in an array.
indexOf/lastIndexOf and includesThe methods arr.indexOf and arr.includes have the similar syntax and do essentially the same as their string counterparts, but operate on items instead of characters:

arr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.
arr.includes(item, from) – looks for item starting from index from, returns true if found.

Usually, these methods are used with only one argument: the item to search. By default, the search is from the beginning.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
        
      
      
      Please note that indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.
If we want to check if item exists in the array and don’t need the index, then arr.includes is preferred.
The method arr.lastIndexOf is the same as indexOf, but looks for from right to left.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ['Apple', 'Orange', 'Apple']

alert( fruits.indexOf('Apple') ); // 0 (first Apple)
alert( fruits.lastIndexOf('Apple') ); // 2 (last Apple)
        
      
      
      
            The includes method handles NaN correctly
            A minor, but noteworthy feature of includes is that it correctly handles NaN, unlike indexOf:

      
        
        
          
            
          
          
            
          
        
        
          const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (wrong, should be 0)
alert( arr.includes(NaN) );// true (correct)
        
      
      
      That’s because includes was added to JavaScript much later and uses the more up-to-date comparison algorithm internally.

find and findIndex/findLastIndexImagine we have an array of objects. How do we find an object with a specific condition?
Here the arr.find(fn) method comes in handy.
The syntax is:

      
        
        
          let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});
        
      
      
      The function is called for elements of the array, one after another:

item is the element.
index is its index.
array is the array itself.

If it returns true, the search is stopped, the item is returned. If nothing is found, undefined is returned.
For example, we have an array of users, each with the fields id and name. Let’s find the one with id == 1:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
        
      
      
      In real life, arrays of objects are a common thing, so the find method is very useful.
Note that in the example we provide to find the function item => item.id == 1 with one argument. That’s typical, other arguments of this function are rarely used.
The arr.findIndex method has the same syntax but returns the index where the element was found instead of the element itself. The value of -1 is returned if nothing is found.
The arr.findLastIndex method is like findIndex, but searches from right to left, similar to lastIndexOf.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"},
  {id: 4, name: "John"}
];

// Find the index of the first John
alert(users.findIndex(user => user.name == 'John')); // 0

// Find the index of the last John
alert(users.findLastIndex(user => user.name == 'John')); // 3
        
      
      
      filterThe find method looks for a single (first) element that makes the function return true.
If there may be many, we can use arr.filter(fn).
The syntax is similar to find, but filter returns an array of all matching elements:

      
        
        
          let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
        
      
      
      Transform an arrayLet’s move on to methods that transform and reorder an array.
mapThe arr.map method is one of the most useful and often used.
It calls the function for each element of the array and returns the array of results.
The syntax is:

      
        
        
          let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
        
      
      
      For instance, here we transform each element into its length:

      
        
        
          
            
          
          
            
          
        
        
          let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
        
      
      
      sort(fn)The call to arr.sort() sorts the array in place, changing its element order.
It also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

// the method reorders the content of arr
arr.sort();

alert( arr );  // 1, 15, 2
        
      
      
      Did you notice anything strange in the outcome?
The order became 1, 15, 2. Incorrect. But why?
The items are sorted as strings by default.
Literally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed "2" > "15".
To use our own sorting order, we need to supply a function as the argument of arr.sort().
The function should compare two arbitrary values and return:

      
        
        
          function compare(a, b) {
  if (a > b) return 1; // if the first value is greater than the second
  if (a == b) return 0; // if values are equal
  if (a < b) return -1; // if the first value is less than the second
}
        
      
      
      For instance, to sort as numbers:

      
        
        
          
            
          
          
            
          
        
        
          function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
        
      
      
      Now it works as intended.
Let’s step aside and think about what’s happening. The arr can be an array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.
The arr.sort(fn) method implements a generic sorting algorithm. We don’t need to care how it internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.
By the way, if we ever want to know which elements are compared – nothing prevents us from alerting them:

      
        
        
          
            
          
          
            
          
        
        
          [1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
        
      
      
      The algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.

            A comparison function may return any number
            Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.
That allows to write shorter functions:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
        
      
      
      

            Arrow functions for the best
            Remember arrow functions? We can use them here for neater sorting:

      
        
        
          arr.sort( (a, b) => a - b );
        
      
      
      This works exactly the same as the longer version above.


            Use localeCompare for strings
            Remember strings comparison algorithm? It compares letters by their codes by default.
For many alphabets, it’s better to use str.localeCompare method to correctly sort letters, such as Ö.
For example, let’s sort a few countries in German:

      
        
        
          
            
          
          
            
          
        
        
          let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)
        
      
      
      
reverseThe method arr.reverse reverses the order of elements in arr.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
        
      
      
      It also returns the array arr after the reversal.
split and joinHere’s the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: John, Pete, Mary. But for us an array of names would be much more comfortable than a single string. How to get it?
The str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim.
In the example below, we split by a comma followed by a space:

      
        
        
          
            
          
          
            
          
        
        
          let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
        
      
      
      The split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:

      
        
        
          
            
          
          
            
          
        
        
          let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
        
      
      
      
            Split into letters
            The call to split(s) with an empty s would split the string into an array of letters:

      
        
        
          
            
          
          
            
          
        
        
          let str = "test";

alert( str.split('') ); // t,e,s,t
        
      
      
      
The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ;

alert( str ); // Bilbo;Gandalf;Nazgul
        
      
      
      reduce/reduceRightWhen we need to iterate over an array – we can use forEach, for or for..of.
When we need to iterate and return the data for each element – we can use map.
The methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.
The syntax is:

      
        
        
          let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
        
      
      
      The function is applied to all array elements one after another and “carries on” its result to the next call.
Arguments:

accumulator – is the result of the previous function call, equals initial the first time (if initial is provided).
item – is the current array item.
index – is its position.
array – is the array.

As the function is applied, the result of the previous function call is passed to the next one as the first argument.
So, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end, it becomes the result of reduce.
Sounds complicated?
The easiest way to grasp that is by example.
Here we get a sum of an array in one line:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
        
      
      
      The function passed to reduce uses only 2 arguments, that’s typically enough.
Let’s see the details of what’s going on.

On the first run, sum is the initial value (the last argument of reduce), equals 0, and current is the first array element, equals 1. So the function result is 1.
On the second run, sum = 1, we add the second array element (2) to it and return.
On the 3rd run, sum = 3 and we add one more element to it, and so on…

The calculation flow:

      
      
        
      
      Or in the form of a table, where each row represents a function call on the next array element:




sum
current
result




the first call
0
1
1


the second call
1
2
3


the third call
3
3
6


the fourth call
6
4
10


the fifth call
10
5
15



Here we can clearly see how the result of the previous call becomes the first argument of the next one.
We also can omit the initial value:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

// removed initial value from reduce (no 0)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
        
      
      
      The result is the same. That’s because if there’s no initial, then reduce takes the first element of the array as the initial value and starts the iteration from the 2nd element.
The calculation table is the same as above, minus the first row.
But such use requires an extreme care. If the array is empty, then reduce call without initial value gives an error.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [];

// Error: Reduce of empty array with no initial value
// if the initial value existed, reduce would return it for the empty arr.
arr.reduce((sum, current) => sum + current);
        
      
      
      So it’s advised to always specify the initial value.
The method arr.reduceRight does the same but goes from right to left.
Array.isArrayArrays do not form a separate language type. They are based on objects.
So typeof does not help to distinguish a plain object from an array:

      
        
        
          
            
          
          
            
          
        
        
          alert(typeof {}); // object
alert(typeof []); // object (same)
        
      
      
      …But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns true if the value is an array, and false otherwise.

      
        
        
          
            
          
          
            
          
        
        
          alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
        
      
      
      Most methods support “thisArg”Almost all array methods that call functions – like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.
That parameter is not explained in the sections above, because it’s rarely used. But for completeness, we have to cover it.
Here’s the full syntax of these methods:

      
        
        
          arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
        
      
      
      The value of thisArg parameter becomes this for func.
For example, here we use a method of army object as a filter, and thisArg passes the context:

      
        
        
          
            
          
          
            
          
        
        
          let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
        
      
      
      If in the example above we used users.filter(army.canJoin), then army.canJoin would be called as a standalone function, with this=undefined, thus leading to an instant error.
A call to users.filter(army.canJoin, army) can be replaced with users.filter(user => army.canJoin(user)), that does the same. The latter is used more often, as it’s a bit easier to understand for most people.
SummaryA cheat sheet of array methods:


To add/remove elements:

push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.
slice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.



To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, and return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.



To iterate over elements:

forEach(func) – calls func for every element, does not return anything.



To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.



Additionally:

Array.isArray(value) checks value for being an array, if so returns true, otherwise false.



Please note that methods sort, reverse and splice modify the array itself.
These methods are the most used ones, they cover 99% of use cases. But there are few others:


arr.some(fn)/arr.every(fn) check the array.
The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.
These methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.
We can use every to compare arrays:

      
        
        
          
            
          
          
            
          
        
        
          function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
        
      
      
      

arr.fill(value, start, end) – fills the array with repeating value from index start to end.


arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).


arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.


For the full list, see the manual.
At first sight, it may seem that there are so many methods, quite difficult to remember. But actually, that’s much easier.
Look through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.
Afterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you’ll automatically remember the methods, without specific efforts from your side.
TasksTranslate border-left-width to borderLeftWidthimportance: 5Write the function camelize(str) that changes dash-separated words like “my-short-string” into camel-cased “myShortString”.
That is: removes all dashes, each word after dash becomes uppercased.
Examples:

      
        
        
          camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
        
      
      
      P.S. Hint: use split to split the string into an array, transform it and join back.
Open a sandbox with tests.solution
      
        
        
          function camelize(str) {
  return str
    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
    .map(
      // capitalizes first letters of all array items except the first one
      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
    )
    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
}
        
      
      
      Open the solution with tests in a sandbox.Filter rangeimportance: 4Write a function filterRange(arr, a, b) that gets an array arr, looks for elements with values higher or equal to a and lower or equal to b and return a result as an array.
The function should not modify the array. It should return the new array.
For instance:

      
        
        
          let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (matching values)

alert( arr ); // 5,3,8,1 (not modified)
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function filterRange(arr, a, b) {
  // added brackets around the expression for better readability
  return arr.filter(item => (a <= item && item <= b));
}

let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (matching values)

alert( arr ); // 5,3,8,1 (not modified)
        
      
      
      Open the solution with tests in a sandbox.Filter range "in place"importance: 4Write a function filterRangeInPlace(arr, a, b) that gets an array arr and removes from it all values except those that are between a and b. The test is: a ≤ arr[i] ≤ b.
The function should only modify the array. It should not return anything.
For instance:

      
        
        
          let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4

alert( arr ); // [3, 1]
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function filterRangeInPlace(arr, a, b) {

  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    // remove if outside of the interval
    if (val < a || val > b) {
      arr.splice(i, 1);
      i--;
    }
  }

}

let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4

alert( arr ); // [3, 1]
        
      
      
      Open the solution with tests in a sandbox.Sort in decreasing orderimportance: 4
      
        
        
          let arr = [5, 2, 1, -10, 8];

// ... your code to sort it in decreasing order

alert( arr ); // 8, 5, 2, 1, -10
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let arr = [5, 2, 1, -10, 8];

arr.sort((a, b) => b - a);

alert( arr );
        
      
      
      Copy and sort arrayimportance: 5We have an array of strings arr. We’d like to have a sorted copy of it, but keep arr unmodified.
Create a function copySorted(arr) that returns such a copy.

      
        
        
          let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (no changes)
        
      
      
      solutionWe can use slice() to make a copy and run the sort on it:

      
        
        
          
            
          
          
            
          
        
        
          function copySorted(arr) {
  return arr.slice().sort();
}

let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted );
alert( arr );
        
      
      
      Create an extendable calculatorimportance: 5Create a constructor function Calculator that creates “extendable” calculator objects.
The task consists of two parts.


First, implement the method calculate(str) that takes a string like "1 + 2" in the format “NUMBER operator NUMBER” (space-delimited) and returns the result. Should understand plus + and minus -.
Usage example:

      
        
        
          let calc = new Calculator;

alert( calc.calculate("3 + 7") ); // 10
        
      
      
      

Then add the method addMethod(name, func) that teaches the calculator a new operation. It takes the operator name and the two-argument function func(a,b) that implements it.
For instance, let’s add the multiplication *, division / and power **:

      
        
        
          let powerCalc = new Calculator;
powerCalc.addMethod("*", (a, b) => a * b);
powerCalc.addMethod("/", (a, b) => a / b);
powerCalc.addMethod("**", (a, b) => a ** b);

let result = powerCalc.calculate("2 ** 3");
alert( result ); // 8
        
      
      
      


No parentheses or complex expressions in this task.
The numbers and the operator are delimited with exactly one space.
There may be error handling if you’d like to add it.

Open a sandbox with tests.solution
Please note how methods are stored. They are simply added to this.methods property.
All tests and numeric conversions are done in the calculate method. In future it may be extended to support more complex expressions.


      
        
        
          function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
        
      
      
      Open the solution with tests in a sandbox.Map to namesimportance: 5You have an array of user objects, each one has user.name. Write the code that converts it into an array of names.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = /* ... your code */

alert( names ); // John, Pete, Mary
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = users.map(item => item.name);

alert( names ); // John, Pete, Mary
        
      
      
      Map to objectsimportance: 5You have an array of user objects, each one has name, surname and id.
Write the code to create another array from it, of objects with id and fullName, where fullName is generated from name and surname.
For instance:

      
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = /* ... your code ... */

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith
        
      
      
      So, actually you need to map one array of objects to another. Try using => here. There’s a small catch.
solution
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith
        
      
      
      Please note that in the arrow functions we need to use additional brackets.
We can’t write like this:

      
        
        
          let usersMapped = users.map(user => {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});
        
      
      
      As we remember, there are two arrow functions: without body value => expr and with body value => {...}.
Here JavaScript would treat { as the start of function body, not the start of the object. The workaround is to wrap them in the “normal” brackets:

      
        
        
          let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
        
      
      
      Now fine.
Sort users by ageimportance: 5Write the function sortByAge(users) that gets an array of objects with the age property and sorts them by age.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function sortByAge(arr) {
  arr.sort((a, b) => a.age - b.age);
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now sorted is: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      Shuffle an arrayimportance: 3Write the function shuffle(array) that shuffles (randomly reorders) elements of the array.
Multiple runs of shuffle may lead to different orders of elements. For instance:

      
        
        
          let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
        
      
      
      All element orders should have an equal probability. For instance, [1,2,3] can be reordered as [1,2,3] or [1,3,2] or [3,1,2] etc, with equal probability of each case.
solutionThe simple solution could be:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
        
      
      
      That somewhat works, because Math.random() - 0.5 is a random number that may be positive or negative, so the sorting function reorders elements randomly.
But because the sorting function is not meant to be used this way, not all permutations have the same probability.
For instance, consider the code below. It runs shuffle 1000000 times and counts appearances of all possible results:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      An example result (depends on JS engine):

      
        
        
          123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
        
      
      
      We can see the bias clearly: 123 and 213 appear much more often than others.
The result of the code may vary between JavaScript engines, but we can already see that the approach is unreliable.
Why it doesn’t work? Generally speaking, sort is a “black box”: we throw an array and a comparison function into it and expect the array to be sorted. But due to the utter randomness of the comparison the black box goes mad, and how exactly it goes mad depends on the concrete implementation that differs between engines.
There are other good ways to do the task. For instance, there’s a great algorithm called Fisher-Yates shuffle. The idea is to walk the array in the reverse order and swap each element with a random one before it:

      
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i

    // swap elements array[i] and array[j]
    // we use "destructuring assignment" syntax to achieve that
    // you'll find more details about that syntax in later chapters
    // same can be written as:
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}
        
      
      
      Let’s test it the same way:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      The example output:

      
        
        
          123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
        
      
      
      Looks good now: all permutations appear with the same probability.
Also, performance-wise the Fisher-Yates algorithm is much better, there’s no “sorting” overhead.
Get average ageimportance: 4Write the function getAverageAge(users) that gets an array of objects with property age and returns the average age.
The formula for the average is (age1 + age2 + ... + ageN) / N.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function getAverageAge(users) {
  return users.reduce((prev, user) => prev + user.age, 0) / users.length;
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // 28
        
      
      
      Filter unique array membersimportance: 4Let arr be an array.
Create a function unique(arr) that should return an array with unique items of arr.
For instance:

      
        
        
          function unique(arr) {
  /* your code */
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      Open a sandbox with tests.solutionLet’s walk the array items:

For each item we’ll check if the resulting array already has that item.
If it is so, then ignore, otherwise add to results.


      
        
        
          
            
          
          
            
          
        
        
          function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      The code works, but there’s a potential performance problem in it.
The method result.includes(str) internally walks the array result and compares each element against str to find the match.
So if there are 100 elements in result and no one matches str, then it will walk the whole result and do exactly 100 comparisons. And if result is large, like 10000, then there would be 10000 comparisons.
That’s not a problem by itself, because JavaScript engines are very fast, so walk 10000 array is a matter of microseconds.
But we do such test for each element of arr, in the for loop.
So if arr.length is 10000 we’ll have something like 10000*10000 = 100 millions of comparisons. That’s a lot.
So the solution is only good for small arrays.
Further in the chapter Map and Set we’ll see how to optimize it.
Open the solution with tests in a sandbox.Create keyed object from arrayimportance: 4Let’s say we received an array of users in the form {id:..., name:..., age:... }.
Create a function groupById(arr) that creates an object from it, with id as the key, and array items as values.
For example:

      
        
        
          let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

/*
// after the call we should have:

usersById = {
  john: {id: 'john', name: "John Smith", age: 20},
  ann: {id: 'ann', name: "Ann Smith", age: 24},
  pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/
        
      
      
      Such function is really handy when working with server data.
In this task we assume that id is unique. There may be no two array items with the same id.
Please use array .reduce method in the solution.
Open a sandbox with tests.solution
      
        
        
          function groupById(array) {
  return array.reduce((obj, value) => {
    obj[value.id] = value;
    return obj;
  }, {})
}
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageData typesDecember 31, 2023Array methodsArrays provide a lot of methods. To make things easier, in this chapter, they are split into groups.
Add/remove itemsWe already know methods that add and remove items from the beginning or the end:

arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.

Here are a few others.
spliceHow to delete an element from the array?
The arrays are objects, so we can try to use delete:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "go", "home"];

delete arr[1]; // remove "go"

alert( arr[1] ); // undefined

// now arr = ["I",  , "home"];
alert( arr.length ); // 3
        
      
      
      The element was removed, but the array still has 3 elements, we can see that arr.length == 3.
That’s natural, because delete obj.key removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of the elements to shift and occupy the freed place. We expect to have a shorter array now.
So, special methods should be used.
The arr.splice method is a Swiss army knife for arrays. It can do everything: insert, remove and replace elements.
The syntax is:

      
        
        
          arr.splice(start[, deleteCount, elem1, ..., elemN])
        
      
      
      It modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.
This method is easy to grasp by examples.
Let’s start with the deletion:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // from index 1 remove 1 element

alert( arr ); // ["I", "JavaScript"]
        
      
      
      Easy, right? Starting from the index 1 it removed 1 element.
In the next example, we remove 3 elements and replace them with the other two:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
        
      
      
      Here we can see that splice returns the array of removed elements:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- array of removed elements
        
      
      
      The splice method is also able to insert the elements without any removals. For that, we need to set deleteCount to 0:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
        
      
      
      
            Negative indexes allowed
            Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
        
      
      
      
sliceThe method arr.slice is much simpler than the similar-looking arr.splice.
The syntax is:

      
        
        
          arr.slice([start], [end])
        
      
      
      It returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.
It’s similar to a string method str.slice, but instead of substrings, it makes subarrays.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)

alert( arr.slice(-2) ); // s,t (copy from -2 till the end)
        
      
      
      We can also call it without arguments: arr.slice() creates a copy of arr. That’s often used to obtain a copy for further transformations that should not affect the original array.
concatThe method arr.concat creates a new array that includes values from other arrays and additional items.
The syntax is:

      
        
        
          arr.concat(arg1, arg2...)
        
      
      
      It accepts any number of arguments – either arrays or values.
The result is a new array containing items from arr, then arg1, arg2 etc.
If an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

// create an array from: arr and [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// create an array from: arr and [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// create an array from: arr and [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
        
      
      
      Normally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
        
      
      
      …But if an array-like object has a special Symbol.isConcatSpreadable property, then it’s treated as an array by concat: its elements are added instead:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
        
      
      
      Iterate: forEachThe arr.forEach method allows to run a function for every element of the array.
The syntax:

      
        
        
          arr.forEach(function(item, index, array) {
  // ... do something with an item
});
        
      
      
      For instance, this shows each element of the array:

      
        
        
          
            
          
          
            
          
        
        
          // for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
        
      
      
      And this code is more elaborate about their positions in the target array:

      
        
        
          
            
          
          
            
          
        
        
          ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
        
      
      
      The result of the function (if it returns any) is thrown away and ignored.
Searching in arrayNow let’s cover methods that search in an array.
indexOf/lastIndexOf and includesThe methods arr.indexOf and arr.includes have the similar syntax and do essentially the same as their string counterparts, but operate on items instead of characters:

arr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.
arr.includes(item, from) – looks for item starting from index from, returns true if found.

Usually, these methods are used with only one argument: the item to search. By default, the search is from the beginning.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
        
      
      
      Please note that indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.
If we want to check if item exists in the array and don’t need the index, then arr.includes is preferred.
The method arr.lastIndexOf is the same as indexOf, but looks for from right to left.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ['Apple', 'Orange', 'Apple']

alert( fruits.indexOf('Apple') ); // 0 (first Apple)
alert( fruits.lastIndexOf('Apple') ); // 2 (last Apple)
        
      
      
      
            The includes method handles NaN correctly
            A minor, but noteworthy feature of includes is that it correctly handles NaN, unlike indexOf:

      
        
        
          
            
          
          
            
          
        
        
          const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (wrong, should be 0)
alert( arr.includes(NaN) );// true (correct)
        
      
      
      That’s because includes was added to JavaScript much later and uses the more up-to-date comparison algorithm internally.

find and findIndex/findLastIndexImagine we have an array of objects. How do we find an object with a specific condition?
Here the arr.find(fn) method comes in handy.
The syntax is:

      
        
        
          let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});
        
      
      
      The function is called for elements of the array, one after another:

item is the element.
index is its index.
array is the array itself.

If it returns true, the search is stopped, the item is returned. If nothing is found, undefined is returned.
For example, we have an array of users, each with the fields id and name. Let’s find the one with id == 1:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
        
      
      
      In real life, arrays of objects are a common thing, so the find method is very useful.
Note that in the example we provide to find the function item => item.id == 1 with one argument. That’s typical, other arguments of this function are rarely used.
The arr.findIndex method has the same syntax but returns the index where the element was found instead of the element itself. The value of -1 is returned if nothing is found.
The arr.findLastIndex method is like findIndex, but searches from right to left, similar to lastIndexOf.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"},
  {id: 4, name: "John"}
];

// Find the index of the first John
alert(users.findIndex(user => user.name == 'John')); // 0

// Find the index of the last John
alert(users.findLastIndex(user => user.name == 'John')); // 3
        
      
      
      filterThe find method looks for a single (first) element that makes the function return true.
If there may be many, we can use arr.filter(fn).
The syntax is similar to find, but filter returns an array of all matching elements:

      
        
        
          let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});
        
      
      
      For instance:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
        
      
      
      Transform an arrayLet’s move on to methods that transform and reorder an array.
mapThe arr.map method is one of the most useful and often used.
It calls the function for each element of the array and returns the array of results.
The syntax is:

      
        
        
          let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
        
      
      
      For instance, here we transform each element into its length:

      
        
        
          
            
          
          
            
          
        
        
          let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
        
      
      
      sort(fn)The call to arr.sort() sorts the array in place, changing its element order.
It also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

// the method reorders the content of arr
arr.sort();

alert( arr );  // 1, 15, 2
        
      
      
      Did you notice anything strange in the outcome?
The order became 1, 15, 2. Incorrect. But why?
The items are sorted as strings by default.
Literally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed "2" > "15".
To use our own sorting order, we need to supply a function as the argument of arr.sort().
The function should compare two arbitrary values and return:

      
        
        
          function compare(a, b) {
  if (a > b) return 1; // if the first value is greater than the second
  if (a == b) return 0; // if values are equal
  if (a < b) return -1; // if the first value is less than the second
}
        
      
      
      For instance, to sort as numbers:

      
        
        
          
            
          
          
            
          
        
        
          function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
        
      
      
      Now it works as intended.
Let’s step aside and think about what’s happening. The arr can be an array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.
The arr.sort(fn) method implements a generic sorting algorithm. We don’t need to care how it internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.
By the way, if we ever want to know which elements are compared – nothing prevents us from alerting them:

      
        
        
          
            
          
          
            
          
        
        
          [1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
        
      
      
      The algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.

            A comparison function may return any number
            Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.
That allows to write shorter functions:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
        
      
      
      

            Arrow functions for the best
            Remember arrow functions? We can use them here for neater sorting:

      
        
        
          arr.sort( (a, b) => a - b );
        
      
      
      This works exactly the same as the longer version above.


            Use localeCompare for strings
            Remember strings comparison algorithm? It compares letters by their codes by default.
For many alphabets, it’s better to use str.localeCompare method to correctly sort letters, such as Ö.
For example, let’s sort a few countries in German:

      
        
        
          
            
          
          
            
          
        
        
          let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)
        
      
      
      
reverseThe method arr.reverse reverses the order of elements in arr.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
        
      
      
      It also returns the array arr after the reversal.
split and joinHere’s the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: John, Pete, Mary. But for us an array of names would be much more comfortable than a single string. How to get it?
The str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim.
In the example below, we split by a comma followed by a space:

      
        
        
          
            
          
          
            
          
        
        
          let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
        
      
      
      The split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:

      
        
        
          
            
          
          
            
          
        
        
          let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
        
      
      
      
            Split into letters
            The call to split(s) with an empty s would split the string into an array of letters:

      
        
        
          
            
          
          
            
          
        
        
          let str = "test";

alert( str.split('') ); // t,e,s,t
        
      
      
      
The call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ;

alert( str ); // Bilbo;Gandalf;Nazgul
        
      
      
      reduce/reduceRightWhen we need to iterate over an array – we can use forEach, for or for..of.
When we need to iterate and return the data for each element – we can use map.
The methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.
The syntax is:

      
        
        
          let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
        
      
      
      The function is applied to all array elements one after another and “carries on” its result to the next call.
Arguments:

accumulator – is the result of the previous function call, equals initial the first time (if initial is provided).
item – is the current array item.
index – is its position.
array – is the array.

As the function is applied, the result of the previous function call is passed to the next one as the first argument.
So, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end, it becomes the result of reduce.
Sounds complicated?
The easiest way to grasp that is by example.
Here we get a sum of an array in one line:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
        
      
      
      The function passed to reduce uses only 2 arguments, that’s typically enough.
Let’s see the details of what’s going on.

On the first run, sum is the initial value (the last argument of reduce), equals 0, and current is the first array element, equals 1. So the function result is 1.
On the second run, sum = 1, we add the second array element (2) to it and return.
On the 3rd run, sum = 3 and we add one more element to it, and so on…

The calculation flow:

      
      
        
      
      Or in the form of a table, where each row represents a function call on the next array element:




sum
current
result




the first call
0
1
1


the second call
1
2
3


the third call
3
3
6


the fourth call
6
4
10


the fifth call
10
5
15



Here we can clearly see how the result of the previous call becomes the first argument of the next one.
We also can omit the initial value:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

// removed initial value from reduce (no 0)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
        
      
      
      The result is the same. That’s because if there’s no initial, then reduce takes the first element of the array as the initial value and starts the iteration from the 2nd element.
The calculation table is the same as above, minus the first row.
But such use requires an extreme care. If the array is empty, then reduce call without initial value gives an error.
Here’s an example:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [];

// Error: Reduce of empty array with no initial value
// if the initial value existed, reduce would return it for the empty arr.
arr.reduce((sum, current) => sum + current);
        
      
      
      So it’s advised to always specify the initial value.
The method arr.reduceRight does the same but goes from right to left.
Array.isArrayArrays do not form a separate language type. They are based on objects.
So typeof does not help to distinguish a plain object from an array:

      
        
        
          
            
          
          
            
          
        
        
          alert(typeof {}); // object
alert(typeof []); // object (same)
        
      
      
      …But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns true if the value is an array, and false otherwise.

      
        
        
          
            
          
          
            
          
        
        
          alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
        
      
      
      Most methods support “thisArg”Almost all array methods that call functions – like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.
That parameter is not explained in the sections above, because it’s rarely used. But for completeness, we have to cover it.
Here’s the full syntax of these methods:

      
        
        
          arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
        
      
      
      The value of thisArg parameter becomes this for func.
For example, here we use a method of army object as a filter, and thisArg passes the context:

      
        
        
          
            
          
          
            
          
        
        
          let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
        
      
      
      If in the example above we used users.filter(army.canJoin), then army.canJoin would be called as a standalone function, with this=undefined, thus leading to an instant error.
A call to users.filter(army.canJoin, army) can be replaced with users.filter(user => army.canJoin(user)), that does the same. The latter is used more often, as it’s a bit easier to understand for most people.
SummaryA cheat sheet of array methods:


To add/remove elements:

push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.
slice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.



To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, and return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.



To iterate over elements:

forEach(func) – calls func for every element, does not return anything.



To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.



Additionally:

Array.isArray(value) checks value for being an array, if so returns true, otherwise false.



Please note that methods sort, reverse and splice modify the array itself.
These methods are the most used ones, they cover 99% of use cases. But there are few others:


arr.some(fn)/arr.every(fn) check the array.
The function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.
These methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.
We can use every to compare arrays:

      
        
        
          
            
          
          
            
          
        
        
          function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
        
      
      
      

arr.fill(value, start, end) – fills the array with repeating value from index start to end.


arr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).


arr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.


For the full list, see the manual.
At first sight, it may seem that there are so many methods, quite difficult to remember. But actually, that’s much easier.
Look through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.
Afterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you’ll automatically remember the methods, without specific efforts from your side.
TasksTranslate border-left-width to borderLeftWidthimportance: 5Write the function camelize(str) that changes dash-separated words like “my-short-string” into camel-cased “myShortString”.
That is: removes all dashes, each word after dash becomes uppercased.
Examples:

      
        
        
          camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
        
      
      
      P.S. Hint: use split to split the string into an array, transform it and join back.
Open a sandbox with tests.solution
      
        
        
          function camelize(str) {
  return str
    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
    .map(
      // capitalizes first letters of all array items except the first one
      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
    )
    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
}
        
      
      
      Open the solution with tests in a sandbox.Filter rangeimportance: 4Write a function filterRange(arr, a, b) that gets an array arr, looks for elements with values higher or equal to a and lower or equal to b and return a result as an array.
The function should not modify the array. It should return the new array.
For instance:

      
        
        
          let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (matching values)

alert( arr ); // 5,3,8,1 (not modified)
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function filterRange(arr, a, b) {
  // added brackets around the expression for better readability
  return arr.filter(item => (a <= item && item <= b));
}

let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (matching values)

alert( arr ); // 5,3,8,1 (not modified)
        
      
      
      Open the solution with tests in a sandbox.Filter range "in place"importance: 4Write a function filterRangeInPlace(arr, a, b) that gets an array arr and removes from it all values except those that are between a and b. The test is: a ≤ arr[i] ≤ b.
The function should only modify the array. It should not return anything.
For instance:

      
        
        
          let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4

alert( arr ); // [3, 1]
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function filterRangeInPlace(arr, a, b) {

  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    // remove if outside of the interval
    if (val < a || val > b) {
      arr.splice(i, 1);
      i--;
    }
  }

}

let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4

alert( arr ); // [3, 1]
        
      
      
      Open the solution with tests in a sandbox.Sort in decreasing orderimportance: 4
      
        
        
          let arr = [5, 2, 1, -10, 8];

// ... your code to sort it in decreasing order

alert( arr ); // 8, 5, 2, 1, -10
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let arr = [5, 2, 1, -10, 8];

arr.sort((a, b) => b - a);

alert( arr );
        
      
      
      Copy and sort arrayimportance: 5We have an array of strings arr. We’d like to have a sorted copy of it, but keep arr unmodified.
Create a function copySorted(arr) that returns such a copy.

      
        
        
          let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (no changes)
        
      
      
      solutionWe can use slice() to make a copy and run the sort on it:

      
        
        
          
            
          
          
            
          
        
        
          function copySorted(arr) {
  return arr.slice().sort();
}

let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted );
alert( arr );
        
      
      
      Create an extendable calculatorimportance: 5Create a constructor function Calculator that creates “extendable” calculator objects.
The task consists of two parts.


First, implement the method calculate(str) that takes a string like "1 + 2" in the format “NUMBER operator NUMBER” (space-delimited) and returns the result. Should understand plus + and minus -.
Usage example:

      
        
        
          let calc = new Calculator;

alert( calc.calculate("3 + 7") ); // 10
        
      
      
      

Then add the method addMethod(name, func) that teaches the calculator a new operation. It takes the operator name and the two-argument function func(a,b) that implements it.
For instance, let’s add the multiplication *, division / and power **:

      
        
        
          let powerCalc = new Calculator;
powerCalc.addMethod("*", (a, b) => a * b);
powerCalc.addMethod("/", (a, b) => a / b);
powerCalc.addMethod("**", (a, b) => a ** b);

let result = powerCalc.calculate("2 ** 3");
alert( result ); // 8
        
      
      
      


No parentheses or complex expressions in this task.
The numbers and the operator are delimited with exactly one space.
There may be error handling if you’d like to add it.

Open a sandbox with tests.solution
Please note how methods are stored. They are simply added to this.methods property.
All tests and numeric conversions are done in the calculate method. In future it may be extended to support more complex expressions.


      
        
        
          function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
        
      
      
      Open the solution with tests in a sandbox.Map to namesimportance: 5You have an array of user objects, each one has user.name. Write the code that converts it into an array of names.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = /* ... your code */

alert( names ); // John, Pete, Mary
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = users.map(item => item.name);

alert( names ); // John, Pete, Mary
        
      
      
      Map to objectsimportance: 5You have an array of user objects, each one has name, surname and id.
Write the code to create another array from it, of objects with id and fullName, where fullName is generated from name and surname.
For instance:

      
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = /* ... your code ... */

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith
        
      
      
      So, actually you need to map one array of objects to another. Try using => here. There’s a small catch.
solution
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith
        
      
      
      Please note that in the arrow functions we need to use additional brackets.
We can’t write like this:

      
        
        
          let usersMapped = users.map(user => {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});
        
      
      
      As we remember, there are two arrow functions: without body value => expr and with body value => {...}.
Here JavaScript would treat { as the start of function body, not the start of the object. The workaround is to wrap them in the “normal” brackets:

      
        
        
          let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
        
      
      
      Now fine.
Sort users by ageimportance: 5Write the function sortByAge(users) that gets an array of objects with the age property and sorts them by age.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function sortByAge(arr) {
  arr.sort((a, b) => a.age - b.age);
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now sorted is: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      Shuffle an arrayimportance: 3Write the function shuffle(array) that shuffles (randomly reorders) elements of the array.
Multiple runs of shuffle may lead to different orders of elements. For instance:

      
        
        
          let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
        
      
      
      All element orders should have an equal probability. For instance, [1,2,3] can be reordered as [1,2,3] or [1,3,2] or [3,1,2] etc, with equal probability of each case.
solutionThe simple solution could be:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
        
      
      
      That somewhat works, because Math.random() - 0.5 is a random number that may be positive or negative, so the sorting function reorders elements randomly.
But because the sorting function is not meant to be used this way, not all permutations have the same probability.
For instance, consider the code below. It runs shuffle 1000000 times and counts appearances of all possible results:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      An example result (depends on JS engine):

      
        
        
          123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
        
      
      
      We can see the bias clearly: 123 and 213 appear much more often than others.
The result of the code may vary between JavaScript engines, but we can already see that the approach is unreliable.
Why it doesn’t work? Generally speaking, sort is a “black box”: we throw an array and a comparison function into it and expect the array to be sorted. But due to the utter randomness of the comparison the black box goes mad, and how exactly it goes mad depends on the concrete implementation that differs between engines.
There are other good ways to do the task. For instance, there’s a great algorithm called Fisher-Yates shuffle. The idea is to walk the array in the reverse order and swap each element with a random one before it:

      
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i

    // swap elements array[i] and array[j]
    // we use "destructuring assignment" syntax to achieve that
    // you'll find more details about that syntax in later chapters
    // same can be written as:
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}
        
      
      
      Let’s test it the same way:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      The example output:

      
        
        
          123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
        
      
      
      Looks good now: all permutations appear with the same probability.
Also, performance-wise the Fisher-Yates algorithm is much better, there’s no “sorting” overhead.
Get average ageimportance: 4Write the function getAverageAge(users) that gets an array of objects with property age and returns the average age.
The formula for the average is (age1 + age2 + ... + ageN) / N.
For instance:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          function getAverageAge(users) {
  return users.reduce((prev, user) => prev + user.age, 0) / users.length;
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // 28
        
      
      
      Filter unique array membersimportance: 4Let arr be an array.
Create a function unique(arr) that should return an array with unique items of arr.
For instance:

      
        
        
          function unique(arr) {
  /* your code */
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      Open a sandbox with tests.solutionLet’s walk the array items:

For each item we’ll check if the resulting array already has that item.
If it is so, then ignore, otherwise add to results.


      
        
        
          
            
          
          
            
          
        
        
          function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      The code works, but there’s a potential performance problem in it.
The method result.includes(str) internally walks the array result and compares each element against str to find the match.
So if there are 100 elements in result and no one matches str, then it will walk the whole result and do exactly 100 comparisons. And if result is large, like 10000, then there would be 10000 comparisons.
That’s not a problem by itself, because JavaScript engines are very fast, so walk 10000 array is a matter of microseconds.
But we do such test for each element of arr, in the for loop.
So if arr.length is 10000 we’ll have something like 10000*10000 = 100 millions of comparisons. That’s a lot.
So the solution is only good for small arrays.
Further in the chapter Map and Set we’ll see how to optimize it.
Open the solution with tests in a sandbox.Create keyed object from arrayimportance: 4Let’s say we received an array of users in the form {id:..., name:..., age:... }.
Create a function groupById(arr) that creates an object from it, with id as the key, and array items as values.
For example:

      
        
        
          let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

/*
// after the call we should have:

usersById = {
  john: {id: 'john', name: "John Smith", age: 20},
  ann: {id: 'ann', name: "Ann Smith", age: 24},
  pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/
        
      
      
      Such function is really handy when working with server data.
In this task we assume that id is unique. There may be no two array items with the same id.
Please use array .reduce method in the solution.
Open a sandbox with tests.solution
      
        
        
          function groupById(array) {
  return array.reduce((obj, value) => {
    obj[value.id] = value;
    return obj;
  }, {})
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nIterable objects are a generalization of arrays. That’s a concept that allows us to make any object useable in a for..of loop.
Of course, Arrays are iterable. But there are many other built-in objects, that are iterable as well. For instance, strings are also iterable.
If an object isn’t technically an array, but represents a collection (list, set) of something, then for..of is a great syntax to loop over it, so let’s see how to make it work.
Symbol.iteratorWe can easily grasp the concept of iterables by making one of our own.
For instance, we have an object that is not an array, but looks suitable for for..of.
Like a range object that represents an interval of numbers:

      
        
        
          let range = {
  from: 1,
  to: 5
};

// We want the for..of to work:
// for(let num of range) ... num=1,2,3,4,5
        
      
      
      To make the range object iterable (and thus let for..of work) we need to add a method to the object named Symbol.iterator (a special built-in symbol just for that).

When for..of starts, it calls that method once (or errors if not found). The method must return an iterator – an object with the method next.
Onward, for..of works only with that returned object.
When for..of wants the next value, it calls next() on that object.
The result of next() must have the form {done: Boolean, value: any}, where done=true means that the loop is finished, otherwise value is the next value.

Here’s the full implementation for range with remarks:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5
};

// 1. call to for..of initially calls this
range[Symbol.iterator] = function() {

  // ...it returns the iterator object:
  // 2. Onward, for..of works only with the iterator object below, asking it for next values
  return {
    current: this.from,
    last: this.to,

    // 3. next() is called on each iteration by the for..of loop
    next() {
      // 4. it should return the value as an object {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// now it works!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Please note the core feature of iterables: separation of concerns.

The range itself does not have the next() method.
Instead, another object, a so-called “iterator” is created by the call to range[Symbol.iterator](), and its next() generates values for the iteration.

So, the iterator object is separate from the object it iterates over.
Technically, we may merge them and use range itself as the iterator to make the code simpler.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Now range[Symbol.iterator]() returns the range object itself:  it has the necessary next() method and remembers the current iteration progress in this.current. Shorter? Yes. And sometimes that’s fine too.
The downside is that now it’s impossible to have two for..of loops running over the object simultaneously: they’ll share the iteration state, because there’s only one iterator – the object itself. But two parallel for-ofs is a rare thing, even in async scenarios.

            Infinite iterators
            Infinite iterators are also possible. For instance, the range becomes infinite for range.to = Infinity. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.
There are no limitations on next, it can return more and more values, that’s normal.
Of course, the for..of loop over such an iterable would be endless. But we can always stop it using break.

String is iterableArrays and strings are most widely used built-in iterables.
For a string, for..of loops over its characters:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "test") {
  // triggers 4 times: once for each character
  alert( char ); // t, then e, then s, then t
}
        
      
      
      And it works correctly with surrogate pairs!

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, and then 😂
}
        
      
      
      Calling an iterator explicitlyFor deeper understanding, let’s see how to use an iterator explicitly.
We’ll iterate over a string in exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values from it “manually”:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

// does the same as
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}
        
      
      
      That is rarely needed, but gives us more control over the process than for..of. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.
Iterables and array-likesTwo official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.

Iterables are objects that implement the Symbol.iterator method, as described above.
Array-likes are objects that have indexes and length, so they look like arrays.

When we use JavaScript for practical tasks in a browser or any other environment, we may meet objects that are iterables or array-likes, or both.
For instance, strings are both iterable (for..of works on them) and array-like (they have numeric indexes and length).
But an iterable may not be array-like. And vice versa an array-like may not be iterable.
For example, the range in the example above is iterable, but not array-like, because it does not have indexed properties and length.
And here’s the object that is array-like, but not iterable:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = { // has indexes and length => array-like
  0: "Hello",
  1: "World",
  length: 2
};

// Error (no Symbol.iterator)
for (let item of arrayLike) {}
        
      
      
      Both iterables and array-likes are usually not arrays, they don’t have push, pop etc. That’s rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with range using array methods. How to achieve that?
Array.fromThere’s a universal method Array.from that takes an iterable or array-like value and makes a “real” Array from it. Then we can call array methods on it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)
        
      
      
      Array.from at the line (*) takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.
The same happens for an iterable:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)
        
      
      
      The full syntax for Array.from also allows us to provide an optional “mapping” function:

      
        
        
          Array.from(obj[, mapFn, thisArg])
        
      
      
      The optional second argument mapFn can be a function that will be applied to each element before adding it to the array, and thisArg allows us to set this for it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above

// square each number
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
        
      
      
      Here we use Array.from to turn a string into an array of characters:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

// splits str into array of characters
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
        
      
      
      Unlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly works with surrogate pairs.
Technically here it does the same as:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}

alert(chars);
        
      
      
      …But it is shorter.
We can even build surrogate-aware slice on it:

      
        
        
          
            
          
          
            
          
        
        
          function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// the native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)
        
      
      
      SummaryObjects that can be used in for..of are called iterable.

Technically, iterables must implement the method named Symbol.iterator.

The result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.
An iterator must have the method named next() that returns an object {done: Boolean, value: any}, here done:true denotes the end of the iteration process, otherwise the value is the next value.


The Symbol.iterator method is called automatically by for..of, but we also can do it directly.
Built-in iterables like strings or arrays, also implement Symbol.iterator.
String iterator knows about surrogate pairs.

Objects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.
If we look inside the specification – we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.
Array.from(obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item.\n\nTutorialThe JavaScript languageData typesMay 10, 2024IterablesIterable objects are a generalization of arrays. That’s a concept that allows us to make any object useable in a for..of loop.
Of course, Arrays are iterable. But there are many other built-in objects, that are iterable as well. For instance, strings are also iterable.
If an object isn’t technically an array, but represents a collection (list, set) of something, then for..of is a great syntax to loop over it, so let’s see how to make it work.
Symbol.iteratorWe can easily grasp the concept of iterables by making one of our own.
For instance, we have an object that is not an array, but looks suitable for for..of.
Like a range object that represents an interval of numbers:

      
        
        
          let range = {
  from: 1,
  to: 5
};

// We want the for..of to work:
// for(let num of range) ... num=1,2,3,4,5
        
      
      
      To make the range object iterable (and thus let for..of work) we need to add a method to the object named Symbol.iterator (a special built-in symbol just for that).

When for..of starts, it calls that method once (or errors if not found). The method must return an iterator – an object with the method next.
Onward, for..of works only with that returned object.
When for..of wants the next value, it calls next() on that object.
The result of next() must have the form {done: Boolean, value: any}, where done=true means that the loop is finished, otherwise value is the next value.

Here’s the full implementation for range with remarks:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5
};

// 1. call to for..of initially calls this
range[Symbol.iterator] = function() {

  // ...it returns the iterator object:
  // 2. Onward, for..of works only with the iterator object below, asking it for next values
  return {
    current: this.from,
    last: this.to,

    // 3. next() is called on each iteration by the for..of loop
    next() {
      // 4. it should return the value as an object {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// now it works!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Please note the core feature of iterables: separation of concerns.

The range itself does not have the next() method.
Instead, another object, a so-called “iterator” is created by the call to range[Symbol.iterator](), and its next() generates values for the iteration.

So, the iterator object is separate from the object it iterates over.
Technically, we may merge them and use range itself as the iterator to make the code simpler.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Now range[Symbol.iterator]() returns the range object itself:  it has the necessary next() method and remembers the current iteration progress in this.current. Shorter? Yes. And sometimes that’s fine too.
The downside is that now it’s impossible to have two for..of loops running over the object simultaneously: they’ll share the iteration state, because there’s only one iterator – the object itself. But two parallel for-ofs is a rare thing, even in async scenarios.

            Infinite iterators
            Infinite iterators are also possible. For instance, the range becomes infinite for range.to = Infinity. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.
There are no limitations on next, it can return more and more values, that’s normal.
Of course, the for..of loop over such an iterable would be endless. But we can always stop it using break.

String is iterableArrays and strings are most widely used built-in iterables.
For a string, for..of loops over its characters:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "test") {
  // triggers 4 times: once for each character
  alert( char ); // t, then e, then s, then t
}
        
      
      
      And it works correctly with surrogate pairs!

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, and then 😂
}
        
      
      
      Calling an iterator explicitlyFor deeper understanding, let’s see how to use an iterator explicitly.
We’ll iterate over a string in exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values from it “manually”:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

// does the same as
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}
        
      
      
      That is rarely needed, but gives us more control over the process than for..of. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.
Iterables and array-likesTwo official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.

Iterables are objects that implement the Symbol.iterator method, as described above.
Array-likes are objects that have indexes and length, so they look like arrays.

When we use JavaScript for practical tasks in a browser or any other environment, we may meet objects that are iterables or array-likes, or both.
For instance, strings are both iterable (for..of works on them) and array-like (they have numeric indexes and length).
But an iterable may not be array-like. And vice versa an array-like may not be iterable.
For example, the range in the example above is iterable, but not array-like, because it does not have indexed properties and length.
And here’s the object that is array-like, but not iterable:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = { // has indexes and length => array-like
  0: "Hello",
  1: "World",
  length: 2
};

// Error (no Symbol.iterator)
for (let item of arrayLike) {}
        
      
      
      Both iterables and array-likes are usually not arrays, they don’t have push, pop etc. That’s rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with range using array methods. How to achieve that?
Array.fromThere’s a universal method Array.from that takes an iterable or array-like value and makes a “real” Array from it. Then we can call array methods on it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)
        
      
      
      Array.from at the line (*) takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.
The same happens for an iterable:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)
        
      
      
      The full syntax for Array.from also allows us to provide an optional “mapping” function:

      
        
        
          Array.from(obj[, mapFn, thisArg])
        
      
      
      The optional second argument mapFn can be a function that will be applied to each element before adding it to the array, and thisArg allows us to set this for it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above

// square each number
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
        
      
      
      Here we use Array.from to turn a string into an array of characters:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

// splits str into array of characters
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
        
      
      
      Unlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly works with surrogate pairs.
Technically here it does the same as:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}

alert(chars);
        
      
      
      …But it is shorter.
We can even build surrogate-aware slice on it:

      
        
        
          
            
          
          
            
          
        
        
          function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// the native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)
        
      
      
      SummaryObjects that can be used in for..of are called iterable.

Technically, iterables must implement the method named Symbol.iterator.

The result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.
An iterator must have the method named next() that returns an object {done: Boolean, value: any}, here done:true denotes the end of the iteration process, otherwise the value is the next value.


The Symbol.iterator method is called automatically by for..of, but we also can do it directly.
Built-in iterables like strings or arrays, also implement Symbol.iterator.
String iterator knows about surrogate pairs.

Objects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.
If we look inside the specification – we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.
Array.from(obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nIterable objects are a generalization of arrays. That’s a concept that allows us to make any object useable in a for..of loop.
Of course, Arrays are iterable. But there are many other built-in objects, that are iterable as well. For instance, strings are also iterable.
If an object isn’t technically an array, but represents a collection (list, set) of something, then for..of is a great syntax to loop over it, so let’s see how to make it work.
Symbol.iteratorWe can easily grasp the concept of iterables by making one of our own.
For instance, we have an object that is not an array, but looks suitable for for..of.
Like a range object that represents an interval of numbers:

      
        
        
          let range = {
  from: 1,
  to: 5
};

// We want the for..of to work:
// for(let num of range) ... num=1,2,3,4,5
        
      
      
      To make the range object iterable (and thus let for..of work) we need to add a method to the object named Symbol.iterator (a special built-in symbol just for that).

When for..of starts, it calls that method once (or errors if not found). The method must return an iterator – an object with the method next.
Onward, for..of works only with that returned object.
When for..of wants the next value, it calls next() on that object.
The result of next() must have the form {done: Boolean, value: any}, where done=true means that the loop is finished, otherwise value is the next value.

Here’s the full implementation for range with remarks:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5
};

// 1. call to for..of initially calls this
range[Symbol.iterator] = function() {

  // ...it returns the iterator object:
  // 2. Onward, for..of works only with the iterator object below, asking it for next values
  return {
    current: this.from,
    last: this.to,

    // 3. next() is called on each iteration by the for..of loop
    next() {
      // 4. it should return the value as an object {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// now it works!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Please note the core feature of iterables: separation of concerns.

The range itself does not have the next() method.
Instead, another object, a so-called “iterator” is created by the call to range[Symbol.iterator](), and its next() generates values for the iteration.

So, the iterator object is separate from the object it iterates over.
Technically, we may merge them and use range itself as the iterator to make the code simpler.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Now range[Symbol.iterator]() returns the range object itself:  it has the necessary next() method and remembers the current iteration progress in this.current. Shorter? Yes. And sometimes that’s fine too.
The downside is that now it’s impossible to have two for..of loops running over the object simultaneously: they’ll share the iteration state, because there’s only one iterator – the object itself. But two parallel for-ofs is a rare thing, even in async scenarios.

            Infinite iterators
            Infinite iterators are also possible. For instance, the range becomes infinite for range.to = Infinity. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.
There are no limitations on next, it can return more and more values, that’s normal.
Of course, the for..of loop over such an iterable would be endless. But we can always stop it using break.

String is iterableArrays and strings are most widely used built-in iterables.
For a string, for..of loops over its characters:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "test") {
  // triggers 4 times: once for each character
  alert( char ); // t, then e, then s, then t
}
        
      
      
      And it works correctly with surrogate pairs!

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, and then 😂
}
        
      
      
      Calling an iterator explicitlyFor deeper understanding, let’s see how to use an iterator explicitly.
We’ll iterate over a string in exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values from it “manually”:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

// does the same as
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}
        
      
      
      That is rarely needed, but gives us more control over the process than for..of. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.
Iterables and array-likesTwo official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.

Iterables are objects that implement the Symbol.iterator method, as described above.
Array-likes are objects that have indexes and length, so they look like arrays.

When we use JavaScript for practical tasks in a browser or any other environment, we may meet objects that are iterables or array-likes, or both.
For instance, strings are both iterable (for..of works on them) and array-like (they have numeric indexes and length).
But an iterable may not be array-like. And vice versa an array-like may not be iterable.
For example, the range in the example above is iterable, but not array-like, because it does not have indexed properties and length.
And here’s the object that is array-like, but not iterable:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = { // has indexes and length => array-like
  0: "Hello",
  1: "World",
  length: 2
};

// Error (no Symbol.iterator)
for (let item of arrayLike) {}
        
      
      
      Both iterables and array-likes are usually not arrays, they don’t have push, pop etc. That’s rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with range using array methods. How to achieve that?
Array.fromThere’s a universal method Array.from that takes an iterable or array-like value and makes a “real” Array from it. Then we can call array methods on it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)
        
      
      
      Array.from at the line (*) takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.
The same happens for an iterable:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)
        
      
      
      The full syntax for Array.from also allows us to provide an optional “mapping” function:

      
        
        
          Array.from(obj[, mapFn, thisArg])
        
      
      
      The optional second argument mapFn can be a function that will be applied to each element before adding it to the array, and thisArg allows us to set this for it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above

// square each number
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
        
      
      
      Here we use Array.from to turn a string into an array of characters:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

// splits str into array of characters
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
        
      
      
      Unlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly works with surrogate pairs.
Technically here it does the same as:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}

alert(chars);
        
      
      
      …But it is shorter.
We can even build surrogate-aware slice on it:

      
        
        
          
            
          
          
            
          
        
        
          function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// the native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)
        
      
      
      SummaryObjects that can be used in for..of are called iterable.

Technically, iterables must implement the method named Symbol.iterator.

The result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.
An iterator must have the method named next() that returns an object {done: Boolean, value: any}, here done:true denotes the end of the iteration process, otherwise the value is the next value.


The Symbol.iterator method is called automatically by for..of, but we also can do it directly.
Built-in iterables like strings or arrays, also implement Symbol.iterator.
String iterator knows about surrogate pairs.

Objects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.
If we look inside the specification – we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.
Array.from(obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item.\n\nTutorialThe JavaScript languageData typesMay 10, 2024IterablesIterable objects are a generalization of arrays. That’s a concept that allows us to make any object useable in a for..of loop.
Of course, Arrays are iterable. But there are many other built-in objects, that are iterable as well. For instance, strings are also iterable.
If an object isn’t technically an array, but represents a collection (list, set) of something, then for..of is a great syntax to loop over it, so let’s see how to make it work.
Symbol.iteratorWe can easily grasp the concept of iterables by making one of our own.
For instance, we have an object that is not an array, but looks suitable for for..of.
Like a range object that represents an interval of numbers:

      
        
        
          let range = {
  from: 1,
  to: 5
};

// We want the for..of to work:
// for(let num of range) ... num=1,2,3,4,5
        
      
      
      To make the range object iterable (and thus let for..of work) we need to add a method to the object named Symbol.iterator (a special built-in symbol just for that).

When for..of starts, it calls that method once (or errors if not found). The method must return an iterator – an object with the method next.
Onward, for..of works only with that returned object.
When for..of wants the next value, it calls next() on that object.
The result of next() must have the form {done: Boolean, value: any}, where done=true means that the loop is finished, otherwise value is the next value.

Here’s the full implementation for range with remarks:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5
};

// 1. call to for..of initially calls this
range[Symbol.iterator] = function() {

  // ...it returns the iterator object:
  // 2. Onward, for..of works only with the iterator object below, asking it for next values
  return {
    current: this.from,
    last: this.to,

    // 3. next() is called on each iteration by the for..of loop
    next() {
      // 4. it should return the value as an object {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// now it works!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Please note the core feature of iterables: separation of concerns.

The range itself does not have the next() method.
Instead, another object, a so-called “iterator” is created by the call to range[Symbol.iterator](), and its next() generates values for the iteration.

So, the iterator object is separate from the object it iterates over.
Technically, we may merge them and use range itself as the iterator to make the code simpler.
Like this:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
        
      
      
      Now range[Symbol.iterator]() returns the range object itself:  it has the necessary next() method and remembers the current iteration progress in this.current. Shorter? Yes. And sometimes that’s fine too.
The downside is that now it’s impossible to have two for..of loops running over the object simultaneously: they’ll share the iteration state, because there’s only one iterator – the object itself. But two parallel for-ofs is a rare thing, even in async scenarios.

            Infinite iterators
            Infinite iterators are also possible. For instance, the range becomes infinite for range.to = Infinity. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.
There are no limitations on next, it can return more and more values, that’s normal.
Of course, the for..of loop over such an iterable would be endless. But we can always stop it using break.

String is iterableArrays and strings are most widely used built-in iterables.
For a string, for..of loops over its characters:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "test") {
  // triggers 4 times: once for each character
  alert( char ); // t, then e, then s, then t
}
        
      
      
      And it works correctly with surrogate pairs!

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, and then 😂
}
        
      
      
      Calling an iterator explicitlyFor deeper understanding, let’s see how to use an iterator explicitly.
We’ll iterate over a string in exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values from it “manually”:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

// does the same as
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}
        
      
      
      That is rarely needed, but gives us more control over the process than for..of. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.
Iterables and array-likesTwo official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.

Iterables are objects that implement the Symbol.iterator method, as described above.
Array-likes are objects that have indexes and length, so they look like arrays.

When we use JavaScript for practical tasks in a browser or any other environment, we may meet objects that are iterables or array-likes, or both.
For instance, strings are both iterable (for..of works on them) and array-like (they have numeric indexes and length).
But an iterable may not be array-like. And vice versa an array-like may not be iterable.
For example, the range in the example above is iterable, but not array-like, because it does not have indexed properties and length.
And here’s the object that is array-like, but not iterable:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = { // has indexes and length => array-like
  0: "Hello",
  1: "World",
  length: 2
};

// Error (no Symbol.iterator)
for (let item of arrayLike) {}
        
      
      
      Both iterables and array-likes are usually not arrays, they don’t have push, pop etc. That’s rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with range using array methods. How to achieve that?
Array.fromThere’s a universal method Array.from that takes an iterable or array-like value and makes a “real” Array from it. Then we can call array methods on it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)
        
      
      
      Array.from at the line (*) takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.
The same happens for an iterable:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)
        
      
      
      The full syntax for Array.from also allows us to provide an optional “mapping” function:

      
        
        
          Array.from(obj[, mapFn, thisArg])
        
      
      
      The optional second argument mapFn can be a function that will be applied to each element before adding it to the array, and thisArg allows us to set this for it.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          // assuming that range is taken from the example above

// square each number
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
        
      
      
      Here we use Array.from to turn a string into an array of characters:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

// splits str into array of characters
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
        
      
      
      Unlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly works with surrogate pairs.
Technically here it does the same as:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}

alert(chars);
        
      
      
      …But it is shorter.
We can even build surrogate-aware slice on it:

      
        
        
          
            
          
          
            
          
        
        
          function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// the native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)
        
      
      
      SummaryObjects that can be used in for..of are called iterable.

Technically, iterables must implement the method named Symbol.iterator.

The result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.
An iterator must have the method named next() that returns an object {done: Boolean, value: any}, here done:true denotes the end of the iteration process, otherwise the value is the next value.


The Symbol.iterator method is called automatically by for..of, but we also can do it directly.
Built-in iterables like strings or arrays, also implement Symbol.iterator.
String iterator knows about surrogate pairs.

Objects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.
If we look inside the specification – we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.
Array.from(obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTill now, we’ve learned about the following complex data structures:

Objects are used for storing keyed collections.
Arrays are used for storing ordered collections.

But that’s not enough for real life. That’s why Map and Set also exist.
MapMap is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.
Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element (the key/value pair) by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key

// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
        
      
      
      As we can see, unlike objects, keys are not converted to strings. Any type of key is possible.

            map[key] isn’t the right way to use a Map
            Although map[key] also works, e.g. we can set map[key] = 2, this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on).
So we should use map methods: set, get and so on.

Map can also use objects as keys.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };

// for every user, let's store their visits count
let visitsCountMap = new Map();

// john is the key for the map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
        
      
      
      Using objects as keys is one of the most notable and important Map features. The same does not count for Object. String as a key in Object is fine, but we can’t use another Object as a key in Object.
Let’s try:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // try to use an object

visitsCountObj[ben] = 234; // try to use ben object as the key
visitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced

// That's what got written!
alert( visitsCountObj["[object Object]"] ); // 123
        
      
      
      As visitsCountObj is an object, it converts all Object keys, such as john and ben above, to same string "[object Object]". Definitely not what we want.

            How Map compares keys
            To test keys for equivalence, Map uses the algorithm SameValueZero. It is roughly the same as strict equality ===, but the difference is that NaN is considered equal to NaN. So NaN can be used as the key as well.
This algorithm can’t be changed or customized.


            Chaining
            Every map.set call returns the map itself, so we can “chain” the calls:

      
        
        
          map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
        
      
      
      
Iteration over MapFor looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  alert(entry); // cucumber,500 (and so on)
}
        
      
      
      
            The insertion order is used
            The iteration goes in the same order as the values were inserted. Map preserves this order, unlike a regular Object.

Besides that, Map has a built-in forEach method, similar to Array:

      
        
        
          // runs the function for each (key, value) pair
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});
        
      
      
      Object.entries: Map from ObjectWhen a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization, like this:

      
        
        
          
            
          
          
            
          
        
        
          // array of [key, value] pairs
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
        
      
      
      If we have a plain object, and we’d like to create a Map from it, then we can use built-in method Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.
So we can create a map from an object like this:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
        
      
      
      Here, Object.entries returns the array of key/value pairs: [ ["name","John"], ["age", 30] ]. That’s what Map needs.
Object.fromEntries: Object from MapWe’ve just seen how to create Map from a plain object with Object.entries(obj).
There’s Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
        
      
      
      We can use Object.fromEntries to get a plain object from Map.
E.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object.
Here we go:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// done!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
        
      
      
      A call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries.
We could also make line (*) shorter:

      
        
        
          let obj = Object.fromEntries(map); // omit .entries()
        
      
      
      That’s the same, because Object.fromEntries expects an iterable object as the argument. Not necessarily an array. And the standard iteration for map returns same key/value pairs as map.entries(). So we get a plain object with same key/values as the map.
SetA Set is a special type collection – “set of values” (without keys), where each value may occur only once.
Its main methods are:

new Set([iterable]) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

The main feature is that repeated calls of set.add(value) with the same value don’t do anything. That’s the reason why each value appears in a Set only once.
For example, we have visitors coming, and we’d like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be “counted” only once.
Set is just the right thing for that:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (then Pete and Mary)
}
        
      
      
      The alternative to Set could be an array of users, and the code to check for duplicates on every insertion using arr.find. But the performance would be much worse, because this method walks through the whole array checking every element. Set is much better optimized internally for uniqueness checks.
Iteration over SetWe can loop over a set either with for..of or using forEach:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// the same with forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
        
      
      
      Note the funny thing. The callback function passed in forEach has 3 arguments: a value, then the same value valueAgain, and then the target object. Indeed, the same value appears in the arguments twice.
That’s for compatibility with Map where the callback passed forEach has three arguments. Looks a bit strange, for sure. But this may help to replace Map with Set in certain cases with ease, and vice versa.
The same methods Map has for iterators are also supported:

set.keys() – returns an iterable object for values,
set.values() – same as set.keys(), for compatibility with Map,
set.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.

SummaryMap – is a collection of keyed values.
Methods and properties:

new Map([iterable]) – creates the map, with optional iterable (e.g. array) of [key,value] pairs for initialization.
map.set(key, value) – stores the value by the key, returns the map itself.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element by the key, returns true if key existed at the moment of the call, otherwise false.
map.clear() – removes everything from the map.
map.size – returns the current element count.

The differences from a regular Object:

Any keys, objects can be keys.
Additional convenient methods, the size property.

Set – is a collection of unique values.
Methods and properties:

new Set([iterable]) – creates the set, with optional iterable (e.g. array) of values for initialization.
set.add(value) – adds a value (does nothing if value exists), returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

Iteration over Map and Set is always in the insertion order, so we can’t say that these collections are unordered, but we can’t reorder elements or directly get an element by its number.\n\nTutorialThe JavaScript languageData typesNovember 14, 2022Map and SetTill now, we’ve learned about the following complex data structures:

Objects are used for storing keyed collections.
Arrays are used for storing ordered collections.

But that’s not enough for real life. That’s why Map and Set also exist.
MapMap is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.
Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element (the key/value pair) by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key

// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
        
      
      
      As we can see, unlike objects, keys are not converted to strings. Any type of key is possible.

            map[key] isn’t the right way to use a Map
            Although map[key] also works, e.g. we can set map[key] = 2, this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on).
So we should use map methods: set, get and so on.

Map can also use objects as keys.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };

// for every user, let's store their visits count
let visitsCountMap = new Map();

// john is the key for the map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
        
      
      
      Using objects as keys is one of the most notable and important Map features. The same does not count for Object. String as a key in Object is fine, but we can’t use another Object as a key in Object.
Let’s try:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // try to use an object

visitsCountObj[ben] = 234; // try to use ben object as the key
visitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced

// That's what got written!
alert( visitsCountObj["[object Object]"] ); // 123
        
      
      
      As visitsCountObj is an object, it converts all Object keys, such as john and ben above, to same string "[object Object]". Definitely not what we want.

            How Map compares keys
            To test keys for equivalence, Map uses the algorithm SameValueZero. It is roughly the same as strict equality ===, but the difference is that NaN is considered equal to NaN. So NaN can be used as the key as well.
This algorithm can’t be changed or customized.


            Chaining
            Every map.set call returns the map itself, so we can “chain” the calls:

      
        
        
          map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
        
      
      
      
Iteration over MapFor looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  alert(entry); // cucumber,500 (and so on)
}
        
      
      
      
            The insertion order is used
            The iteration goes in the same order as the values were inserted. Map preserves this order, unlike a regular Object.

Besides that, Map has a built-in forEach method, similar to Array:

      
        
        
          // runs the function for each (key, value) pair
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});
        
      
      
      Object.entries: Map from ObjectWhen a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization, like this:

      
        
        
          
            
          
          
            
          
        
        
          // array of [key, value] pairs
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
        
      
      
      If we have a plain object, and we’d like to create a Map from it, then we can use built-in method Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.
So we can create a map from an object like this:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
        
      
      
      Here, Object.entries returns the array of key/value pairs: [ ["name","John"], ["age", 30] ]. That’s what Map needs.
Object.fromEntries: Object from MapWe’ve just seen how to create Map from a plain object with Object.entries(obj).
There’s Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
        
      
      
      We can use Object.fromEntries to get a plain object from Map.
E.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object.
Here we go:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// done!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
        
      
      
      A call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries.
We could also make line (*) shorter:

      
        
        
          let obj = Object.fromEntries(map); // omit .entries()
        
      
      
      That’s the same, because Object.fromEntries expects an iterable object as the argument. Not necessarily an array. And the standard iteration for map returns same key/value pairs as map.entries(). So we get a plain object with same key/values as the map.
SetA Set is a special type collection – “set of values” (without keys), where each value may occur only once.
Its main methods are:

new Set([iterable]) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

The main feature is that repeated calls of set.add(value) with the same value don’t do anything. That’s the reason why each value appears in a Set only once.
For example, we have visitors coming, and we’d like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be “counted” only once.
Set is just the right thing for that:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (then Pete and Mary)
}
        
      
      
      The alternative to Set could be an array of users, and the code to check for duplicates on every insertion using arr.find. But the performance would be much worse, because this method walks through the whole array checking every element. Set is much better optimized internally for uniqueness checks.
Iteration over SetWe can loop over a set either with for..of or using forEach:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// the same with forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
        
      
      
      Note the funny thing. The callback function passed in forEach has 3 arguments: a value, then the same value valueAgain, and then the target object. Indeed, the same value appears in the arguments twice.
That’s for compatibility with Map where the callback passed forEach has three arguments. Looks a bit strange, for sure. But this may help to replace Map with Set in certain cases with ease, and vice versa.
The same methods Map has for iterators are also supported:

set.keys() – returns an iterable object for values,
set.values() – same as set.keys(), for compatibility with Map,
set.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.

SummaryMap – is a collection of keyed values.
Methods and properties:

new Map([iterable]) – creates the map, with optional iterable (e.g. array) of [key,value] pairs for initialization.
map.set(key, value) – stores the value by the key, returns the map itself.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element by the key, returns true if key existed at the moment of the call, otherwise false.
map.clear() – removes everything from the map.
map.size – returns the current element count.

The differences from a regular Object:

Any keys, objects can be keys.
Additional convenient methods, the size property.

Set – is a collection of unique values.
Methods and properties:

new Set([iterable]) – creates the set, with optional iterable (e.g. array) of values for initialization.
set.add(value) – adds a value (does nothing if value exists), returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

Iteration over Map and Set is always in the insertion order, so we can’t say that these collections are unordered, but we can’t reorder elements or directly get an element by its number.
TasksFilter unique array membersimportance: 5Let arr be an array.
Create a function unique(arr) that should return an array with unique items of arr.
For instance:

      
        
        
          function unique(arr) {
  /* your code */
}

let values = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(values) ); // Hare, Krishna, :-O
        
      
      
      P.S. Here strings are used, but can be values of any type.
P.P.S. Use Set to store unique values.
Open a sandbox with tests.solution
      
        
        
          function unique(arr) {
  return Array.from(new Set(arr));
}
        
      
      
      Open the solution with tests in a sandbox.Filter anagramsimportance: 4Anagrams are words that have the same number of same letters, but in different order.
For instance:

      
        
        
          nap - pan
ear - are - era
cheaters - hectares - teachers
        
      
      
      Write a function aclean(arr) that returns an array cleaned from anagrams.
For instance:

      
        
        
          let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
        
      
      
      From every anagram group should remain only one word, no matter which one.
Open a sandbox with tests.solutionTo find all anagrams, let’s split every word to letters and sort them. When letter-sorted, all anagrams are same.
For instance:

      
        
        
          nap, pan -> anp
ear, era, are -> aer
cheaters, hectares, teachers -> aceehrst
...
        
      
      
      We’ll use the letter-sorted variants as map keys to store only one value per each key:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let map = new Map();

  for (let word of arr) {
    // split the word by letters, sort them and join back
    let sorted = word.toLowerCase().split('').sort().join(''); // (*)
    map.set(sorted, word);
  }

  return Array.from(map.values());
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Letter-sorting is done by the chain of calls in the line (*).
For convenience let’s split it into multiple lines:

      
        
        
          let sorted = word // PAN
  .toLowerCase() // pan
  .split('') // ['p','a','n']
  .sort() // ['a','n','p']
  .join(''); // anp
        
      
      
      Two different words 'PAN' and 'nap' receive the same letter-sorted form 'anp'.
The next line put the word into the map:

      
        
        
          map.set(sorted, word);
        
      
      
      If we ever meet a word the same letter-sorted form again, then it would overwrite the previous value with the same key in the map. So we’ll always have at maximum one word per letter-form.
At the end Array.from(map.values()) takes an iterable over map values (we don’t need keys in the result) and returns an array of them.
Here we could also use a plain object instead of the Map, because keys are strings.
That’s how the solution can look:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    let sorted = arr[i].toLowerCase().split("").sort().join("");
    obj[sorted] = arr[i];
  }

  return Object.values(obj);
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Open the solution with tests in a sandbox.Iterable keysimportance: 5We’d like to get an array of map.keys() in a variable and then apply array-specific methods to it, e.g. .push.
But that doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = map.keys();

// Error: keys.push is not a function
keys.push("more");
        
      
      
      Why? How can we fix the code to make keys.push work?
solutionThat’s because map.keys() returns an iterable, but not an array.
We can convert it into an array using Array.from:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = Array.from(map.keys());

keys.push("more");

alert(keys); // name, more
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nTill now, we’ve learned about the following complex data structures:

Objects are used for storing keyed collections.
Arrays are used for storing ordered collections.

But that’s not enough for real life. That’s why Map and Set also exist.
MapMap is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.
Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element (the key/value pair) by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key

// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
        
      
      
      As we can see, unlike objects, keys are not converted to strings. Any type of key is possible.

            map[key] isn’t the right way to use a Map
            Although map[key] also works, e.g. we can set map[key] = 2, this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on).
So we should use map methods: set, get and so on.

Map can also use objects as keys.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };

// for every user, let's store their visits count
let visitsCountMap = new Map();

// john is the key for the map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
        
      
      
      Using objects as keys is one of the most notable and important Map features. The same does not count for Object. String as a key in Object is fine, but we can’t use another Object as a key in Object.
Let’s try:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // try to use an object

visitsCountObj[ben] = 234; // try to use ben object as the key
visitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced

// That's what got written!
alert( visitsCountObj["[object Object]"] ); // 123
        
      
      
      As visitsCountObj is an object, it converts all Object keys, such as john and ben above, to same string "[object Object]". Definitely not what we want.

            How Map compares keys
            To test keys for equivalence, Map uses the algorithm SameValueZero. It is roughly the same as strict equality ===, but the difference is that NaN is considered equal to NaN. So NaN can be used as the key as well.
This algorithm can’t be changed or customized.


            Chaining
            Every map.set call returns the map itself, so we can “chain” the calls:

      
        
        
          map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
        
      
      
      
Iteration over MapFor looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  alert(entry); // cucumber,500 (and so on)
}
        
      
      
      
            The insertion order is used
            The iteration goes in the same order as the values were inserted. Map preserves this order, unlike a regular Object.

Besides that, Map has a built-in forEach method, similar to Array:

      
        
        
          // runs the function for each (key, value) pair
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});
        
      
      
      Object.entries: Map from ObjectWhen a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization, like this:

      
        
        
          
            
          
          
            
          
        
        
          // array of [key, value] pairs
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
        
      
      
      If we have a plain object, and we’d like to create a Map from it, then we can use built-in method Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.
So we can create a map from an object like this:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
        
      
      
      Here, Object.entries returns the array of key/value pairs: [ ["name","John"], ["age", 30] ]. That’s what Map needs.
Object.fromEntries: Object from MapWe’ve just seen how to create Map from a plain object with Object.entries(obj).
There’s Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
        
      
      
      We can use Object.fromEntries to get a plain object from Map.
E.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object.
Here we go:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// done!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
        
      
      
      A call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries.
We could also make line (*) shorter:

      
        
        
          let obj = Object.fromEntries(map); // omit .entries()
        
      
      
      That’s the same, because Object.fromEntries expects an iterable object as the argument. Not necessarily an array. And the standard iteration for map returns same key/value pairs as map.entries(). So we get a plain object with same key/values as the map.
SetA Set is a special type collection – “set of values” (without keys), where each value may occur only once.
Its main methods are:

new Set([iterable]) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

The main feature is that repeated calls of set.add(value) with the same value don’t do anything. That’s the reason why each value appears in a Set only once.
For example, we have visitors coming, and we’d like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be “counted” only once.
Set is just the right thing for that:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (then Pete and Mary)
}
        
      
      
      The alternative to Set could be an array of users, and the code to check for duplicates on every insertion using arr.find. But the performance would be much worse, because this method walks through the whole array checking every element. Set is much better optimized internally for uniqueness checks.
Iteration over SetWe can loop over a set either with for..of or using forEach:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// the same with forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
        
      
      
      Note the funny thing. The callback function passed in forEach has 3 arguments: a value, then the same value valueAgain, and then the target object. Indeed, the same value appears in the arguments twice.
That’s for compatibility with Map where the callback passed forEach has three arguments. Looks a bit strange, for sure. But this may help to replace Map with Set in certain cases with ease, and vice versa.
The same methods Map has for iterators are also supported:

set.keys() – returns an iterable object for values,
set.values() – same as set.keys(), for compatibility with Map,
set.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.

SummaryMap – is a collection of keyed values.
Methods and properties:

new Map([iterable]) – creates the map, with optional iterable (e.g. array) of [key,value] pairs for initialization.
map.set(key, value) – stores the value by the key, returns the map itself.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element by the key, returns true if key existed at the moment of the call, otherwise false.
map.clear() – removes everything from the map.
map.size – returns the current element count.

The differences from a regular Object:

Any keys, objects can be keys.
Additional convenient methods, the size property.

Set – is a collection of unique values.
Methods and properties:

new Set([iterable]) – creates the set, with optional iterable (e.g. array) of values for initialization.
set.add(value) – adds a value (does nothing if value exists), returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

Iteration over Map and Set is always in the insertion order, so we can’t say that these collections are unordered, but we can’t reorder elements or directly get an element by its number.
TasksFilter unique array membersimportance: 5Let arr be an array.
Create a function unique(arr) that should return an array with unique items of arr.
For instance:

      
        
        
          function unique(arr) {
  /* your code */
}

let values = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(values) ); // Hare, Krishna, :-O
        
      
      
      P.S. Here strings are used, but can be values of any type.
P.P.S. Use Set to store unique values.
Open a sandbox with tests.solution
      
        
        
          function unique(arr) {
  return Array.from(new Set(arr));
}
        
      
      
      Open the solution with tests in a sandbox.Filter anagramsimportance: 4Anagrams are words that have the same number of same letters, but in different order.
For instance:

      
        
        
          nap - pan
ear - are - era
cheaters - hectares - teachers
        
      
      
      Write a function aclean(arr) that returns an array cleaned from anagrams.
For instance:

      
        
        
          let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
        
      
      
      From every anagram group should remain only one word, no matter which one.
Open a sandbox with tests.solutionTo find all anagrams, let’s split every word to letters and sort them. When letter-sorted, all anagrams are same.
For instance:

      
        
        
          nap, pan -> anp
ear, era, are -> aer
cheaters, hectares, teachers -> aceehrst
...
        
      
      
      We’ll use the letter-sorted variants as map keys to store only one value per each key:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let map = new Map();

  for (let word of arr) {
    // split the word by letters, sort them and join back
    let sorted = word.toLowerCase().split('').sort().join(''); // (*)
    map.set(sorted, word);
  }

  return Array.from(map.values());
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Letter-sorting is done by the chain of calls in the line (*).
For convenience let’s split it into multiple lines:

      
        
        
          let sorted = word // PAN
  .toLowerCase() // pan
  .split('') // ['p','a','n']
  .sort() // ['a','n','p']
  .join(''); // anp
        
      
      
      Two different words 'PAN' and 'nap' receive the same letter-sorted form 'anp'.
The next line put the word into the map:

      
        
        
          map.set(sorted, word);
        
      
      
      If we ever meet a word the same letter-sorted form again, then it would overwrite the previous value with the same key in the map. So we’ll always have at maximum one word per letter-form.
At the end Array.from(map.values()) takes an iterable over map values (we don’t need keys in the result) and returns an array of them.
Here we could also use a plain object instead of the Map, because keys are strings.
That’s how the solution can look:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    let sorted = arr[i].toLowerCase().split("").sort().join("");
    obj[sorted] = arr[i];
  }

  return Object.values(obj);
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Open the solution with tests in a sandbox.Iterable keysimportance: 5We’d like to get an array of map.keys() in a variable and then apply array-specific methods to it, e.g. .push.
But that doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = map.keys();

// Error: keys.push is not a function
keys.push("more");
        
      
      
      Why? How can we fix the code to make keys.push work?
solutionThat’s because map.keys() returns an iterable, but not an array.
We can convert it into an array using Array.from:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = Array.from(map.keys());

keys.push("more");

alert(keys); // name, more\n\nTutorialThe JavaScript languageData typesNovember 14, 2022Map and SetTill now, we’ve learned about the following complex data structures:

Objects are used for storing keyed collections.
Arrays are used for storing ordered collections.

But that’s not enough for real life. That’s why Map and Set also exist.
MapMap is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.
Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element (the key/value pair) by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key

// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
        
      
      
      As we can see, unlike objects, keys are not converted to strings. Any type of key is possible.

            map[key] isn’t the right way to use a Map
            Although map[key] also works, e.g. we can set map[key] = 2, this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on).
So we should use map methods: set, get and so on.

Map can also use objects as keys.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };

// for every user, let's store their visits count
let visitsCountMap = new Map();

// john is the key for the map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
        
      
      
      Using objects as keys is one of the most notable and important Map features. The same does not count for Object. String as a key in Object is fine, but we can’t use another Object as a key in Object.
Let’s try:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // try to use an object

visitsCountObj[ben] = 234; // try to use ben object as the key
visitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced

// That's what got written!
alert( visitsCountObj["[object Object]"] ); // 123
        
      
      
      As visitsCountObj is an object, it converts all Object keys, such as john and ben above, to same string "[object Object]". Definitely not what we want.

            How Map compares keys
            To test keys for equivalence, Map uses the algorithm SameValueZero. It is roughly the same as strict equality ===, but the difference is that NaN is considered equal to NaN. So NaN can be used as the key as well.
This algorithm can’t be changed or customized.


            Chaining
            Every map.set call returns the map itself, so we can “chain” the calls:

      
        
        
          map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
        
      
      
      
Iteration over MapFor looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  alert(entry); // cucumber,500 (and so on)
}
        
      
      
      
            The insertion order is used
            The iteration goes in the same order as the values were inserted. Map preserves this order, unlike a regular Object.

Besides that, Map has a built-in forEach method, similar to Array:

      
        
        
          // runs the function for each (key, value) pair
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});
        
      
      
      Object.entries: Map from ObjectWhen a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization, like this:

      
        
        
          
            
          
          
            
          
        
        
          // array of [key, value] pairs
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
        
      
      
      If we have a plain object, and we’d like to create a Map from it, then we can use built-in method Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.
So we can create a map from an object like this:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
        
      
      
      Here, Object.entries returns the array of key/value pairs: [ ["name","John"], ["age", 30] ]. That’s what Map needs.
Object.fromEntries: Object from MapWe’ve just seen how to create Map from a plain object with Object.entries(obj).
There’s Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
        
      
      
      We can use Object.fromEntries to get a plain object from Map.
E.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object.
Here we go:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// done!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
        
      
      
      A call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries.
We could also make line (*) shorter:

      
        
        
          let obj = Object.fromEntries(map); // omit .entries()
        
      
      
      That’s the same, because Object.fromEntries expects an iterable object as the argument. Not necessarily an array. And the standard iteration for map returns same key/value pairs as map.entries(). So we get a plain object with same key/values as the map.
SetA Set is a special type collection – “set of values” (without keys), where each value may occur only once.
Its main methods are:

new Set([iterable]) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

The main feature is that repeated calls of set.add(value) with the same value don’t do anything. That’s the reason why each value appears in a Set only once.
For example, we have visitors coming, and we’d like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be “counted” only once.
Set is just the right thing for that:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (then Pete and Mary)
}
        
      
      
      The alternative to Set could be an array of users, and the code to check for duplicates on every insertion using arr.find. But the performance would be much worse, because this method walks through the whole array checking every element. Set is much better optimized internally for uniqueness checks.
Iteration over SetWe can loop over a set either with for..of or using forEach:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// the same with forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
        
      
      
      Note the funny thing. The callback function passed in forEach has 3 arguments: a value, then the same value valueAgain, and then the target object. Indeed, the same value appears in the arguments twice.
That’s for compatibility with Map where the callback passed forEach has three arguments. Looks a bit strange, for sure. But this may help to replace Map with Set in certain cases with ease, and vice versa.
The same methods Map has for iterators are also supported:

set.keys() – returns an iterable object for values,
set.values() – same as set.keys(), for compatibility with Map,
set.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.

SummaryMap – is a collection of keyed values.
Methods and properties:

new Map([iterable]) – creates the map, with optional iterable (e.g. array) of [key,value] pairs for initialization.
map.set(key, value) – stores the value by the key, returns the map itself.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the element by the key, returns true if key existed at the moment of the call, otherwise false.
map.clear() – removes everything from the map.
map.size – returns the current element count.

The differences from a regular Object:

Any keys, objects can be keys.
Additional convenient methods, the size property.

Set – is a collection of unique values.
Methods and properties:

new Set([iterable]) – creates the set, with optional iterable (e.g. array) of values for initialization.
set.add(value) – adds a value (does nothing if value exists), returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

Iteration over Map and Set is always in the insertion order, so we can’t say that these collections are unordered, but we can’t reorder elements or directly get an element by its number.
TasksFilter unique array membersimportance: 5Let arr be an array.
Create a function unique(arr) that should return an array with unique items of arr.
For instance:

      
        
        
          function unique(arr) {
  /* your code */
}

let values = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(values) ); // Hare, Krishna, :-O
        
      
      
      P.S. Here strings are used, but can be values of any type.
P.P.S. Use Set to store unique values.
Open a sandbox with tests.solution
      
        
        
          function unique(arr) {
  return Array.from(new Set(arr));
}
        
      
      
      Open the solution with tests in a sandbox.Filter anagramsimportance: 4Anagrams are words that have the same number of same letters, but in different order.
For instance:

      
        
        
          nap - pan
ear - are - era
cheaters - hectares - teachers
        
      
      
      Write a function aclean(arr) that returns an array cleaned from anagrams.
For instance:

      
        
        
          let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
        
      
      
      From every anagram group should remain only one word, no matter which one.
Open a sandbox with tests.solutionTo find all anagrams, let’s split every word to letters and sort them. When letter-sorted, all anagrams are same.
For instance:

      
        
        
          nap, pan -> anp
ear, era, are -> aer
cheaters, hectares, teachers -> aceehrst
...
        
      
      
      We’ll use the letter-sorted variants as map keys to store only one value per each key:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let map = new Map();

  for (let word of arr) {
    // split the word by letters, sort them and join back
    let sorted = word.toLowerCase().split('').sort().join(''); // (*)
    map.set(sorted, word);
  }

  return Array.from(map.values());
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Letter-sorting is done by the chain of calls in the line (*).
For convenience let’s split it into multiple lines:

      
        
        
          let sorted = word // PAN
  .toLowerCase() // pan
  .split('') // ['p','a','n']
  .sort() // ['a','n','p']
  .join(''); // anp
        
      
      
      Two different words 'PAN' and 'nap' receive the same letter-sorted form 'anp'.
The next line put the word into the map:

      
        
        
          map.set(sorted, word);
        
      
      
      If we ever meet a word the same letter-sorted form again, then it would overwrite the previous value with the same key in the map. So we’ll always have at maximum one word per letter-form.
At the end Array.from(map.values()) takes an iterable over map values (we don’t need keys in the result) and returns an array of them.
Here we could also use a plain object instead of the Map, because keys are strings.
That’s how the solution can look:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    let sorted = arr[i].toLowerCase().split("").sort().join("");
    obj[sorted] = arr[i];
  }

  return Object.values(obj);
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Open the solution with tests in a sandbox.Iterable keysimportance: 5We’d like to get an array of map.keys() in a variable and then apply array-specific methods to it, e.g. .push.
But that doesn’t work:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = map.keys();

// Error: keys.push is not a function
keys.push("more");
        
      
      
      Why? How can we fix the code to make keys.push work?
solutionThat’s because map.keys() returns an iterable, but not an array.
We can convert it into an array using Array.from:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = Array.from(map.keys());

keys.push("more");

alert(keys); // name, more
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nAs we know from the chapter Garbage collection, JavaScript engine keeps a value in memory while it is “reachable” and can potentially be used.
For instance:

      
        
        
          let john = { name: "John" };

// the object can be accessed, john is the reference to it

// overwrite the reference
john = null;

// the object will be removed from memory
        
      
      
      Usually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.
For instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.
Like this:

      
        
        
          let john = { name: "John" };

let array = [ john ];

john = null; // overwrite the reference

// the object previously referenced by john is stored inside the array
// therefore it won't be garbage-collected
// we can get it as array[0]
        
      
      
      Similar to that, if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.
For instance:

      
        
        
          let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // overwrite the reference

// john is stored inside the map,
// we can get it by using map.keys()
        
      
      
      WeakMap is fundamentally different in this aspect. It doesn’t prevent garbage-collection of key objects.
Let’s see what it means on examples.
WeakMapThe first difference between Map and WeakMap is that keys must be objects, not primitive values:

      
        
        
          
            
          
          
            
          
        
        
          let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // works fine (object key)

// can't use a string as the key
weakMap.set("test", "Whoops"); // Error, because "test" is not an object
        
      
      
      Now, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

      
        
        
          let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // overwrite the reference

// john is removed from memory!
        
      
      
      Compare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).
WeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.
WeakMap has only the following methods:

weakMap.set(key, value)
weakMap.get(key)
weakMap.delete(key)
weakMap.has(key)

Why such a limitation? That’s for technical reasons. If an object has lost all other references (like john in the code above), then it is to be garbage-collected automatically. But technically it’s not exactly specified when the cleanup happens.
The JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically, the current element count of a WeakMap is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access all keys/values are not supported.
Now, where do we need such a data structure?
Use case: additional dataThe main area of application for WeakMap is an additional data storage.
If we’re working with an object that “belongs” to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive – then WeakMap is exactly what’s needed.
We put the data to a WeakMap, using the object as the key, and when the object is garbage collected, that data will automatically disappear as well.

      
        
        
          weakMap.set(john, "secret documents");
// if john dies, secret documents will be destroyed automatically
        
      
      
      Let’s look at an example.
For instance, we have code that keeps a visit count for users. The information is stored in a map: a user object is the key and the visit count is the value. When a user leaves (its object gets garbage collected), we don’t want to store their visit count anymore.
Here’s an example of a counting function with Map:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new Map(); // map: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      And here’s another part of the code, maybe another file using it:

      
        
        
          // 📁 main.js
let john = { name: "John" };

countUser(john); // count his visits

// later john leaves us
john = null;
        
      
      
      Now, john object should be garbage collected, but remains in memory, as it’s a key in visitsCountMap.
We need to clean visitsCountMap when we remove users, otherwise it will grow in memory indefinitely. Such cleaning can become a tedious task in complex architectures.
We can avoid it by switching to WeakMap instead:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // weakmap: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      Now we don’t have to clean visitsCountMap. After john object becomes unreachable, by all means except as a key of WeakMap, it gets removed from memory, along with the information by that key from WeakMap.
Use case: cachingAnother common example is caching. We can store (“cache”) results from a function, so that future calls on the same object can reuse it.
To achieve that, we can use Map (not optimal scenario):

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new Map();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculations of the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// Now we use process() in another file:

// 📁 main.js
let obj = {/* let's say we have an object */};

let result1 = process(obj); // calculated

// ...later, from another place of the code...
let result2 = process(obj); // remembered result taken from cache

// ...later, when the object is not needed any more:
obj = null;

alert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)
        
      
      
      For multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more.
If we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new WeakMap();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculate the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* some object */};

let result1 = process(obj);
let result2 = process(obj);

// ...later, when the object is not needed any more:
obj = null;

// Can't get cache.size, as it's a WeakMap,
// but it's 0 or soon be 0
// When obj gets garbage collected, cached data will be removed as well
        
      
      
      WeakSetWeakSet behaves similarly:

It is analogous to Set, but we may only add objects to WeakSet (not primitives).
An object exists in the set while it is reachable from somewhere else.
Like Set, it supports add, has and delete, but not size, keys() and no iterations.

Being “weak”, it also serves as additional storage. But not for arbitrary data, rather for “yes/no” facts. A membership in WeakSet may mean something about the object.
For instance, we can add users to WeakSet to keep track of those who visited our site:

      
        
        
          
            
          
          
            
          
        
        
          let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John visited us
visitedSet.add(pete); // Then Pete
visitedSet.add(john); // John again

// visitedSet has 2 users now

// check if John visited?
alert(visitedSet.has(john)); // true

// check if Mary visited?
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet will be cleaned automatically
        
      
      
      The most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.
SummaryWeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.
WeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means.
Their main advantages are that they have weak reference to objects, so they can easily be removed by garbage collector.
That comes at the cost of not having support for clear, size, keys, values…
WeakMap and WeakSet are used as “secondary” data structures in addition to the “primary” object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.\n\nTutorialThe JavaScript languageData typesNovember 13, 2022WeakMap and WeakSetAs we know from the chapter Garbage collection, JavaScript engine keeps a value in memory while it is “reachable” and can potentially be used.
For instance:

      
        
        
          let john = { name: "John" };

// the object can be accessed, john is the reference to it

// overwrite the reference
john = null;

// the object will be removed from memory
        
      
      
      Usually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.
For instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.
Like this:

      
        
        
          let john = { name: "John" };

let array = [ john ];

john = null; // overwrite the reference

// the object previously referenced by john is stored inside the array
// therefore it won't be garbage-collected
// we can get it as array[0]
        
      
      
      Similar to that, if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.
For instance:

      
        
        
          let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // overwrite the reference

// john is stored inside the map,
// we can get it by using map.keys()
        
      
      
      WeakMap is fundamentally different in this aspect. It doesn’t prevent garbage-collection of key objects.
Let’s see what it means on examples.
WeakMapThe first difference between Map and WeakMap is that keys must be objects, not primitive values:

      
        
        
          
            
          
          
            
          
        
        
          let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // works fine (object key)

// can't use a string as the key
weakMap.set("test", "Whoops"); // Error, because "test" is not an object
        
      
      
      Now, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

      
        
        
          let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // overwrite the reference

// john is removed from memory!
        
      
      
      Compare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).
WeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.
WeakMap has only the following methods:

weakMap.set(key, value)
weakMap.get(key)
weakMap.delete(key)
weakMap.has(key)

Why such a limitation? That’s for technical reasons. If an object has lost all other references (like john in the code above), then it is to be garbage-collected automatically. But technically it’s not exactly specified when the cleanup happens.
The JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically, the current element count of a WeakMap is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access all keys/values are not supported.
Now, where do we need such a data structure?
Use case: additional dataThe main area of application for WeakMap is an additional data storage.
If we’re working with an object that “belongs” to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive – then WeakMap is exactly what’s needed.
We put the data to a WeakMap, using the object as the key, and when the object is garbage collected, that data will automatically disappear as well.

      
        
        
          weakMap.set(john, "secret documents");
// if john dies, secret documents will be destroyed automatically
        
      
      
      Let’s look at an example.
For instance, we have code that keeps a visit count for users. The information is stored in a map: a user object is the key and the visit count is the value. When a user leaves (its object gets garbage collected), we don’t want to store their visit count anymore.
Here’s an example of a counting function with Map:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new Map(); // map: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      And here’s another part of the code, maybe another file using it:

      
        
        
          // 📁 main.js
let john = { name: "John" };

countUser(john); // count his visits

// later john leaves us
john = null;
        
      
      
      Now, john object should be garbage collected, but remains in memory, as it’s a key in visitsCountMap.
We need to clean visitsCountMap when we remove users, otherwise it will grow in memory indefinitely. Such cleaning can become a tedious task in complex architectures.
We can avoid it by switching to WeakMap instead:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // weakmap: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      Now we don’t have to clean visitsCountMap. After john object becomes unreachable, by all means except as a key of WeakMap, it gets removed from memory, along with the information by that key from WeakMap.
Use case: cachingAnother common example is caching. We can store (“cache”) results from a function, so that future calls on the same object can reuse it.
To achieve that, we can use Map (not optimal scenario):

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new Map();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculations of the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// Now we use process() in another file:

// 📁 main.js
let obj = {/* let's say we have an object */};

let result1 = process(obj); // calculated

// ...later, from another place of the code...
let result2 = process(obj); // remembered result taken from cache

// ...later, when the object is not needed any more:
obj = null;

alert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)
        
      
      
      For multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more.
If we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new WeakMap();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculate the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* some object */};

let result1 = process(obj);
let result2 = process(obj);

// ...later, when the object is not needed any more:
obj = null;

// Can't get cache.size, as it's a WeakMap,
// but it's 0 or soon be 0
// When obj gets garbage collected, cached data will be removed as well
        
      
      
      WeakSetWeakSet behaves similarly:

It is analogous to Set, but we may only add objects to WeakSet (not primitives).
An object exists in the set while it is reachable from somewhere else.
Like Set, it supports add, has and delete, but not size, keys() and no iterations.

Being “weak”, it also serves as additional storage. But not for arbitrary data, rather for “yes/no” facts. A membership in WeakSet may mean something about the object.
For instance, we can add users to WeakSet to keep track of those who visited our site:

      
        
        
          
            
          
          
            
          
        
        
          let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John visited us
visitedSet.add(pete); // Then Pete
visitedSet.add(john); // John again

// visitedSet has 2 users now

// check if John visited?
alert(visitedSet.has(john)); // true

// check if Mary visited?
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet will be cleaned automatically
        
      
      
      The most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.
SummaryWeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.
WeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means.
Their main advantages are that they have weak reference to objects, so they can easily be removed by garbage collector.
That comes at the cost of not having support for clear, size, keys, values…
WeakMap and WeakSet are used as “secondary” data structures in addition to the “primary” object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.
TasksStore "unread" flagsimportance: 5There’s an array of messages:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      Your code can access it, but the messages are managed by someone else’s code. New messages are added, old ones are removed regularly by that code, and you don’t know the exact moments when it happens.
Now, which data structure could you use to store information about whether the message “has been read”? The structure must be well-suited to give the answer “was it read?” for the given message object.
P.S. When a message is removed from messages, it should disappear from your structure as well.
P.P.S. We shouldn’t modify message objects, add our properties to them. As they are managed by someone else’s code, that may lead to bad consequences.
solutionLet’s store read messages in WeakSet:

      
        
        
          
            
          
          
            
          
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMessages = new WeakSet();

// two messages have been read
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages has 2 elements

// ...let's read the first message again!
readMessages.add(messages[0]);
// readMessages still has 2 unique elements

// answer: was the message[0] read?
alert("Read message 0: " + readMessages.has(messages[0])); // true

messages.shift();
// now readMessages has 1 element (technically memory may be cleaned later)
        
      
      
      The WeakSet allows to store a set of messages and easily check for the existence of a message in it.
It cleans up itself automatically. The tradeoff is that we can’t iterate over it,  can’t get “all read messages” from it directly. But we can do it by iterating over all messages and filtering those that are in the set.
Another, different solution could be to add a property like message.isRead=true to a message after it’s read. As messages objects are managed by another code, that’s generally discouraged, but we can use a symbolic property to avoid conflicts.
Like this:

      
        
        
          // the symbolic property is only known to our code
let isRead = Symbol("isRead");
messages[0][isRead] = true;
        
      
      
      Now third-party code probably won’t see our extra property.
Although symbols allow to lower the probability of problems, using WeakSet is better from the architectural point of view.
Store read datesimportance: 5There’s an array of messages as in the previous task. The situation is similar.

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      The question now is: which data structure you’d suggest to store the information: “when the message was read?”.
In the previous task we only needed to store the “yes/no” fact. Now we need to store the date, and it should only remain in memory until the message is garbage collected.
P.S. Dates can be stored as objects of built-in Date class, that we’ll cover later.
solutionTo store a date, we can use WeakMap:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMap = new WeakMap();

readMap.set(messages[0], new Date(2017, 1, 1));
// Date object we'll study later
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nAs we know from the chapter Garbage collection, JavaScript engine keeps a value in memory while it is “reachable” and can potentially be used.
For instance:

      
        
        
          let john = { name: "John" };

// the object can be accessed, john is the reference to it

// overwrite the reference
john = null;

// the object will be removed from memory
        
      
      
      Usually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.
For instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.
Like this:

      
        
        
          let john = { name: "John" };

let array = [ john ];

john = null; // overwrite the reference

// the object previously referenced by john is stored inside the array
// therefore it won't be garbage-collected
// we can get it as array[0]
        
      
      
      Similar to that, if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.
For instance:

      
        
        
          let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // overwrite the reference

// john is stored inside the map,
// we can get it by using map.keys()
        
      
      
      WeakMap is fundamentally different in this aspect. It doesn’t prevent garbage-collection of key objects.
Let’s see what it means on examples.
WeakMapThe first difference between Map and WeakMap is that keys must be objects, not primitive values:

      
        
        
          
            
          
          
            
          
        
        
          let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // works fine (object key)

// can't use a string as the key
weakMap.set("test", "Whoops"); // Error, because "test" is not an object
        
      
      
      Now, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

      
        
        
          let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // overwrite the reference

// john is removed from memory!
        
      
      
      Compare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).
WeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.
WeakMap has only the following methods:

weakMap.set(key, value)
weakMap.get(key)
weakMap.delete(key)
weakMap.has(key)

Why such a limitation? That’s for technical reasons. If an object has lost all other references (like john in the code above), then it is to be garbage-collected automatically. But technically it’s not exactly specified when the cleanup happens.
The JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically, the current element count of a WeakMap is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access all keys/values are not supported.
Now, where do we need such a data structure?
Use case: additional dataThe main area of application for WeakMap is an additional data storage.
If we’re working with an object that “belongs” to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive – then WeakMap is exactly what’s needed.
We put the data to a WeakMap, using the object as the key, and when the object is garbage collected, that data will automatically disappear as well.

      
        
        
          weakMap.set(john, "secret documents");
// if john dies, secret documents will be destroyed automatically
        
      
      
      Let’s look at an example.
For instance, we have code that keeps a visit count for users. The information is stored in a map: a user object is the key and the visit count is the value. When a user leaves (its object gets garbage collected), we don’t want to store their visit count anymore.
Here’s an example of a counting function with Map:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new Map(); // map: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      And here’s another part of the code, maybe another file using it:

      
        
        
          // 📁 main.js
let john = { name: "John" };

countUser(john); // count his visits

// later john leaves us
john = null;
        
      
      
      Now, john object should be garbage collected, but remains in memory, as it’s a key in visitsCountMap.
We need to clean visitsCountMap when we remove users, otherwise it will grow in memory indefinitely. Such cleaning can become a tedious task in complex architectures.
We can avoid it by switching to WeakMap instead:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // weakmap: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      Now we don’t have to clean visitsCountMap. After john object becomes unreachable, by all means except as a key of WeakMap, it gets removed from memory, along with the information by that key from WeakMap.
Use case: cachingAnother common example is caching. We can store (“cache”) results from a function, so that future calls on the same object can reuse it.
To achieve that, we can use Map (not optimal scenario):

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new Map();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculations of the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// Now we use process() in another file:

// 📁 main.js
let obj = {/* let's say we have an object */};

let result1 = process(obj); // calculated

// ...later, from another place of the code...
let result2 = process(obj); // remembered result taken from cache

// ...later, when the object is not needed any more:
obj = null;

alert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)
        
      
      
      For multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more.
If we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new WeakMap();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculate the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* some object */};

let result1 = process(obj);
let result2 = process(obj);

// ...later, when the object is not needed any more:
obj = null;

// Can't get cache.size, as it's a WeakMap,
// but it's 0 or soon be 0
// When obj gets garbage collected, cached data will be removed as well
        
      
      
      WeakSetWeakSet behaves similarly:

It is analogous to Set, but we may only add objects to WeakSet (not primitives).
An object exists in the set while it is reachable from somewhere else.
Like Set, it supports add, has and delete, but not size, keys() and no iterations.

Being “weak”, it also serves as additional storage. But not for arbitrary data, rather for “yes/no” facts. A membership in WeakSet may mean something about the object.
For instance, we can add users to WeakSet to keep track of those who visited our site:

      
        
        
          
            
          
          
            
          
        
        
          let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John visited us
visitedSet.add(pete); // Then Pete
visitedSet.add(john); // John again

// visitedSet has 2 users now

// check if John visited?
alert(visitedSet.has(john)); // true

// check if Mary visited?
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet will be cleaned automatically
        
      
      
      The most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.
SummaryWeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.
WeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means.
Their main advantages are that they have weak reference to objects, so they can easily be removed by garbage collector.
That comes at the cost of not having support for clear, size, keys, values…
WeakMap and WeakSet are used as “secondary” data structures in addition to the “primary” object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.
TasksStore "unread" flagsimportance: 5There’s an array of messages:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      Your code can access it, but the messages are managed by someone else’s code. New messages are added, old ones are removed regularly by that code, and you don’t know the exact moments when it happens.
Now, which data structure could you use to store information about whether the message “has been read”? The structure must be well-suited to give the answer “was it read?” for the given message object.
P.S. When a message is removed from messages, it should disappear from your structure as well.
P.P.S. We shouldn’t modify message objects, add our properties to them. As they are managed by someone else’s code, that may lead to bad consequences.
solutionLet’s store read messages in WeakSet:

      
        
        
          
            
          
          
            
          
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMessages = new WeakSet();

// two messages have been read
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages has 2 elements

// ...let's read the first message again!
readMessages.add(messages[0]);
// readMessages still has 2 unique elements

// answer: was the message[0] read?
alert("Read message 0: " + readMessages.has(messages[0])); // true

messages.shift();
// now readMessages has 1 element (technically memory may be cleaned later)
        
      
      
      The WeakSet allows to store a set of messages and easily check for the existence of a message in it.
It cleans up itself automatically. The tradeoff is that we can’t iterate over it,  can’t get “all read messages” from it directly. But we can do it by iterating over all messages and filtering those that are in the set.
Another, different solution could be to add a property like message.isRead=true to a message after it’s read. As messages objects are managed by another code, that’s generally discouraged, but we can use a symbolic property to avoid conflicts.
Like this:

      
        
        
          // the symbolic property is only known to our code
let isRead = Symbol("isRead");
messages[0][isRead] = true;
        
      
      
      Now third-party code probably won’t see our extra property.
Although symbols allow to lower the probability of problems, using WeakSet is better from the architectural point of view.
Store read datesimportance: 5There’s an array of messages as in the previous task. The situation is similar.

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      The question now is: which data structure you’d suggest to store the information: “when the message was read?”.
In the previous task we only needed to store the “yes/no” fact. Now we need to store the date, and it should only remain in memory until the message is garbage collected.
P.S. Dates can be stored as objects of built-in Date class, that we’ll cover later.
solutionTo store a date, we can use WeakMap:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMap = new WeakMap();

readMap.set(messages[0], new Date(2017, 1, 1));
// Date object we'll study later\n\nTutorialThe JavaScript languageData typesNovember 13, 2022WeakMap and WeakSetAs we know from the chapter Garbage collection, JavaScript engine keeps a value in memory while it is “reachable” and can potentially be used.
For instance:

      
        
        
          let john = { name: "John" };

// the object can be accessed, john is the reference to it

// overwrite the reference
john = null;

// the object will be removed from memory
        
      
      
      Usually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.
For instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.
Like this:

      
        
        
          let john = { name: "John" };

let array = [ john ];

john = null; // overwrite the reference

// the object previously referenced by john is stored inside the array
// therefore it won't be garbage-collected
// we can get it as array[0]
        
      
      
      Similar to that, if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.
For instance:

      
        
        
          let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // overwrite the reference

// john is stored inside the map,
// we can get it by using map.keys()
        
      
      
      WeakMap is fundamentally different in this aspect. It doesn’t prevent garbage-collection of key objects.
Let’s see what it means on examples.
WeakMapThe first difference between Map and WeakMap is that keys must be objects, not primitive values:

      
        
        
          
            
          
          
            
          
        
        
          let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // works fine (object key)

// can't use a string as the key
weakMap.set("test", "Whoops"); // Error, because "test" is not an object
        
      
      
      Now, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

      
        
        
          let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // overwrite the reference

// john is removed from memory!
        
      
      
      Compare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).
WeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.
WeakMap has only the following methods:

weakMap.set(key, value)
weakMap.get(key)
weakMap.delete(key)
weakMap.has(key)

Why such a limitation? That’s for technical reasons. If an object has lost all other references (like john in the code above), then it is to be garbage-collected automatically. But technically it’s not exactly specified when the cleanup happens.
The JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically, the current element count of a WeakMap is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access all keys/values are not supported.
Now, where do we need such a data structure?
Use case: additional dataThe main area of application for WeakMap is an additional data storage.
If we’re working with an object that “belongs” to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive – then WeakMap is exactly what’s needed.
We put the data to a WeakMap, using the object as the key, and when the object is garbage collected, that data will automatically disappear as well.

      
        
        
          weakMap.set(john, "secret documents");
// if john dies, secret documents will be destroyed automatically
        
      
      
      Let’s look at an example.
For instance, we have code that keeps a visit count for users. The information is stored in a map: a user object is the key and the visit count is the value. When a user leaves (its object gets garbage collected), we don’t want to store their visit count anymore.
Here’s an example of a counting function with Map:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new Map(); // map: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      And here’s another part of the code, maybe another file using it:

      
        
        
          // 📁 main.js
let john = { name: "John" };

countUser(john); // count his visits

// later john leaves us
john = null;
        
      
      
      Now, john object should be garbage collected, but remains in memory, as it’s a key in visitsCountMap.
We need to clean visitsCountMap when we remove users, otherwise it will grow in memory indefinitely. Such cleaning can become a tedious task in complex architectures.
We can avoid it by switching to WeakMap instead:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // weakmap: user => visits count

// increase the visits count
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      Now we don’t have to clean visitsCountMap. After john object becomes unreachable, by all means except as a key of WeakMap, it gets removed from memory, along with the information by that key from WeakMap.
Use case: cachingAnother common example is caching. We can store (“cache”) results from a function, so that future calls on the same object can reuse it.
To achieve that, we can use Map (not optimal scenario):

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new Map();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculations of the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// Now we use process() in another file:

// 📁 main.js
let obj = {/* let's say we have an object */};

let result1 = process(obj); // calculated

// ...later, from another place of the code...
let result2 = process(obj); // remembered result taken from cache

// ...later, when the object is not needed any more:
obj = null;

alert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)
        
      
      
      For multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more.
If we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new WeakMap();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculate the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* some object */};

let result1 = process(obj);
let result2 = process(obj);

// ...later, when the object is not needed any more:
obj = null;

// Can't get cache.size, as it's a WeakMap,
// but it's 0 or soon be 0
// When obj gets garbage collected, cached data will be removed as well
        
      
      
      WeakSetWeakSet behaves similarly:

It is analogous to Set, but we may only add objects to WeakSet (not primitives).
An object exists in the set while it is reachable from somewhere else.
Like Set, it supports add, has and delete, but not size, keys() and no iterations.

Being “weak”, it also serves as additional storage. But not for arbitrary data, rather for “yes/no” facts. A membership in WeakSet may mean something about the object.
For instance, we can add users to WeakSet to keep track of those who visited our site:

      
        
        
          
            
          
          
            
          
        
        
          let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John visited us
visitedSet.add(pete); // Then Pete
visitedSet.add(john); // John again

// visitedSet has 2 users now

// check if John visited?
alert(visitedSet.has(john)); // true

// check if Mary visited?
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet will be cleaned automatically
        
      
      
      The most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.
SummaryWeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.
WeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means.
Their main advantages are that they have weak reference to objects, so they can easily be removed by garbage collector.
That comes at the cost of not having support for clear, size, keys, values…
WeakMap and WeakSet are used as “secondary” data structures in addition to the “primary” object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.
TasksStore "unread" flagsimportance: 5There’s an array of messages:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      Your code can access it, but the messages are managed by someone else’s code. New messages are added, old ones are removed regularly by that code, and you don’t know the exact moments when it happens.
Now, which data structure could you use to store information about whether the message “has been read”? The structure must be well-suited to give the answer “was it read?” for the given message object.
P.S. When a message is removed from messages, it should disappear from your structure as well.
P.P.S. We shouldn’t modify message objects, add our properties to them. As they are managed by someone else’s code, that may lead to bad consequences.
solutionLet’s store read messages in WeakSet:

      
        
        
          
            
          
          
            
          
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMessages = new WeakSet();

// two messages have been read
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages has 2 elements

// ...let's read the first message again!
readMessages.add(messages[0]);
// readMessages still has 2 unique elements

// answer: was the message[0] read?
alert("Read message 0: " + readMessages.has(messages[0])); // true

messages.shift();
// now readMessages has 1 element (technically memory may be cleaned later)
        
      
      
      The WeakSet allows to store a set of messages and easily check for the existence of a message in it.
It cleans up itself automatically. The tradeoff is that we can’t iterate over it,  can’t get “all read messages” from it directly. But we can do it by iterating over all messages and filtering those that are in the set.
Another, different solution could be to add a property like message.isRead=true to a message after it’s read. As messages objects are managed by another code, that’s generally discouraged, but we can use a symbolic property to avoid conflicts.
Like this:

      
        
        
          // the symbolic property is only known to our code
let isRead = Symbol("isRead");
messages[0][isRead] = true;
        
      
      
      Now third-party code probably won’t see our extra property.
Although symbols allow to lower the probability of problems, using WeakSet is better from the architectural point of view.
Store read datesimportance: 5There’s an array of messages as in the previous task. The situation is similar.

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      The question now is: which data structure you’d suggest to store the information: “when the message was read?”.
In the previous task we only needed to store the “yes/no” fact. Now we need to store the date, and it should only remain in memory until the message is garbage collected.
P.S. Dates can be stored as objects of built-in Date class, that we’ll cover later.
solutionTo store a date, we can use WeakMap:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMap = new WeakMap();

readMap.set(messages[0], new Date(2017, 1, 1));
// Date object we'll study later
        
      
      
      Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nLet’s step away from the individual data structures and talk about the iterations over them.
In the previous chapter we saw methods map.keys(), map.values(), map.entries().
These methods are generic, there is a common agreement to use them for data structures. If we ever create a data structure of our own, we should implement them too.
They are supported for:

Map
Set
Array

Plain objects also support similar methods, but the syntax is a bit different.
Object.keys, values, entriesFor plain objects, the following methods are available:

Object.keys(obj) – returns an array of keys.
Object.values(obj) – returns an array of values.
Object.entries(obj) – returns an array of [key, value] pairs.

Please note the distinctions (compared to map for example):




Map
Object




Call syntax
map.keys()
Object.keys(obj), but not obj.keys()


Returns
iterable
“real” Array



The first difference is that we have to call Object.keys(obj), and not obj.keys().
Why so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like data that implements its own data.values() method. And we still can call Object.values(data) on it.
The second difference is that Object.* methods return “real” array objects, not just an iterable. That’s mainly for historical reasons.
For instance:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]

Here’s an example of using Object.values to loop over property values:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over values
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
        
      
      
      
            Object.keys/values/entries ignore symbolic properties
            Just like a for..in loop, these methods ignore properties that use Symbol(...) as keys.
Usually that’s convenient. But if we want symbolic keys too, then there’s a separate method Object.getOwnPropertySymbols that returns an array of only symbolic keys. Also, there exist a method Reflect.ownKeys(obj) that returns all keys.

Transforming objectsObjects lack many methods that exist for arrays, e.g. map, filter and others.
If we’d like to apply them, then we can use Object.entries followed by Object.fromEntries:

Use Object.entries(obj) to get an array of key/value pairs from obj.
Use array methods on that array, e.g. map, to transform these key/value pairs.
Use Object.fromEntries(array) on the resulting array to turn it back into an object.

For example, we have an object with prices, and would like to double them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // convert prices to array, map each key/value pair into another pair
  // and then fromEntries gives back the object
  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
);

alert(doublePrices.meat); // 8
        
      
      
      It may look difficult at first sight, but becomes easy to understand after you use it once or twice. We can make powerful chains of transforms this way.\n\nTutorialThe JavaScript languageData typesJune 27, 2021Object.keys, values, entriesLet’s step away from the individual data structures and talk about the iterations over them.
In the previous chapter we saw methods map.keys(), map.values(), map.entries().
These methods are generic, there is a common agreement to use them for data structures. If we ever create a data structure of our own, we should implement them too.
They are supported for:

Map
Set
Array

Plain objects also support similar methods, but the syntax is a bit different.
Object.keys, values, entriesFor plain objects, the following methods are available:

Object.keys(obj) – returns an array of keys.
Object.values(obj) – returns an array of values.
Object.entries(obj) – returns an array of [key, value] pairs.

Please note the distinctions (compared to map for example):




Map
Object




Call syntax
map.keys()
Object.keys(obj), but not obj.keys()


Returns
iterable
“real” Array



The first difference is that we have to call Object.keys(obj), and not obj.keys().
Why so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like data that implements its own data.values() method. And we still can call Object.values(data) on it.
The second difference is that Object.* methods return “real” array objects, not just an iterable. That’s mainly for historical reasons.
For instance:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]

Here’s an example of using Object.values to loop over property values:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over values
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
        
      
      
      
            Object.keys/values/entries ignore symbolic properties
            Just like a for..in loop, these methods ignore properties that use Symbol(...) as keys.
Usually that’s convenient. But if we want symbolic keys too, then there’s a separate method Object.getOwnPropertySymbols that returns an array of only symbolic keys. Also, there exist a method Reflect.ownKeys(obj) that returns all keys.

Transforming objectsObjects lack many methods that exist for arrays, e.g. map, filter and others.
If we’d like to apply them, then we can use Object.entries followed by Object.fromEntries:

Use Object.entries(obj) to get an array of key/value pairs from obj.
Use array methods on that array, e.g. map, to transform these key/value pairs.
Use Object.fromEntries(array) on the resulting array to turn it back into an object.

For example, we have an object with prices, and would like to double them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // convert prices to array, map each key/value pair into another pair
  // and then fromEntries gives back the object
  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
);

alert(doublePrices.meat); // 8
        
      
      
      It may look difficult at first sight, but becomes easy to understand after you use it once or twice. We can make powerful chains of transforms this way.
TasksSum the propertiesimportance: 5There is a salaries object with arbitrary number of salaries.
Write the function sumSalaries(salaries) that returns the sum of all salaries using Object.values and the for..of loop.
If salaries is empty, then the result must be 0.
For instance:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function sumSalaries(salaries) {

  let sum = 0;
  for (let salary of Object.values(salaries)) {
    sum += salary;
  }

  return sum; // 650
}

let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Or, optionally, we could also get the sum using Object.values and reduce:

      
        
        
          // reduce loops over array of salaries,
// adding them up
// and returns the result
function sumSalaries(salaries) {
  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650
}
        
      
      
      Open the solution with tests in a sandbox.Count propertiesimportance: 5Write a function count(obj) that returns the number of properties in the object:

      
        
        
          let user = {
  name: 'John',
  age: 30
};

alert( count(user) ); // 2
        
      
      
      Try to make the code as short as possible.
P.S. Ignore symbolic properties, count only “regular” ones.
Open a sandbox with tests.solution
      
        
        
          function count(obj) {
  return Object.keys(obj).length;
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nLet’s step away from the individual data structures and talk about the iterations over them.
In the previous chapter we saw methods map.keys(), map.values(), map.entries().
These methods are generic, there is a common agreement to use them for data structures. If we ever create a data structure of our own, we should implement them too.
They are supported for:

Map
Set
Array

Plain objects also support similar methods, but the syntax is a bit different.
Object.keys, values, entriesFor plain objects, the following methods are available:

Object.keys(obj) – returns an array of keys.
Object.values(obj) – returns an array of values.
Object.entries(obj) – returns an array of [key, value] pairs.

Please note the distinctions (compared to map for example):




Map
Object




Call syntax
map.keys()
Object.keys(obj), but not obj.keys()


Returns
iterable
“real” Array



The first difference is that we have to call Object.keys(obj), and not obj.keys().
Why so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like data that implements its own data.values() method. And we still can call Object.values(data) on it.
The second difference is that Object.* methods return “real” array objects, not just an iterable. That’s mainly for historical reasons.
For instance:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]

Here’s an example of using Object.values to loop over property values:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over values
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
        
      
      
      
            Object.keys/values/entries ignore symbolic properties
            Just like a for..in loop, these methods ignore properties that use Symbol(...) as keys.
Usually that’s convenient. But if we want symbolic keys too, then there’s a separate method Object.getOwnPropertySymbols that returns an array of only symbolic keys. Also, there exist a method Reflect.ownKeys(obj) that returns all keys.

Transforming objectsObjects lack many methods that exist for arrays, e.g. map, filter and others.
If we’d like to apply them, then we can use Object.entries followed by Object.fromEntries:

Use Object.entries(obj) to get an array of key/value pairs from obj.
Use array methods on that array, e.g. map, to transform these key/value pairs.
Use Object.fromEntries(array) on the resulting array to turn it back into an object.

For example, we have an object with prices, and would like to double them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // convert prices to array, map each key/value pair into another pair
  // and then fromEntries gives back the object
  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
);

alert(doublePrices.meat); // 8
        
      
      
      It may look difficult at first sight, but becomes easy to understand after you use it once or twice. We can make powerful chains of transforms this way.
TasksSum the propertiesimportance: 5There is a salaries object with arbitrary number of salaries.
Write the function sumSalaries(salaries) that returns the sum of all salaries using Object.values and the for..of loop.
If salaries is empty, then the result must be 0.
For instance:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function sumSalaries(salaries) {

  let sum = 0;
  for (let salary of Object.values(salaries)) {
    sum += salary;
  }

  return sum; // 650
}

let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Or, optionally, we could also get the sum using Object.values and reduce:

      
        
        
          // reduce loops over array of salaries,
// adding them up
// and returns the result
function sumSalaries(salaries) {
  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650
}
        
      
      
      Open the solution with tests in a sandbox.Count propertiesimportance: 5Write a function count(obj) that returns the number of properties in the object:

      
        
        
          let user = {
  name: 'John',
  age: 30
};

alert( count(user) ); // 2
        
      
      
      Try to make the code as short as possible.
P.S. Ignore symbolic properties, count only “regular” ones.
Open a sandbox with tests.solution
      
        
        
          function count(obj) {
  return Object.keys(obj).length;
}
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageData typesJune 27, 2021Object.keys, values, entriesLet’s step away from the individual data structures and talk about the iterations over them.
In the previous chapter we saw methods map.keys(), map.values(), map.entries().
These methods are generic, there is a common agreement to use them for data structures. If we ever create a data structure of our own, we should implement them too.
They are supported for:

Map
Set
Array

Plain objects also support similar methods, but the syntax is a bit different.
Object.keys, values, entriesFor plain objects, the following methods are available:

Object.keys(obj) – returns an array of keys.
Object.values(obj) – returns an array of values.
Object.entries(obj) – returns an array of [key, value] pairs.

Please note the distinctions (compared to map for example):




Map
Object




Call syntax
map.keys()
Object.keys(obj), but not obj.keys()


Returns
iterable
“real” Array



The first difference is that we have to call Object.keys(obj), and not obj.keys().
Why so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like data that implements its own data.values() method. And we still can call Object.values(data) on it.
The second difference is that Object.* methods return “real” array objects, not just an iterable. That’s mainly for historical reasons.
For instance:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]

Here’s an example of using Object.values to loop over property values:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over values
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
        
      
      
      
            Object.keys/values/entries ignore symbolic properties
            Just like a for..in loop, these methods ignore properties that use Symbol(...) as keys.
Usually that’s convenient. But if we want symbolic keys too, then there’s a separate method Object.getOwnPropertySymbols that returns an array of only symbolic keys. Also, there exist a method Reflect.ownKeys(obj) that returns all keys.

Transforming objectsObjects lack many methods that exist for arrays, e.g. map, filter and others.
If we’d like to apply them, then we can use Object.entries followed by Object.fromEntries:

Use Object.entries(obj) to get an array of key/value pairs from obj.
Use array methods on that array, e.g. map, to transform these key/value pairs.
Use Object.fromEntries(array) on the resulting array to turn it back into an object.

For example, we have an object with prices, and would like to double them:

      
        
        
          
            
          
          
            
          
        
        
          let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // convert prices to array, map each key/value pair into another pair
  // and then fromEntries gives back the object
  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])
);

alert(doublePrices.meat); // 8
        
      
      
      It may look difficult at first sight, but becomes easy to understand after you use it once or twice. We can make powerful chains of transforms this way.
TasksSum the propertiesimportance: 5There is a salaries object with arbitrary number of salaries.
Write the function sumSalaries(salaries) that returns the sum of all salaries using Object.values and the for..of loop.
If salaries is empty, then the result must be 0.
For instance:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Open a sandbox with tests.solution
      
        
        
          
            
          
          
            
          
        
        
          function sumSalaries(salaries) {

  let sum = 0;
  for (let salary of Object.values(salaries)) {
    sum += salary;
  }

  return sum; // 650
}

let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Or, optionally, we could also get the sum using Object.values and reduce:

      
        
        
          // reduce loops over array of salaries,
// adding them up
// and returns the result
function sumSalaries(salaries) {
  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650
}
        
      
      
      Open the solution with tests in a sandbox.Count propertiesimportance: 5Write a function count(obj) that returns the number of properties in the object:

      
        
        
          let user = {
  name: 'John',
  age: 30
};

alert( count(user) ); // 2
        
      
      
      Try to make the code as short as possible.
P.S. Ignore symbolic properties, count only “regular” ones.
Open a sandbox with tests.solution
      
        
        
          function count(obj) {
  return Object.keys(obj).length;
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nThe two most used data structures in JavaScript are Object and Array.

Objects allow us to create a single entity that stores data items by key.
Arrays allow us to gather data items into an ordered list.

However, when we pass these to a function, we may not need all of it. The function might only require certain elements or properties.
Destructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.
Destructuring also works well with complex functions that have a lot of parameters, default values, and so on. Soon we’ll see that.
Array destructuringHere’s an example of how an array is destructured into variables:

      
        
        
          // we have an array with a name and surname
let arr = ["John", "Smith"]

// destructuring assignment
// sets firstName = arr[0]
// and surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // John
alert(surname);  // Smith
        
      
      
      Now we can work with variables instead of array members.
It looks great when combined with split or other array-returning methods:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = "John Smith".split(' ');
alert(firstName); // John
alert(surname);  // Smith
        
      
      
      As you can see, the syntax is simple. There are several peculiar details though. Let’s see more examples to understand it better.

            “Destructuring” does not mean “destructive”.
            It’s called “destructuring assignment,” because it “destructurizes” by copying items into variables. However, the array itself is not modified.
It’s just a shorter way to write:

      
        
        
          // let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
        
      
      
      

            Ignore elements using commas
            Unwanted elements of the array can also be thrown away via an extra comma:

      
        
        
          
            
          
          
            
          
        
        
          // second element is not needed
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
        
      
      
      In the code above, the second element of the array is skipped, the third one is assigned to title, and the rest of the array items are also skipped (as there are no variables for them).


            Works with any iterable on the right-side
            …Actually, we can use it with any iterable, not only arrays:

      
        
        
          let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
        
      
      
      That works, because internally a destructuring assignment works by iterating over the right value. It’s a kind of syntax sugar for calling for..of over the value to the right of = and assigning the values.


            Assign to anything at the left-side
            We can use any “assignables” on the left side.
For instance, an object property:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
[user.name, user.surname] = "John Smith".split(' ');

alert(user.name); // John
alert(user.surname); // Smith
        
      
      
      

            Looping with .entries()
            In the previous chapter, we saw the Object.entries(obj) method.
We can use it with destructuring to loop over the keys-and-values of an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over the keys-and-values
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      The similar code for a Map is simpler, as it’s iterable:

      
        
        
          
            
          
          
            
          
        
        
          let user = new Map();
user.set("name", "John");
user.set("age", "30");

// Map iterates as [key, value] pairs, very convenient for destructuring
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      

            Swap variables trick
            There’s a well-known trick for swapping values of two variables using a destructuring assignment:

      
        
        
          
            
          
          
            
          
        
        
          let guest = "Jane";
let admin = "Pete";

// Let's swap the values: make guest=Pete, admin=Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)
        
      
      
      Here we create a temporary array of two variables and immediately destructure it in swapped order.
We can swap more than two variables this way.

The rest ‘…’Usually, if the array is longer than the list at the left, the “extra” items are omitted.
For example, here only two items are taken, and the rest is just ignored:

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
// Further items aren't assigned anywhere
        
      
      
      If we’d like also to gather all that follows – we can add one more parameter that gets “the rest” using three dots "...":

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest is an array of items, starting from the 3rd one
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
        
      
      
      The value of rest is the array of the remaining array elements.
We can use any other variable name in place of rest, just make sure it has three dots before it and goes last in the destructuring assignment.

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// now titles = ["Consul", "of the Roman Republic"]
        
      
      
      Default valuesIf the array is shorter than the list of variables on the left, there will be no errors. Absent values are considered undefined:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
        
      
      
      If we want a “default” value to replace the missing one, we can provide it using =:

      
        
        
          
            
          
          
            
          
        
        
          // default values
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // Anonymous (default used)
        
      
      
      Default values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.
For instance, here we use the prompt function for two defaults:

      
        
        
          
            
          
          
            
          
        
        
          // runs only prompt for surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // whatever prompt gets
        
      
      
      Please note: the prompt will run only for the missing value (surname).
Object destructuringThe destructuring assignment also works with objects.
The basic syntax is:

      
        
        
          let {var1, var2} = {var1:…, var2:…}
        
      
      
      We should have an existing object on the right side, that we want to split into variables. The left side contains an object-like “pattern” for corresponding properties. In the simplest case, that’s a list of variable names in {...}.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Properties options.title, options.width and options.height are assigned to the corresponding variables.
The order does not matter. This works too:

      
        
        
          // changed the order in let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
        
      
      
      The pattern on the left side may be more complex and specify the mapping between properties and variables.
If we want to assign a property to a variable with another name, for instance, make options.width go into the variable named w, then we can set the variable name using a colon:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      The colon shows “what : goes where”. In the example above the property width goes to w, property height goes to h, and title is assigned to the same name.
For potentially missing properties we can set default values using "=", like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Just like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.
In the code below prompt asks for width, but not for title:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (whatever the result of prompt is)
        
      
      
      We also can combine both the colon and equality:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      If we have a complex object with many properties, we can extract only what we need:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// only extract title as a variable
let { title } = options;

alert(title); // Menu
        
      
      
      The rest pattern “…”What if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?
We can use the rest pattern, just like we did with arrays. It’s not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.
It looks like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = property named title
// rest = object with the rest of properties
let {title, ...rest} = options;

// now title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
        
      
      
      
            Gotcha if there’s no let
            In the examples above variables were declared right in the assignment: let {…} = {…}. Of course, we could use existing variables too, without let. But there’s a catch.
This won’t work:

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// error in this line
{title, width, height} = {title: "Menu", width: 200, height: 100};
        
      
      
      The problem is that JavaScript treats {...} in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements, like this:

      
        
        
          
            
          
          
            
          
        
        
          {
  // a code block
  let message = "Hello";
  // ...
  alert( message );
}
        
      
      
      So here JavaScript assumes that we have a code block, that’s why there’s an error. We want destructuring instead.
To show JavaScript that it’s not a code block, we can wrap the expression in parentheses (...):

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// okay now
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
        
      
      
      
Nested destructuringIf an object or an array contains other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions.
In the code below options has another object in the property size and an array in the property items. The pattern on the left side of the assignment has the same structure to extract values from them:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
        
      
      
      All properties of options object except extra which is absent in the left part, are assigned to corresponding variables:

      
      
        
      
      Finally, we have width, height, item1, item2 and title from the default value.
Note that there are no variables for size and items, as we take their content instead.
Smart function parametersThere are times when a function has many parameters, most of which are optional. That’s especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, an item list and so on.
Here’s a bad way to write such a function:

      
        
        
          function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
        
      
      
      In real-life, the problem is how to remember the order of arguments. Usually, IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.
Like this?

      
        
        
          // undefined where default values are fine
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
        
      
      
      That’s ugly. And becomes unreadable when we deal with more parameters.
Destructuring comes to the rescue!
We can pass parameters as an object, and the function immediately destructurizes them into variables:

      
        
        
          
            
          
          
            
          
        
        
          // we pass object to function
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...and it immediately expands it to variables
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – taken from options,
  // width, height – defaults used
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
        
      
      
      We can also use more complex destructuring with nested objects and colon mappings:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width goes to w
  height: h = 200, // height goes to h
  items: [item1, item2] // items first element goes to item1, second to item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
        
      
      
      The full syntax is the same as for a destructuring assignment:

      
        
        
          function({
  incomingProperty: varName = defaultValue
  ...
})
        
      
      
      Then, for an object of parameters, there will be a variable varName for the property incomingProperty, with defaultValue by default.
Please note that such destructuring assumes that showMenu() does have an argument. If we want all values by default, then we should specify an empty object:

      
        
        
          showMenu({}); // ok, all values are default

showMenu(); // this would give an error
        
      
      
      We can fix this by making {} the default value for the whole object of parameters:

      
        
        
          
            
          
          
            
          
        
        
          function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
        
      
      
      In the code above, the whole arguments object is {} by default, so there’s always something to destructurize.
Summary

Destructuring assignment allows for instantly mapping an object or array onto many variables.


The full object syntax:

      
        
        
          let {prop : varName = defaultValue, ...rest} = object
        
      
      
      This means that property prop should go into the variable varName and, if no such property exists, then the default value should be used.
Object properties that have no mapping are copied to the rest object.


The full array syntax:

      
        
        
          let [item1 = defaultValue, item2, ...rest] = array
        
      
      
      The first item goes to item1; the second goes into item2, and all the rest makes the array rest.


It’s possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one.\n\nTutorialThe JavaScript languageData typesJanuary 27, 2024Destructuring assignmentThe two most used data structures in JavaScript are Object and Array.

Objects allow us to create a single entity that stores data items by key.
Arrays allow us to gather data items into an ordered list.

However, when we pass these to a function, we may not need all of it. The function might only require certain elements or properties.
Destructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.
Destructuring also works well with complex functions that have a lot of parameters, default values, and so on. Soon we’ll see that.
Array destructuringHere’s an example of how an array is destructured into variables:

      
        
        
          // we have an array with a name and surname
let arr = ["John", "Smith"]

// destructuring assignment
// sets firstName = arr[0]
// and surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // John
alert(surname);  // Smith
        
      
      
      Now we can work with variables instead of array members.
It looks great when combined with split or other array-returning methods:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = "John Smith".split(' ');
alert(firstName); // John
alert(surname);  // Smith
        
      
      
      As you can see, the syntax is simple. There are several peculiar details though. Let’s see more examples to understand it better.

            “Destructuring” does not mean “destructive”.
            It’s called “destructuring assignment,” because it “destructurizes” by copying items into variables. However, the array itself is not modified.
It’s just a shorter way to write:

      
        
        
          // let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
        
      
      
      

            Ignore elements using commas
            Unwanted elements of the array can also be thrown away via an extra comma:

      
        
        
          
            
          
          
            
          
        
        
          // second element is not needed
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
        
      
      
      In the code above, the second element of the array is skipped, the third one is assigned to title, and the rest of the array items are also skipped (as there are no variables for them).


            Works with any iterable on the right-side
            …Actually, we can use it with any iterable, not only arrays:

      
        
        
          let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
        
      
      
      That works, because internally a destructuring assignment works by iterating over the right value. It’s a kind of syntax sugar for calling for..of over the value to the right of = and assigning the values.


            Assign to anything at the left-side
            We can use any “assignables” on the left side.
For instance, an object property:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
[user.name, user.surname] = "John Smith".split(' ');

alert(user.name); // John
alert(user.surname); // Smith
        
      
      
      

            Looping with .entries()
            In the previous chapter, we saw the Object.entries(obj) method.
We can use it with destructuring to loop over the keys-and-values of an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over the keys-and-values
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      The similar code for a Map is simpler, as it’s iterable:

      
        
        
          
            
          
          
            
          
        
        
          let user = new Map();
user.set("name", "John");
user.set("age", "30");

// Map iterates as [key, value] pairs, very convenient for destructuring
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      

            Swap variables trick
            There’s a well-known trick for swapping values of two variables using a destructuring assignment:

      
        
        
          
            
          
          
            
          
        
        
          let guest = "Jane";
let admin = "Pete";

// Let's swap the values: make guest=Pete, admin=Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)
        
      
      
      Here we create a temporary array of two variables and immediately destructure it in swapped order.
We can swap more than two variables this way.

The rest ‘…’Usually, if the array is longer than the list at the left, the “extra” items are omitted.
For example, here only two items are taken, and the rest is just ignored:

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
// Further items aren't assigned anywhere
        
      
      
      If we’d like also to gather all that follows – we can add one more parameter that gets “the rest” using three dots "...":

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest is an array of items, starting from the 3rd one
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
        
      
      
      The value of rest is the array of the remaining array elements.
We can use any other variable name in place of rest, just make sure it has three dots before it and goes last in the destructuring assignment.

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// now titles = ["Consul", "of the Roman Republic"]
        
      
      
      Default valuesIf the array is shorter than the list of variables on the left, there will be no errors. Absent values are considered undefined:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
        
      
      
      If we want a “default” value to replace the missing one, we can provide it using =:

      
        
        
          
            
          
          
            
          
        
        
          // default values
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // Anonymous (default used)
        
      
      
      Default values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.
For instance, here we use the prompt function for two defaults:

      
        
        
          
            
          
          
            
          
        
        
          // runs only prompt for surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // whatever prompt gets
        
      
      
      Please note: the prompt will run only for the missing value (surname).
Object destructuringThe destructuring assignment also works with objects.
The basic syntax is:

      
        
        
          let {var1, var2} = {var1:…, var2:…}
        
      
      
      We should have an existing object on the right side, that we want to split into variables. The left side contains an object-like “pattern” for corresponding properties. In the simplest case, that’s a list of variable names in {...}.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Properties options.title, options.width and options.height are assigned to the corresponding variables.
The order does not matter. This works too:

      
        
        
          // changed the order in let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
        
      
      
      The pattern on the left side may be more complex and specify the mapping between properties and variables.
If we want to assign a property to a variable with another name, for instance, make options.width go into the variable named w, then we can set the variable name using a colon:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      The colon shows “what : goes where”. In the example above the property width goes to w, property height goes to h, and title is assigned to the same name.
For potentially missing properties we can set default values using "=", like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Just like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.
In the code below prompt asks for width, but not for title:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (whatever the result of prompt is)
        
      
      
      We also can combine both the colon and equality:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      If we have a complex object with many properties, we can extract only what we need:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// only extract title as a variable
let { title } = options;

alert(title); // Menu
        
      
      
      The rest pattern “…”What if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?
We can use the rest pattern, just like we did with arrays. It’s not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.
It looks like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = property named title
// rest = object with the rest of properties
let {title, ...rest} = options;

// now title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
        
      
      
      
            Gotcha if there’s no let
            In the examples above variables were declared right in the assignment: let {…} = {…}. Of course, we could use existing variables too, without let. But there’s a catch.
This won’t work:

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// error in this line
{title, width, height} = {title: "Menu", width: 200, height: 100};
        
      
      
      The problem is that JavaScript treats {...} in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements, like this:

      
        
        
          
            
          
          
            
          
        
        
          {
  // a code block
  let message = "Hello";
  // ...
  alert( message );
}
        
      
      
      So here JavaScript assumes that we have a code block, that’s why there’s an error. We want destructuring instead.
To show JavaScript that it’s not a code block, we can wrap the expression in parentheses (...):

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// okay now
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
        
      
      
      
Nested destructuringIf an object or an array contains other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions.
In the code below options has another object in the property size and an array in the property items. The pattern on the left side of the assignment has the same structure to extract values from them:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
        
      
      
      All properties of options object except extra which is absent in the left part, are assigned to corresponding variables:

      
      
        
      
      Finally, we have width, height, item1, item2 and title from the default value.
Note that there are no variables for size and items, as we take their content instead.
Smart function parametersThere are times when a function has many parameters, most of which are optional. That’s especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, an item list and so on.
Here’s a bad way to write such a function:

      
        
        
          function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
        
      
      
      In real-life, the problem is how to remember the order of arguments. Usually, IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.
Like this?

      
        
        
          // undefined where default values are fine
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
        
      
      
      That’s ugly. And becomes unreadable when we deal with more parameters.
Destructuring comes to the rescue!
We can pass parameters as an object, and the function immediately destructurizes them into variables:

      
        
        
          
            
          
          
            
          
        
        
          // we pass object to function
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...and it immediately expands it to variables
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – taken from options,
  // width, height – defaults used
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
        
      
      
      We can also use more complex destructuring with nested objects and colon mappings:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width goes to w
  height: h = 200, // height goes to h
  items: [item1, item2] // items first element goes to item1, second to item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
        
      
      
      The full syntax is the same as for a destructuring assignment:

      
        
        
          function({
  incomingProperty: varName = defaultValue
  ...
})
        
      
      
      Then, for an object of parameters, there will be a variable varName for the property incomingProperty, with defaultValue by default.
Please note that such destructuring assumes that showMenu() does have an argument. If we want all values by default, then we should specify an empty object:

      
        
        
          showMenu({}); // ok, all values are default

showMenu(); // this would give an error
        
      
      
      We can fix this by making {} the default value for the whole object of parameters:

      
        
        
          
            
          
          
            
          
        
        
          function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
        
      
      
      In the code above, the whole arguments object is {} by default, so there’s always something to destructurize.
Summary

Destructuring assignment allows for instantly mapping an object or array onto many variables.


The full object syntax:

      
        
        
          let {prop : varName = defaultValue, ...rest} = object
        
      
      
      This means that property prop should go into the variable varName and, if no such property exists, then the default value should be used.
Object properties that have no mapping are copied to the rest object.


The full array syntax:

      
        
        
          let [item1 = defaultValue, item2, ...rest] = array
        
      
      
      The first item goes to item1; the second goes into item2, and all the rest makes the array rest.


It’s possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one.


TasksDestructuring assignmentimportance: 5We have an object:

      
        
        
          let user = {
  name: "John",
  years: 30
};
        
      
      
      Write the destructuring assignment that reads:

name property into the variable name.
years property into the variable age.
isAdmin property into the variable isAdmin (false, if no such property)

Here’s an example of the values after your assignment:

      
        
        
          let user = { name: "John", years: 30 };

// your code to the left side:
// ... = user

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  years: 30
};

let {name, years: age, isAdmin = false} = user;

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      The maximal salaryimportance: 5There is a salaries object:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};
        
      
      
      Create the function topSalary(salaries) that returns the name of the top-paid person.

If salaries is empty, it should return null.
If there are multiple top-paid persons, return any of them.

P.S. Use Object.entries and destructuring to iterate over key/value pairs.
Open a sandbox with tests.solution
      
        
        
          function topSalary(salaries) {

  let maxSalary = 0;
  let maxName = null;

  for(const [name, salary] of Object.entries(salaries)) {
    if (maxSalary < salary) {
      maxSalary = salary;
      maxName = name;
    }
  }

  return maxName;
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nThe two most used data structures in JavaScript are Object and Array.

Objects allow us to create a single entity that stores data items by key.
Arrays allow us to gather data items into an ordered list.

However, when we pass these to a function, we may not need all of it. The function might only require certain elements or properties.
Destructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.
Destructuring also works well with complex functions that have a lot of parameters, default values, and so on. Soon we’ll see that.
Array destructuringHere’s an example of how an array is destructured into variables:

      
        
        
          // we have an array with a name and surname
let arr = ["John", "Smith"]

// destructuring assignment
// sets firstName = arr[0]
// and surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // John
alert(surname);  // Smith
        
      
      
      Now we can work with variables instead of array members.
It looks great when combined with split or other array-returning methods:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = "John Smith".split(' ');
alert(firstName); // John
alert(surname);  // Smith
        
      
      
      As you can see, the syntax is simple. There are several peculiar details though. Let’s see more examples to understand it better.

            “Destructuring” does not mean “destructive”.
            It’s called “destructuring assignment,” because it “destructurizes” by copying items into variables. However, the array itself is not modified.
It’s just a shorter way to write:

      
        
        
          // let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
        
      
      
      

            Ignore elements using commas
            Unwanted elements of the array can also be thrown away via an extra comma:

      
        
        
          
            
          
          
            
          
        
        
          // second element is not needed
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
        
      
      
      In the code above, the second element of the array is skipped, the third one is assigned to title, and the rest of the array items are also skipped (as there are no variables for them).


            Works with any iterable on the right-side
            …Actually, we can use it with any iterable, not only arrays:

      
        
        
          let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
        
      
      
      That works, because internally a destructuring assignment works by iterating over the right value. It’s a kind of syntax sugar for calling for..of over the value to the right of = and assigning the values.


            Assign to anything at the left-side
            We can use any “assignables” on the left side.
For instance, an object property:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
[user.name, user.surname] = "John Smith".split(' ');

alert(user.name); // John
alert(user.surname); // Smith
        
      
      
      

            Looping with .entries()
            In the previous chapter, we saw the Object.entries(obj) method.
We can use it with destructuring to loop over the keys-and-values of an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over the keys-and-values
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      The similar code for a Map is simpler, as it’s iterable:

      
        
        
          
            
          
          
            
          
        
        
          let user = new Map();
user.set("name", "John");
user.set("age", "30");

// Map iterates as [key, value] pairs, very convenient for destructuring
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      

            Swap variables trick
            There’s a well-known trick for swapping values of two variables using a destructuring assignment:

      
        
        
          
            
          
          
            
          
        
        
          let guest = "Jane";
let admin = "Pete";

// Let's swap the values: make guest=Pete, admin=Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)
        
      
      
      Here we create a temporary array of two variables and immediately destructure it in swapped order.
We can swap more than two variables this way.

The rest ‘…’Usually, if the array is longer than the list at the left, the “extra” items are omitted.
For example, here only two items are taken, and the rest is just ignored:

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
// Further items aren't assigned anywhere
        
      
      
      If we’d like also to gather all that follows – we can add one more parameter that gets “the rest” using three dots "...":

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest is an array of items, starting from the 3rd one
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
        
      
      
      The value of rest is the array of the remaining array elements.
We can use any other variable name in place of rest, just make sure it has three dots before it and goes last in the destructuring assignment.

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// now titles = ["Consul", "of the Roman Republic"]
        
      
      
      Default valuesIf the array is shorter than the list of variables on the left, there will be no errors. Absent values are considered undefined:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
        
      
      
      If we want a “default” value to replace the missing one, we can provide it using =:

      
        
        
          
            
          
          
            
          
        
        
          // default values
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // Anonymous (default used)
        
      
      
      Default values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.
For instance, here we use the prompt function for two defaults:

      
        
        
          
            
          
          
            
          
        
        
          // runs only prompt for surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // whatever prompt gets
        
      
      
      Please note: the prompt will run only for the missing value (surname).
Object destructuringThe destructuring assignment also works with objects.
The basic syntax is:

      
        
        
          let {var1, var2} = {var1:…, var2:…}
        
      
      
      We should have an existing object on the right side, that we want to split into variables. The left side contains an object-like “pattern” for corresponding properties. In the simplest case, that’s a list of variable names in {...}.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Properties options.title, options.width and options.height are assigned to the corresponding variables.
The order does not matter. This works too:

      
        
        
          // changed the order in let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
        
      
      
      The pattern on the left side may be more complex and specify the mapping between properties and variables.
If we want to assign a property to a variable with another name, for instance, make options.width go into the variable named w, then we can set the variable name using a colon:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      The colon shows “what : goes where”. In the example above the property width goes to w, property height goes to h, and title is assigned to the same name.
For potentially missing properties we can set default values using "=", like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Just like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.
In the code below prompt asks for width, but not for title:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (whatever the result of prompt is)
        
      
      
      We also can combine both the colon and equality:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      If we have a complex object with many properties, we can extract only what we need:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// only extract title as a variable
let { title } = options;

alert(title); // Menu
        
      
      
      The rest pattern “…”What if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?
We can use the rest pattern, just like we did with arrays. It’s not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.
It looks like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = property named title
// rest = object with the rest of properties
let {title, ...rest} = options;

// now title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
        
      
      
      
            Gotcha if there’s no let
            In the examples above variables were declared right in the assignment: let {…} = {…}. Of course, we could use existing variables too, without let. But there’s a catch.
This won’t work:

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// error in this line
{title, width, height} = {title: "Menu", width: 200, height: 100};
        
      
      
      The problem is that JavaScript treats {...} in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements, like this:

      
        
        
          
            
          
          
            
          
        
        
          {
  // a code block
  let message = "Hello";
  // ...
  alert( message );
}
        
      
      
      So here JavaScript assumes that we have a code block, that’s why there’s an error. We want destructuring instead.
To show JavaScript that it’s not a code block, we can wrap the expression in parentheses (...):

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// okay now
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
        
      
      
      
Nested destructuringIf an object or an array contains other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions.
In the code below options has another object in the property size and an array in the property items. The pattern on the left side of the assignment has the same structure to extract values from them:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
        
      
      
      All properties of options object except extra which is absent in the left part, are assigned to corresponding variables:

      
      
        
      
      Finally, we have width, height, item1, item2 and title from the default value.
Note that there are no variables for size and items, as we take their content instead.
Smart function parametersThere are times when a function has many parameters, most of which are optional. That’s especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, an item list and so on.
Here’s a bad way to write such a function:

      
        
        
          function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
        
      
      
      In real-life, the problem is how to remember the order of arguments. Usually, IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.
Like this?

      
        
        
          // undefined where default values are fine
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
        
      
      
      That’s ugly. And becomes unreadable when we deal with more parameters.
Destructuring comes to the rescue!
We can pass parameters as an object, and the function immediately destructurizes them into variables:

      
        
        
          
            
          
          
            
          
        
        
          // we pass object to function
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...and it immediately expands it to variables
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – taken from options,
  // width, height – defaults used
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
        
      
      
      We can also use more complex destructuring with nested objects and colon mappings:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width goes to w
  height: h = 200, // height goes to h
  items: [item1, item2] // items first element goes to item1, second to item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
        
      
      
      The full syntax is the same as for a destructuring assignment:

      
        
        
          function({
  incomingProperty: varName = defaultValue
  ...
})
        
      
      
      Then, for an object of parameters, there will be a variable varName for the property incomingProperty, with defaultValue by default.
Please note that such destructuring assumes that showMenu() does have an argument. If we want all values by default, then we should specify an empty object:

      
        
        
          showMenu({}); // ok, all values are default

showMenu(); // this would give an error
        
      
      
      We can fix this by making {} the default value for the whole object of parameters:

      
        
        
          
            
          
          
            
          
        
        
          function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
        
      
      
      In the code above, the whole arguments object is {} by default, so there’s always something to destructurize.
Summary

Destructuring assignment allows for instantly mapping an object or array onto many variables.


The full object syntax:

      
        
        
          let {prop : varName = defaultValue, ...rest} = object
        
      
      
      This means that property prop should go into the variable varName and, if no such property exists, then the default value should be used.
Object properties that have no mapping are copied to the rest object.


The full array syntax:

      
        
        
          let [item1 = defaultValue, item2, ...rest] = array
        
      
      
      The first item goes to item1; the second goes into item2, and all the rest makes the array rest.


It’s possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one.


TasksDestructuring assignmentimportance: 5We have an object:

      
        
        
          let user = {
  name: "John",
  years: 30
};
        
      
      
      Write the destructuring assignment that reads:

name property into the variable name.
years property into the variable age.
isAdmin property into the variable isAdmin (false, if no such property)

Here’s an example of the values after your assignment:

      
        
        
          let user = { name: "John", years: 30 };

// your code to the left side:
// ... = user

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  years: 30
};

let {name, years: age, isAdmin = false} = user;

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      The maximal salaryimportance: 5There is a salaries object:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};
        
      
      
      Create the function topSalary(salaries) that returns the name of the top-paid person.

If salaries is empty, it should return null.
If there are multiple top-paid persons, return any of them.

P.S. Use Object.entries and destructuring to iterate over key/value pairs.
Open a sandbox with tests.solution
      
        
        
          function topSalary(salaries) {

  let maxSalary = 0;
  let maxName = null;

  for(const [name, salary] of Object.entries(salaries)) {
    if (maxSalary < salary) {
      maxSalary = salary;
      maxName = name;
    }
  }

  return maxName;
}
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageData typesJanuary 27, 2024Destructuring assignmentThe two most used data structures in JavaScript are Object and Array.

Objects allow us to create a single entity that stores data items by key.
Arrays allow us to gather data items into an ordered list.

However, when we pass these to a function, we may not need all of it. The function might only require certain elements or properties.
Destructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.
Destructuring also works well with complex functions that have a lot of parameters, default values, and so on. Soon we’ll see that.
Array destructuringHere’s an example of how an array is destructured into variables:

      
        
        
          // we have an array with a name and surname
let arr = ["John", "Smith"]

// destructuring assignment
// sets firstName = arr[0]
// and surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // John
alert(surname);  // Smith
        
      
      
      Now we can work with variables instead of array members.
It looks great when combined with split or other array-returning methods:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = "John Smith".split(' ');
alert(firstName); // John
alert(surname);  // Smith
        
      
      
      As you can see, the syntax is simple. There are several peculiar details though. Let’s see more examples to understand it better.

            “Destructuring” does not mean “destructive”.
            It’s called “destructuring assignment,” because it “destructurizes” by copying items into variables. However, the array itself is not modified.
It’s just a shorter way to write:

      
        
        
          // let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
        
      
      
      

            Ignore elements using commas
            Unwanted elements of the array can also be thrown away via an extra comma:

      
        
        
          
            
          
          
            
          
        
        
          // second element is not needed
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
        
      
      
      In the code above, the second element of the array is skipped, the third one is assigned to title, and the rest of the array items are also skipped (as there are no variables for them).


            Works with any iterable on the right-side
            …Actually, we can use it with any iterable, not only arrays:

      
        
        
          let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
        
      
      
      That works, because internally a destructuring assignment works by iterating over the right value. It’s a kind of syntax sugar for calling for..of over the value to the right of = and assigning the values.


            Assign to anything at the left-side
            We can use any “assignables” on the left side.
For instance, an object property:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
[user.name, user.surname] = "John Smith".split(' ');

alert(user.name); // John
alert(user.surname); // Smith
        
      
      
      

            Looping with .entries()
            In the previous chapter, we saw the Object.entries(obj) method.
We can use it with destructuring to loop over the keys-and-values of an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// loop over the keys-and-values
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      The similar code for a Map is simpler, as it’s iterable:

      
        
        
          
            
          
          
            
          
        
        
          let user = new Map();
user.set("name", "John");
user.set("age", "30");

// Map iterates as [key, value] pairs, very convenient for destructuring
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
        
      
      
      

            Swap variables trick
            There’s a well-known trick for swapping values of two variables using a destructuring assignment:

      
        
        
          
            
          
          
            
          
        
        
          let guest = "Jane";
let admin = "Pete";

// Let's swap the values: make guest=Pete, admin=Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)
        
      
      
      Here we create a temporary array of two variables and immediately destructure it in swapped order.
We can swap more than two variables this way.

The rest ‘…’Usually, if the array is longer than the list at the left, the “extra” items are omitted.
For example, here only two items are taken, and the rest is just ignored:

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
// Further items aren't assigned anywhere
        
      
      
      If we’d like also to gather all that follows – we can add one more parameter that gets “the rest” using three dots "...":

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// rest is an array of items, starting from the 3rd one
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
        
      
      
      The value of rest is the array of the remaining array elements.
We can use any other variable name in place of rest, just make sure it has three dots before it and goes last in the destructuring assignment.

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// now titles = ["Consul", "of the Roman Republic"]
        
      
      
      Default valuesIf the array is shorter than the list of variables on the left, there will be no errors. Absent values are considered undefined:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
        
      
      
      If we want a “default” value to replace the missing one, we can provide it using =:

      
        
        
          
            
          
          
            
          
        
        
          // default values
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // Anonymous (default used)
        
      
      
      Default values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.
For instance, here we use the prompt function for two defaults:

      
        
        
          
            
          
          
            
          
        
        
          // runs only prompt for surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (from array)
alert(surname); // whatever prompt gets
        
      
      
      Please note: the prompt will run only for the missing value (surname).
Object destructuringThe destructuring assignment also works with objects.
The basic syntax is:

      
        
        
          let {var1, var2} = {var1:…, var2:…}
        
      
      
      We should have an existing object on the right side, that we want to split into variables. The left side contains an object-like “pattern” for corresponding properties. In the simplest case, that’s a list of variable names in {...}.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Properties options.title, options.width and options.height are assigned to the corresponding variables.
The order does not matter. This works too:

      
        
        
          // changed the order in let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
        
      
      
      The pattern on the left side may be more complex and specify the mapping between properties and variables.
If we want to assign a property to a variable with another name, for instance, make options.width go into the variable named w, then we can set the variable name using a colon:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      The colon shows “what : goes where”. In the example above the property width goes to w, property height goes to h, and title is assigned to the same name.
For potentially missing properties we can set default values using "=", like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Just like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.
In the code below prompt asks for width, but not for title:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (whatever the result of prompt is)
        
      
      
      We also can combine both the colon and equality:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      If we have a complex object with many properties, we can extract only what we need:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// only extract title as a variable
let { title } = options;

alert(title); // Menu
        
      
      
      The rest pattern “…”What if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?
We can use the rest pattern, just like we did with arrays. It’s not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.
It looks like this:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = property named title
// rest = object with the rest of properties
let {title, ...rest} = options;

// now title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
        
      
      
      
            Gotcha if there’s no let
            In the examples above variables were declared right in the assignment: let {…} = {…}. Of course, we could use existing variables too, without let. But there’s a catch.
This won’t work:

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// error in this line
{title, width, height} = {title: "Menu", width: 200, height: 100};
        
      
      
      The problem is that JavaScript treats {...} in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements, like this:

      
        
        
          
            
          
          
            
          
        
        
          {
  // a code block
  let message = "Hello";
  // ...
  alert( message );
}
        
      
      
      So here JavaScript assumes that we have a code block, that’s why there’s an error. We want destructuring instead.
To show JavaScript that it’s not a code block, we can wrap the expression in parentheses (...):

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// okay now
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
        
      
      
      
Nested destructuringIf an object or an array contains other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions.
In the code below options has another object in the property size and an array in the property items. The pattern on the left side of the assignment has the same structure to extract values from them:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
        
      
      
      All properties of options object except extra which is absent in the left part, are assigned to corresponding variables:

      
      
        
      
      Finally, we have width, height, item1, item2 and title from the default value.
Note that there are no variables for size and items, as we take their content instead.
Smart function parametersThere are times when a function has many parameters, most of which are optional. That’s especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, an item list and so on.
Here’s a bad way to write such a function:

      
        
        
          function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
        
      
      
      In real-life, the problem is how to remember the order of arguments. Usually, IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.
Like this?

      
        
        
          // undefined where default values are fine
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
        
      
      
      That’s ugly. And becomes unreadable when we deal with more parameters.
Destructuring comes to the rescue!
We can pass parameters as an object, and the function immediately destructurizes them into variables:

      
        
        
          
            
          
          
            
          
        
        
          // we pass object to function
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...and it immediately expands it to variables
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – taken from options,
  // width, height – defaults used
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
        
      
      
      We can also use more complex destructuring with nested objects and colon mappings:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width goes to w
  height: h = 200, // height goes to h
  items: [item1, item2] // items first element goes to item1, second to item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
        
      
      
      The full syntax is the same as for a destructuring assignment:

      
        
        
          function({
  incomingProperty: varName = defaultValue
  ...
})
        
      
      
      Then, for an object of parameters, there will be a variable varName for the property incomingProperty, with defaultValue by default.
Please note that such destructuring assumes that showMenu() does have an argument. If we want all values by default, then we should specify an empty object:

      
        
        
          showMenu({}); // ok, all values are default

showMenu(); // this would give an error
        
      
      
      We can fix this by making {} the default value for the whole object of parameters:

      
        
        
          
            
          
          
            
          
        
        
          function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
        
      
      
      In the code above, the whole arguments object is {} by default, so there’s always something to destructurize.
Summary

Destructuring assignment allows for instantly mapping an object or array onto many variables.


The full object syntax:

      
        
        
          let {prop : varName = defaultValue, ...rest} = object
        
      
      
      This means that property prop should go into the variable varName and, if no such property exists, then the default value should be used.
Object properties that have no mapping are copied to the rest object.


The full array syntax:

      
        
        
          let [item1 = defaultValue, item2, ...rest] = array
        
      
      
      The first item goes to item1; the second goes into item2, and all the rest makes the array rest.


It’s possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one.


TasksDestructuring assignmentimportance: 5We have an object:

      
        
        
          let user = {
  name: "John",
  years: 30
};
        
      
      
      Write the destructuring assignment that reads:

name property into the variable name.
years property into the variable age.
isAdmin property into the variable isAdmin (false, if no such property)

Here’s an example of the values after your assignment:

      
        
        
          let user = { name: "John", years: 30 };

// your code to the left side:
// ... = user

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  years: 30
};

let {name, years: age, isAdmin = false} = user;

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      The maximal salaryimportance: 5There is a salaries object:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};
        
      
      
      Create the function topSalary(salaries) that returns the name of the top-paid person.

If salaries is empty, it should return null.
If there are multiple top-paid persons, return any of them.

P.S. Use Object.entries and destructuring to iterate over key/value pairs.
Open a sandbox with tests.solution
      
        
        
          function topSalary(salaries) {

  let maxSalary = 0;
  let maxName = null;

  for(const [name, salary] of Object.entries(salaries)) {
    if (maxSalary < salary) {
      maxSalary = salary;
      maxName = name;
    }
  }

  return maxName;
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nLet’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
For instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.
CreationTo create a new Date object call new Date() with one of the following arguments:

new Date()

Without arguments – create a Date object for the current date and time:

      
        
        
          
            
          
          
            
          
        
        
          let now = new Date();
alert( now ); // shows current date/time
        
      
      
      
new Date(milliseconds)

Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

      
        
        
          
            
          
          
            
          
        
        
          // 0 means 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// now add 24 hours, get 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
        
      
      
      An integer number representing the number of milliseconds that has passed since the beginning of 1970 is called a timestamp.
It’s a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).
Dates before 01.01.1970 have negative timestamps, e.g.:

      
        
        
          
            
          
          
            
          
        
        
          // 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
        
      
      
      
new Date(datestring)

If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date("2017-01-26");
alert(date);
// The time is not set, so it's assumed to be midnight GMT and
// is adjusted according to the timezone the code is run in
// So the result could be
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// or
// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
        
      
      
      
new Date(year, month, date, hours, minutes, seconds, ms)

Create the date with the given components in the local time zone. Only the first two arguments are obligatory.

The year should have 4 digits. For compatibility, 2 digits are also accepted and considered 19xx, e.g. 98 is the same as 1998 here, but always using 4 digits is strongly encouraged.
The month count starts with 0 (Jan), up to 11 (Dec).
The date parameter is actually the day of month, if absent then 1 is assumed.
If hours/minutes/seconds/ms is absent, they are assumed to be equal 0.

For instance:

      
        
        
          new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default
        
      
      
      The maximal precision is 1 ms (1/1000 sec):

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
        
      
      
      

Access date componentsThere are methods to access the year, month and so on from the Date object:

getFullYear()
Get the year (4 digits)
getMonth()
Get the month, from 0 to 11.
getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.


            Not getYear(), but getFullYear()
            Many JavaScript engines implement a non-standard method getYear(). This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is getFullYear() for the year.

Additionally, we can get a day of week:

getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.

All the methods above return the components relative to the local time zone.
There are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Just insert the "UTC" right after "get".
If your local time zone is shifted relative to UTC, then the code below shows different hours:

      
        
        
          
            
          
          
            
          
        
        
          // current date
let date = new Date();

// the hour in your current time zone
alert( date.getHours() );

// the hour in UTC+0 time zone (London time without daylight savings)
alert( date.getUTCHours() );
        
      
      
      Besides the given methods, there are two special ones that do not have a UTC-variant:

getTime()

Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.

getTimezoneOffset()

Returns the difference between UTC and the local time zone, in minutes:

      
        
        
          
            
          
          
            
          
        
        
          // if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );
        
      
      
      

Setting date componentsThe following methods allow to set date/time components:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)

Every one of them except setTime() has a UTC-variant, for instance: setUTCHours().
As we can see, some methods can set multiple components at once, for example setHours. The components that are not mentioned are not modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let today = new Date();

today.setHours(0);
alert(today); // still today, but the hour is changed to 0

today.setHours(0, 0, 0, 0);
alert(today); // still today, now 00:00:00 sharp.
        
      
      
      AutocorrectionThe autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!
        
      
      
      Out-of-range date components are distributed automatically.
Let’s say we need to increase the date “28 Feb 2016” by 2 days. It may be “2 Mar” or “1 Mar” in case of a leap-year. We don’t need to think about it. Just add 2 days. The Date object will do the rest:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
        
      
      
      That feature is often used to get the date after the given period of time. For instance, let’s get the date for “70 seconds after now”:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // shows the correct date
        
      
      
      We can also set zero or even negative values. For example:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // set day 1 of month
alert( date );

date.setDate(0); // min day is 1, so the last day of the previous month is assumed
alert( date ); // 31 Dec 2015
        
      
      
      Date to number, date diffWhen a Date object is converted to number, it becomes the timestamp same as date.getTime():

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()
        
      
      
      The important side effect: dates can be subtracted, the result is their difference in ms.
That can be used for time measurements:

      
        
        
          
            
          
          
            
          
        
        
          let start = new Date(); // start measuring time

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // end measuring time

alert( `The loop took ${end - start} ms` );
        
      
      
      Date.now()If we only want to measure time, we don’t need the Date object.
There’s a special method Date.now() that returns the current timestamp.
It is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.
It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.
So this is probably better:

      
        
        
          
            
          
          
            
          
        
        
          let start = Date.now(); // milliseconds count from 1 Jan 1970

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // done

alert( `The loop took ${end - start} ms` ); // subtract numbers, not dates
        
      
      
      BenchmarkingIf we want a reliable benchmark of CPU-hungry function, we should be careful.
For instance, let’s measure two functions that calculate the difference between two dates: which one is faster?
Such performance measurements are often called “benchmarks”.

      
        
        
          // we have date1 and date2, which function faster returns their difference in ms?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// or
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
        
      
      
      These two do exactly the same thing, but one of them uses an explicit date.getTime() to get the date in ms, and the other one relies on a date-to-number transform. Their result is always the same.
So, which one is faster?
The first idea may be to run them many times in a row and measure the time difference. For our case, functions are very simple, so we have to do it at least 100000 times.
Let’s measure:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );
        
      
      
      Wow! Using getTime() is so much faster! That’s because there’s no type conversion, it is much easier for engines to optimize.
Okay, we have something. But that’s not a good benchmark yet.
Imagine that at the time of running bench(diffSubtract) CPU was doing something in parallel, and it was taking resources. And by the time of running bench(diffGetTime) that work has finished.
A pretty real scenario for a modern multi-process OS.
As a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results.
For more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.
For example, like this:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );
        
      
      
      Modern JavaScript engines start applying advanced optimizations only to “hot code” that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a heat-up run:

      
        
        
          // added for "heating up" prior to the main loop
bench(diffSubtract);
bench(diffGetTime);

// now benchmark
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
        
      
      
      
            Be careful doing microbenchmarking
            Modern JavaScript engines perform many optimizations. They may tweak results of “artificial tests” compared to “normal usage”, especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then please study how the JavaScript engine works. And then you probably won’t need microbenchmarks at all.
The great pack of articles about V8 can be found at https://mrale.ph.

Date.parse from a stringThe method Date.parse(str) can read a date from a string.
The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:

YYYY-MM-DD – is the date: year-month-day.
The character "T" is used as the delimiter.
HH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.
The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0.

Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.
The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (timestamp)
        
      
      
      We can instantly create a new Date object from the timestamp:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
        
      
      
      Summary
Date and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.
Months are counted from zero (yes, January is a zero month).
Days of week in getDay() are also counted from zero (that’s Sunday).
Date auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.
Dates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.
Use Date.now() to get the current timestamp fast.

Note that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.
Sometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has performance.now() that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):

      
        
        
          
            
          
          
            
          
        
        
          alert(`Loading started ${performance.now()}ms ago`);
// Something like: "Loading started 34731.26000000001ms ago"
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, only the first 3 are correct
        
      
      
      Node.js has microtime module and other ways. Technically, almost any device and environment allows to get more precision, it’s just not in Date.\n\nTutorialThe JavaScript languageData typesOctober 14, 2022Date and timeLet’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
For instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.
CreationTo create a new Date object call new Date() with one of the following arguments:

new Date()

Without arguments – create a Date object for the current date and time:

      
        
        
          
            
          
          
            
          
        
        
          let now = new Date();
alert( now ); // shows current date/time
        
      
      
      
new Date(milliseconds)

Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

      
        
        
          
            
          
          
            
          
        
        
          // 0 means 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// now add 24 hours, get 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
        
      
      
      An integer number representing the number of milliseconds that has passed since the beginning of 1970 is called a timestamp.
It’s a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).
Dates before 01.01.1970 have negative timestamps, e.g.:

      
        
        
          
            
          
          
            
          
        
        
          // 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
        
      
      
      
new Date(datestring)

If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date("2017-01-26");
alert(date);
// The time is not set, so it's assumed to be midnight GMT and
// is adjusted according to the timezone the code is run in
// So the result could be
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// or
// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
        
      
      
      
new Date(year, month, date, hours, minutes, seconds, ms)

Create the date with the given components in the local time zone. Only the first two arguments are obligatory.

The year should have 4 digits. For compatibility, 2 digits are also accepted and considered 19xx, e.g. 98 is the same as 1998 here, but always using 4 digits is strongly encouraged.
The month count starts with 0 (Jan), up to 11 (Dec).
The date parameter is actually the day of month, if absent then 1 is assumed.
If hours/minutes/seconds/ms is absent, they are assumed to be equal 0.

For instance:

      
        
        
          new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default
        
      
      
      The maximal precision is 1 ms (1/1000 sec):

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
        
      
      
      

Access date componentsThere are methods to access the year, month and so on from the Date object:

getFullYear()
Get the year (4 digits)
getMonth()
Get the month, from 0 to 11.
getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.


            Not getYear(), but getFullYear()
            Many JavaScript engines implement a non-standard method getYear(). This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is getFullYear() for the year.

Additionally, we can get a day of week:

getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.

All the methods above return the components relative to the local time zone.
There are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Just insert the "UTC" right after "get".
If your local time zone is shifted relative to UTC, then the code below shows different hours:

      
        
        
          
            
          
          
            
          
        
        
          // current date
let date = new Date();

// the hour in your current time zone
alert( date.getHours() );

// the hour in UTC+0 time zone (London time without daylight savings)
alert( date.getUTCHours() );
        
      
      
      Besides the given methods, there are two special ones that do not have a UTC-variant:

getTime()

Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.

getTimezoneOffset()

Returns the difference between UTC and the local time zone, in minutes:

      
        
        
          
            
          
          
            
          
        
        
          // if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );
        
      
      
      

Setting date componentsThe following methods allow to set date/time components:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)

Every one of them except setTime() has a UTC-variant, for instance: setUTCHours().
As we can see, some methods can set multiple components at once, for example setHours. The components that are not mentioned are not modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let today = new Date();

today.setHours(0);
alert(today); // still today, but the hour is changed to 0

today.setHours(0, 0, 0, 0);
alert(today); // still today, now 00:00:00 sharp.
        
      
      
      AutocorrectionThe autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!
        
      
      
      Out-of-range date components are distributed automatically.
Let’s say we need to increase the date “28 Feb 2016” by 2 days. It may be “2 Mar” or “1 Mar” in case of a leap-year. We don’t need to think about it. Just add 2 days. The Date object will do the rest:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
        
      
      
      That feature is often used to get the date after the given period of time. For instance, let’s get the date for “70 seconds after now”:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // shows the correct date
        
      
      
      We can also set zero or even negative values. For example:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // set day 1 of month
alert( date );

date.setDate(0); // min day is 1, so the last day of the previous month is assumed
alert( date ); // 31 Dec 2015
        
      
      
      Date to number, date diffWhen a Date object is converted to number, it becomes the timestamp same as date.getTime():

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()
        
      
      
      The important side effect: dates can be subtracted, the result is their difference in ms.
That can be used for time measurements:

      
        
        
          
            
          
          
            
          
        
        
          let start = new Date(); // start measuring time

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // end measuring time

alert( `The loop took ${end - start} ms` );
        
      
      
      Date.now()If we only want to measure time, we don’t need the Date object.
There’s a special method Date.now() that returns the current timestamp.
It is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.
It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.
So this is probably better:

      
        
        
          
            
          
          
            
          
        
        
          let start = Date.now(); // milliseconds count from 1 Jan 1970

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // done

alert( `The loop took ${end - start} ms` ); // subtract numbers, not dates
        
      
      
      BenchmarkingIf we want a reliable benchmark of CPU-hungry function, we should be careful.
For instance, let’s measure two functions that calculate the difference between two dates: which one is faster?
Such performance measurements are often called “benchmarks”.

      
        
        
          // we have date1 and date2, which function faster returns their difference in ms?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// or
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
        
      
      
      These two do exactly the same thing, but one of them uses an explicit date.getTime() to get the date in ms, and the other one relies on a date-to-number transform. Their result is always the same.
So, which one is faster?
The first idea may be to run them many times in a row and measure the time difference. For our case, functions are very simple, so we have to do it at least 100000 times.
Let’s measure:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );
        
      
      
      Wow! Using getTime() is so much faster! That’s because there’s no type conversion, it is much easier for engines to optimize.
Okay, we have something. But that’s not a good benchmark yet.
Imagine that at the time of running bench(diffSubtract) CPU was doing something in parallel, and it was taking resources. And by the time of running bench(diffGetTime) that work has finished.
A pretty real scenario for a modern multi-process OS.
As a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results.
For more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.
For example, like this:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );
        
      
      
      Modern JavaScript engines start applying advanced optimizations only to “hot code” that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a heat-up run:

      
        
        
          // added for "heating up" prior to the main loop
bench(diffSubtract);
bench(diffGetTime);

// now benchmark
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
        
      
      
      
            Be careful doing microbenchmarking
            Modern JavaScript engines perform many optimizations. They may tweak results of “artificial tests” compared to “normal usage”, especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then please study how the JavaScript engine works. And then you probably won’t need microbenchmarks at all.
The great pack of articles about V8 can be found at https://mrale.ph.

Date.parse from a stringThe method Date.parse(str) can read a date from a string.
The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:

YYYY-MM-DD – is the date: year-month-day.
The character "T" is used as the delimiter.
HH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.
The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0.

Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.
The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (timestamp)
        
      
      
      We can instantly create a new Date object from the timestamp:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
        
      
      
      Summary
Date and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.
Months are counted from zero (yes, January is a zero month).
Days of week in getDay() are also counted from zero (that’s Sunday).
Date auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.
Dates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.
Use Date.now() to get the current timestamp fast.

Note that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.
Sometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has performance.now() that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):

      
        
        
          
            
          
          
            
          
        
        
          alert(`Loading started ${performance.now()}ms ago`);
// Something like: "Loading started 34731.26000000001ms ago"
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, only the first 3 are correct
        
      
      
      Node.js has microtime module and other ways. Technically, almost any device and environment allows to get more precision, it’s just not in Date.
TasksCreate a dateimportance: 5Create a Date object for the date: Feb 20, 2012, 3:12am. The time zone is local.
Show it using alert.
solutionThe new Date constructor uses the local time zone. So the only important thing to remember is that months start from zero.
So February has number 1.
Here’s an example with numbers as date components:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(year, month, date, hour, minute, second, millisecond)
let d1 = new Date(2012, 1, 20, 3, 12);
alert( d1 );
        
      
      
      We could also create a date from a string, like this:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(datastring)
let d2 = new Date("2012-02-20T03:12");
alert( d2 );
        
      
      
      Show a weekdayimportance: 5Write a function getWeekDay(date) to show the weekday in short format: ‘MO’, ‘TU’, ‘WE’, ‘TH’, ‘FR’, ‘SA’, ‘SU’.
For instance:

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getWeekDay(date) );        // should output "TU"
        
      
      
      Open a sandbox with tests.solutionThe method date.getDay() returns the number of the weekday, starting from sunday.
Let’s make an array of weekdays, so that we can get the proper day name by its number:

      
        
        
          
            
          
          
            
          
        
        
          function getWeekDay(date) {
  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

  return days[date.getDay()];
}

let date = new Date(2014, 0, 3); // 3 Jan 2014
alert( getWeekDay(date) ); // FR
        
      
      
      Open the solution with tests in a sandbox.European weekdayimportance: 5European countries have days of week starting with Monday (number 1), then Tuesday (number 2) and till Sunday (number 7). Write a function getLocalDay(date) that returns the “European” day of week for date.

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getLocalDay(date) );       // tuesday, should show 2
        
      
      
      Open a sandbox with tests.solution
      
        
        
          function getLocalDay(date) {

  let day = date.getDay();

  if (day == 0) { // weekday 0 (sunday) is 7 in european
    day = 7;
  }

  return day;
}
        
      
      
      Open the solution with tests in a sandbox.Which day of month was many days ago?importance: 4Create a function getDateAgo(date, days) to return the day of month days ago from the date.
For instance, if today is 20th, then getDateAgo(new Date(), 1) should be 19th and getDateAgo(new Date(), 2) should be 18th.
Should work reliably for days=365 or more:

      
        
        
          let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      P.S. The function should not modify the given date.
Open a sandbox with tests.solutionThe idea is simple: to substract given number of days from date:

      
        
        
          function getDateAgo(date, days) {
  date.setDate(date.getDate() - days);
  return date.getDate();
}
        
      
      
      …But the function should not change date. That’s an important thing, because the outer code which gives us the date does not expect it to change.
To implement it let’s clone the date, like this:

      
        
        
          
            
          
          
            
          
        
        
          function getDateAgo(date, days) {
  let dateCopy = new Date(date);

  dateCopy.setDate(date.getDate() - days);
  return dateCopy.getDate();
}

let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      Open the solution with tests in a sandbox.Last day of month?importance: 5Write a function getLastDayOfMonth(year, month) that returns the last day of month. Sometimes it is 30th, 31st or even 28/29th for Feb.
Parameters:

year – four-digits year, for instance 2012.
month – month, from 0 to 11.

For instance, getLastDayOfMonth(2012, 1) = 29 (leap year, Feb).
Open a sandbox with tests.solutionLet’s create a date using the next month, but pass zero as the day:

      
        
        
          
            
          
          
            
          
        
        
          function getLastDayOfMonth(year, month) {
  let date = new Date(year, month + 1, 0);
  return date.getDate();
}

alert( getLastDayOfMonth(2012, 0) ); // 31
alert( getLastDayOfMonth(2012, 1) ); // 29
alert( getLastDayOfMonth(2013, 1) ); // 28
        
      
      
      Normally, dates start from 1, but technically we can pass any number, the date will autoadjust itself. So when we pass 0, then it means “one day before 1st day of the month”, in other words: “the last day of the previous month”.
Open the solution with tests in a sandbox.How many seconds have passed today?importance: 5Write a function getSecondsToday() that returns the number of seconds from the beginning of today.
For instance, if now were 10:00 am, and there was no daylight savings shift, then:

      
        
        
          getSecondsToday() == 36000 // (3600 * 10)
        
      
      
      The function should work in any day. That is, it should not have a hard-coded value of “today”.
solutionTo get the number of seconds, we can generate a date using the current day and time 00:00:00, then substract it from “now”.
The difference is the number of milliseconds from the beginning of the day, that we should divide by 1000 to get seconds:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let now = new Date();

  // create an object using the current day/month/year
  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  let diff = now - today; // ms difference
  return Math.round(diff / 1000); // make seconds
}

alert( getSecondsToday() );
        
      
      
      An alternative solution would be to get hours/minutes/seconds and convert them to seconds:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let d = new Date();
  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
}

alert( getSecondsToday() );
        
      
      
      How many seconds till tomorrow?importance: 5Create a function getSecondsToTomorrow() that returns the number of seconds till tomorrow.
For instance, if now is 23:00, then:

      
        
        
          getSecondsToTomorrow() == 3600
        
      
      
      P.S. The function should work at any day, the “today” is not hardcoded.
solutionTo get the number of milliseconds till tomorrow, we can from “tomorrow 00:00:00” substract the current date.
First, we generate that “tomorrow”, and then do it:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();

  // tomorrow date
  let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);

  let diff = tomorrow - now; // difference in ms
  return Math.round(diff / 1000); // convert to seconds
}
        
      
      
      Alternative solution:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();
  let hour = now.getHours();
  let minutes = now.getMinutes();
  let seconds = now.getSeconds();
  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;
  let totalSecondsInADay = 86400;

  return totalSecondsInADay - totalSecondsToday;
}
        
      
      
      Please note that many countries have Daylight Savings Time (DST), so there may be days with 23 or 25 hours. We may want to treat such days separately.
Format the relative dateimportance: 4Write a function formatDate(date) that should format date as follows:

If since date passed less than 1 second, then "right now".
Otherwise, if since date passed less than 1 minute, then "n sec. ago".
Otherwise, if less than an hour, then "m min. ago".
Otherwise, the full date in the format "DD.MM.YY HH:mm". That is: "day.month.year hours:minutes", all in 2-digit format, e.g. 31.12.16 10:00.

For instance:

      
        
        
          alert( formatDate(new Date(new Date - 1)) ); // "right now"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"

// yesterday's date like 31.12.16 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Open a sandbox with tests.solutionTo get the time from date till now – let’s substract the dates.

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let diff = new Date() - date; // the difference in milliseconds

  if (diff < 1000) { // less than 1 second
    return 'right now';
  }

  let sec = Math.floor(diff / 1000); // convert diff to seconds

  if (sec < 60) {
    return sec + ' sec. ago';
  }

  let min = Math.floor(diff / 60000); // convert diff to minutes
  if (min < 60) {
    return min + ' min. ago';
  }

  // format the date
  // add leading zeroes to single-digit day/month/hours/minutes
  let d = date;
  d = [
    '0' + d.getDate(),
    '0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ].map(component => component.slice(-2)); // take last 2 digits of every component

  // join the components into date
  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
}

alert( formatDate(new Date(new Date - 1)) ); // "right now"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"

// yesterday's date like 31.12.2016 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Alternative solution:

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let dayOfMonth = date.getDate();
  let month = date.getMonth() + 1;
  let year = date.getFullYear();
  let hour = date.getHours();
  let minutes = date.getMinutes();
  let diffMs = new Date() - date;
  let diffSec = Math.round(diffMs / 1000);
  let diffMin = diffSec / 60;
  let diffHour = diffMin / 60;

  // formatting
  year = year.toString().slice(-2);
  month = month < 10 ? '0' + month : month;
  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
  hour = hour < 10 ? '0' + hour : hour;
  minutes = minutes < 10 ? '0' + minutes : minutes;

  if (diffSec < 1) {
    return 'right now';
  } else if (diffMin < 1) {
    return `${diffSec} sec. ago`
  } else if (diffHour < 1) {
    return `${diffMin} min. ago`
  } else {
    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`
  }
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nLet’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
For instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.
CreationTo create a new Date object call new Date() with one of the following arguments:

new Date()

Without arguments – create a Date object for the current date and time:

      
        
        
          
            
          
          
            
          
        
        
          let now = new Date();
alert( now ); // shows current date/time
        
      
      
      
new Date(milliseconds)

Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

      
        
        
          
            
          
          
            
          
        
        
          // 0 means 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// now add 24 hours, get 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
        
      
      
      An integer number representing the number of milliseconds that has passed since the beginning of 1970 is called a timestamp.
It’s a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).
Dates before 01.01.1970 have negative timestamps, e.g.:

      
        
        
          
            
          
          
            
          
        
        
          // 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
        
      
      
      
new Date(datestring)

If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date("2017-01-26");
alert(date);
// The time is not set, so it's assumed to be midnight GMT and
// is adjusted according to the timezone the code is run in
// So the result could be
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// or
// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
        
      
      
      
new Date(year, month, date, hours, minutes, seconds, ms)

Create the date with the given components in the local time zone. Only the first two arguments are obligatory.

The year should have 4 digits. For compatibility, 2 digits are also accepted and considered 19xx, e.g. 98 is the same as 1998 here, but always using 4 digits is strongly encouraged.
The month count starts with 0 (Jan), up to 11 (Dec).
The date parameter is actually the day of month, if absent then 1 is assumed.
If hours/minutes/seconds/ms is absent, they are assumed to be equal 0.

For instance:

      
        
        
          new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default
        
      
      
      The maximal precision is 1 ms (1/1000 sec):

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
        
      
      
      

Access date componentsThere are methods to access the year, month and so on from the Date object:

getFullYear()
Get the year (4 digits)
getMonth()
Get the month, from 0 to 11.
getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.


            Not getYear(), but getFullYear()
            Many JavaScript engines implement a non-standard method getYear(). This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is getFullYear() for the year.

Additionally, we can get a day of week:

getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.

All the methods above return the components relative to the local time zone.
There are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Just insert the "UTC" right after "get".
If your local time zone is shifted relative to UTC, then the code below shows different hours:

      
        
        
          
            
          
          
            
          
        
        
          // current date
let date = new Date();

// the hour in your current time zone
alert( date.getHours() );

// the hour in UTC+0 time zone (London time without daylight savings)
alert( date.getUTCHours() );
        
      
      
      Besides the given methods, there are two special ones that do not have a UTC-variant:

getTime()

Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.

getTimezoneOffset()

Returns the difference between UTC and the local time zone, in minutes:

      
        
        
          
            
          
          
            
          
        
        
          // if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );
        
      
      
      

Setting date componentsThe following methods allow to set date/time components:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)

Every one of them except setTime() has a UTC-variant, for instance: setUTCHours().
As we can see, some methods can set multiple components at once, for example setHours. The components that are not mentioned are not modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let today = new Date();

today.setHours(0);
alert(today); // still today, but the hour is changed to 0

today.setHours(0, 0, 0, 0);
alert(today); // still today, now 00:00:00 sharp.
        
      
      
      AutocorrectionThe autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!
        
      
      
      Out-of-range date components are distributed automatically.
Let’s say we need to increase the date “28 Feb 2016” by 2 days. It may be “2 Mar” or “1 Mar” in case of a leap-year. We don’t need to think about it. Just add 2 days. The Date object will do the rest:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
        
      
      
      That feature is often used to get the date after the given period of time. For instance, let’s get the date for “70 seconds after now”:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // shows the correct date
        
      
      
      We can also set zero or even negative values. For example:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // set day 1 of month
alert( date );

date.setDate(0); // min day is 1, so the last day of the previous month is assumed
alert( date ); // 31 Dec 2015
        
      
      
      Date to number, date diffWhen a Date object is converted to number, it becomes the timestamp same as date.getTime():

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()
        
      
      
      The important side effect: dates can be subtracted, the result is their difference in ms.
That can be used for time measurements:

      
        
        
          
            
          
          
            
          
        
        
          let start = new Date(); // start measuring time

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // end measuring time

alert( `The loop took ${end - start} ms` );
        
      
      
      Date.now()If we only want to measure time, we don’t need the Date object.
There’s a special method Date.now() that returns the current timestamp.
It is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.
It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.
So this is probably better:

      
        
        
          
            
          
          
            
          
        
        
          let start = Date.now(); // milliseconds count from 1 Jan 1970

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // done

alert( `The loop took ${end - start} ms` ); // subtract numbers, not dates
        
      
      
      BenchmarkingIf we want a reliable benchmark of CPU-hungry function, we should be careful.
For instance, let’s measure two functions that calculate the difference between two dates: which one is faster?
Such performance measurements are often called “benchmarks”.

      
        
        
          // we have date1 and date2, which function faster returns their difference in ms?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// or
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
        
      
      
      These two do exactly the same thing, but one of them uses an explicit date.getTime() to get the date in ms, and the other one relies on a date-to-number transform. Their result is always the same.
So, which one is faster?
The first idea may be to run them many times in a row and measure the time difference. For our case, functions are very simple, so we have to do it at least 100000 times.
Let’s measure:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );
        
      
      
      Wow! Using getTime() is so much faster! That’s because there’s no type conversion, it is much easier for engines to optimize.
Okay, we have something. But that’s not a good benchmark yet.
Imagine that at the time of running bench(diffSubtract) CPU was doing something in parallel, and it was taking resources. And by the time of running bench(diffGetTime) that work has finished.
A pretty real scenario for a modern multi-process OS.
As a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results.
For more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.
For example, like this:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );
        
      
      
      Modern JavaScript engines start applying advanced optimizations only to “hot code” that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a heat-up run:

      
        
        
          // added for "heating up" prior to the main loop
bench(diffSubtract);
bench(diffGetTime);

// now benchmark
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
        
      
      
      
            Be careful doing microbenchmarking
            Modern JavaScript engines perform many optimizations. They may tweak results of “artificial tests” compared to “normal usage”, especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then please study how the JavaScript engine works. And then you probably won’t need microbenchmarks at all.
The great pack of articles about V8 can be found at https://mrale.ph.

Date.parse from a stringThe method Date.parse(str) can read a date from a string.
The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:

YYYY-MM-DD – is the date: year-month-day.
The character "T" is used as the delimiter.
HH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.
The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0.

Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.
The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (timestamp)
        
      
      
      We can instantly create a new Date object from the timestamp:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
        
      
      
      Summary
Date and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.
Months are counted from zero (yes, January is a zero month).
Days of week in getDay() are also counted from zero (that’s Sunday).
Date auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.
Dates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.
Use Date.now() to get the current timestamp fast.

Note that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.
Sometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has performance.now() that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):

      
        
        
          
            
          
          
            
          
        
        
          alert(`Loading started ${performance.now()}ms ago`);
// Something like: "Loading started 34731.26000000001ms ago"
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, only the first 3 are correct
        
      
      
      Node.js has microtime module and other ways. Technically, almost any device and environment allows to get more precision, it’s just not in Date.
TasksCreate a dateimportance: 5Create a Date object for the date: Feb 20, 2012, 3:12am. The time zone is local.
Show it using alert.
solutionThe new Date constructor uses the local time zone. So the only important thing to remember is that months start from zero.
So February has number 1.
Here’s an example with numbers as date components:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(year, month, date, hour, minute, second, millisecond)
let d1 = new Date(2012, 1, 20, 3, 12);
alert( d1 );
        
      
      
      We could also create a date from a string, like this:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(datastring)
let d2 = new Date("2012-02-20T03:12");
alert( d2 );
        
      
      
      Show a weekdayimportance: 5Write a function getWeekDay(date) to show the weekday in short format: ‘MO’, ‘TU’, ‘WE’, ‘TH’, ‘FR’, ‘SA’, ‘SU’.
For instance:

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getWeekDay(date) );        // should output "TU"
        
      
      
      Open a sandbox with tests.solutionThe method date.getDay() returns the number of the weekday, starting from sunday.
Let’s make an array of weekdays, so that we can get the proper day name by its number:

      
        
        
          
            
          
          
            
          
        
        
          function getWeekDay(date) {
  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

  return days[date.getDay()];
}

let date = new Date(2014, 0, 3); // 3 Jan 2014
alert( getWeekDay(date) ); // FR
        
      
      
      Open the solution with tests in a sandbox.European weekdayimportance: 5European countries have days of week starting with Monday (number 1), then Tuesday (number 2) and till Sunday (number 7). Write a function getLocalDay(date) that returns the “European” day of week for date.

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getLocalDay(date) );       // tuesday, should show 2
        
      
      
      Open a sandbox with tests.solution
      
        
        
          function getLocalDay(date) {

  let day = date.getDay();

  if (day == 0) { // weekday 0 (sunday) is 7 in european
    day = 7;
  }

  return day;
}
        
      
      
      Open the solution with tests in a sandbox.Which day of month was many days ago?importance: 4Create a function getDateAgo(date, days) to return the day of month days ago from the date.
For instance, if today is 20th, then getDateAgo(new Date(), 1) should be 19th and getDateAgo(new Date(), 2) should be 18th.
Should work reliably for days=365 or more:

      
        
        
          let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      P.S. The function should not modify the given date.
Open a sandbox with tests.solutionThe idea is simple: to substract given number of days from date:

      
        
        
          function getDateAgo(date, days) {
  date.setDate(date.getDate() - days);
  return date.getDate();
}
        
      
      
      …But the function should not change date. That’s an important thing, because the outer code which gives us the date does not expect it to change.
To implement it let’s clone the date, like this:

      
        
        
          
            
          
          
            
          
        
        
          function getDateAgo(date, days) {
  let dateCopy = new Date(date);

  dateCopy.setDate(date.getDate() - days);
  return dateCopy.getDate();
}

let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      Open the solution with tests in a sandbox.Last day of month?importance: 5Write a function getLastDayOfMonth(year, month) that returns the last day of month. Sometimes it is 30th, 31st or even 28/29th for Feb.
Parameters:

year – four-digits year, for instance 2012.
month – month, from 0 to 11.

For instance, getLastDayOfMonth(2012, 1) = 29 (leap year, Feb).
Open a sandbox with tests.solutionLet’s create a date using the next month, but pass zero as the day:

      
        
        
          
            
          
          
            
          
        
        
          function getLastDayOfMonth(year, month) {
  let date = new Date(year, month + 1, 0);
  return date.getDate();
}

alert( getLastDayOfMonth(2012, 0) ); // 31
alert( getLastDayOfMonth(2012, 1) ); // 29
alert( getLastDayOfMonth(2013, 1) ); // 28
        
      
      
      Normally, dates start from 1, but technically we can pass any number, the date will autoadjust itself. So when we pass 0, then it means “one day before 1st day of the month”, in other words: “the last day of the previous month”.
Open the solution with tests in a sandbox.How many seconds have passed today?importance: 5Write a function getSecondsToday() that returns the number of seconds from the beginning of today.
For instance, if now were 10:00 am, and there was no daylight savings shift, then:

      
        
        
          getSecondsToday() == 36000 // (3600 * 10)
        
      
      
      The function should work in any day. That is, it should not have a hard-coded value of “today”.
solutionTo get the number of seconds, we can generate a date using the current day and time 00:00:00, then substract it from “now”.
The difference is the number of milliseconds from the beginning of the day, that we should divide by 1000 to get seconds:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let now = new Date();

  // create an object using the current day/month/year
  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  let diff = now - today; // ms difference
  return Math.round(diff / 1000); // make seconds
}

alert( getSecondsToday() );
        
      
      
      An alternative solution would be to get hours/minutes/seconds and convert them to seconds:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let d = new Date();
  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
}

alert( getSecondsToday() );
        
      
      
      How many seconds till tomorrow?importance: 5Create a function getSecondsToTomorrow() that returns the number of seconds till tomorrow.
For instance, if now is 23:00, then:

      
        
        
          getSecondsToTomorrow() == 3600
        
      
      
      P.S. The function should work at any day, the “today” is not hardcoded.
solutionTo get the number of milliseconds till tomorrow, we can from “tomorrow 00:00:00” substract the current date.
First, we generate that “tomorrow”, and then do it:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();

  // tomorrow date
  let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);

  let diff = tomorrow - now; // difference in ms
  return Math.round(diff / 1000); // convert to seconds
}
        
      
      
      Alternative solution:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();
  let hour = now.getHours();
  let minutes = now.getMinutes();
  let seconds = now.getSeconds();
  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;
  let totalSecondsInADay = 86400;

  return totalSecondsInADay - totalSecondsToday;
}
        
      
      
      Please note that many countries have Daylight Savings Time (DST), so there may be days with 23 or 25 hours. We may want to treat such days separately.
Format the relative dateimportance: 4Write a function formatDate(date) that should format date as follows:

If since date passed less than 1 second, then "right now".
Otherwise, if since date passed less than 1 minute, then "n sec. ago".
Otherwise, if less than an hour, then "m min. ago".
Otherwise, the full date in the format "DD.MM.YY HH:mm". That is: "day.month.year hours:minutes", all in 2-digit format, e.g. 31.12.16 10:00.

For instance:

      
        
        
          alert( formatDate(new Date(new Date - 1)) ); // "right now"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"

// yesterday's date like 31.12.16 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Open a sandbox with tests.solutionTo get the time from date till now – let’s substract the dates.

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let diff = new Date() - date; // the difference in milliseconds

  if (diff < 1000) { // less than 1 second
    return 'right now';
  }

  let sec = Math.floor(diff / 1000); // convert diff to seconds

  if (sec < 60) {
    return sec + ' sec. ago';
  }

  let min = Math.floor(diff / 60000); // convert diff to minutes
  if (min < 60) {
    return min + ' min. ago';
  }

  // format the date
  // add leading zeroes to single-digit day/month/hours/minutes
  let d = date;
  d = [
    '0' + d.getDate(),
    '0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ].map(component => component.slice(-2)); // take last 2 digits of every component

  // join the components into date
  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
}

alert( formatDate(new Date(new Date - 1)) ); // "right now"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"

// yesterday's date like 31.12.2016 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Alternative solution:

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let dayOfMonth = date.getDate();
  let month = date.getMonth() + 1;
  let year = date.getFullYear();
  let hour = date.getHours();
  let minutes = date.getMinutes();
  let diffMs = new Date() - date;
  let diffSec = Math.round(diffMs / 1000);
  let diffMin = diffSec / 60;
  let diffHour = diffMin / 60;

  // formatting
  year = year.toString().slice(-2);
  month = month < 10 ? '0' + month : month;
  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
  hour = hour < 10 ? '0' + hour : hour;
  minutes = minutes < 10 ? '0' + minutes : minutes;

  if (diffSec < 1) {
    return 'right now';
  } else if (diffMin < 1) {
    return `${diffSec} sec. ago`
  } else if (diffHour < 1) {
    return `${diffMin} min. ago`
  } else {
    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`
  }
}
        
      
      
      Open the solution with tests in a sandbox.\n\nTutorialThe JavaScript languageData typesOctober 14, 2022Date and timeLet’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
For instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.
CreationTo create a new Date object call new Date() with one of the following arguments:

new Date()

Without arguments – create a Date object for the current date and time:

      
        
        
          
            
          
          
            
          
        
        
          let now = new Date();
alert( now ); // shows current date/time
        
      
      
      
new Date(milliseconds)

Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

      
        
        
          
            
          
          
            
          
        
        
          // 0 means 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// now add 24 hours, get 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
        
      
      
      An integer number representing the number of milliseconds that has passed since the beginning of 1970 is called a timestamp.
It’s a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).
Dates before 01.01.1970 have negative timestamps, e.g.:

      
        
        
          
            
          
          
            
          
        
        
          // 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
        
      
      
      
new Date(datestring)

If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date("2017-01-26");
alert(date);
// The time is not set, so it's assumed to be midnight GMT and
// is adjusted according to the timezone the code is run in
// So the result could be
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// or
// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
        
      
      
      
new Date(year, month, date, hours, minutes, seconds, ms)

Create the date with the given components in the local time zone. Only the first two arguments are obligatory.

The year should have 4 digits. For compatibility, 2 digits are also accepted and considered 19xx, e.g. 98 is the same as 1998 here, but always using 4 digits is strongly encouraged.
The month count starts with 0 (Jan), up to 11 (Dec).
The date parameter is actually the day of month, if absent then 1 is assumed.
If hours/minutes/seconds/ms is absent, they are assumed to be equal 0.

For instance:

      
        
        
          new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default
        
      
      
      The maximal precision is 1 ms (1/1000 sec):

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
        
      
      
      

Access date componentsThere are methods to access the year, month and so on from the Date object:

getFullYear()
Get the year (4 digits)
getMonth()
Get the month, from 0 to 11.
getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.


            Not getYear(), but getFullYear()
            Many JavaScript engines implement a non-standard method getYear(). This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is getFullYear() for the year.

Additionally, we can get a day of week:

getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.

All the methods above return the components relative to the local time zone.
There are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Just insert the "UTC" right after "get".
If your local time zone is shifted relative to UTC, then the code below shows different hours:

      
        
        
          
            
          
          
            
          
        
        
          // current date
let date = new Date();

// the hour in your current time zone
alert( date.getHours() );

// the hour in UTC+0 time zone (London time without daylight savings)
alert( date.getUTCHours() );
        
      
      
      Besides the given methods, there are two special ones that do not have a UTC-variant:

getTime()

Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.

getTimezoneOffset()

Returns the difference between UTC and the local time zone, in minutes:

      
        
        
          
            
          
          
            
          
        
        
          // if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );
        
      
      
      

Setting date componentsThe following methods allow to set date/time components:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)

Every one of them except setTime() has a UTC-variant, for instance: setUTCHours().
As we can see, some methods can set multiple components at once, for example setHours. The components that are not mentioned are not modified.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let today = new Date();

today.setHours(0);
alert(today); // still today, but the hour is changed to 0

today.setHours(0, 0, 0, 0);
alert(today); // still today, now 00:00:00 sharp.
        
      
      
      AutocorrectionThe autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!
        
      
      
      Out-of-range date components are distributed automatically.
Let’s say we need to increase the date “28 Feb 2016” by 2 days. It may be “2 Mar” or “1 Mar” in case of a leap-year. We don’t need to think about it. Just add 2 days. The Date object will do the rest:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
        
      
      
      That feature is often used to get the date after the given period of time. For instance, let’s get the date for “70 seconds after now”:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // shows the correct date
        
      
      
      We can also set zero or even negative values. For example:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // set day 1 of month
alert( date );

date.setDate(0); // min day is 1, so the last day of the previous month is assumed
alert( date ); // 31 Dec 2015
        
      
      
      Date to number, date diffWhen a Date object is converted to number, it becomes the timestamp same as date.getTime():

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()
        
      
      
      The important side effect: dates can be subtracted, the result is their difference in ms.
That can be used for time measurements:

      
        
        
          
            
          
          
            
          
        
        
          let start = new Date(); // start measuring time

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // end measuring time

alert( `The loop took ${end - start} ms` );
        
      
      
      Date.now()If we only want to measure time, we don’t need the Date object.
There’s a special method Date.now() that returns the current timestamp.
It is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.
It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.
So this is probably better:

      
        
        
          
            
          
          
            
          
        
        
          let start = Date.now(); // milliseconds count from 1 Jan 1970

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // done

alert( `The loop took ${end - start} ms` ); // subtract numbers, not dates
        
      
      
      BenchmarkingIf we want a reliable benchmark of CPU-hungry function, we should be careful.
For instance, let’s measure two functions that calculate the difference between two dates: which one is faster?
Such performance measurements are often called “benchmarks”.

      
        
        
          // we have date1 and date2, which function faster returns their difference in ms?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// or
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
        
      
      
      These two do exactly the same thing, but one of them uses an explicit date.getTime() to get the date in ms, and the other one relies on a date-to-number transform. Their result is always the same.
So, which one is faster?
The first idea may be to run them many times in a row and measure the time difference. For our case, functions are very simple, so we have to do it at least 100000 times.
Let’s measure:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );
        
      
      
      Wow! Using getTime() is so much faster! That’s because there’s no type conversion, it is much easier for engines to optimize.
Okay, we have something. But that’s not a good benchmark yet.
Imagine that at the time of running bench(diffSubtract) CPU was doing something in parallel, and it was taking resources. And by the time of running bench(diffGetTime) that work has finished.
A pretty real scenario for a modern multi-process OS.
As a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results.
For more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.
For example, like this:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );
        
      
      
      Modern JavaScript engines start applying advanced optimizations only to “hot code” that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a heat-up run:

      
        
        
          // added for "heating up" prior to the main loop
bench(diffSubtract);
bench(diffGetTime);

// now benchmark
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
        
      
      
      
            Be careful doing microbenchmarking
            Modern JavaScript engines perform many optimizations. They may tweak results of “artificial tests” compared to “normal usage”, especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then please study how the JavaScript engine works. And then you probably won’t need microbenchmarks at all.
The great pack of articles about V8 can be found at https://mrale.ph.

Date.parse from a stringThe method Date.parse(str) can read a date from a string.
The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:

YYYY-MM-DD – is the date: year-month-day.
The character "T" is used as the delimiter.
HH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.
The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0.

Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.
The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (timestamp)
        
      
      
      We can instantly create a new Date object from the timestamp:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
        
      
      
      Summary
Date and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.
Months are counted from zero (yes, January is a zero month).
Days of week in getDay() are also counted from zero (that’s Sunday).
Date auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.
Dates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.
Use Date.now() to get the current timestamp fast.

Note that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.
Sometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has performance.now() that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):

      
        
        
          
            
          
          
            
          
        
        
          alert(`Loading started ${performance.now()}ms ago`);
// Something like: "Loading started 34731.26000000001ms ago"
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, only the first 3 are correct
        
      
      
      Node.js has microtime module and other ways. Technically, almost any device and environment allows to get more precision, it’s just not in Date.
TasksCreate a dateimportance: 5Create a Date object for the date: Feb 20, 2012, 3:12am. The time zone is local.
Show it using alert.
solutionThe new Date constructor uses the local time zone. So the only important thing to remember is that months start from zero.
So February has number 1.
Here’s an example with numbers as date components:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(year, month, date, hour, minute, second, millisecond)
let d1 = new Date(2012, 1, 20, 3, 12);
alert( d1 );
        
      
      
      We could also create a date from a string, like this:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(datastring)
let d2 = new Date("2012-02-20T03:12");
alert( d2 );
        
      
      
      Show a weekdayimportance: 5Write a function getWeekDay(date) to show the weekday in short format: ‘MO’, ‘TU’, ‘WE’, ‘TH’, ‘FR’, ‘SA’, ‘SU’.
For instance:

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getWeekDay(date) );        // should output "TU"
        
      
      
      Open a sandbox with tests.solutionThe method date.getDay() returns the number of the weekday, starting from sunday.
Let’s make an array of weekdays, so that we can get the proper day name by its number:

      
        
        
          
            
          
          
            
          
        
        
          function getWeekDay(date) {
  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

  return days[date.getDay()];
}

let date = new Date(2014, 0, 3); // 3 Jan 2014
alert( getWeekDay(date) ); // FR
        
      
      
      Open the solution with tests in a sandbox.European weekdayimportance: 5European countries have days of week starting with Monday (number 1), then Tuesday (number 2) and till Sunday (number 7). Write a function getLocalDay(date) that returns the “European” day of week for date.

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getLocalDay(date) );       // tuesday, should show 2
        
      
      
      Open a sandbox with tests.solution
      
        
        
          function getLocalDay(date) {

  let day = date.getDay();

  if (day == 0) { // weekday 0 (sunday) is 7 in european
    day = 7;
  }

  return day;
}
        
      
      
      Open the solution with tests in a sandbox.Which day of month was many days ago?importance: 4Create a function getDateAgo(date, days) to return the day of month days ago from the date.
For instance, if today is 20th, then getDateAgo(new Date(), 1) should be 19th and getDateAgo(new Date(), 2) should be 18th.
Should work reliably for days=365 or more:

      
        
        
          let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      P.S. The function should not modify the given date.
Open a sandbox with tests.solutionThe idea is simple: to substract given number of days from date:

      
        
        
          function getDateAgo(date, days) {
  date.setDate(date.getDate() - days);
  return date.getDate();
}
        
      
      
      …But the function should not change date. That’s an important thing, because the outer code which gives us the date does not expect it to change.
To implement it let’s clone the date, like this:

      
        
        
          
            
          
          
            
          
        
        
          function getDateAgo(date, days) {
  let dateCopy = new Date(date);

  dateCopy.setDate(date.getDate() - days);
  return dateCopy.getDate();
}

let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      Open the solution with tests in a sandbox.Last day of month?importance: 5Write a function getLastDayOfMonth(year, month) that returns the last day of month. Sometimes it is 30th, 31st or even 28/29th for Feb.
Parameters:

year – four-digits year, for instance 2012.
month – month, from 0 to 11.

For instance, getLastDayOfMonth(2012, 1) = 29 (leap year, Feb).
Open a sandbox with tests.solutionLet’s create a date using the next month, but pass zero as the day:

      
        
        
          
            
          
          
            
          
        
        
          function getLastDayOfMonth(year, month) {
  let date = new Date(year, month + 1, 0);
  return date.getDate();
}

alert( getLastDayOfMonth(2012, 0) ); // 31
alert( getLastDayOfMonth(2012, 1) ); // 29
alert( getLastDayOfMonth(2013, 1) ); // 28
        
      
      
      Normally, dates start from 1, but technically we can pass any number, the date will autoadjust itself. So when we pass 0, then it means “one day before 1st day of the month”, in other words: “the last day of the previous month”.
Open the solution with tests in a sandbox.How many seconds have passed today?importance: 5Write a function getSecondsToday() that returns the number of seconds from the beginning of today.
For instance, if now were 10:00 am, and there was no daylight savings shift, then:

      
        
        
          getSecondsToday() == 36000 // (3600 * 10)
        
      
      
      The function should work in any day. That is, it should not have a hard-coded value of “today”.
solutionTo get the number of seconds, we can generate a date using the current day and time 00:00:00, then substract it from “now”.
The difference is the number of milliseconds from the beginning of the day, that we should divide by 1000 to get seconds:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let now = new Date();

  // create an object using the current day/month/year
  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  let diff = now - today; // ms difference
  return Math.round(diff / 1000); // make seconds
}

alert( getSecondsToday() );
        
      
      
      An alternative solution would be to get hours/minutes/seconds and convert them to seconds:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let d = new Date();
  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
}

alert( getSecondsToday() );
        
      
      
      How many seconds till tomorrow?importance: 5Create a function getSecondsToTomorrow() that returns the number of seconds till tomorrow.
For instance, if now is 23:00, then:

      
        
        
          getSecondsToTomorrow() == 3600
        
      
      
      P.S. The function should work at any day, the “today” is not hardcoded.
solutionTo get the number of milliseconds till tomorrow, we can from “tomorrow 00:00:00” substract the current date.
First, we generate that “tomorrow”, and then do it:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();

  // tomorrow date
  let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);

  let diff = tomorrow - now; // difference in ms
  return Math.round(diff / 1000); // convert to seconds
}
        
      
      
      Alternative solution:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();
  let hour = now.getHours();
  let minutes = now.getMinutes();
  let seconds = now.getSeconds();
  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;
  let totalSecondsInADay = 86400;

  return totalSecondsInADay - totalSecondsToday;
}
        
      
      
      Please note that many countries have Daylight Savings Time (DST), so there may be days with 23 or 25 hours. We may want to treat such days separately.
Format the relative dateimportance: 4Write a function formatDate(date) that should format date as follows:

If since date passed less than 1 second, then "right now".
Otherwise, if since date passed less than 1 minute, then "n sec. ago".
Otherwise, if less than an hour, then "m min. ago".
Otherwise, the full date in the format "DD.MM.YY HH:mm". That is: "day.month.year hours:minutes", all in 2-digit format, e.g. 31.12.16 10:00.

For instance:

      
        
        
          alert( formatDate(new Date(new Date - 1)) ); // "right now"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"

// yesterday's date like 31.12.16 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Open a sandbox with tests.solutionTo get the time from date till now – let’s substract the dates.

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let diff = new Date() - date; // the difference in milliseconds

  if (diff < 1000) { // less than 1 second
    return 'right now';
  }

  let sec = Math.floor(diff / 1000); // convert diff to seconds

  if (sec < 60) {
    return sec + ' sec. ago';
  }

  let min = Math.floor(diff / 60000); // convert diff to minutes
  if (min < 60) {
    return min + ' min. ago';
  }

  // format the date
  // add leading zeroes to single-digit day/month/hours/minutes
  let d = date;
  d = [
    '0' + d.getDate(),
    '0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ].map(component => component.slice(-2)); // take last 2 digits of every component

  // join the components into date
  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
}

alert( formatDate(new Date(new Date - 1)) ); // "right now"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"

// yesterday's date like 31.12.2016 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Alternative solution:

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let dayOfMonth = date.getDate();
  let month = date.getMonth() + 1;
  let year = date.getFullYear();
  let hour = date.getHours();
  let minutes = date.getMinutes();
  let diffMs = new Date() - date;
  let diffSec = Math.round(diffMs / 1000);
  let diffMin = diffSec / 60;
  let diffHour = diffMin / 60;

  // formatting
  year = year.toString().slice(-2);
  month = month < 10 ? '0' + month : month;
  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
  hour = hour < 10 ? '0' + hour : hour;
  minutes = minutes < 10 ? '0' + minutes : minutes;

  if (diffSec < 1) {
    return 'right now';
  } else if (diffMin < 1) {
    return `${diffSec} sec. ago`
  } else if (diffHour < 1) {
    return `${diffMin} min. ago`
  } else {
    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`
  }
}
        
      
      
      Open the solution with tests in a sandbox.Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nLet’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.
Naturally, such a string should include all important properties.
We could implement the conversion like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  toString() {
    return `{name: "${this.name}", age: ${this.age}}`;
  }
};

alert(user); // {name: "John", age: 30}
        
      
      
      …But in the process of development, new properties are added, old properties are renamed and removed. Updating such toString every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We’d need to implement their conversion as well.
Luckily, there’s no need to write the code to handle all this. The task has been solved already.
JSON.stringifyThe JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well.  So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.
JavaScript provides methods:

JSON.stringify to convert objects into JSON.
JSON.parse to convert JSON back into an object.

For instance, here we JSON.stringify a student:

      
        
        
          
            
          
          
            
          
        
        
          let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
/* JSON-encoded object:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
*/
        
      
      
      The method JSON.stringify(student) takes the object and converts it into a string.
The resulting json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.
Please note that a JSON-encoded object has several important differences from the object literal:

Strings use double quotes. No single quotes or backticks in JSON. So 'John' becomes "John".
Object property names are double-quoted also. That’s obligatory. So age:30 becomes "age":30.

JSON.stringify can be applied to primitives as well.
JSON supports following data types:

Objects { ... }
Arrays [ ... ]
Primitives:

strings,
numbers,
boolean values true/false,
null.



For instance:

      
        
        
          
            
          
          
            
          
        
        
          // a number in JSON is just a number
alert( JSON.stringify(1) ) // 1

// a string in JSON is still a string, but double-quoted
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
        
      
      
      JSON is data-only language-independent specification, so some JavaScript-specific object properties are skipped by JSON.stringify.
Namely:

Function properties (methods).
Symbolic keys and values.
Properties that store undefined.


      
        
        
          
            
          
          
            
          
        
        
          let user = {
  sayHi() { // ignored
    alert("Hello");
  },
  [Symbol("id")]: 123, // ignored
  something: undefined // ignored
};

alert( JSON.stringify(user) ); // {} (empty object)
        
      
      
      Usually that’s fine. If that’s not what we want, then soon we’ll see how to customize the process.
The great thing is that nested objects are supported and converted automatically.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* The whole structure is stringified:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
        
      
      
      The important limitation: there must be no circular references.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup references room
room.occupiedBy = meetup; // room references meetup

JSON.stringify(meetup); // Error: Converting circular structure to JSON
        
      
      
      Here, the conversion fails, because of circular reference: room.occupiedBy references meetup, and meetup.place references room:

      
      
        
      
      Excluding and transforming: replacerThe full syntax of JSON.stringify is:

      
        
        
          let json = JSON.stringify(value[, replacer, space])
        
      
      
      
value
A value to encode.
replacer
Array of properties to encode or a mapping function function(key, value).
space
Amount of space to use for formatting

Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.
If we pass an array of properties to it, only these properties will be encoded.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}
        
      
      
      Here we are probably too strict. The property list is applied to the whole object structure. So the objects in participants are empty, because name is not in the list.
Let’s include in the list every property except room.occupiedBy that would cause the circular reference:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Now everything except occupiedBy is serialized. But the list of properties is quite long.
Fortunately, we can use a function instead of an array as the replacer.
The function will be called for every (key, value) pair and should return the “replaced” value, which will be used instead of the original one. Or undefined if the value is to be skipped.
In our case, we can return value “as is” for everything except occupiedBy. To ignore occupiedBy, the code below returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
occupiedBy: [object Object]
*/
        
      
      
      Please note that replacer function gets every key/value pair including nested objects and array items. It is applied recursively. The value of this inside replacer is the object that contains the current property.
The first call is special. It is made using a special “wrapper object”: {"": meetup}. In other words, the first (key, value) pair has an empty key, and the value is the target object as a whole. That’s why the first line is ":[object Object]" in the example above.
The idea is to provide as much power for replacer as possible: it has a chance to analyze and replace/skip even the whole object if necessary.
Formatting: spaceThe third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.
Previously, all stringified objects had no indents and extra spaces. That’s fine if we want to send an object over a network. The space argument is used exclusively for a nice output.
Here space = 2 tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* two-space indents:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* for JSON.stringify(user, null, 4) the result would be more indented:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
        
      
      
      The third argument can also be a string. In this case, the string is used for indentation instead of a number of spaces.
The space parameter is used solely for logging and nice-output purposes.
Custom “toJSON”Like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
        
      
      
      Here we can see that date (1) became a string. That’s because all dates have a built-in toJSON method which returns such kind of string.
Now let’s add a custom toJSON for our object room (2):

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
        
      
      
      As we can see, toJSON is used both for the direct call JSON.stringify(room) and when room is nested in another encoded object.
JSON.parseTo decode a JSON-string, we need another method named JSON.parse.
The syntax:

      
        
        
          let value = JSON.parse(str[, reviver]);
        
      
      
      
str
JSON-string to parse.
reviver
Optional function(key,value) that will be called for each (key, value) pair and can transform the value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          // stringified array
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
        
      
      
      Or for nested objects:

      
        
        
          
            
          
          
            
          
        
        
          let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
        
      
      
      The JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the same JSON format.
Here are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):

      
        
        
          let json = `{
  name: "John",                     // mistake: property name without quotes
  "surname": 'Smith',               // mistake: single quotes in value (must be double)
  'isAdmin': false                  // mistake: single quotes in key (must be double)
  "birthday": new Date(2000, 2, 3), // mistake: no "new" is allowed, only bare values
  "friends": [0,1,2,3]              // here all fine
}`;
        
      
      
      Besides, JSON does not support comments. Adding a comment to JSON makes it invalid.
There’s another format named JSON5, which allows unquoted keys, comments etc. But this is a standalone library, not in the specification of the language.
The regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.
Using reviverImagine, we got a stringified meetup object from the server.
It looks like this:

      
        
        
          // title: (meetup title), date: (meetup date)
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        
      
      
      …And now we need to deserialize it, to turn back into JavaScript object.
Let’s do it by calling JSON.parse:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!
        
      
      
      Whoops! An error!
The value of meetup.date is a string, not a Date object. How could JSON.parse know that it should transform that string into a Date?
Let’s pass to JSON.parse the reviving function as the second argument, that returns all values “as is”, but date will become a Date:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // now works!
        
      
      
      By the way, that works for nested objects as well:

      
        
        
          
            
          
          
            
          
        
        
          let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // works!
        
      
      
      Summary
JSON is a data format that has its own independent standard and libraries for most programming languages.
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.\n\nTutorialThe JavaScript languageData typesJanuary 24, 2024JSON methods, toJSONLet’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.
Naturally, such a string should include all important properties.
We could implement the conversion like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  toString() {
    return `{name: "${this.name}", age: ${this.age}}`;
  }
};

alert(user); // {name: "John", age: 30}
        
      
      
      …But in the process of development, new properties are added, old properties are renamed and removed. Updating such toString every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We’d need to implement their conversion as well.
Luckily, there’s no need to write the code to handle all this. The task has been solved already.
JSON.stringifyThe JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well.  So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.
JavaScript provides methods:

JSON.stringify to convert objects into JSON.
JSON.parse to convert JSON back into an object.

For instance, here we JSON.stringify a student:

      
        
        
          
            
          
          
            
          
        
        
          let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
/* JSON-encoded object:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
*/
        
      
      
      The method JSON.stringify(student) takes the object and converts it into a string.
The resulting json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.
Please note that a JSON-encoded object has several important differences from the object literal:

Strings use double quotes. No single quotes or backticks in JSON. So 'John' becomes "John".
Object property names are double-quoted also. That’s obligatory. So age:30 becomes "age":30.

JSON.stringify can be applied to primitives as well.
JSON supports following data types:

Objects { ... }
Arrays [ ... ]
Primitives:

strings,
numbers,
boolean values true/false,
null.



For instance:

      
        
        
          
            
          
          
            
          
        
        
          // a number in JSON is just a number
alert( JSON.stringify(1) ) // 1

// a string in JSON is still a string, but double-quoted
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
        
      
      
      JSON is data-only language-independent specification, so some JavaScript-specific object properties are skipped by JSON.stringify.
Namely:

Function properties (methods).
Symbolic keys and values.
Properties that store undefined.


      
        
        
          
            
          
          
            
          
        
        
          let user = {
  sayHi() { // ignored
    alert("Hello");
  },
  [Symbol("id")]: 123, // ignored
  something: undefined // ignored
};

alert( JSON.stringify(user) ); // {} (empty object)
        
      
      
      Usually that’s fine. If that’s not what we want, then soon we’ll see how to customize the process.
The great thing is that nested objects are supported and converted automatically.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* The whole structure is stringified:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
        
      
      
      The important limitation: there must be no circular references.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup references room
room.occupiedBy = meetup; // room references meetup

JSON.stringify(meetup); // Error: Converting circular structure to JSON
        
      
      
      Here, the conversion fails, because of circular reference: room.occupiedBy references meetup, and meetup.place references room:

      
      
        
      
      Excluding and transforming: replacerThe full syntax of JSON.stringify is:

      
        
        
          let json = JSON.stringify(value[, replacer, space])
        
      
      
      
value
A value to encode.
replacer
Array of properties to encode or a mapping function function(key, value).
space
Amount of space to use for formatting

Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.
If we pass an array of properties to it, only these properties will be encoded.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}
        
      
      
      Here we are probably too strict. The property list is applied to the whole object structure. So the objects in participants are empty, because name is not in the list.
Let’s include in the list every property except room.occupiedBy that would cause the circular reference:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Now everything except occupiedBy is serialized. But the list of properties is quite long.
Fortunately, we can use a function instead of an array as the replacer.
The function will be called for every (key, value) pair and should return the “replaced” value, which will be used instead of the original one. Or undefined if the value is to be skipped.
In our case, we can return value “as is” for everything except occupiedBy. To ignore occupiedBy, the code below returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
occupiedBy: [object Object]
*/
        
      
      
      Please note that replacer function gets every key/value pair including nested objects and array items. It is applied recursively. The value of this inside replacer is the object that contains the current property.
The first call is special. It is made using a special “wrapper object”: {"": meetup}. In other words, the first (key, value) pair has an empty key, and the value is the target object as a whole. That’s why the first line is ":[object Object]" in the example above.
The idea is to provide as much power for replacer as possible: it has a chance to analyze and replace/skip even the whole object if necessary.
Formatting: spaceThe third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.
Previously, all stringified objects had no indents and extra spaces. That’s fine if we want to send an object over a network. The space argument is used exclusively for a nice output.
Here space = 2 tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* two-space indents:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* for JSON.stringify(user, null, 4) the result would be more indented:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
        
      
      
      The third argument can also be a string. In this case, the string is used for indentation instead of a number of spaces.
The space parameter is used solely for logging and nice-output purposes.
Custom “toJSON”Like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
        
      
      
      Here we can see that date (1) became a string. That’s because all dates have a built-in toJSON method which returns such kind of string.
Now let’s add a custom toJSON for our object room (2):

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
        
      
      
      As we can see, toJSON is used both for the direct call JSON.stringify(room) and when room is nested in another encoded object.
JSON.parseTo decode a JSON-string, we need another method named JSON.parse.
The syntax:

      
        
        
          let value = JSON.parse(str[, reviver]);
        
      
      
      
str
JSON-string to parse.
reviver
Optional function(key,value) that will be called for each (key, value) pair and can transform the value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          // stringified array
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
        
      
      
      Or for nested objects:

      
        
        
          
            
          
          
            
          
        
        
          let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
        
      
      
      The JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the same JSON format.
Here are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):

      
        
        
          let json = `{
  name: "John",                     // mistake: property name without quotes
  "surname": 'Smith',               // mistake: single quotes in value (must be double)
  'isAdmin': false                  // mistake: single quotes in key (must be double)
  "birthday": new Date(2000, 2, 3), // mistake: no "new" is allowed, only bare values
  "friends": [0,1,2,3]              // here all fine
}`;
        
      
      
      Besides, JSON does not support comments. Adding a comment to JSON makes it invalid.
There’s another format named JSON5, which allows unquoted keys, comments etc. But this is a standalone library, not in the specification of the language.
The regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.
Using reviverImagine, we got a stringified meetup object from the server.
It looks like this:

      
        
        
          // title: (meetup title), date: (meetup date)
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        
      
      
      …And now we need to deserialize it, to turn back into JavaScript object.
Let’s do it by calling JSON.parse:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!
        
      
      
      Whoops! An error!
The value of meetup.date is a string, not a Date object. How could JSON.parse know that it should transform that string into a Date?
Let’s pass to JSON.parse the reviving function as the second argument, that returns all values “as is”, but date will become a Date:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // now works!
        
      
      
      By the way, that works for nested objects as well:

      
        
        
          
            
          
          
            
          
        
        
          let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // works!
        
      
      
      Summary
JSON is a data format that has its own independent standard and libraries for most programming languages.
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.

TasksTurn the object into JSON and backimportance: 5Turn the user into JSON and then read it back into another variable.

      
        
        
          let user = {
  name: "John Smith",
  age: 35
};
        
      
      
      solution
      
        
        
          let user = {
  name: "John Smith",
  age: 35
};

let user2 = JSON.parse(JSON.stringify(user));
        
      
      
      Exclude backreferencesimportance: 5In simple cases of circular references, we can exclude an offending property from serialization by its name.
But sometimes we can’t just use the name, as it may be used both in circular references and normal properties. So we can check the property by its value.
Write replacer function to stringify everything, but remove properties that reference meetup:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

// circular references
room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  /* your code */
}));

/* result should be:
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  return (key != "" && value == meetup) ? undefined : value;
}));

/*
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Here we also need to test key=="" to exclude the first call where it is normal that value is meetup.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nLet’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.
Naturally, such a string should include all important properties.
We could implement the conversion like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  toString() {
    return `{name: "${this.name}", age: ${this.age}}`;
  }
};

alert(user); // {name: "John", age: 30}
        
      
      
      …But in the process of development, new properties are added, old properties are renamed and removed. Updating such toString every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We’d need to implement their conversion as well.
Luckily, there’s no need to write the code to handle all this. The task has been solved already.
JSON.stringifyThe JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well.  So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.
JavaScript provides methods:

JSON.stringify to convert objects into JSON.
JSON.parse to convert JSON back into an object.

For instance, here we JSON.stringify a student:

      
        
        
          
            
          
          
            
          
        
        
          let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
/* JSON-encoded object:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
*/
        
      
      
      The method JSON.stringify(student) takes the object and converts it into a string.
The resulting json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.
Please note that a JSON-encoded object has several important differences from the object literal:

Strings use double quotes. No single quotes or backticks in JSON. So 'John' becomes "John".
Object property names are double-quoted also. That’s obligatory. So age:30 becomes "age":30.

JSON.stringify can be applied to primitives as well.
JSON supports following data types:

Objects { ... }
Arrays [ ... ]
Primitives:

strings,
numbers,
boolean values true/false,
null.



For instance:

      
        
        
          
            
          
          
            
          
        
        
          // a number in JSON is just a number
alert( JSON.stringify(1) ) // 1

// a string in JSON is still a string, but double-quoted
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
        
      
      
      JSON is data-only language-independent specification, so some JavaScript-specific object properties are skipped by JSON.stringify.
Namely:

Function properties (methods).
Symbolic keys and values.
Properties that store undefined.


      
        
        
          
            
          
          
            
          
        
        
          let user = {
  sayHi() { // ignored
    alert("Hello");
  },
  [Symbol("id")]: 123, // ignored
  something: undefined // ignored
};

alert( JSON.stringify(user) ); // {} (empty object)
        
      
      
      Usually that’s fine. If that’s not what we want, then soon we’ll see how to customize the process.
The great thing is that nested objects are supported and converted automatically.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* The whole structure is stringified:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
        
      
      
      The important limitation: there must be no circular references.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup references room
room.occupiedBy = meetup; // room references meetup

JSON.stringify(meetup); // Error: Converting circular structure to JSON
        
      
      
      Here, the conversion fails, because of circular reference: room.occupiedBy references meetup, and meetup.place references room:

      
      
        
      
      Excluding and transforming: replacerThe full syntax of JSON.stringify is:

      
        
        
          let json = JSON.stringify(value[, replacer, space])
        
      
      
      
value
A value to encode.
replacer
Array of properties to encode or a mapping function function(key, value).
space
Amount of space to use for formatting

Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.
If we pass an array of properties to it, only these properties will be encoded.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}
        
      
      
      Here we are probably too strict. The property list is applied to the whole object structure. So the objects in participants are empty, because name is not in the list.
Let’s include in the list every property except room.occupiedBy that would cause the circular reference:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Now everything except occupiedBy is serialized. But the list of properties is quite long.
Fortunately, we can use a function instead of an array as the replacer.
The function will be called for every (key, value) pair and should return the “replaced” value, which will be used instead of the original one. Or undefined if the value is to be skipped.
In our case, we can return value “as is” for everything except occupiedBy. To ignore occupiedBy, the code below returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
occupiedBy: [object Object]
*/
        
      
      
      Please note that replacer function gets every key/value pair including nested objects and array items. It is applied recursively. The value of this inside replacer is the object that contains the current property.
The first call is special. It is made using a special “wrapper object”: {"": meetup}. In other words, the first (key, value) pair has an empty key, and the value is the target object as a whole. That’s why the first line is ":[object Object]" in the example above.
The idea is to provide as much power for replacer as possible: it has a chance to analyze and replace/skip even the whole object if necessary.
Formatting: spaceThe third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.
Previously, all stringified objects had no indents and extra spaces. That’s fine if we want to send an object over a network. The space argument is used exclusively for a nice output.
Here space = 2 tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* two-space indents:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* for JSON.stringify(user, null, 4) the result would be more indented:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
        
      
      
      The third argument can also be a string. In this case, the string is used for indentation instead of a number of spaces.
The space parameter is used solely for logging and nice-output purposes.
Custom “toJSON”Like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
        
      
      
      Here we can see that date (1) became a string. That’s because all dates have a built-in toJSON method which returns such kind of string.
Now let’s add a custom toJSON for our object room (2):

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
        
      
      
      As we can see, toJSON is used both for the direct call JSON.stringify(room) and when room is nested in another encoded object.
JSON.parseTo decode a JSON-string, we need another method named JSON.parse.
The syntax:

      
        
        
          let value = JSON.parse(str[, reviver]);
        
      
      
      
str
JSON-string to parse.
reviver
Optional function(key,value) that will be called for each (key, value) pair and can transform the value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          // stringified array
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
        
      
      
      Or for nested objects:

      
        
        
          
            
          
          
            
          
        
        
          let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
        
      
      
      The JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the same JSON format.
Here are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):

      
        
        
          let json = `{
  name: "John",                     // mistake: property name without quotes
  "surname": 'Smith',               // mistake: single quotes in value (must be double)
  'isAdmin': false                  // mistake: single quotes in key (must be double)
  "birthday": new Date(2000, 2, 3), // mistake: no "new" is allowed, only bare values
  "friends": [0,1,2,3]              // here all fine
}`;
        
      
      
      Besides, JSON does not support comments. Adding a comment to JSON makes it invalid.
There’s another format named JSON5, which allows unquoted keys, comments etc. But this is a standalone library, not in the specification of the language.
The regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.
Using reviverImagine, we got a stringified meetup object from the server.
It looks like this:

      
        
        
          // title: (meetup title), date: (meetup date)
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        
      
      
      …And now we need to deserialize it, to turn back into JavaScript object.
Let’s do it by calling JSON.parse:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!
        
      
      
      Whoops! An error!
The value of meetup.date is a string, not a Date object. How could JSON.parse know that it should transform that string into a Date?
Let’s pass to JSON.parse the reviving function as the second argument, that returns all values “as is”, but date will become a Date:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // now works!
        
      
      
      By the way, that works for nested objects as well:

      
        
        
          
            
          
          
            
          
        
        
          let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // works!
        
      
      
      Summary
JSON is a data format that has its own independent standard and libraries for most programming languages.
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.

TasksTurn the object into JSON and backimportance: 5Turn the user into JSON and then read it back into another variable.

      
        
        
          let user = {
  name: "John Smith",
  age: 35
};
        
      
      
      solution
      
        
        
          let user = {
  name: "John Smith",
  age: 35
};

let user2 = JSON.parse(JSON.stringify(user));
        
      
      
      Exclude backreferencesimportance: 5In simple cases of circular references, we can exclude an offending property from serialization by its name.
But sometimes we can’t just use the name, as it may be used both in circular references and normal properties. So we can check the property by its value.
Write replacer function to stringify everything, but remove properties that reference meetup:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

// circular references
room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  /* your code */
}));

/* result should be:
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  return (key != "" && value == meetup) ? undefined : value;
}));

/*
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Here we also need to test key=="" to exclude the first call where it is normal that value is meetup.\n\nTutorialThe JavaScript languageData typesJanuary 24, 2024JSON methods, toJSONLet’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.
Naturally, such a string should include all important properties.
We could implement the conversion like this:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  toString() {
    return `{name: "${this.name}", age: ${this.age}}`;
  }
};

alert(user); // {name: "John", age: 30}
        
      
      
      …But in the process of development, new properties are added, old properties are renamed and removed. Updating such toString every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We’d need to implement their conversion as well.
Luckily, there’s no need to write the code to handle all this. The task has been solved already.
JSON.stringifyThe JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well.  So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.
JavaScript provides methods:

JSON.stringify to convert objects into JSON.
JSON.parse to convert JSON back into an object.

For instance, here we JSON.stringify a student:

      
        
        
          
            
          
          
            
          
        
        
          let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);

alert(typeof json); // we've got a string!

alert(json);
/* JSON-encoded object:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
*/
        
      
      
      The method JSON.stringify(student) takes the object and converts it into a string.
The resulting json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.
Please note that a JSON-encoded object has several important differences from the object literal:

Strings use double quotes. No single quotes or backticks in JSON. So 'John' becomes "John".
Object property names are double-quoted also. That’s obligatory. So age:30 becomes "age":30.

JSON.stringify can be applied to primitives as well.
JSON supports following data types:

Objects { ... }
Arrays [ ... ]
Primitives:

strings,
numbers,
boolean values true/false,
null.



For instance:

      
        
        
          
            
          
          
            
          
        
        
          // a number in JSON is just a number
alert( JSON.stringify(1) ) // 1

// a string in JSON is still a string, but double-quoted
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
        
      
      
      JSON is data-only language-independent specification, so some JavaScript-specific object properties are skipped by JSON.stringify.
Namely:

Function properties (methods).
Symbolic keys and values.
Properties that store undefined.


      
        
        
          
            
          
          
            
          
        
        
          let user = {
  sayHi() { // ignored
    alert("Hello");
  },
  [Symbol("id")]: 123, // ignored
  something: undefined // ignored
};

alert( JSON.stringify(user) ); // {} (empty object)
        
      
      
      Usually that’s fine. If that’s not what we want, then soon we’ll see how to customize the process.
The great thing is that nested objects are supported and converted automatically.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* The whole structure is stringified:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
        
      
      
      The important limitation: there must be no circular references.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup references room
room.occupiedBy = meetup; // room references meetup

JSON.stringify(meetup); // Error: Converting circular structure to JSON
        
      
      
      Here, the conversion fails, because of circular reference: room.occupiedBy references meetup, and meetup.place references room:

      
      
        
      
      Excluding and transforming: replacerThe full syntax of JSON.stringify is:

      
        
        
          let json = JSON.stringify(value[, replacer, space])
        
      
      
      
value
A value to encode.
replacer
Array of properties to encode or a mapping function function(key, value).
space
Amount of space to use for formatting

Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.
If we pass an array of properties to it, only these properties will be encoded.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}
        
      
      
      Here we are probably too strict. The property list is applied to the whole object structure. So the objects in participants are empty, because name is not in the list.
Let’s include in the list every property except room.occupiedBy that would cause the circular reference:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Now everything except occupiedBy is serialized. But the list of properties is quite long.
Fortunately, we can use a function instead of an array as the replacer.
The function will be called for every (key, value) pair and should return the “replaced” value, which will be used instead of the original one. Or undefined if the value is to be skipped.
In our case, we can return value “as is” for everything except occupiedBy. To ignore occupiedBy, the code below returns undefined:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup references room
};

room.occupiedBy = meetup; // room references meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
occupiedBy: [object Object]
*/
        
      
      
      Please note that replacer function gets every key/value pair including nested objects and array items. It is applied recursively. The value of this inside replacer is the object that contains the current property.
The first call is special. It is made using a special “wrapper object”: {"": meetup}. In other words, the first (key, value) pair has an empty key, and the value is the target object as a whole. That’s why the first line is ":[object Object]" in the example above.
The idea is to provide as much power for replacer as possible: it has a chance to analyze and replace/skip even the whole object if necessary.
Formatting: spaceThe third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.
Previously, all stringified objects had no indents and extra spaces. That’s fine if we want to send an object over a network. The space argument is used exclusively for a nice output.
Here space = 2 tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* two-space indents:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* for JSON.stringify(user, null, 4) the result would be more indented:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
        
      
      
      The third argument can also be a string. In this case, the string is used for indentation instead of a number of spaces.
The space parameter is used solely for logging and nice-output purposes.
Custom “toJSON”Like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.
For instance:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
        
      
      
      Here we can see that date (1) became a string. That’s because all dates have a built-in toJSON method which returns such kind of string.
Now let’s add a custom toJSON for our object room (2):

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
        
      
      
      As we can see, toJSON is used both for the direct call JSON.stringify(room) and when room is nested in another encoded object.
JSON.parseTo decode a JSON-string, we need another method named JSON.parse.
The syntax:

      
        
        
          let value = JSON.parse(str[, reviver]);
        
      
      
      
str
JSON-string to parse.
reviver
Optional function(key,value) that will be called for each (key, value) pair and can transform the value.

For instance:

      
        
        
          
            
          
          
            
          
        
        
          // stringified array
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
        
      
      
      Or for nested objects:

      
        
        
          
            
          
          
            
          
        
        
          let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
        
      
      
      The JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the same JSON format.
Here are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):

      
        
        
          let json = `{
  name: "John",                     // mistake: property name without quotes
  "surname": 'Smith',               // mistake: single quotes in value (must be double)
  'isAdmin': false                  // mistake: single quotes in key (must be double)
  "birthday": new Date(2000, 2, 3), // mistake: no "new" is allowed, only bare values
  "friends": [0,1,2,3]              // here all fine
}`;
        
      
      
      Besides, JSON does not support comments. Adding a comment to JSON makes it invalid.
There’s another format named JSON5, which allows unquoted keys, comments etc. But this is a standalone library, not in the specification of the language.
The regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.
Using reviverImagine, we got a stringified meetup object from the server.
It looks like this:

      
        
        
          // title: (meetup title), date: (meetup date)
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        
      
      
      …And now we need to deserialize it, to turn back into JavaScript object.
Let’s do it by calling JSON.parse:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!
        
      
      
      Whoops! An error!
The value of meetup.date is a string, not a Date object. How could JSON.parse know that it should transform that string into a Date?
Let’s pass to JSON.parse the reviving function as the second argument, that returns all values “as is”, but date will become a Date:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // now works!
        
      
      
      By the way, that works for nested objects as well:

      
        
        
          
            
          
          
            
          
        
        
          let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // works!
        
      
      
      Summary
JSON is a data format that has its own independent standard and libraries for most programming languages.
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.

TasksTurn the object into JSON and backimportance: 5Turn the user into JSON and then read it back into another variable.

      
        
        
          let user = {
  name: "John Smith",
  age: 35
};
        
      
      
      solution
      
        
        
          let user = {
  name: "John Smith",
  age: 35
};

let user2 = JSON.parse(JSON.stringify(user));
        
      
      
      Exclude backreferencesimportance: 5In simple cases of circular references, we can exclude an offending property from serialization by its name.
But sometimes we can’t just use the name, as it may be used both in circular references and normal properties. So we can check the property by its value.
Write replacer function to stringify everything, but remove properties that reference meetup:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

// circular references
room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  /* your code */
}));

/* result should be:
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      solution
      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  return (key != "" && value == meetup) ? undefined : value;
}));

/*
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Here we also need to test key=="" to exclude the first call where it is normal that value is meetup.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\nTutorialThe JavaScript languageAdvanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedPrevious lessonNext lessonShareTutorial map\n\nRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisited\n\nTutorialThe JavaScript languageAdvanced working with functionsRecursion and stackRest parameters and spread syntaxVariable scope, closureThe old "var"Global objectFunction object, NFEThe "new Function" syntaxScheduling: setTimeout and setIntervalDecorators and forwarding, call/applyFunction bindingArrow functions revisitedPrevious lessonNext lessonShareTutorial map\n\n\n\nLet’s return to functions and study them more in-depth.
Our first topic will be recursion.
If you are not new to programming, then it is probably familiar and you could skip this chapter.
Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.
When a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.
Two ways of thinkingFor something simple to start with – let’s write a function pow(x, n) that raises x to a natural power of n. In other words, multiplies x by itself n times.

      
        
        
          pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
        
      
      
      There are two ways to implement it.


Iterative thinking: the for loop:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = 1;

  // multiply result by x n times in the loop
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
        
      
      
      

Recursive thinking: simplify the task and call self:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
        
      
      
      

Please note how the recursive variant is fundamentally different.
When pow(x, n) is called, the execution splits into two branches:

      
        
        
                        if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
        
      
      
      
If n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.
Otherwise, we can represent pow(x, n) as x * pow(x, n - 1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pow with lower n). Next steps simplify it further and further until n reaches 1.

We can also say that pow recursively calls itself till n == 1.

      
      
        
      
      For example, to calculate pow(2, 4) the recursive variant does these steps:

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

So, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.

            Recursion is usually shorter
            A recursive solution is usually shorter than an iterative one.
Here we can rewrite the same using the conditional operator ? instead of if to make pow(x, n) more terse and still very readable:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
        
      
      
      
The maximal number of nested calls (including the first one) is called recursion depth. In our case, it will be exactly n.
The maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.
That limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.
The execution context and stackNow let’s examine how recursive calls work. For that we’ll look under the hood of functions.
The information about the process of execution of a running function is stored in its execution context.
The execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of this (we don’t use it here) and few other internal details.
One function call has exactly one execution context associated with it.
When a function makes a nested call, the following happens:

The current function is paused.
The execution context associated with it is remembered in a special data structure called execution context stack.
The nested call executes.
After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.

Let’s see what happens during the pow(2, 3) call.
pow(2, 3)In the beginning of the call pow(2, 3) the execution context will store variables: x = 2, n = 3, the execution flow is at line 1 of the function.
We can sketch it as:

  
    Context: { x: 2, n: 3, at line 1 }
    pow(2, 3)
  

That’s when the function starts to execute. The condition n == 1 is falsy, so the flow continues into the second branch of if:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
        
      
      
      The variables are same, but the line changes, so the context is now:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

To calculate x * pow(x, n - 1), we need to make a subcall of pow with new arguments pow(2, 2).
pow(2, 2)To do a nested call, JavaScript remembers the current execution context in the execution context stack.
Here we call the same function pow, but it absolutely doesn’t matter. The process is the same for all functions:

The current context is “remembered” on top of the stack.
The new context is created for the subcall.
When the subcall is finished – the previous context is popped from the stack, and its execution continues.

Here’s the context stack when we entered the subcall pow(2, 2):

  
    Context: { x: 2, n: 2, at line 1 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The new current execution context is on top (and bold), and previous remembered contexts are below.
When we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped.

            Please note:
            Here in the picture we use the word “line”, as in our example there’s only one subcall in line, but generally a single line of code may contain multiple subcalls, like pow(…) + pow(…) + somethingElse(…).
So it would be more precise to say that the execution resumes “immediately after the subcall”.

pow(2, 1)The process repeats: a new subcall is made at line 5, now with arguments x=2, n=1.
A new execution context is created, the previous one is pushed on top of the stack:

  
    Context: { x: 2, n: 1, at line 1 }
    pow(2, 1)
  
  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

There are 2 old contexts now and 1 currently running for pow(2, 1).
The exitDuring the execution of pow(2, 1), unlike before, the condition n == 1 is truthy, so the first branch of if works:

      
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
        
      
      
      There are no more nested calls, so the function finishes, returning 2.
As the function finishes, its execution context is not needed anymore, so it’s removed from the memory. The previous one is restored off the top of the stack:

  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The execution of pow(2, 2) is resumed. It has the result of the subcall pow(2, 1), so it also can finish the evaluation of x * pow(x, n - 1), returning 4.
Then the previous context is restored:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

When it finishes, we have a result of pow(2, 3) = 8.
The recursion depth in this case was: 3.
As we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.
Note the memory requirements. Contexts take memory. In our case, raising to the power of n actually requires the memory for n contexts, for all lower values of n.
A loop-based algorithm is more memory-saving:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The iterative pow uses a single context changing i and result in the process. Its memory requirements are small, fixed and do not depend on n.
Any recursion can be rewritten as a loop. The loop variant usually can be made more effective.
…But sometimes the rewrite is non-trivial, especially when a function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.
Recursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.
Recursive traversalsAnother great application of the recursion is a recursive traversal.
Imagine, we have a company. The staff structure can be presented as an object:

      
        
        
          let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
        
      
      
      In other words, a company has departments.


A department may have an array of staff. For instance, sales department has 2 employees: John and Alice.


Or a department may split into subdepartments, like development has two branches: sites and internals. Each of them has their own staff.


It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).
For instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That’s not on the picture, just something to have in mind.


Now let’s say we want a function to get the sum of all salaries. How can we do that?
An iterative approach is not easy, because the structure is not simple. The first idea may be to make a for loop over company with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like sites… And then another subloop inside those for 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.
Let’s try recursion.
As we can see, when our function gets a department to sum, there are two possible cases:

Either it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.
Or it’s an object with N subdepartments – then we can make N recursive calls to get the sum for each of the subdeps and combine the results.

The 1st case is the base of recursion, the trivial case, when we get an array.
The 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).
The algorithm is probably even easier to read from the code:

      
        
        
          
            
          
          
            
          
        
        
          let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// The function to do the job
function sumSalaries(department) {
  if (Array.isArray(department)) { // case (1)
    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array
  } else { // case (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
        
      
      
      The code is short and easy to understand (hopefully?). That’s the power of recursion. It also works for any level of subdepartment nesting.
Here’s the diagram of calls:

      
      
        
      
      We can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the “leaves” of the recursion tree, they give immediate result.
Note that the code uses smart features that we’ve covered before:

Method arr.reduce explained in the chapter Array methods to get the sum of the array.
Loop for(val of Object.values(obj)) to iterate over object values: Object.values returns an array of them.

Recursive structuresA recursive (recursively-defined) data structure is a structure that replicates itself in parts.
We’ve just seen it in the example of a company structure above.
A company department is:

Either an array of people.
Or an object with departments.

For web-developers there are much better-known examples: HTML and XML documents.
In the HTML document, an HTML-tag may contain a list of:

Text pieces.
HTML-comments.
Other HTML-tags (that in turn may contain text pieces/comments or other tags etc).

That’s once again a recursive definition.
For better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.
Linked listImagine, we want to store an ordered list of objects.
The natural choice would be an array:

      
        
        
          let arr = [obj1, obj2, obj3];
        
      
      
      …But there’s a problem with arrays. The “delete element” and “insert element” operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().
The only structural modifications that do not require mass-renumbering are those that operate with the end of array: arr.push/pop. So an array can be quite slow for big queues, when we have to work with the beginning.
Alternatively, if we really need fast insertion/deletion, we can choose another data structure called a linked list.
The linked list element is recursively defined as an object with:

value.
next property referencing the next linked list element or null if that’s the end.

For instance:

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Graphical representation of the list:

      
      
        
      
      An alternative code for creation:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
        
      
      
      Here we can even more clearly see that there are multiple objects, each one has the value and next pointing to the neighbour. The list variable is the first object in the chain, so following next pointers from it we can reach any element.
The list can be easily split into multiple parts and later joined back:

      
        
        
          let secondList = list.next.next;
list.next.next = null;
        
      
      
      
      
      
        
      
      To join:

      
        
        
          list.next.next = secondList;
        
      
      
      And surely we can insert or remove items in any place.
For instance, to prepend a new value, we need to update the head of the list:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// prepend the new value to the list
list = { value: "new item", next: list };
        
      
      
      
      
      
        
      
      To remove a value from the middle, change next of the previous one:

      
        
        
          list.next = list.next.next;
        
      
      
      
      
      
        
      
      We made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory.
Unlike arrays, there’s no mass-renumbering, we can easily rearrange elements.
Naturally, lists are not always better than arrays. Otherwise everyone would use only lists.
The main drawback is that we can’t easily access an element by its number. In an array that’s easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.
…But we don’t always need such operations. For instance, when we need a queue or even a deque – the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.
Lists can be enhanced:

We can add property prev in addition to next to reference the previous element, to move back easily.
We can also add a variable named tail referencing the last element of the list (and update it when adding/removing elements from the end).
…The data structure may vary according to our needs.

SummaryTerms:


Recursion  is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways.
When a function calls itself, that’s called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.


A recursively-defined data structure is a data structure that can be defined using itself.
For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).

      
        
        
          list = { value, next -> list }
        
      
      
      Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they have branches and every branch can have other branches.
Recursive functions can be used to walk them as we’ve seen in the sumSalary example.


Any recursive function can be rewritten into an iterative one. And that’s sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support.\n\nTutorialThe JavaScript languageAdvanced working with functionsOctober 1, 2022Recursion and stackLet’s return to functions and study them more in-depth.
Our first topic will be recursion.
If you are not new to programming, then it is probably familiar and you could skip this chapter.
Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.
When a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.
Two ways of thinkingFor something simple to start with – let’s write a function pow(x, n) that raises x to a natural power of n. In other words, multiplies x by itself n times.

      
        
        
          pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
        
      
      
      There are two ways to implement it.


Iterative thinking: the for loop:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = 1;

  // multiply result by x n times in the loop
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
        
      
      
      

Recursive thinking: simplify the task and call self:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
        
      
      
      

Please note how the recursive variant is fundamentally different.
When pow(x, n) is called, the execution splits into two branches:

      
        
        
                        if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
        
      
      
      
If n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.
Otherwise, we can represent pow(x, n) as x * pow(x, n - 1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pow with lower n). Next steps simplify it further and further until n reaches 1.

We can also say that pow recursively calls itself till n == 1.

      
      
        
      
      For example, to calculate pow(2, 4) the recursive variant does these steps:

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

So, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.

            Recursion is usually shorter
            A recursive solution is usually shorter than an iterative one.
Here we can rewrite the same using the conditional operator ? instead of if to make pow(x, n) more terse and still very readable:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
        
      
      
      
The maximal number of nested calls (including the first one) is called recursion depth. In our case, it will be exactly n.
The maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.
That limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.
The execution context and stackNow let’s examine how recursive calls work. For that we’ll look under the hood of functions.
The information about the process of execution of a running function is stored in its execution context.
The execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of this (we don’t use it here) and few other internal details.
One function call has exactly one execution context associated with it.
When a function makes a nested call, the following happens:

The current function is paused.
The execution context associated with it is remembered in a special data structure called execution context stack.
The nested call executes.
After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.

Let’s see what happens during the pow(2, 3) call.
pow(2, 3)In the beginning of the call pow(2, 3) the execution context will store variables: x = 2, n = 3, the execution flow is at line 1 of the function.
We can sketch it as:

  
    Context: { x: 2, n: 3, at line 1 }
    pow(2, 3)
  

That’s when the function starts to execute. The condition n == 1 is falsy, so the flow continues into the second branch of if:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
        
      
      
      The variables are same, but the line changes, so the context is now:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

To calculate x * pow(x, n - 1), we need to make a subcall of pow with new arguments pow(2, 2).
pow(2, 2)To do a nested call, JavaScript remembers the current execution context in the execution context stack.
Here we call the same function pow, but it absolutely doesn’t matter. The process is the same for all functions:

The current context is “remembered” on top of the stack.
The new context is created for the subcall.
When the subcall is finished – the previous context is popped from the stack, and its execution continues.

Here’s the context stack when we entered the subcall pow(2, 2):

  
    Context: { x: 2, n: 2, at line 1 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The new current execution context is on top (and bold), and previous remembered contexts are below.
When we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped.

            Please note:
            Here in the picture we use the word “line”, as in our example there’s only one subcall in line, but generally a single line of code may contain multiple subcalls, like pow(…) + pow(…) + somethingElse(…).
So it would be more precise to say that the execution resumes “immediately after the subcall”.

pow(2, 1)The process repeats: a new subcall is made at line 5, now with arguments x=2, n=1.
A new execution context is created, the previous one is pushed on top of the stack:

  
    Context: { x: 2, n: 1, at line 1 }
    pow(2, 1)
  
  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

There are 2 old contexts now and 1 currently running for pow(2, 1).
The exitDuring the execution of pow(2, 1), unlike before, the condition n == 1 is truthy, so the first branch of if works:

      
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
        
      
      
      There are no more nested calls, so the function finishes, returning 2.
As the function finishes, its execution context is not needed anymore, so it’s removed from the memory. The previous one is restored off the top of the stack:

  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The execution of pow(2, 2) is resumed. It has the result of the subcall pow(2, 1), so it also can finish the evaluation of x * pow(x, n - 1), returning 4.
Then the previous context is restored:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

When it finishes, we have a result of pow(2, 3) = 8.
The recursion depth in this case was: 3.
As we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.
Note the memory requirements. Contexts take memory. In our case, raising to the power of n actually requires the memory for n contexts, for all lower values of n.
A loop-based algorithm is more memory-saving:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The iterative pow uses a single context changing i and result in the process. Its memory requirements are small, fixed and do not depend on n.
Any recursion can be rewritten as a loop. The loop variant usually can be made more effective.
…But sometimes the rewrite is non-trivial, especially when a function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.
Recursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.
Recursive traversalsAnother great application of the recursion is a recursive traversal.
Imagine, we have a company. The staff structure can be presented as an object:

      
        
        
          let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
        
      
      
      In other words, a company has departments.


A department may have an array of staff. For instance, sales department has 2 employees: John and Alice.


Or a department may split into subdepartments, like development has two branches: sites and internals. Each of them has their own staff.


It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).
For instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That’s not on the picture, just something to have in mind.


Now let’s say we want a function to get the sum of all salaries. How can we do that?
An iterative approach is not easy, because the structure is not simple. The first idea may be to make a for loop over company with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like sites… And then another subloop inside those for 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.
Let’s try recursion.
As we can see, when our function gets a department to sum, there are two possible cases:

Either it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.
Or it’s an object with N subdepartments – then we can make N recursive calls to get the sum for each of the subdeps and combine the results.

The 1st case is the base of recursion, the trivial case, when we get an array.
The 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).
The algorithm is probably even easier to read from the code:

      
        
        
          
            
          
          
            
          
        
        
          let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// The function to do the job
function sumSalaries(department) {
  if (Array.isArray(department)) { // case (1)
    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array
  } else { // case (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
        
      
      
      The code is short and easy to understand (hopefully?). That’s the power of recursion. It also works for any level of subdepartment nesting.
Here’s the diagram of calls:

      
      
        
      
      We can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the “leaves” of the recursion tree, they give immediate result.
Note that the code uses smart features that we’ve covered before:

Method arr.reduce explained in the chapter Array methods to get the sum of the array.
Loop for(val of Object.values(obj)) to iterate over object values: Object.values returns an array of them.

Recursive structuresA recursive (recursively-defined) data structure is a structure that replicates itself in parts.
We’ve just seen it in the example of a company structure above.
A company department is:

Either an array of people.
Or an object with departments.

For web-developers there are much better-known examples: HTML and XML documents.
In the HTML document, an HTML-tag may contain a list of:

Text pieces.
HTML-comments.
Other HTML-tags (that in turn may contain text pieces/comments or other tags etc).

That’s once again a recursive definition.
For better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.
Linked listImagine, we want to store an ordered list of objects.
The natural choice would be an array:

      
        
        
          let arr = [obj1, obj2, obj3];
        
      
      
      …But there’s a problem with arrays. The “delete element” and “insert element” operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().
The only structural modifications that do not require mass-renumbering are those that operate with the end of array: arr.push/pop. So an array can be quite slow for big queues, when we have to work with the beginning.
Alternatively, if we really need fast insertion/deletion, we can choose another data structure called a linked list.
The linked list element is recursively defined as an object with:

value.
next property referencing the next linked list element or null if that’s the end.

For instance:

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Graphical representation of the list:

      
      
        
      
      An alternative code for creation:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
        
      
      
      Here we can even more clearly see that there are multiple objects, each one has the value and next pointing to the neighbour. The list variable is the first object in the chain, so following next pointers from it we can reach any element.
The list can be easily split into multiple parts and later joined back:

      
        
        
          let secondList = list.next.next;
list.next.next = null;
        
      
      
      
      
      
        
      
      To join:

      
        
        
          list.next.next = secondList;
        
      
      
      And surely we can insert or remove items in any place.
For instance, to prepend a new value, we need to update the head of the list:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// prepend the new value to the list
list = { value: "new item", next: list };
        
      
      
      
      
      
        
      
      To remove a value from the middle, change next of the previous one:

      
        
        
          list.next = list.next.next;
        
      
      
      
      
      
        
      
      We made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory.
Unlike arrays, there’s no mass-renumbering, we can easily rearrange elements.
Naturally, lists are not always better than arrays. Otherwise everyone would use only lists.
The main drawback is that we can’t easily access an element by its number. In an array that’s easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.
…But we don’t always need such operations. For instance, when we need a queue or even a deque – the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.
Lists can be enhanced:

We can add property prev in addition to next to reference the previous element, to move back easily.
We can also add a variable named tail referencing the last element of the list (and update it when adding/removing elements from the end).
…The data structure may vary according to our needs.

SummaryTerms:


Recursion  is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways.
When a function calls itself, that’s called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.


A recursively-defined data structure is a data structure that can be defined using itself.
For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).

      
        
        
          list = { value, next -> list }
        
      
      
      Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they have branches and every branch can have other branches.
Recursive functions can be used to walk them as we’ve seen in the sumSalary example.


Any recursive function can be rewritten into an iterative one. And that’s sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support.
TasksSum all numbers till the given oneimportance: 5Write a function sumTo(n) that calculates the sum of numbers 1 + 2 + ... + n.
For instance:

      
        
        
          sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
        
      
      
      Make 3 solution variants:

Using a for loop.
Using a recursion, cause sumTo(n) = n + sumTo(n-1) for n > 1.
Using the arithmetic progression formula.

An example of the result:

      
        
        
          function sumTo(n) { /*... your code ... */ }

alert( sumTo(100) ); // 5050
        
      
      
      P.S. Which solution variant is the fastest? The slowest? Why?
P.P.S. Can we use recursion to count sumTo(100000)?
solutionThe solution using a loop:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
        
      
      
      The solution using recursion:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
        
      
      
      The solution using the formula: sumTo(n) = n*(n+1)/2:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
        
      
      
      P.S. Naturally, the formula is the fastest solution. It uses only 3 operations for any number n. The math helps!
The loop variant is the second in terms of speed. In both the recursive and the loop variant we sum the same numbers. But the recursion involves nested calls and execution stack management. That also takes resources, so it’s slower.
P.P.S. Some engines support the “tail call” optimization: if a recursive call is the very last one in the function, with no other calculations performed, then the outer function will not need to resume the execution, so the engine doesn’t need to remember its execution context. That removes the burden on memory. But if the JavaScript engine does not support tail call optimization (most of them don’t), there will be an error: maximum stack size exceeded, because there’s usually a limitation on the total stack size.
Calculate factorialimportance: 4The factorial of a natural number is a number multiplied by "number minus one", then by "number minus two", and so on till 1. The factorial of n is denoted as n!
We can write a definition of factorial like this:

      
        
        
          n! = n * (n - 1) * (n - 2) * ...*1
        
      
      
      Values of factorials for different n:

      
        
        
          1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
        
      
      
      The task is to write a function factorial(n) that calculates n! using recursive calls.

      
        
        
          alert( factorial(5) ); // 120
        
      
      
      P.S. Hint: n! can be written as n * (n-1)! For instance: 3! = 3*2! = 3*2*1! = 6
solutionBy definition, a factorial n! can be written as n * (n-1)!.
In other words, the result of factorial(n) can be calculated as n multiplied by the result of factorial(n-1). And the call for n-1 can recursively descend lower, and lower, till 1.

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      The basis of recursion is the value 1. We can also make 0 the basis here, doesn’t matter much, but gives one more recursive step:

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      Fibonacci numbersimportance: 5The sequence of Fibonacci numbers has the formula Fn = Fn-1 + Fn-2. In other words, the next number is a sum of the two preceding ones.
First two numbers are 1, then 2(1+1), then 3(1+2), 5(2+3) and so on: 1, 1, 2, 3, 5, 8, 13, 21....
Fibonacci numbers are related to the Golden ratio and many natural phenomena around us.
Write a function fib(n) that returns the n-th Fibonacci number.
An example of work:

      
        
        
          function fib(n) { /* your code */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
        
      
      
      P.S. The function should be fast. The call to fib(77) should take no more than a fraction of a second.
solutionThe first solution we could try here is the recursive one.
Fibonacci numbers are recursive by definition:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // will be extremely slow!
        
      
      
      …But for big values of n it’s very slow. For instance, fib(77) may hang up the engine for some time eating all CPU resources.
That’s because the function makes too many subcalls. The same values are re-evaluated again and again.
For instance, let’s see a piece of calculations for fib(5):

      
        
        
          ...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...
        
      
      
      Here we can see that the value of fib(3) is needed for both fib(5) and fib(4). So fib(3) will be called and evaluated two times completely independently.
Here’s the full recursion tree:

      
      
        
      
      We can clearly notice that fib(3) is evaluated two times and fib(2) is evaluated three times. The total amount of computations grows much faster than n, making it enormous even for n=77.
We can optimize that by remembering already-evaluated values: if a value of say fib(3) is calculated once, then we can just reuse it in future computations.
Another variant would be to give up recursion and use a totally different loop-based algorithm.
Instead of going from n down to lower values, we can make a loop that starts from 1 and 2, then gets fib(3) as their sum, then fib(4) as the sum of two previous values, then fib(5) and goes up and up, till it gets to the needed value. On each step we only need to remember two previous values.
Here are the steps of the new algorithm in details.
The start:

      
        
        
          // a = fib(1), b = fib(2), these values are by definition 1
let a = 1, b = 1;

// get c = fib(3) as their sum
let c = a + b;

/* we now have fib(1), fib(2), fib(3)
a  b  c
1, 1, 2
*/
        
      
      
      Now we want to get fib(4) = fib(2) + fib(3).
Let’s shift the variables: a,b will get fib(2),fib(3), and c will get their sum:

      
        
        
          a = b; // now a = fib(2)
b = c; // now b = fib(3)
c = a + b; // c = fib(4)

/* now we have the sequence:
   a  b  c
1, 1, 2, 3
*/
        
      
      
      The next step gives another sequence number:

      
        
        
          a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)

/* now the sequence is (one more number):
      a  b  c
1, 1, 2, 3, 5
*/
        
      
      
      …And so on until we get the needed value. That’s much faster than recursion and involves no duplicate computations.
The full code:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
        
      
      
      The loop starts with i=3, because the first and the second sequence values are hard-coded into variables a=1, b=1.
The approach is called dynamic programming bottom-up.
Output a single-linked listimportance: 5Let’s say we have a single-linked list (as described in the chapter Recursion and stack):

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Write a function printList(list) that outputs list items one-by-one.
Make two variants of the solution: using a loop and using recursion.
What’s better: with recursion or without it?
solutionLoop-based solutionLoop-based solutionThe loop-based variant of the solution:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);
        
      
      
      Please note that we use a temporary variable tmp to walk over the list. Technically, we could use a function parameter list instead:

      
        
        
          function printList(list) {

  while(list) {
    alert(list.value);
    list = list.next;
  }

}
        
      
      
      …But that would be unwise. In the future we may need to extend a function, do something else with the list. If we change list, then we lose such ability.
Talking about good variable names, list here is the list itself. The first element of it. And it should remain like that. That’s clear and reliable.
From the other side, the role of tmp is exclusively a list traversal, like i in the for loop.
Recursive solutionRecursive solutionThe recursive variant of printList(list) follows a simple logic: to output a list we should output the current element list, then do the same for list.next:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert(list.value); // output the current item

  if (list.next) {
    printList(list.next); // do the same for the rest of the list
  }

}

printList(list);
        
      
      
      Now what’s better?
Technically, the loop is more effective. These two variants do the same, but the loop does not spend resources for nested function calls.
From the other side, the recursive variant is shorter and sometimes easier to understand.
Output a single-linked list in the reverse orderimportance: 5Output a single-linked list from the previous task Output a single-linked list in the reverse order.
Make two solutions: using a loop and using a recursion.
solutionUsing a recursionUsing a recursionThe recursive logic is a little bit tricky here.
We need to first output the rest of the list and then output the current one:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);
        
      
      
      Using a loopUsing a loopThe loop variant is also a little bit more complicated than the direct output.
There is no way to get the last value in our list. We also can’t “go back”.
So what we can do is to first go through the items in the direct order and remember them in an array, and then output what we remembered in the reverse order:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
        
      
      
      Please note that the recursive solution actually does exactly the same: it follows the list, remembers the items in the chain of nested calls (in the execution context stack), and then outputs them.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\nLet’s return to functions and study them more in-depth.
Our first topic will be recursion.
If you are not new to programming, then it is probably familiar and you could skip this chapter.
Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.
When a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.
Two ways of thinkingFor something simple to start with – let’s write a function pow(x, n) that raises x to a natural power of n. In other words, multiplies x by itself n times.

      
        
        
          pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
        
      
      
      There are two ways to implement it.


Iterative thinking: the for loop:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = 1;

  // multiply result by x n times in the loop
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
        
      
      
      

Recursive thinking: simplify the task and call self:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
        
      
      
      

Please note how the recursive variant is fundamentally different.
When pow(x, n) is called, the execution splits into two branches:

      
        
        
                        if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
        
      
      
      
If n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.
Otherwise, we can represent pow(x, n) as x * pow(x, n - 1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pow with lower n). Next steps simplify it further and further until n reaches 1.

We can also say that pow recursively calls itself till n == 1.

      
      
        
      
      For example, to calculate pow(2, 4) the recursive variant does these steps:

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

So, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.

            Recursion is usually shorter
            A recursive solution is usually shorter than an iterative one.
Here we can rewrite the same using the conditional operator ? instead of if to make pow(x, n) more terse and still very readable:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
        
      
      
      
The maximal number of nested calls (including the first one) is called recursion depth. In our case, it will be exactly n.
The maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.
That limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.
The execution context and stackNow let’s examine how recursive calls work. For that we’ll look under the hood of functions.
The information about the process of execution of a running function is stored in its execution context.
The execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of this (we don’t use it here) and few other internal details.
One function call has exactly one execution context associated with it.
When a function makes a nested call, the following happens:

The current function is paused.
The execution context associated with it is remembered in a special data structure called execution context stack.
The nested call executes.
After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.

Let’s see what happens during the pow(2, 3) call.
pow(2, 3)In the beginning of the call pow(2, 3) the execution context will store variables: x = 2, n = 3, the execution flow is at line 1 of the function.
We can sketch it as:

  
    Context: { x: 2, n: 3, at line 1 }
    pow(2, 3)
  

That’s when the function starts to execute. The condition n == 1 is falsy, so the flow continues into the second branch of if:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
        
      
      
      The variables are same, but the line changes, so the context is now:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

To calculate x * pow(x, n - 1), we need to make a subcall of pow with new arguments pow(2, 2).
pow(2, 2)To do a nested call, JavaScript remembers the current execution context in the execution context stack.
Here we call the same function pow, but it absolutely doesn’t matter. The process is the same for all functions:

The current context is “remembered” on top of the stack.
The new context is created for the subcall.
When the subcall is finished – the previous context is popped from the stack, and its execution continues.

Here’s the context stack when we entered the subcall pow(2, 2):

  
    Context: { x: 2, n: 2, at line 1 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The new current execution context is on top (and bold), and previous remembered contexts are below.
When we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped.

            Please note:
            Here in the picture we use the word “line”, as in our example there’s only one subcall in line, but generally a single line of code may contain multiple subcalls, like pow(…) + pow(…) + somethingElse(…).
So it would be more precise to say that the execution resumes “immediately after the subcall”.

pow(2, 1)The process repeats: a new subcall is made at line 5, now with arguments x=2, n=1.
A new execution context is created, the previous one is pushed on top of the stack:

  
    Context: { x: 2, n: 1, at line 1 }
    pow(2, 1)
  
  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

There are 2 old contexts now and 1 currently running for pow(2, 1).
The exitDuring the execution of pow(2, 1), unlike before, the condition n == 1 is truthy, so the first branch of if works:

      
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
        
      
      
      There are no more nested calls, so the function finishes, returning 2.
As the function finishes, its execution context is not needed anymore, so it’s removed from the memory. The previous one is restored off the top of the stack:

  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The execution of pow(2, 2) is resumed. It has the result of the subcall pow(2, 1), so it also can finish the evaluation of x * pow(x, n - 1), returning 4.
Then the previous context is restored:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

When it finishes, we have a result of pow(2, 3) = 8.
The recursion depth in this case was: 3.
As we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.
Note the memory requirements. Contexts take memory. In our case, raising to the power of n actually requires the memory for n contexts, for all lower values of n.
A loop-based algorithm is more memory-saving:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The iterative pow uses a single context changing i and result in the process. Its memory requirements are small, fixed and do not depend on n.
Any recursion can be rewritten as a loop. The loop variant usually can be made more effective.
…But sometimes the rewrite is non-trivial, especially when a function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.
Recursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.
Recursive traversalsAnother great application of the recursion is a recursive traversal.
Imagine, we have a company. The staff structure can be presented as an object:

      
        
        
          let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
        
      
      
      In other words, a company has departments.


A department may have an array of staff. For instance, sales department has 2 employees: John and Alice.


Or a department may split into subdepartments, like development has two branches: sites and internals. Each of them has their own staff.


It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).
For instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That’s not on the picture, just something to have in mind.


Now let’s say we want a function to get the sum of all salaries. How can we do that?
An iterative approach is not easy, because the structure is not simple. The first idea may be to make a for loop over company with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like sites… And then another subloop inside those for 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.
Let’s try recursion.
As we can see, when our function gets a department to sum, there are two possible cases:

Either it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.
Or it’s an object with N subdepartments – then we can make N recursive calls to get the sum for each of the subdeps and combine the results.

The 1st case is the base of recursion, the trivial case, when we get an array.
The 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).
The algorithm is probably even easier to read from the code:

      
        
        
          
            
          
          
            
          
        
        
          let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// The function to do the job
function sumSalaries(department) {
  if (Array.isArray(department)) { // case (1)
    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array
  } else { // case (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
        
      
      
      The code is short and easy to understand (hopefully?). That’s the power of recursion. It also works for any level of subdepartment nesting.
Here’s the diagram of calls:

      
      
        
      
      We can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the “leaves” of the recursion tree, they give immediate result.
Note that the code uses smart features that we’ve covered before:

Method arr.reduce explained in the chapter Array methods to get the sum of the array.
Loop for(val of Object.values(obj)) to iterate over object values: Object.values returns an array of them.

Recursive structuresA recursive (recursively-defined) data structure is a structure that replicates itself in parts.
We’ve just seen it in the example of a company structure above.
A company department is:

Either an array of people.
Or an object with departments.

For web-developers there are much better-known examples: HTML and XML documents.
In the HTML document, an HTML-tag may contain a list of:

Text pieces.
HTML-comments.
Other HTML-tags (that in turn may contain text pieces/comments or other tags etc).

That’s once again a recursive definition.
For better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.
Linked listImagine, we want to store an ordered list of objects.
The natural choice would be an array:

      
        
        
          let arr = [obj1, obj2, obj3];
        
      
      
      …But there’s a problem with arrays. The “delete element” and “insert element” operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().
The only structural modifications that do not require mass-renumbering are those that operate with the end of array: arr.push/pop. So an array can be quite slow for big queues, when we have to work with the beginning.
Alternatively, if we really need fast insertion/deletion, we can choose another data structure called a linked list.
The linked list element is recursively defined as an object with:

value.
next property referencing the next linked list element or null if that’s the end.

For instance:

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Graphical representation of the list:

      
      
        
      
      An alternative code for creation:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
        
      
      
      Here we can even more clearly see that there are multiple objects, each one has the value and next pointing to the neighbour. The list variable is the first object in the chain, so following next pointers from it we can reach any element.
The list can be easily split into multiple parts and later joined back:

      
        
        
          let secondList = list.next.next;
list.next.next = null;
        
      
      
      
      
      
        
      
      To join:

      
        
        
          list.next.next = secondList;
        
      
      
      And surely we can insert or remove items in any place.
For instance, to prepend a new value, we need to update the head of the list:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// prepend the new value to the list
list = { value: "new item", next: list };
        
      
      
      
      
      
        
      
      To remove a value from the middle, change next of the previous one:

      
        
        
          list.next = list.next.next;
        
      
      
      
      
      
        
      
      We made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory.
Unlike arrays, there’s no mass-renumbering, we can easily rearrange elements.
Naturally, lists are not always better than arrays. Otherwise everyone would use only lists.
The main drawback is that we can’t easily access an element by its number. In an array that’s easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.
…But we don’t always need such operations. For instance, when we need a queue or even a deque – the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.
Lists can be enhanced:

We can add property prev in addition to next to reference the previous element, to move back easily.
We can also add a variable named tail referencing the last element of the list (and update it when adding/removing elements from the end).
…The data structure may vary according to our needs.

SummaryTerms:


Recursion  is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways.
When a function calls itself, that’s called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.


A recursively-defined data structure is a data structure that can be defined using itself.
For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).

      
        
        
          list = { value, next -> list }
        
      
      
      Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they have branches and every branch can have other branches.
Recursive functions can be used to walk them as we’ve seen in the sumSalary example.


Any recursive function can be rewritten into an iterative one. And that’s sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support.
TasksSum all numbers till the given oneimportance: 5Write a function sumTo(n) that calculates the sum of numbers 1 + 2 + ... + n.
For instance:

      
        
        
          sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
        
      
      
      Make 3 solution variants:

Using a for loop.
Using a recursion, cause sumTo(n) = n + sumTo(n-1) for n > 1.
Using the arithmetic progression formula.

An example of the result:

      
        
        
          function sumTo(n) { /*... your code ... */ }

alert( sumTo(100) ); // 5050
        
      
      
      P.S. Which solution variant is the fastest? The slowest? Why?
P.P.S. Can we use recursion to count sumTo(100000)?
solutionThe solution using a loop:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
        
      
      
      The solution using recursion:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
        
      
      
      The solution using the formula: sumTo(n) = n*(n+1)/2:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
        
      
      
      P.S. Naturally, the formula is the fastest solution. It uses only 3 operations for any number n. The math helps!
The loop variant is the second in terms of speed. In both the recursive and the loop variant we sum the same numbers. But the recursion involves nested calls and execution stack management. That also takes resources, so it’s slower.
P.P.S. Some engines support the “tail call” optimization: if a recursive call is the very last one in the function, with no other calculations performed, then the outer function will not need to resume the execution, so the engine doesn’t need to remember its execution context. That removes the burden on memory. But if the JavaScript engine does not support tail call optimization (most of them don’t), there will be an error: maximum stack size exceeded, because there’s usually a limitation on the total stack size.
Calculate factorialimportance: 4The factorial of a natural number is a number multiplied by "number minus one", then by "number minus two", and so on till 1. The factorial of n is denoted as n!
We can write a definition of factorial like this:

      
        
        
          n! = n * (n - 1) * (n - 2) * ...*1
        
      
      
      Values of factorials for different n:

      
        
        
          1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
        
      
      
      The task is to write a function factorial(n) that calculates n! using recursive calls.

      
        
        
          alert( factorial(5) ); // 120
        
      
      
      P.S. Hint: n! can be written as n * (n-1)! For instance: 3! = 3*2! = 3*2*1! = 6
solutionBy definition, a factorial n! can be written as n * (n-1)!.
In other words, the result of factorial(n) can be calculated as n multiplied by the result of factorial(n-1). And the call for n-1 can recursively descend lower, and lower, till 1.

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      The basis of recursion is the value 1. We can also make 0 the basis here, doesn’t matter much, but gives one more recursive step:

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      Fibonacci numbersimportance: 5The sequence of Fibonacci numbers has the formula Fn = Fn-1 + Fn-2. In other words, the next number is a sum of the two preceding ones.
First two numbers are 1, then 2(1+1), then 3(1+2), 5(2+3) and so on: 1, 1, 2, 3, 5, 8, 13, 21....
Fibonacci numbers are related to the Golden ratio and many natural phenomena around us.
Write a function fib(n) that returns the n-th Fibonacci number.
An example of work:

      
        
        
          function fib(n) { /* your code */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
        
      
      
      P.S. The function should be fast. The call to fib(77) should take no more than a fraction of a second.
solutionThe first solution we could try here is the recursive one.
Fibonacci numbers are recursive by definition:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // will be extremely slow!
        
      
      
      …But for big values of n it’s very slow. For instance, fib(77) may hang up the engine for some time eating all CPU resources.
That’s because the function makes too many subcalls. The same values are re-evaluated again and again.
For instance, let’s see a piece of calculations for fib(5):

      
        
        
          ...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...
        
      
      
      Here we can see that the value of fib(3) is needed for both fib(5) and fib(4). So fib(3) will be called and evaluated two times completely independently.
Here’s the full recursion tree:

      
      
        
      
      We can clearly notice that fib(3) is evaluated two times and fib(2) is evaluated three times. The total amount of computations grows much faster than n, making it enormous even for n=77.
We can optimize that by remembering already-evaluated values: if a value of say fib(3) is calculated once, then we can just reuse it in future computations.
Another variant would be to give up recursion and use a totally different loop-based algorithm.
Instead of going from n down to lower values, we can make a loop that starts from 1 and 2, then gets fib(3) as their sum, then fib(4) as the sum of two previous values, then fib(5) and goes up and up, till it gets to the needed value. On each step we only need to remember two previous values.
Here are the steps of the new algorithm in details.
The start:

      
        
        
          // a = fib(1), b = fib(2), these values are by definition 1
let a = 1, b = 1;

// get c = fib(3) as their sum
let c = a + b;

/* we now have fib(1), fib(2), fib(3)
a  b  c
1, 1, 2
*/
        
      
      
      Now we want to get fib(4) = fib(2) + fib(3).
Let’s shift the variables: a,b will get fib(2),fib(3), and c will get their sum:

      
        
        
          a = b; // now a = fib(2)
b = c; // now b = fib(3)
c = a + b; // c = fib(4)

/* now we have the sequence:
   a  b  c
1, 1, 2, 3
*/
        
      
      
      The next step gives another sequence number:

      
        
        
          a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)

/* now the sequence is (one more number):
      a  b  c
1, 1, 2, 3, 5
*/
        
      
      
      …And so on until we get the needed value. That’s much faster than recursion and involves no duplicate computations.
The full code:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
        
      
      
      The loop starts with i=3, because the first and the second sequence values are hard-coded into variables a=1, b=1.
The approach is called dynamic programming bottom-up.
Output a single-linked listimportance: 5Let’s say we have a single-linked list (as described in the chapter Recursion and stack):

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Write a function printList(list) that outputs list items one-by-one.
Make two variants of the solution: using a loop and using recursion.
What’s better: with recursion or without it?
solutionLoop-based solutionLoop-based solutionThe loop-based variant of the solution:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);
        
      
      
      Please note that we use a temporary variable tmp to walk over the list. Technically, we could use a function parameter list instead:

      
        
        
          function printList(list) {

  while(list) {
    alert(list.value);
    list = list.next;
  }

}
        
      
      
      …But that would be unwise. In the future we may need to extend a function, do something else with the list. If we change list, then we lose such ability.
Talking about good variable names, list here is the list itself. The first element of it. And it should remain like that. That’s clear and reliable.
From the other side, the role of tmp is exclusively a list traversal, like i in the for loop.
Recursive solutionRecursive solutionThe recursive variant of printList(list) follows a simple logic: to output a list we should output the current element list, then do the same for list.next:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert(list.value); // output the current item

  if (list.next) {
    printList(list.next); // do the same for the rest of the list
  }

}

printList(list);
        
      
      
      Now what’s better?
Technically, the loop is more effective. These two variants do the same, but the loop does not spend resources for nested function calls.
From the other side, the recursive variant is shorter and sometimes easier to understand.
Output a single-linked list in the reverse orderimportance: 5Output a single-linked list from the previous task Output a single-linked list in the reverse order.
Make two solutions: using a loop and using a recursion.
solutionUsing a recursionUsing a recursionThe recursive logic is a little bit tricky here.
We need to first output the rest of the list and then output the current one:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);
        
      
      
      Using a loopUsing a loopThe loop variant is also a little bit more complicated than the direct output.
There is no way to get the last value in our list. We also can’t “go back”.
So what we can do is to first go through the items in the direct order and remember them in an array, and then output what we remembered in the reverse order:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
        
      
      
      Please note that the recursive solution actually does exactly the same: it follows the list, remembers the items in the chain of nested calls (in the execution context stack), and then outputs them.\n\nTutorialThe JavaScript languageAdvanced working with functionsOctober 1, 2022Recursion and stackLet’s return to functions and study them more in-depth.
Our first topic will be recursion.
If you are not new to programming, then it is probably familiar and you could skip this chapter.
Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.
When a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.
Two ways of thinkingFor something simple to start with – let’s write a function pow(x, n) that raises x to a natural power of n. In other words, multiplies x by itself n times.

      
        
        
          pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
        
      
      
      There are two ways to implement it.


Iterative thinking: the for loop:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = 1;

  // multiply result by x n times in the loop
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
        
      
      
      

Recursive thinking: simplify the task and call self:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
        
      
      
      

Please note how the recursive variant is fundamentally different.
When pow(x, n) is called, the execution splits into two branches:

      
        
        
                        if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
        
      
      
      
If n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.
Otherwise, we can represent pow(x, n) as x * pow(x, n - 1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pow with lower n). Next steps simplify it further and further until n reaches 1.

We can also say that pow recursively calls itself till n == 1.

      
      
        
      
      For example, to calculate pow(2, 4) the recursive variant does these steps:

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

So, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.

            Recursion is usually shorter
            A recursive solution is usually shorter than an iterative one.
Here we can rewrite the same using the conditional operator ? instead of if to make pow(x, n) more terse and still very readable:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
        
      
      
      
The maximal number of nested calls (including the first one) is called recursion depth. In our case, it will be exactly n.
The maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.
That limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.
The execution context and stackNow let’s examine how recursive calls work. For that we’ll look under the hood of functions.
The information about the process of execution of a running function is stored in its execution context.
The execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of this (we don’t use it here) and few other internal details.
One function call has exactly one execution context associated with it.
When a function makes a nested call, the following happens:

The current function is paused.
The execution context associated with it is remembered in a special data structure called execution context stack.
The nested call executes.
After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.

Let’s see what happens during the pow(2, 3) call.
pow(2, 3)In the beginning of the call pow(2, 3) the execution context will store variables: x = 2, n = 3, the execution flow is at line 1 of the function.
We can sketch it as:

  
    Context: { x: 2, n: 3, at line 1 }
    pow(2, 3)
  

That’s when the function starts to execute. The condition n == 1 is falsy, so the flow continues into the second branch of if:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
        
      
      
      The variables are same, but the line changes, so the context is now:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

To calculate x * pow(x, n - 1), we need to make a subcall of pow with new arguments pow(2, 2).
pow(2, 2)To do a nested call, JavaScript remembers the current execution context in the execution context stack.
Here we call the same function pow, but it absolutely doesn’t matter. The process is the same for all functions:

The current context is “remembered” on top of the stack.
The new context is created for the subcall.
When the subcall is finished – the previous context is popped from the stack, and its execution continues.

Here’s the context stack when we entered the subcall pow(2, 2):

  
    Context: { x: 2, n: 2, at line 1 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The new current execution context is on top (and bold), and previous remembered contexts are below.
When we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped.

            Please note:
            Here in the picture we use the word “line”, as in our example there’s only one subcall in line, but generally a single line of code may contain multiple subcalls, like pow(…) + pow(…) + somethingElse(…).
So it would be more precise to say that the execution resumes “immediately after the subcall”.

pow(2, 1)The process repeats: a new subcall is made at line 5, now with arguments x=2, n=1.
A new execution context is created, the previous one is pushed on top of the stack:

  
    Context: { x: 2, n: 1, at line 1 }
    pow(2, 1)
  
  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

There are 2 old contexts now and 1 currently running for pow(2, 1).
The exitDuring the execution of pow(2, 1), unlike before, the condition n == 1 is truthy, so the first branch of if works:

      
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
        
      
      
      There are no more nested calls, so the function finishes, returning 2.
As the function finishes, its execution context is not needed anymore, so it’s removed from the memory. The previous one is restored off the top of the stack:

  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

The execution of pow(2, 2) is resumed. It has the result of the subcall pow(2, 1), so it also can finish the evaluation of x * pow(x, n - 1), returning 4.
Then the previous context is restored:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

When it finishes, we have a result of pow(2, 3) = 8.
The recursion depth in this case was: 3.
As we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.
Note the memory requirements. Contexts take memory. In our case, raising to the power of n actually requires the memory for n contexts, for all lower values of n.
A loop-based algorithm is more memory-saving:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      The iterative pow uses a single context changing i and result in the process. Its memory requirements are small, fixed and do not depend on n.
Any recursion can be rewritten as a loop. The loop variant usually can be made more effective.
…But sometimes the rewrite is non-trivial, especially when a function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.
Recursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.
Recursive traversalsAnother great application of the recursion is a recursive traversal.
Imagine, we have a company. The staff structure can be presented as an object:

      
        
        
          let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
        
      
      
      In other words, a company has departments.


A department may have an array of staff. For instance, sales department has 2 employees: John and Alice.


Or a department may split into subdepartments, like development has two branches: sites and internals. Each of them has their own staff.


It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).
For instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That’s not on the picture, just something to have in mind.


Now let’s say we want a function to get the sum of all salaries. How can we do that?
An iterative approach is not easy, because the structure is not simple. The first idea may be to make a for loop over company with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like sites… And then another subloop inside those for 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.
Let’s try recursion.
As we can see, when our function gets a department to sum, there are two possible cases:

Either it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.
Or it’s an object with N subdepartments – then we can make N recursive calls to get the sum for each of the subdeps and combine the results.

The 1st case is the base of recursion, the trivial case, when we get an array.
The 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).
The algorithm is probably even easier to read from the code:

      
        
        
          
            
          
          
            
          
        
        
          let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// The function to do the job
function sumSalaries(department) {
  if (Array.isArray(department)) { // case (1)
    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array
  } else { // case (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
        
      
      
      The code is short and easy to understand (hopefully?). That’s the power of recursion. It also works for any level of subdepartment nesting.
Here’s the diagram of calls:

      
      
        
      
      We can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the “leaves” of the recursion tree, they give immediate result.
Note that the code uses smart features that we’ve covered before:

Method arr.reduce explained in the chapter Array methods to get the sum of the array.
Loop for(val of Object.values(obj)) to iterate over object values: Object.values returns an array of them.

Recursive structuresA recursive (recursively-defined) data structure is a structure that replicates itself in parts.
We’ve just seen it in the example of a company structure above.
A company department is:

Either an array of people.
Or an object with departments.

For web-developers there are much better-known examples: HTML and XML documents.
In the HTML document, an HTML-tag may contain a list of:

Text pieces.
HTML-comments.
Other HTML-tags (that in turn may contain text pieces/comments or other tags etc).

That’s once again a recursive definition.
For better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.
Linked listImagine, we want to store an ordered list of objects.
The natural choice would be an array:

      
        
        
          let arr = [obj1, obj2, obj3];
        
      
      
      …But there’s a problem with arrays. The “delete element” and “insert element” operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().
The only structural modifications that do not require mass-renumbering are those that operate with the end of array: arr.push/pop. So an array can be quite slow for big queues, when we have to work with the beginning.
Alternatively, if we really need fast insertion/deletion, we can choose another data structure called a linked list.
The linked list element is recursively defined as an object with:

value.
next property referencing the next linked list element or null if that’s the end.

For instance:

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Graphical representation of the list:

      
      
        
      
      An alternative code for creation:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
        
      
      
      Here we can even more clearly see that there are multiple objects, each one has the value and next pointing to the neighbour. The list variable is the first object in the chain, so following next pointers from it we can reach any element.
The list can be easily split into multiple parts and later joined back:

      
        
        
          let secondList = list.next.next;
list.next.next = null;
        
      
      
      
      
      
        
      
      To join:

      
        
        
          list.next.next = secondList;
        
      
      
      And surely we can insert or remove items in any place.
For instance, to prepend a new value, we need to update the head of the list:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// prepend the new value to the list
list = { value: "new item", next: list };
        
      
      
      
      
      
        
      
      To remove a value from the middle, change next of the previous one:

      
        
        
          list.next = list.next.next;
        
      
      
      
      
      
        
      
      We made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory.
Unlike arrays, there’s no mass-renumbering, we can easily rearrange elements.
Naturally, lists are not always better than arrays. Otherwise everyone would use only lists.
The main drawback is that we can’t easily access an element by its number. In an array that’s easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.
…But we don’t always need such operations. For instance, when we need a queue or even a deque – the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.
Lists can be enhanced:

We can add property prev in addition to next to reference the previous element, to move back easily.
We can also add a variable named tail referencing the last element of the list (and update it when adding/removing elements from the end).
…The data structure may vary according to our needs.

SummaryTerms:


Recursion  is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways.
When a function calls itself, that’s called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.


A recursively-defined data structure is a data structure that can be defined using itself.
For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).

      
        
        
          list = { value, next -> list }
        
      
      
      Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they have branches and every branch can have other branches.
Recursive functions can be used to walk them as we’ve seen in the sumSalary example.


Any recursive function can be rewritten into an iterative one. And that’s sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support.
TasksSum all numbers till the given oneimportance: 5Write a function sumTo(n) that calculates the sum of numbers 1 + 2 + ... + n.
For instance:

      
        
        
          sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
        
      
      
      Make 3 solution variants:

Using a for loop.
Using a recursion, cause sumTo(n) = n + sumTo(n-1) for n > 1.
Using the arithmetic progression formula.

An example of the result:

      
        
        
          function sumTo(n) { /*... your code ... */ }

alert( sumTo(100) ); // 5050
        
      
      
      P.S. Which solution variant is the fastest? The slowest? Why?
P.P.S. Can we use recursion to count sumTo(100000)?
solutionThe solution using a loop:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
        
      
      
      The solution using recursion:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
        
      
      
      The solution using the formula: sumTo(n) = n*(n+1)/2:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
        
      
      
      P.S. Naturally, the formula is the fastest solution. It uses only 3 operations for any number n. The math helps!
The loop variant is the second in terms of speed. In both the recursive and the loop variant we sum the same numbers. But the recursion involves nested calls and execution stack management. That also takes resources, so it’s slower.
P.P.S. Some engines support the “tail call” optimization: if a recursive call is the very last one in the function, with no other calculations performed, then the outer function will not need to resume the execution, so the engine doesn’t need to remember its execution context. That removes the burden on memory. But if the JavaScript engine does not support tail call optimization (most of them don’t), there will be an error: maximum stack size exceeded, because there’s usually a limitation on the total stack size.
Calculate factorialimportance: 4The factorial of a natural number is a number multiplied by "number minus one", then by "number minus two", and so on till 1. The factorial of n is denoted as n!
We can write a definition of factorial like this:

      
        
        
          n! = n * (n - 1) * (n - 2) * ...*1
        
      
      
      Values of factorials for different n:

      
        
        
          1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
        
      
      
      The task is to write a function factorial(n) that calculates n! using recursive calls.

      
        
        
          alert( factorial(5) ); // 120
        
      
      
      P.S. Hint: n! can be written as n * (n-1)! For instance: 3! = 3*2! = 3*2*1! = 6
solutionBy definition, a factorial n! can be written as n * (n-1)!.
In other words, the result of factorial(n) can be calculated as n multiplied by the result of factorial(n-1). And the call for n-1 can recursively descend lower, and lower, till 1.

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      The basis of recursion is the value 1. We can also make 0 the basis here, doesn’t matter much, but gives one more recursive step:

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      Fibonacci numbersimportance: 5The sequence of Fibonacci numbers has the formula Fn = Fn-1 + Fn-2. In other words, the next number is a sum of the two preceding ones.
First two numbers are 1, then 2(1+1), then 3(1+2), 5(2+3) and so on: 1, 1, 2, 3, 5, 8, 13, 21....
Fibonacci numbers are related to the Golden ratio and many natural phenomena around us.
Write a function fib(n) that returns the n-th Fibonacci number.
An example of work:

      
        
        
          function fib(n) { /* your code */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
        
      
      
      P.S. The function should be fast. The call to fib(77) should take no more than a fraction of a second.
solutionThe first solution we could try here is the recursive one.
Fibonacci numbers are recursive by definition:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // will be extremely slow!
        
      
      
      …But for big values of n it’s very slow. For instance, fib(77) may hang up the engine for some time eating all CPU resources.
That’s because the function makes too many subcalls. The same values are re-evaluated again and again.
For instance, let’s see a piece of calculations for fib(5):

      
        
        
          ...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...
        
      
      
      Here we can see that the value of fib(3) is needed for both fib(5) and fib(4). So fib(3) will be called and evaluated two times completely independently.
Here’s the full recursion tree:

      
      
        
      
      We can clearly notice that fib(3) is evaluated two times and fib(2) is evaluated three times. The total amount of computations grows much faster than n, making it enormous even for n=77.
We can optimize that by remembering already-evaluated values: if a value of say fib(3) is calculated once, then we can just reuse it in future computations.
Another variant would be to give up recursion and use a totally different loop-based algorithm.
Instead of going from n down to lower values, we can make a loop that starts from 1 and 2, then gets fib(3) as their sum, then fib(4) as the sum of two previous values, then fib(5) and goes up and up, till it gets to the needed value. On each step we only need to remember two previous values.
Here are the steps of the new algorithm in details.
The start:

      
        
        
          // a = fib(1), b = fib(2), these values are by definition 1
let a = 1, b = 1;

// get c = fib(3) as their sum
let c = a + b;

/* we now have fib(1), fib(2), fib(3)
a  b  c
1, 1, 2
*/
        
      
      
      Now we want to get fib(4) = fib(2) + fib(3).
Let’s shift the variables: a,b will get fib(2),fib(3), and c will get their sum:

      
        
        
          a = b; // now a = fib(2)
b = c; // now b = fib(3)
c = a + b; // c = fib(4)

/* now we have the sequence:
   a  b  c
1, 1, 2, 3
*/
        
      
      
      The next step gives another sequence number:

      
        
        
          a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)

/* now the sequence is (one more number):
      a  b  c
1, 1, 2, 3, 5
*/
        
      
      
      …And so on until we get the needed value. That’s much faster than recursion and involves no duplicate computations.
The full code:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
        
      
      
      The loop starts with i=3, because the first and the second sequence values are hard-coded into variables a=1, b=1.
The approach is called dynamic programming bottom-up.
Output a single-linked listimportance: 5Let’s say we have a single-linked list (as described in the chapter Recursion and stack):

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Write a function printList(list) that outputs list items one-by-one.
Make two variants of the solution: using a loop and using recursion.
What’s better: with recursion or without it?
solutionLoop-based solutionLoop-based solutionThe loop-based variant of the solution:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);
        
      
      
      Please note that we use a temporary variable tmp to walk over the list. Technically, we could use a function parameter list instead:

      
        
        
          function printList(list) {

  while(list) {
    alert(list.value);
    list = list.next;
  }

}
        
      
      
      …But that would be unwise. In the future we may need to extend a function, do something else with the list. If we change list, then we lose such ability.
Talking about good variable names, list here is the list itself. The first element of it. And it should remain like that. That’s clear and reliable.
From the other side, the role of tmp is exclusively a list traversal, like i in the for loop.
Recursive solutionRecursive solutionThe recursive variant of printList(list) follows a simple logic: to output a list we should output the current element list, then do the same for list.next:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert(list.value); // output the current item

  if (list.next) {
    printList(list.next); // do the same for the rest of the list
  }

}

printList(list);
        
      
      
      Now what’s better?
Technically, the loop is more effective. These two variants do the same, but the loop does not spend resources for nested function calls.
From the other side, the recursive variant is shorter and sometimes easier to understand.
Output a single-linked list in the reverse orderimportance: 5Output a single-linked list from the previous task Output a single-linked list in the reverse order.
Make two solutions: using a loop and using a recursion.
solutionUsing a recursionUsing a recursionThe recursive logic is a little bit tricky here.
We need to first output the rest of the list and then output the current one:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);
        
      
      
      Using a loopUsing a loopThe loop variant is also a little bit more complicated than the direct output.
There is no way to get the last value in our list. We also can’t “go back”.
So what we can do is to first go through the items in the direct order and remember them in an array, and then output what we remembered in the reverse order:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
        
      
      
      Please note that the recursive solution actually does exactly the same: it follows the list, remembers the items in the chain of nested calls (in the execution context stack), and then outputs them.
Previous lessonNext lessonShareTutorial mapCommentsread this before commenting…If you have suggestions what to improve - please submit a GitHub issue or a pull request instead of commenting.If you can't understand something in the article – please elaborate.To insert few words of code, use the <code> tag, for several lines – wrap them in <pre> tag, for more than 10 lines – use a sandbox (plnkr, jsbin, codepen…)\n\n\n\n