directive* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*\n\n\n\nWiki
               Email Archive 
              
                 
                  
                    
                   
              
            
          
        
      
      
      
         
        
        
          Site Navigation

           Online resources 
          
            Micro-tutorial
            Primer
            ShEx spec
            ShapeMap spec
            JSON representation
            
            ShEx Extensions
            ShEx Tools
            issues on ShEx specs
            ShEx Next features
          
           Upcoming specs 
          
            
            ShEx with EXTENDS
            ShEx primer with EXTENDS
          
           Online learning tools 
          
            
            
            
            
            
            RDFShape
            ShExDemo
          
           Contact Info
          
          
            ShEx Community Group
            language list: public-shex@w3.org
            dev list: public-shex-dev@w3.org
          
        
        
          ShEx - Shape Expressions
          
            
              Validation, traversal and transformation of RDF graphs.
	      
		      Shape Expressions is a structural schema language for RDF graphs.
          It allows one to describe profiles of data like this:
	      

        
          # our EmployeeShape reuses the FOAF ontology
<EmployeeShape> {                # An <EmployeeShape> has:
    foaf:givenName  xsd:string+,   # at least one givenName.
    foaf:familyName xsd:string,    # one familyName.
    foaf:phone      IRI*,          # any number of phone numbers.
    foaf:mbox       IRI            # one FOAF mbox.
}
          # Employee7 matches EmployeeShape
<http://a.example/Employee7>
    foaf:givenName  "Robert", "Taylor" ;
    foaf:familyName "Johnson" ;
    # no phone number needed
    foaf:mbox       <mailto:rtj@example.com>
    .

        
         Features
	      
		datatype constraints
		value sets
		XML Schema facets
		nested shapes
    additive property constraints
    algabraics (or, and)
		negated properties
		incoming arcs
		node kind (IRI, BNode or literal)
		open/closed shapes and properties
		JSON schema format
		JSON validation results
	      

	      
		      
          Validators
	      
		  ImplementationPlatform/Language
		  shex.js(wiki,repo), runs on n3.js
      ShExJavaJava
      ShEx-sScala (Jena or RDF4J)
      Ruby ShExRuby
      PyShExPython
      Apache Jena ShExJava (repo)
      
      
		      
          WebApps
	      
		  try it! repo Environment
		  rdfshapegithub public React
		  shex-simplegithub public custom js
		  shexmap-simplegithub public custom js
		  shex-authorgithub public React
		  ace-shexcgithub public Ace Editor
		  YaShEgithub public Javascript
	      
          
		      
          Tools
	      
		  Tool Description
		  sheXerautomatic extraction of ShEx schemata in RDF graphs
		  shex-formuse ShEx to create and populate HTML forms
		  ST3 shexc.syntaxSyntax highlighting for ShExC in Sublime Text 3
		  VSCode ShEx ExtensionsSyntax highlighting for ShExC in VSCode
		  ShExMLmap and merge heterogeneous data sources
		  shexc-modeAn Emacs mode for editing ShEx (good for Turtle too).
	      
          
		      
           Tutorials
           
             Tutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)
             Validating RDF (book)
           
          
	      
          
           
         
       
    
    
      
         Further information: public-shex-dev@w3.org\nWiki
               Email Archive\nWiki
               Email Archive\nSite Navigation

           Online resources 
          
            Micro-tutorial
            Primer
            ShEx spec
            ShapeMap spec
            JSON representation
            
            ShEx Extensions
            ShEx Tools
            issues on ShEx specs
            ShEx Next features
          
           Upcoming specs 
          
            
            ShEx with EXTENDS
            ShEx primer with EXTENDS
          
           Online learning tools 
          
            
            
            
            
            
            RDFShape
            ShExDemo
          
           Contact Info
          
          
            ShEx Community Group
            language list: public-shex@w3.org
            dev list: public-shex-dev@w3.org
          
        
        
          ShEx - Shape Expressions
          
            
              Validation, traversal and transformation of RDF graphs.
	      
		      Shape Expressions is a structural schema language for RDF graphs.
          It allows one to describe profiles of data like this:
	      

        
          # our EmployeeShape reuses the FOAF ontology
<EmployeeShape> {                # An <EmployeeShape> has:
    foaf:givenName  xsd:string+,   # at least one givenName.
    foaf:familyName xsd:string,    # one familyName.
    foaf:phone      IRI*,          # any number of phone numbers.
    foaf:mbox       IRI            # one FOAF mbox.
}
          # Employee7 matches EmployeeShape
<http://a.example/Employee7>
    foaf:givenName  "Robert", "Taylor" ;
    foaf:familyName "Johnson" ;
    # no phone number needed
    foaf:mbox       <mailto:rtj@example.com>
    .

        
         Features
	      
		datatype constraints
		value sets
		XML Schema facets
		nested shapes
    additive property constraints
    algabraics (or, and)
		negated properties
		incoming arcs
		node kind (IRI, BNode or literal)
		open/closed shapes and properties
		JSON schema format
		JSON validation results
	      

	      
		      
          Validators
	      
		  ImplementationPlatform/Language
		  shex.js(wiki,repo), runs on n3.js
      ShExJavaJava
      ShEx-sScala (Jena or RDF4J)
      Ruby ShExRuby
      PyShExPython
      Apache Jena ShExJava (repo)
      
      
		      
          WebApps
	      
		  try it! repo Environment
		  rdfshapegithub public React
		  shex-simplegithub public custom js
		  shexmap-simplegithub public custom js
		  shex-authorgithub public React
		  ace-shexcgithub public Ace Editor
		  YaShEgithub public Javascript
	      
          
		      
          Tools
	      
		  Tool Description
		  sheXerautomatic extraction of ShEx schemata in RDF graphs
		  shex-formuse ShEx to create and populate HTML forms
		  ST3 shexc.syntaxSyntax highlighting for ShExC in Sublime Text 3
		  VSCode ShEx ExtensionsSyntax highlighting for ShExC in VSCode
		  ShExMLmap and merge heterogeneous data sources
		  shexc-modeAn Emacs mode for editing ShEx (good for Turtle too).
	      
          
		      
           Tutorials
           
             Tutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)
             Validating RDF (book)\nSite Navigation

           Online resources 
          
            Micro-tutorial
            Primer
            ShEx spec
            ShapeMap spec
            JSON representation
            
            ShEx Extensions
            ShEx Tools
            issues on ShEx specs
            ShEx Next features
          
           Upcoming specs 
          
            
            ShEx with EXTENDS
            ShEx primer with EXTENDS
          
           Online learning tools 
          
            
            
            
            
            
            RDFShape
            ShExDemo
          
           Contact Info
          
          
            ShEx Community Group
            language list: public-shex@w3.org
            dev list: public-shex-dev@w3.org\nShEx primer with EXTENDS\nShEx primer with EXTENDS\nOnline learning tools\nOnline learning tools\nlanguage list: public-shex@w3.org\ndev list: public-shex-dev@w3.org\npublic-shex-dev@w3.org\nShEx - Shape Expressions
          
            
              Validation, traversal and transformation of RDF graphs.
	      
		      Shape Expressions is a structural schema language for RDF graphs.
          It allows one to describe profiles of data like this:
	      

        
          # our EmployeeShape reuses the FOAF ontology
<EmployeeShape> {                # An <EmployeeShape> has:
    foaf:givenName  xsd:string+,   # at least one givenName.
    foaf:familyName xsd:string,    # one familyName.
    foaf:phone      IRI*,          # any number of phone numbers.
    foaf:mbox       IRI            # one FOAF mbox.
}
          # Employee7 matches EmployeeShape
<http://a.example/Employee7>
    foaf:givenName  "Robert", "Taylor" ;
    foaf:familyName "Johnson" ;
    # no phone number needed
    foaf:mbox       <mailto:rtj@example.com>
    .

        
         Features
	      
		datatype constraints
		value sets
		XML Schema facets
		nested shapes
    additive property constraints
    algabraics (or, and)
		negated properties
		incoming arcs
		node kind (IRI, BNode or literal)
		open/closed shapes and properties
		JSON schema format
		JSON validation results
	      

	      
		      
          Validators
	      
		  ImplementationPlatform/Language
		  shex.js(wiki,repo), runs on n3.js
      ShExJavaJava
      ShEx-sScala (Jena or RDF4J)
      Ruby ShExRuby
      PyShExPython
      Apache Jena ShExJava (repo)
      
      
		      
          WebApps
	      
		  try it! repo Environment
		  rdfshapegithub public React
		  shex-simplegithub public custom js
		  shexmap-simplegithub public custom js
		  shex-authorgithub public React
		  ace-shexcgithub public Ace Editor
		  YaShEgithub public Javascript
	      
          
		      
          Tools
	      
		  Tool Description
		  sheXerautomatic extraction of ShEx schemata in RDF graphs
		  shex-formuse ShEx to create and populate HTML forms
		  ST3 shexc.syntaxSyntax highlighting for ShExC in Sublime Text 3
		  VSCode ShEx ExtensionsSyntax highlighting for ShExC in VSCode
		  ShExMLmap and merge heterogeneous data sources
		  shexc-modeAn Emacs mode for editing ShEx (good for Turtle too).
	      
          
		      
           Tutorials
           
             Tutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)
             Validating RDF (book)\nShEx - Shape Expressions\nValidation, traversal and transformation of RDF graphs.
	      
		      Shape Expressions is a structural schema language for RDF graphs.
          It allows one to describe profiles of data like this:
	      

        
          # our EmployeeShape reuses the FOAF ontology
<EmployeeShape> {                # An <EmployeeShape> has:
    foaf:givenName  xsd:string+,   # at least one givenName.
    foaf:familyName xsd:string,    # one familyName.
    foaf:phone      IRI*,          # any number of phone numbers.
    foaf:mbox       IRI            # one FOAF mbox.
}
          # Employee7 matches EmployeeShape
<http://a.example/Employee7>
    foaf:givenName  "Robert", "Taylor" ;
    foaf:familyName "Johnson" ;
    # no phone number needed
    foaf:mbox       <mailto:rtj@example.com>
    .

        
         Features
	      
		datatype constraints
		value sets
		XML Schema facets
		nested shapes
    additive property constraints
    algabraics (or, and)
		negated properties
		incoming arcs
		node kind (IRI, BNode or literal)
		open/closed shapes and properties
		JSON schema format
		JSON validation results
	      

	      
		      
          Validators
	      
		  ImplementationPlatform/Language
		  shex.js(wiki,repo), runs on n3.js
      ShExJavaJava
      ShEx-sScala (Jena or RDF4J)
      Ruby ShExRuby
      PyShExPython
      Apache Jena ShExJava (repo)
      
      
		      
          WebApps
	      
		  try it! repo Environment
		  rdfshapegithub public React
		  shex-simplegithub public custom js
		  shexmap-simplegithub public custom js
		  shex-authorgithub public React
		  ace-shexcgithub public Ace Editor
		  YaShEgithub public Javascript
	      
          
		      
          Tools
	      
		  Tool Description
		  sheXerautomatic extraction of ShEx schemata in RDF graphs
		  shex-formuse ShEx to create and populate HTML forms
		  ST3 shexc.syntaxSyntax highlighting for ShExC in Sublime Text 3
		  VSCode ShEx ExtensionsSyntax highlighting for ShExC in VSCode
		  ShExMLmap and merge heterogeneous data sources
		  shexc-modeAn Emacs mode for editing ShEx (good for Turtle too).
	      
          
		      
           Tutorials
           
             Tutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)
             Validating RDF (book)\nValidation, traversal and transformation of RDF graphs.
	      
		      Shape Expressions is a structural schema language for RDF graphs.
          It allows one to describe profiles of data like this:
	      

        
          # our EmployeeShape reuses the FOAF ontology
<EmployeeShape> {                # An <EmployeeShape> has:
    foaf:givenName  xsd:string+,   # at least one givenName.
    foaf:familyName xsd:string,    # one familyName.
    foaf:phone      IRI*,          # any number of phone numbers.
    foaf:mbox       IRI            # one FOAF mbox.
}
          # Employee7 matches EmployeeShape
<http://a.example/Employee7>
    foaf:givenName  "Robert", "Taylor" ;
    foaf:familyName "Johnson" ;
    # no phone number needed
    foaf:mbox       <mailto:rtj@example.com>
    .

        
         Features
	      
		datatype constraints
		value sets
		XML Schema facets
		nested shapes
    additive property constraints
    algabraics (or, and)
		negated properties
		incoming arcs
		node kind (IRI, BNode or literal)
		open/closed shapes and properties
		JSON schema format
		JSON validation results
	      

	      
		      
          Validators
	      
		  ImplementationPlatform/Language
		  shex.js(wiki,repo), runs on n3.js
      ShExJavaJava
      ShEx-sScala (Jena or RDF4J)
      Ruby ShExRuby
      PyShExPython
      Apache Jena ShExJava (repo)
      
      
		      
          WebApps
	      
		  try it! repo Environment
		  rdfshapegithub public React
		  shex-simplegithub public custom js
		  shexmap-simplegithub public custom js
		  shex-authorgithub public React
		  ace-shexcgithub public Ace Editor
		  YaShEgithub public Javascript
	      
          
		      
          Tools
	      
		  Tool Description
		  sheXerautomatic extraction of ShEx schemata in RDF graphs
		  shex-formuse ShEx to create and populate HTML forms
		  ST3 shexc.syntaxSyntax highlighting for ShExC in Sublime Text 3
		  VSCode ShEx ExtensionsSyntax highlighting for ShExC in VSCode
		  ShExMLmap and merge heterogeneous data sources
		  shexc-modeAn Emacs mode for editing ShEx (good for Turtle too).
	      
          
		      
           Tutorials
           
             Tutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)
             Validating RDF (book)\nValidation, traversal and transformation of RDF graphs.\nShape Expressions is a structural schema language for RDF graphs.
          It allows one to describe profiles of data like this:\n# our EmployeeShape reuses the FOAF ontology
<EmployeeShape> {                # An <EmployeeShape> has:
    foaf:givenName  xsd:string+,   # at least one givenName.
    foaf:familyName xsd:string,    # one familyName.
    foaf:phone      IRI*,          # any number of phone numbers.
    foaf:mbox       IRI            # one FOAF mbox.
}
          # Employee7 matches EmployeeShape
<http://a.example/Employee7>
    foaf:givenName  "Robert", "Taylor" ;
    foaf:familyName "Johnson" ;
    # no phone number needed
    foaf:mbox       <mailto:rtj@example.com>
    .\n# our EmployeeShape reuses the FOAF ontology\n# An <EmployeeShape> has:\n# at least one givenName.\n# any number of phone numbers.\n# Employee7 matches EmployeeShape\n# no phone number needed\nadditive property constraints\nadditive property constraints\nnode kind (IRI, BNode or literal)\nnode kind (IRI, BNode or literal)\nopen/closed shapes and properties\nJSON validation results\nJSON validation results\nValidators
	      
		  ImplementationPlatform/Language
		  shex.js(wiki,repo), runs on n3.js
      ShExJavaJava
      ShEx-sScala (Jena or RDF4J)
      Ruby ShExRuby
      PyShExPython
      Apache Jena ShExJava (repo)\n(wiki,repo), runs on n3.js\nScala (Jena or RDF4J)\nWebApps
	      
		  try it! repo Environment
		  rdfshapegithub public React
		  shex-simplegithub public custom js
		  shexmap-simplegithub public custom js
		  shex-authorgithub public React
		  ace-shexcgithub public Ace Editor
		  YaShEgithub public Javascript\nTools
	      
		  Tool Description
		  sheXerautomatic extraction of ShEx schemata in RDF graphs
		  shex-formuse ShEx to create and populate HTML forms
		  ST3 shexc.syntaxSyntax highlighting for ShExC in Sublime Text 3
		  VSCode ShEx ExtensionsSyntax highlighting for ShExC in VSCode
		  ShExMLmap and merge heterogeneous data sources
		  shexc-modeAn Emacs mode for editing ShEx (good for Turtle too).\nautomatic extraction of ShEx schemata in RDF graphs\nuse ShEx to create and populate HTML forms\nSyntax highlighting for ShExC in Sublime Text 3\nVSCode ShEx Extensions\nVSCode ShEx Extensions\nSyntax highlighting for ShExC in VSCode\nmap and merge heterogeneous data sources\nAn Emacs mode for editing ShEx (good for Turtle too).\nTutorials
           
             Tutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)
             Validating RDF (book)\nTutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)\nTutorial "Shapes Applications and tools" at ISWC'20 (contains slides and videos)\nValidating RDF (book)\nValidating RDF (book)\nFurther information: public-shex-dev@w3.org\nFurther information: public-shex-dev@w3.org\npublic-shex-dev@w3.org\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\nshapeAssociation (',' shapeAssociation)*nodeSelector shapeLabelobjectTerm | triplePatterniri | 'a'subjectTerm | literal  '{' "FOCUS" iri (objectTerm | '_') '}'
                                                                                                                                                                                                                          | '{' (subjectTerm | '_') iri "FOCUS" '}''@' (iri | "START") | AT_STARTrdfLiteral | numericLiteral | booleanLiteralINTEGER | DECIMAL | DOUBLElangString | string ("^^" iri)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF"<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">""_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@START""@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) ( (PN_CHARS | "." | ":" | PLX)* (PN_CHARS | ":" | PLX) )?PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*\n\n\n\nshapeAssociation (',' shapeAssociation)*nodeSelector shapeLabelobjectTerm | triplePatterniri | 'a'subjectTerm | literal  '{' "FOCUS" iri (objectTerm | '_') '}'
                                                                                                                                                                                                                          | '{' (subjectTerm | '_') iri "FOCUS" '}''@' (iri | "START") | AT_STARTrdfLiteral | numericLiteral | booleanLiteralINTEGER | DECIMAL | DOUBLElangString | string ("^^" iri)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF"<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">""_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@START""@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) ( (PN_CHARS | "." | ":" | PLX)* (PN_CHARS | ":" | PLX) )?PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\nShape Expressions (ShEx) 2.1 Primer
      
      
        Final Community Group Report
        09 October 2019
      
      
        This version:
                http://shex.io/shex-primer-20191009
              
        Latest published version:
                http://shex.io/shex-primer/
              
        Latest editor's draft:https://shexspec.github.io/primer/
        
        
        
        Previous version:http://shex.io/shex-primer-20170713
        
        Editors:
        Thomas Baker
            (Dublin Core Metadata Initiative)
          Eric Prud′hommeaux
            (W3C/MIT)
          
        
        
        
      
      
      
        Copyright
        ©
        2019
        
        the Contributors to the Shape Expressions (ShEx) 2.1 Primer Specification, published by the
        Shape Expressions Community Group under the
        W3C Community Final Specification Agreement (FSA). A human-readable
              summary
              is available.\nShape Expressions (ShEx) 2.1 Primer\nFinal Community Group Report
        09 October 2019\nhttp://shex.io/shex-primer-20191009\nhttp://shex.io/shex-primer/\nhttps://shexspec.github.io/primer/\nhttp://shex.io/shex-primer-20170713\nDublin Core Metadata Initiative\nCopyright
        ©
        2019
        
        the Contributors to the Shape Expressions (ShEx) 2.1 Primer Specification, published by the
        Shape Expressions Community Group under the
        W3C Community Final Specification Agreement (FSA). A human-readable
              summary
              is available.\nShape Expressions Community Group\nW3C Community Final Specification Agreement (FSA)\nShape Expressions (ShEx) is a language for describing RDF graph structures.
        A ShEx schema prescribes conditions that RDF data graphs must meet in order to be considered "conformant": which subjects, predicates, and objects may appear in a given graph, in what combinations and with what cardinalities and datatypes.  
        In the ShEx model, an RDF graph is tested against a ShEx schema to yield a validation result that flags any parts of the data which do not conform.
        ShEx schemas are intended for use in validating RDF data, communicating interface parameters and data structures, generating user interfaces, and transforming RDF graphs into other data formats and structures.  
        This primer introduces ShEx by means of annotated examples.  
        Readers should already be familiar with the basic concepts of RDF.
        The primer is a companion to the full ShEx language specification [shex-semantics].\nStatus of This Document\nThis specification was published by the
      Shape Expressions Community Group. It is not a W3C Standard nor is it
      on the W3C Standards Track.
      
            Please note that under the
            W3C Community Final Specification Agreement (FSA)
            other conditions apply.
          
      Learn more about
      W3C Community and Business Groups.\nShape Expressions Community Group\nW3C Community Final Specification Agreement (FSA)\nW3C Community and Business Groups\nThis version of the document represents a Candidate Release, with stable features. Comments and implementations are solicited prior to an eventual Final 2.0 Release.\nThe Shape Expressions language is expected to remain stable with the exception of:\naddition of a UNIQUE function\nIf you wish to make comments regarding this document, please send
            them to
            public-shex@w3.org
            (subscribe,
            archives).\n2. ShEx Model and Terminology2.1 Validating RDF Data2.2 Basic Terminology\n2. ShEx Model and Terminology\n2.1 Validating RDF Data\n2.1 Validating RDF Data\n2.2 Basic Terminology\n2.2 Basic Terminology\n3. ShEx Essentials3.1 Node Constraints3.2 Triple Constraints3.3 Grouping Triple Constraints in Shapes3.4 Combining Value Constraints3.5 Nesting Shapes3.6 Expressions with Choices3.7 Value Sets\n3.2 Triple Constraints\n3.2 Triple Constraints\n3.3 Grouping Triple Constraints in Shapes\n3.3 Grouping Triple Constraints in Shapes\n3.4 Combining Value Constraints\n3.4 Combining Value Constraints\n3.6 Expressions with Choices\n3.6 Expressions with Choices\n4. Advanced Concepts4.1 Inverse Triple Constraints4.2 Negative Triple Constraints4.3 Closing Shapes4.4 Permitting Extra Properties4.5 Repeated Properties\n4.1 Inverse Triple Constraints\n4.1 Inverse Triple Constraints\n4.2 Negative Triple Constraints\n4.2 Negative Triple Constraints\n4.4 Permitting Extra Properties\n4.4 Permitting Extra Properties\n4.5 Repeated Properties\n4.5 Repeated Properties\n5. Shape Re-use5.1 Reusing Triple Expressions5.2 Importing schemas\n5.1 Reusing Triple Expressions\n5.1 Reusing Triple Expressions\n5.2 Importing schemas\n5.2 Importing schemas\n6. Relationship of ShEx to RDF and OWL\n6. Relationship of ShEx to RDF and OWL\nA. Namespaces in this Document\nA. Namespaces in this Document\nB. ReferencesB.1 Informative references\nB.1 Informative references\nB.1 Informative references\nShape Expressions (ShEx) is a language for describing RDF graph structures.
          A ShEx schema prescribes conditions that RDF data graphs must meet in order to be considered "conformant".
          In the ShEx model, a shape map specifies which nodes in an RDF graph will be tested against a ShEx schema.
          ShEx schemas are intended for use in validating instance data, communicating interface parameters and data structures, generating user interfaces, and transforming RDF graphs into other data formats and structures.  
          This primer, a companion to the full ShEx language specification [shex-semantics], focuses on the common use case of validating instance data.
        
        
          A ShEx schema is built on node constraints and triple constraints that define what it means for a given RDF data graph to conform.
          An RDF triple is the three-part data structure of subject, predicate, and object with which all RDF data is expressed, and an RDF node is the piece of data found in the subject or object position of a triple.
          (Readers unfamiliar these terms may want to consult an RDF primer.[rdf11-primer])
          Node constraints and triple constraints are called "constraints" because they define, or "constrain", the set of RDF nodes and data triples that will pass a conformance test.
        
        
          Picture an RDF database (graph) that carries information about enrollees in a school.
          Put yourself into the position of a data manager who wants to ensure that every student "record" in this graph reports a valid age and references one or two guardians, identified by IRI.
          The ShEx schema for accomplishing this has: one node constraint, school:enrolleeAge, for matching data nodes with an integer value between 13 and 20; one triple constraint, defined within the shape school:Enrollee, for matching one or two triples having the predicate ex:hasGuardian, and a second node constraint for specifying that the object (value) of the triple is an IRI.
          Data that conforms to these constraints will pass validation tests, and data that does not conform will fail.
        
        
          PREFIX school: <http://school.example/#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX ex: <http://ex.example/#>

# Node constraint
school:enrolleeAge xsd:integer MinInclusive 13 MaxInclusive 20


school:Enrollee {
  # Triple constraint (including node constraint IRI)
  ex:hasGuardian IRI {1,2}
}
          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://school.example/#enrolleeAge",
      "type": "NodeConstraint",
      "datatype": "http://www.w3.org/2001/XMLSchema#integer",
      "mininclusive": 13, "maxinclusive": 20 },
    { "id": "http://school.example/#Enrollee",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint", "min": 1, "max": 2,
        "predicate": "http://ex.example/#hasGuardian",
        "valueExpr": {
          "type": "NodeConstraint",
          "nodeKind": "iri" } } }
  ] }
          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>

inst:Student1 ex:hasGuardian
  inst:Person2, inst:Person3 .
try it: js | scala
          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>

inst:Student2 ex:hasGuardian
  inst:Person4, inst:Person5, inst:Person6 .
try it: js | scala
        
        
        The next example adds a triple constraint on the data predicate foaf:age, which must have a value matching the node constraint school:enrolleeAge, which is cited in the triple constraint by reference, indicated by the '@' symbol.
        
        
          
          PREFIX ex: <http://ex.example/#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX school: <http://school.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

school:enrolleeAge xsd:integer MinInclusive 13 MaxInclusive 20 

school:Enrollee {
  foaf:age @school:enrolleeAge ;
  ex:hasGuardian IRI {1,2}
}
          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://school.example/#enrolleeAge",
      "type": "NodeConstraint",
      "datatype": "http://www.w3.org/2001/XMLSchema#integer",
      "mininclusive": 13, "maxinclusive": 20 },
    { "id": "http://school.example/#Enrollee",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://xmlns.com/foaf/0.1/age",
            "valueExpr": "http://school.example/#enrolleeAge" },
          { "type": "TripleConstraint", "min": 1, "max": 2,
            "predicate": "http://ex.example/#hasGuardian",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
            PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX school: <http://school.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Alice foaf:age 13 ;                     
  ex:hasGuardian inst:Person2, inst:Person3 .

inst:Bob foaf:age 15 ;                       
  ex:hasGuardian inst:Person4 .              
try it: js | scala

            PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX school: <http://school.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Claire foaf:age 12 ;                     
  ex:hasGuardian inst:Person5 .               

inst:Don foaf:age 14 .                        
try it: js | scala
        
        

        
          The four RDF data nodes inst:Alice, inst:Bob, inst:Claire, and inst:Don can be tested against the shape school:Enrollee by using either a fixed shape map, which selects nodes by simple enumeration, or a query shape map, which selects nodes matching a triple pattern.  In the latter, the shape map keyword "FOCUS" identifies the node of the triple to be selected (here, the subject node), and the keyword "_" acts as a placeholder for any object.  For readability, the IRIs are rendered here with prefixes.
        
        
          inst:Alice @ school:Enrollee,
inst:Bob @ school:Enrollee,
inst:Claire @ school:Enrollee,
inst:Don @ school:Enrollee
        
        
          {FOCUS foaf:age _} @ school:Enrollee
        
        
        
        
          This example yields a validation result in the form of a result shape map.  A validation result may be presented in different formats and with different levels of verbosity according to implementation requirements.
        
        
          NodeShapeResultReason
          inst:Alice school:Enrolleepass
          inst:Bob   school:Enrolleepass
          inst:Claireschool:Enrolleefailfoaf:age 12 less than 13.
          inst:Don   school:EnrolleefailNo ex:hasGuardian supplied.\nShape Expressions (ShEx) is a language for describing RDF graph structures.
          A ShEx schema prescribes conditions that RDF data graphs must meet in order to be considered "conformant".
          In the ShEx model, a shape map specifies which nodes in an RDF graph will be tested against a ShEx schema.
          ShEx schemas are intended for use in validating instance data, communicating interface parameters and data structures, generating user interfaces, and transforming RDF graphs into other data formats and structures.  
          This primer, a companion to the full ShEx language specification [shex-semantics], focuses on the common use case of validating instance data.\nA ShEx schema is built on node constraints and triple constraints that define what it means for a given RDF data graph to conform.
          An RDF triple is the three-part data structure of subject, predicate, and object with which all RDF data is expressed, and an RDF node is the piece of data found in the subject or object position of a triple.
          (Readers unfamiliar these terms may want to consult an RDF primer.[rdf11-primer])
          Node constraints and triple constraints are called "constraints" because they define, or "constrain", the set of RDF nodes and data triples that will pass a conformance test.\nPicture an RDF database (graph) that carries information about enrollees in a school.
          Put yourself into the position of a data manager who wants to ensure that every student "record" in this graph reports a valid age and references one or two guardians, identified by IRI.
          The ShEx schema for accomplishing this has: one node constraint, school:enrolleeAge, for matching data nodes with an integer value between 13 and 20; one triple constraint, defined within the shape school:Enrollee, for matching one or two triples having the predicate ex:hasGuardian, and a second node constraint for specifying that the object (value) of the triple is an IRI.
          Data that conforms to these constraints will pass validation tests, and data that does not conform will fail.\nPREFIX school: <http://school.example/#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX ex: <http://ex.example/#>

# Node constraint
school:enrolleeAge xsd:integer MinInclusive 13 MaxInclusive 20


school:Enrollee {
  # Triple constraint (including node constraint IRI)
  ex:hasGuardian IRI {1,2}
}
          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://school.example/#enrolleeAge",
      "type": "NodeConstraint",
      "datatype": "http://www.w3.org/2001/XMLSchema#integer",
      "mininclusive": 13, "maxinclusive": 20 },
    { "id": "http://school.example/#Enrollee",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint", "min": 1, "max": 2,
        "predicate": "http://ex.example/#hasGuardian",
        "valueExpr": {
          "type": "NodeConstraint",
          "nodeKind": "iri" } } }
  ] }
          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>

inst:Student1 ex:hasGuardian
  inst:Person2, inst:Person3 .
try it: js | scala
          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>

inst:Student2 ex:hasGuardian
  inst:Person4, inst:Person5, inst:Person6 .
try it: js | scala\n<http://school.example/#>\n<http://www.w3.org/2001/XMLSchema#>\n<http://ex.example/#>\nxsd:integer MinInclusive 13 MaxInclusive 20\n# Triple constraint (including node constraint IRI)\n<http://ex.example/#>\n<http://example.com/users/>\n<http://ex.example/#>\n<http://example.com/users/>\nThe next example adds a triple constraint on the data predicate foaf:age, which must have a value matching the node constraint school:enrolleeAge, which is cited in the triple constraint by reference, indicated by the '@' symbol.\nPREFIX ex: <http://ex.example/#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX school: <http://school.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

school:enrolleeAge xsd:integer MinInclusive 13 MaxInclusive 20 

school:Enrollee {
  foaf:age @school:enrolleeAge ;
  ex:hasGuardian IRI {1,2}
}
          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://school.example/#enrolleeAge",
      "type": "NodeConstraint",
      "datatype": "http://www.w3.org/2001/XMLSchema#integer",
      "mininclusive": 13, "maxinclusive": 20 },
    { "id": "http://school.example/#Enrollee",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://xmlns.com/foaf/0.1/age",
            "valueExpr": "http://school.example/#enrolleeAge" },
          { "type": "TripleConstraint", "min": 1, "max": 2,
            "predicate": "http://ex.example/#hasGuardian",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
            PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX school: <http://school.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Alice foaf:age 13 ;                     
  ex:hasGuardian inst:Person2, inst:Person3 .

inst:Bob foaf:age 15 ;                       
  ex:hasGuardian inst:Person4 .              
try it: js | scala

            PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX school: <http://school.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Claire foaf:age 12 ;                     
  ex:hasGuardian inst:Person5 .               

inst:Don foaf:age 14 .                        
try it: js | scala\n<http://ex.example/#>\n<http://www.w3.org/2001/XMLSchema#>\n<http://school.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n<http://example.com/users/>\n<http://school.example/#>\n<http://xmlns.com/foaf/0.1/>\ninst:Alice foaf:age 13 ;\nex:hasGuardian inst:Person2, inst:Person3 .\ninst:Bob foaf:age 15 ;\nex:hasGuardian inst:Person4 .\n<http://ex.example/#>\n<http://example.com/users/>\n<http://school.example/#>\n<http://xmlns.com/foaf/0.1/>\ninst:Claire foaf:age 12 ;\nex:hasGuardian inst:Person5 .\ninst:Don foaf:age 14 .\nThe four RDF data nodes inst:Alice, inst:Bob, inst:Claire, and inst:Don can be tested against the shape school:Enrollee by using either a fixed shape map, which selects nodes by simple enumeration, or a query shape map, which selects nodes matching a triple pattern.  In the latter, the shape map keyword "FOCUS" identifies the node of the triple to be selected (here, the subject node), and the keyword "_" acts as a placeholder for any object.  For readability, the IRIs are rendered here with prefixes.\ninst:Alice @ school:Enrollee,
inst:Bob @ school:Enrollee,
inst:Claire @ school:Enrollee,
inst:Don @ school:Enrollee\n{FOCUS foaf:age _} @ school:Enrollee\nThis example yields a validation result in the form of a result shape map.  A validation result may be presented in different formats and with different levels of verbosity according to implementation requirements.\nfoaf:age 12 less than 13.\nNo ex:hasGuardian supplied.\n2. ShEx Model and Terminology\n2.1 Validating RDF Data\nIn the Shape Expressions model, RDF data is seen from the standpoint of its structural components, or abstract syntax.
          An RDF graph is a collection of triples.
          A triple is a data structure composed of three RDF terms.
          An RDF term may be an IRI, blank node (BNode), or literal.
          In a triple, RDF terms are arranged in a fixed order, or directed arc, from subject to predicate to object.
          A node in the subject position has an outgoing arc and a node in the object position has an incoming arc.
          RDF data may be serialized in any of several interchangeable concrete syntaxes designed for a variety of application requirements.\nA ShEx schema is a collection of shape expressions that describe an RDF graph in terms of these abstract-syntactic components.
        A shape expression is a logical combination of node constraints and shapes.
          Node constraints define the characteristics of matching RDF nodes.
          A shape describes a collection of RDF triples touching a given RDF node in terms of triple constraints. Triple constraints specify matching RDF triples in terms of their predicates, direction (whether they are incoming or outgoing arcs with respect to a node), cardinality (how many triples should match), or value (characteristics of its subject or object node).\nIn the ShEx model, a given RDF data graph is tested against a ShEx schema to yield a validation result.
          In the example above, the RDF nodes inst:Alice, inst:Bob, inst:Claire and inst:Don are tested against the ShEx shape school:Enrollee.
          In the validation process, each of four nodes in the RDF data is treated, in turn, as a focus node, and triples involving that node are tested against a triple constraint which, in turn, includes the node constraint IRI.
          This validation process is controlled by a shape map that specifies how the constructs of a ShEx schema relate to the components of RDF data graphs.
          There are many ways to populate a shape map with nodes to be validated: through queries, APIs, protocols, or simple enumeration.\nShEx may be serialized using any of three interchangeable concrete syntaxes: 
          Shape Expressions Compact Syntax 
          or ShExC, a compact syntax meant for human eyes and fingers; 
          ShExJ, a JSON-LD [json-ld] (Javascript) syntax meant for machine processing; and ShExR, the RDF interpretation of ShExJ expressed in RDF Turtle syntax [turtle].
          The ShEx schemas in this primer may be viewed in ShExC syntax (by default) or JSON-LD syntax by pressing 'c' or 'j' in the browser or by clicking on the following radio buttons:\nShape Expressions Compact Syntax\n2.2 Basic Terminology\ninverse triple constraints\ninverse triple constraints\nThis document uses a running example illustrated by the following graph in which an Issue is submitted by some person and may be reproduced by the same person or someone else.
            These issues can have a status of unassigned or assigned.\nThe following node constraints can be used alone, or in combination.
        
        
          literal datatype A node constraint that identifies the datatype of an RDF literal.
          my:UserShape {
  foaf:name xsd:string
}
          { "my:UserShape": { "type": "Shape",
  "expression": {
    "type": "TripleConstraint", "predicate": "foaf:name",
    "value": { "type": "NodeConstraint", "datatype": "xsd:string" } } } }

          
          literal facet A node constraint that applies XML Schema constraining facets, including numeric facets, which apply only to numeric RDF literals (MinInclusive, MinExclusive, MaxInclusive, MaxExclusive, TotalDigits, FractionDigits) and string facets, which apply to all RDF literals (Length, MinLength, MaxLength, Pattern).  In the ShExC syntax, facet names are not case-sensitive.

          my:UserShape {
  ex:shoeSize xsd:float MinInclusive 5.5 MaxInclusive 12.5
}
          { "my:UserShape": { "type": "Shape",
  "expression": { "type": "TripleConstraint", "predicate": "ex:shoeSize",
    "value": { "type": "NodeConstraint", "datatype": "http://www.w3.org/2001/XMLSchema#float",
               "mininclusive": 5.5, "maxinclusive": 12.5 } } } }

          
          node kind A node constraint that specifies whether an RDF data node is of kind Literal, IRI, BNode, or NonLiteral, a union of the kinds IRI and BNode.  In the ShExC syntax, node kinds are not case-sensitive.
          my:UserShape {
  foaf:mbox IRI
}
          { "my:UserShape": { "type": "Shape",
  "expression": {
    "type": "TripleConstraint", "predicate": "foaf:mbox",
    "value": { "type": "NodeConstraint", "nodeKind": "IRI" } } } }

          
          value set Enumerates a set of specific expected values.
          my:IssueShape {
  ex:state [ex:unassigned ex:assigned]
}
          { "my:IssueShape": { "type": "Shape",
  "expression": { "type": "TripleConstraint", "predicate": "ex:status",
    "value": { "type": "NodeConstraint", "values": [ "ex:unassigned", "ex:assigned" ] } } } }
          my:IssueShape {
  ex:state ["unassigned" "assigned"]
}
          { "my:IssueShape": { "type": "Shape",
  "expression": { "type": "TripleConstraint", "predicate": "ex:status",
    "value": { "type": "NodeConstraint", "values": [ { "value": "unassigned" }, { "value": "assigned" } ] } } } }
          my:IssueShape {
  ex:state [0 1]
}
          { "my:IssueShape": { "type": "Shape",
  "expression": { "type": "TripleConstraint", "predicate": "ex:status",
    "value": { "type": "NodeConstraint", "values": [ { "value": "0" }, { "value": "1" } ] } } } }
          
          value shape Asserts that the value is described by another shape, e.g.
          my:IssueShape {
  ex:reportedBy @my:UserShape
}
          { "my:IssueShape": { "type": "Shape",
  "expression": { "type": "TripleConstraint", "predicate": "ex:reportedBy",
      "value": "my:PersonShape" } } }\nThe following node constraints can be used alone, or in combination.\n"datatype": "xsd:string"\nXML Schema constraining facets\nxsd:float MinInclusive 5.5 MaxInclusive 12.5\nMinInclusive 5.5 MaxInclusive 12.5\n"mininclusive": 5.5, "maxinclusive": 12.5\n[ex:unassigned ex:assigned]\n[ "ex:unassigned", "ex:assigned" ]\n["unassigned" "assigned"]\n[ { "value": "unassigned" }, { "value": "assigned" } ]\n[ { "value": "0" }, { "value": "1" } ]\n3.2 Triple Constraints\nTriple constraints are evaluated against all of the triples in an RDF graph that touch a given data node.  
          The RDF data node examined during validation is called the focus node.
          Triple constraints identify a predicate and describe matching triples as having the focus node as the subject (or object).
          (The exception is the inverse triple constraint, which describes matching triples as having the focus node as the object.)
          Triple constraints specify a cardinality (how many matching triples are expected or permitted).
          They may include a value constraint, which is a node constraint describing the object of matching triples (or subject, in the case of inverse triple constraints).\nThe following simple example has one shape, my:UserShape, with a single triple constraint on the property foaf:name.
          A value constraint within the triple constraint says that the object of a foaf:name triple must be an RDF literal with a datatype of xsd:string.
          A conforming node in an RDF data graph will have exactly one such triple.
        

        
          
          PREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

my:UserShape {
  foaf:name xsd:string
}
          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://xmlns.com/foaf/0.1/name",
        "valueExpr": {
          "type": "NodeConstraint",
          "datatype": "http://www.w3.org/2001/XMLSchema#string" } } }
  ] }

          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

inst:User1                              
    foaf:name  "Bob Smith"^^xsd:string .

inst:User2                              
    foaf:name  "Bob Smith" .            
try it: js | scala

          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

inst:User3                              
    foaf:name  "Joe Jones"^^xsd:string ;
    foaf:name  "J. Jones"^^xsd:string . 

inst:User4                              
    foaf:name  "Bob Smith"^^xsd:anyURI .
try it: js | scala

          
           
          
            NodeShapeResultReason
            inst:User1my:UserShapepass
            inst:User2my:UserShapepassLiterals in Turtle have a default datatype of xsd:string.
            inst:User3my:UserShapefailExpected exactly one foaf:name arc.
            inst:User4my:UserShapefailExpected an xsd:string, not a xsd:anyURI.
          

          
            The following regular expression conventions are used to specify cardinalities other than the default of "exactly one" (see the example in Quick Start, with cardinality "one or two").
          
          
            "+" - one or more
            "*" - zero or more
            "?" - zero or one
            "{m}" - exactly m
            "{m,n}" - at least m, no more than n\nThe following simple example has one shape, my:UserShape, with a single triple constraint on the property foaf:name.
          A value constraint within the triple constraint says that the object of a foaf:name triple must be an RDF literal with a datatype of xsd:string.
          A conforming node in an RDF data graph will have exactly one such triple.\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

my:UserShape {
  foaf:name xsd:string
}
          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://xmlns.com/foaf/0.1/name",
        "valueExpr": {
          "type": "NodeConstraint",
          "datatype": "http://www.w3.org/2001/XMLSchema#string" } } }
  ] }

          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

inst:User1                              
    foaf:name  "Bob Smith"^^xsd:string .

inst:User2                              
    foaf:name  "Bob Smith" .            
try it: js | scala

          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

inst:User3                              
    foaf:name  "Joe Jones"^^xsd:string ;
    foaf:name  "J. Jones"^^xsd:string . 

inst:User4                              
    foaf:name  "Bob Smith"^^xsd:anyURI .
try it: js | scala\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n<http://ex.example/#>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://www.w3.org/2001/XMLSchema#>\nPREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n<http://ex.example/#>\n<http://example.com/users/>\n<http://xmlns.com/foaf/0.1/>\n<http://www.w3.org/2001/XMLSchema#>\nfoaf:name  "Bob Smith"^^xsd:string .\n"Bob Smith"^^xsd:string\nfoaf:name  "Bob Smith" .\nfoaf:name  "Bob Smith"\nPREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n<http://ex.example/#>\n<http://example.com/users/>\n<http://xmlns.com/foaf/0.1/>\n<http://www.w3.org/2001/XMLSchema#>\nfoaf:name  "Joe Jones"^^xsd:string ;\n"Joe Jones"^^xsd:string\nfoaf:name  "J. Jones"^^xsd:string .\nfoaf:name  "J. Jones"^^xsd:string\n"J. Jones"^^xsd:string\nfoaf:name  "Bob Smith"^^xsd:anyURI .\n"Bob Smith"^^xsd:anyURI\nLiterals in Turtle have a default datatype of xsd:string.\nExpected exactly one foaf:name arc.\nExpected an xsd:string, not a xsd:anyURI.\nThe following regular expression conventions are used to specify cardinalities other than the default of "exactly one" (see the example in Quick Start, with cardinality "one or two").\nexample in Quick Start\n"{m,n}" - at least m, no more than n\n3.3 Grouping Triple Constraints in Shapes\nThe examples above show just one triple constraint per shape.
          In practice, most shape declarations will include multiple constraints.
          In the ShExC syntax, triple constraints are separated by a semi-colon.
          In the following example, the shape my:IssueShape will match:
        
      
        exactly one data triple with predicate ex:state and a value in the value set ex:unassigned or ex:assigned,
        exactly one data triple with predicate ex:reportedBy and a value matching the shape labeled my:UserShape.
      
      
        The shape labeled my:UserShape must have:
      
      
        exactly one triple constraint on predicate foaf:name with a value of the literal datatype xsd:string
        one or more triple constraints on predicate foaf:mbox with a node kind of IRI.
      

        
          
          PREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:reportedBy @my:UserShape
}

my:UserShape {
  foaf:name xsd:string;
  foaf:mbox IRI+
}

          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#unassigned",
                "http://ex.example/#assigned"
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reportedBy",
            "valueExpr": "http://my.example/#UserShape" }
        ] } },
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://xmlns.com/foaf/0.1/name",
            "valueExpr": {
              "type": "NodeConstraint",
              "datatype": "http://www.w3.org/2001/XMLSchema#string" } },
          { "type": "TripleConstraint", "min": 1, "max": -1,
            "predicate": "http://xmlns.com/foaf/0.1/mbox",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
          PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned ;
    ex:reportedBy   inst:User2 .

inst:User2 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
try it: js | scala
          PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:Issue3 a ex:Issue ;
    ex:state        ex:unsinged ; # <-- typo
    ex:reportedBy   inst:User4 .

inst:User4 a foaf:Person ;
    foaf:name       "Bob Smith", "Robert Smith" ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
try it: js | scala
      
          
      
        NodeShapeResultReason
        inst:Issue1my:IssueShapepass
        inst:User2 my:UserShapepass
        inst:Issue3my:IssueShapefailex:unsinged not in range of ex:status.
        inst:User4 my:UserShapefailMax cardinality of foaf:name exceeded.\nThe examples above show just one triple constraint per shape.
          In practice, most shape declarations will include multiple constraints.
          In the ShExC syntax, triple constraints are separated by a semi-colon.
          In the following example, the shape my:IssueShape will match:\nexactly one data triple with predicate ex:state and a value in the value set ex:unassigned or ex:assigned,\nex:unassigned or ex:assigned\nexactly one data triple with predicate ex:reportedBy and a value matching the shape labeled my:UserShape.\nThe shape labeled my:UserShape must have:\nexactly one triple constraint on predicate foaf:name with a value of the literal datatype xsd:string\none or more triple constraints on predicate foaf:mbox with a node kind of IRI.\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:reportedBy @my:UserShape
}

my:UserShape {
  foaf:name xsd:string;
  foaf:mbox IRI+
}

          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#unassigned",
                "http://ex.example/#assigned"
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reportedBy",
            "valueExpr": "http://my.example/#UserShape" }
        ] } },
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://xmlns.com/foaf/0.1/name",
            "valueExpr": {
              "type": "NodeConstraint",
              "datatype": "http://www.w3.org/2001/XMLSchema#string" } },
          { "type": "TripleConstraint", "min": 1, "max": -1,
            "predicate": "http://xmlns.com/foaf/0.1/mbox",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
          PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned ;
    ex:reportedBy   inst:User2 .

inst:User2 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
try it: js | scala
          PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:Issue3 a ex:Issue ;
    ex:state        ex:unsinged ; # <-- typo
    ex:reportedBy   inst:User4 .

inst:User4 a foaf:Person ;
    foaf:name       "Bob Smith", "Robert Smith" ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
try it: js | scala\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n<http://ex.example/#>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://www.w3.org/2001/XMLSchema#>\nex:state [ex:unassigned ex:assigned]\nex:unassigned ex:assigned\nex:reportedBy @my:UserShape\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>\n<http://ex.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://inst.example/#>\nex:state        ex:unassigned\nex:reportedBy   inst:User2\nfoaf:name       "Bob Smith"\nfoaf:mbox       <mailto:bob@example.org>\n<mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox       <mailto:rs@example.org>\n<mailto:rs@example.org>\n<mailto:rs@example.org>\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>\n<http://ex.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://inst.example/#>\nex:state        ex:unsinged\nex:reportedBy   inst:User4\nfoaf:name       "Bob Smith", "Robert Smith"\nfoaf:mbox       <mailto:bob@example.org>\n<mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox       <mailto:rs@example.org>\n<mailto:rs@example.org>\n<mailto:rs@example.org>\nex:unsinged not in range of ex:status.\nMax cardinality of foaf:name exceeded.\nNote that a shape composed of triple expressions with a minimum cardinality of zero will trivially match any RDF node that does not have outgoing arcs.\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://ex.example/#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:reportedBy @my:UserShape
}

my:UserShape {
  foaf:name LITERAL?;
  foaf:mbox IRI*
}

          
          { "@context": "https://shexspec.github.io/context.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#unassigned",
                "http://ex.example/#assigned"
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reportedBy",
            "valueExpr": "http://my.example/#UserShape" }
        ] } },
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint", "min": 0, "max": 1,
            "predicate": "http://xmlns.com/foaf/0.1/name",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" }
          },
          { "type": "TripleConstraint", "min": 0, "max": -1,
            "predicate": "http://xmlns.com/foaf/0.1/mbox",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
          PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>

inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned ;
    ex:reportedBy   "Bob Smith" .
try it: js | scala
        
        

        
          NodeShapeResultReason
          inst:Issue1my:IssueShapepass
          "Bob Smith" my:UserShapepassMatched 0 foaf:name and 0 foaf:mbox arcs.\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://ex.example/#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:reportedBy @my:UserShape
}

my:UserShape {
  foaf:name LITERAL?;
  foaf:mbox IRI*
}

          
          { "@context": "https://shexspec.github.io/context.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#unassigned",
                "http://ex.example/#assigned"
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reportedBy",
            "valueExpr": "http://my.example/#UserShape" }
        ] } },
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint", "min": 0, "max": 1,
            "predicate": "http://xmlns.com/foaf/0.1/name",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" }
          },
          { "type": "TripleConstraint", "min": 0, "max": -1,
            "predicate": "http://xmlns.com/foaf/0.1/mbox",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
          PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>

inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned ;
    ex:reportedBy   "Bob Smith" .
try it: js | scala\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://ex.example/#>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\nPREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>\n<http://inst.example/#>\n<http://ex.example/#>\nMatched 0 foaf:name and 0 foaf:mbox arcs.\nFor both properties in my:UserShape, the minimum number of triples is zero.
        Any RDF data node will match this shape as long as it does not have conflicting ex:state or ex:reportedBy properties.
        Since no RDF literal may be the subject of RDF triples, any literal would satisfy this shape.  This can lead to unintended results and confusing errors.\n3.4 Combining Value Constraints\nValue constraints can be combined, for example to say that an issue conforms to a given shape and is identified by an IRI matching a certain pattern.
          

          
            
            PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX my: <http://my.example/#>

my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ex:reproducedBy @my:EmployeeShape
}

my:EmployeeShape IRI                      
 /^http:\/\/hr\.example\/id#[0-9]+/ {      
  foaf:name LITERAL;                      
  ex:department [ex:ProgrammingDepartment]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#accepted",
                "http://ex.example/#resolved"
              ]
            } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reproducedBy",
            "valueExpr": "http://my.example/#EmployeeShape" }
        ] } },
    { "id": "http://my.example/#EmployeeShape",
      "type": "ShapeAnd",
      "shapeExprs": [
        { "type": "NodeConstraint",
          "nodeKind": "iri",
          "pattern": "^http://hr.example/id#[0-9]+" },
        { "type": "Shape",
          "expression": {
            "type": "EachOf",
            "expressions": [
              {
                "type": "TripleConstraint",
                "predicate": "http://xmlns.com/foaf/0.1/name",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "literal" } },
              {
                "type": "TripleConstraint",
                "predicate": "http://ex.example/#department",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "values": [
                    "http://ex.example/#ProgrammingDepartment"
                  ] } }
            ] } }
      ] }
  ] }
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>

inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy <http://hr.example/id#123> .

<http://hr.example/id#123>                  
  foaf:name "Bob Smith" ;                   
  ex:department ex:ProgrammingDepartment .  
try it: js | scala
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>

inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy <http://hr.example/id#abc> .

<http://hr.example/id#abc>                  
  foaf:name "Bob Smith" ;                   
  ex:department ex:ProgrammingDepartment .  
try it: js | scala
            
          
            
              NodeShapeResultReason
              inst:User1my:UserShapepass
              <http://hr.example/id#123>my:EmployeeShapepass
              inst:User3my:UserShapefailObject of ex:reproducedBy does not match my:EmployeeShape.
              <http://hr.example/id#abc>my:EmployeeShapefail<http://hr.example/id#abc> does not match regular expression.\nValue constraints can be combined, for example to say that an issue conforms to a given shape and is identified by an IRI matching a certain pattern.\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX my: <http://my.example/#>

my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ex:reproducedBy @my:EmployeeShape
}

my:EmployeeShape IRI                      
 /^http:\/\/hr\.example\/id#[0-9]+/ {      
  foaf:name LITERAL;                      
  ex:department [ex:ProgrammingDepartment]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#accepted",
                "http://ex.example/#resolved"
              ]
            } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reproducedBy",
            "valueExpr": "http://my.example/#EmployeeShape" }
        ] } },
    { "id": "http://my.example/#EmployeeShape",
      "type": "ShapeAnd",
      "shapeExprs": [
        { "type": "NodeConstraint",
          "nodeKind": "iri",
          "pattern": "^http://hr.example/id#[0-9]+" },
        { "type": "Shape",
          "expression": {
            "type": "EachOf",
            "expressions": [
              {
                "type": "TripleConstraint",
                "predicate": "http://xmlns.com/foaf/0.1/name",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "literal" } },
              {
                "type": "TripleConstraint",
                "predicate": "http://ex.example/#department",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "values": [
                    "http://ex.example/#ProgrammingDepartment"
                  ] } }
            ] } }
      ] }
  ] }
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>

inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy <http://hr.example/id#123> .

<http://hr.example/id#123>                  
  foaf:name "Bob Smith" ;                   
  ex:department ex:ProgrammingDepartment .  
try it: js | scala
              PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>

inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy <http://hr.example/id#abc> .

<http://hr.example/id#abc>                  
  foaf:name "Bob Smith" ;                   
  ex:department ex:ProgrammingDepartment .  
try it: js | scala\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX my: <http://my.example/#>\n<http://ex.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://www.w3.org/2001/XMLSchema#>\n<http://my.example/#>\nex:accepted ex:resolved\n/^http:\/\/hr\.example\/id#[0-9]+/\n^http:\/\/hr\.example\/id#[0-9]+\nex:ProgrammingDepartment\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://inst.example/#>\n<http://ex.example/#>\n<http://hr.example/id#123>\n<http://hr.example/id#123>\nex:ProgrammingDepartment\nProgrammingDepartment\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>
PREFIX ex: <http://ex.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://inst.example/#>\n<http://ex.example/#>\n<http://hr.example/id#abc>\n<http://hr.example/id#abc>\nex:ProgrammingDepartment\nProgrammingDepartment\n<http://hr.example/id#123>\nObject of ex:reproducedBy does not match my:EmployeeShape.\n<http://hr.example/id#abc>\n<http://hr.example/id#abc> does not match regular expression.\n<http://hr.example/id#abc>\nIn the examples above, value expressions referenced shape expressions with the '@' symbol.
          It is also possible to write "anonymous" shapes directly in the value expression.
          In the example below, the value of the triple constraint on predicate ex:reportedBy is a shape comprised of triples constraints on the predicates foaf:name and foaf:mbox.  
          In ShExC syntax, this anonymous shape is enclosed in curly brackets.
          In ShExJ, it is contained in the triple constraint's valueExpr property.\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://ex.example/#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:reportedBy {
    foaf:name LITERAL;
    foaf:mbox IRI+
  }
}

          
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#unassigned",
                "http://ex.example/#assigned"
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reportedBy",
            "valueExpr": {
              "type": "Shape",
              "expression": {
                "type": "EachOf",
                "expressions": [
                  { "type": "TripleConstraint",
                    "predicate": "http://xmlns.com/foaf/0.1/name",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "literal" } },
                  {
                    "type": "TripleConstraint", "min": 1, "max": -1,
                    "predicate": "http://xmlns.com/foaf/0.1/mbox",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "iri" } }
                ] } } }
        ] } }
  ] }\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://ex.example/#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:reportedBy {
    foaf:name LITERAL;
    foaf:mbox IRI+
  }
}

          
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#state",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://ex.example/#unassigned",
                "http://ex.example/#assigned"
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#reportedBy",
            "valueExpr": {
              "type": "Shape",
              "expression": {
                "type": "EachOf",
                "expressions": [
                  { "type": "TripleConstraint",
                    "predicate": "http://xmlns.com/foaf/0.1/name",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "literal" } },
                  {
                    "type": "TripleConstraint", "min": 1, "max": -1,
                    "predicate": "http://xmlns.com/foaf/0.1/mbox",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "iri" } }
                ] } } }
        ] } }
  ] }\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://ex.example/#>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n[ex:unassigned ex:assigned]\n3.6 Expressions with Choices\nMost schema languages offer a way to express choices.
          In the following example, a user has either a simple name (foaf:name), or a composite name (foaf:familyName with one or more foaf:givenNames).
          The user must have exactly one foaf:mbox.
        

        
          
          PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

my:UserShape {
  (                              
     foaf:name LITERAL
                                 
    |                            
      foaf:givenName LITERAL+;
      foaf:familyName LITERAL
  );                             
  foaf:mbox IRI
}

          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "OneOf",
            "expressions": [
              { "type": "TripleConstraint",
                "predicate": "http://xmlns.com/foaf/0.1/name",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "literal" } },
              { "type": "EachOf",
                "expressions": [
                  { "type": "TripleConstraint", "min": 1, "max": -1,
                    "predicate": "http://xmlns.com/foaf/0.1/givenName",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "literal" } },
                  { "type": "TripleConstraint",
                    "predicate": "http://xmlns.com/foaf/0.1/familyName",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "literal" } }
                ] }
            ] },
          { "type": "TripleConstraint",
            "predicate": "http://xmlns.com/foaf/0.1/mbox",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
          PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:User1 a foaf:Person ;
    foaf:name       "Alice Walker" ;
    foaf:mbox       <mailto:awalker@example.org> .

inst:User2 a foaf:Person ;
    foaf:givenName  "Robert" ;
    foaf:givenName  "Paris" ;
    foaf:familyName "Moses" ;
    foaf:mbox       <mailto:rpmoses@example.org> .
try it: js | scala
          PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:User3 a foaf:Person ;
    foaf:givenName  "Smith" ;
    foaf:mbox       <mailto:bobs@example.org> .

inst:User4 a foaf:Person ;
    foaf:name       "A" ;
    foaf:givenName  "B" ;
    foaf:familyName "C" ;
    foaf:mbox       <mailto:bobs@example.org> .

inst:User5 a foaf:Person ;
    foaf:name       "A" ;
    foaf:givenName  "B" ;
    foaf:mbox       <mailto:bobs@example.org> .
try it: js | scala

          
      
          
            NodeShapeResultReason
            inst:User1my:UserShapepass
            inst:User2my:UserShapepass
            inst:User3my:UserShapefailExpected a foaf:familyName arc.
            inst:User4my:UserShapefailExpected only one disjunction to pass.
            inst:User5my:UserShapefailExtra foaf:givenName arc.\nMost schema languages offer a way to express choices.
          In the following example, a user has either a simple name (foaf:name), or a composite name (foaf:familyName with one or more foaf:givenNames).
          The user must have exactly one foaf:mbox.\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

my:UserShape {
  (                              
     foaf:name LITERAL
                                 
    |                            
      foaf:givenName LITERAL+;
      foaf:familyName LITERAL
  );                             
  foaf:mbox IRI
}

          
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#UserShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "OneOf",
            "expressions": [
              { "type": "TripleConstraint",
                "predicate": "http://xmlns.com/foaf/0.1/name",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "literal" } },
              { "type": "EachOf",
                "expressions": [
                  { "type": "TripleConstraint", "min": 1, "max": -1,
                    "predicate": "http://xmlns.com/foaf/0.1/givenName",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "literal" } },
                  { "type": "TripleConstraint",
                    "predicate": "http://xmlns.com/foaf/0.1/familyName",
                    "valueExpr": {
                      "type": "NodeConstraint",
                      "nodeKind": "literal" } }
                ] }
            ] },
          { "type": "TripleConstraint",
            "predicate": "http://xmlns.com/foaf/0.1/mbox",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "iri" } }
        ] } }
  ] }
          PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:User1 a foaf:Person ;
    foaf:name       "Alice Walker" ;
    foaf:mbox       <mailto:awalker@example.org> .

inst:User2 a foaf:Person ;
    foaf:givenName  "Robert" ;
    foaf:givenName  "Paris" ;
    foaf:familyName "Moses" ;
    foaf:mbox       <mailto:rpmoses@example.org> .
try it: js | scala
          PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>

inst:User3 a foaf:Person ;
    foaf:givenName  "Smith" ;
    foaf:mbox       <mailto:bobs@example.org> .

inst:User4 a foaf:Person ;
    foaf:name       "A" ;
    foaf:givenName  "B" ;
    foaf:familyName "C" ;
    foaf:mbox       <mailto:bobs@example.org> .

inst:User5 a foaf:Person ;
    foaf:name       "A" ;
    foaf:givenName  "B" ;
    foaf:mbox       <mailto:bobs@example.org> .
try it: js | scala\nPREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\nfoaf:givenName LITERAL+\nfoaf:familyName LITERAL\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://inst.example/#>\nfoaf:name       "Alice Walker"\nfoaf:mbox       <mailto:awalker@example.org>\n<mailto:awalker@example.org>\nfoaf:givenName  "Robert"\nfoaf:givenName  "Paris"\nfoaf:familyName "Moses"\nfoaf:mbox       <mailto:rpmoses@example.org>\n<mailto:rpmoses@example.org>\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX inst: <http://inst.example/#>\n<http://xmlns.com/foaf/0.1/>\n<http://inst.example/#>\nfoaf:givenName  "Smith"\nfoaf:mbox       <mailto:bobs@example.org>\n<mailto:bobs@example.org>\nfoaf:mbox       <mailto:bobs@example.org>\n<mailto:bobs@example.org>\nfoaf:mbox       <mailto:bobs@example.org>\n<mailto:bobs@example.org>\nExpected a foaf:familyName arc.\nExpected only one disjunction to pass.\nExtra foaf:givenName arc.\nA value set is a value constraint for enumerating the set of permissible RDF nodes.
          The values can be IRIs, literals or language tags.
          In the example below, "[@en @fr]" matches any RDF literal with a language tag of "en" or "fr".\n[ex:unassigned ex:assigned]\n[ "ex:unassigned", "ex:assigned" ]\n["unassigned" "assigned"]\n[ "\"unassigned\'", "\"assigned\"" ]\nPREFIX my: <http://my.example/#>
PREFIX ex: <http://ex.example/users/>\n<http://my.example/#>\n<http://ex.example/users/>\n[ "\"unassigned\'", "\"assigned\"" ]\nFixed values are represented as value sets with one member.
          For example, a required type triple can be expressed in the following two ways using the ShExC syntax:\nA value set can also contain stems for IRIs, strings and language tags.
          An IRI orx string stem matches any IRI or string that starts with the stem.
          A language tag stem matches any literal with a language tag that starts with the stem.
          These are flagged as stems by appending a tilde ("~").\nThe last triple constraint in my:IssueShape below is an       inverse triple constraint.
          These are described in the next section.
          This inverse triple constraint states that every my:IssueShape must have an incoming arc from one of two nodes: my:Product1 or my:Product2.\ninverse triple constraint\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status   [ excodes:~ auxterms:~ ];
  ex:mood     [ @en~ - @en-fr ];
 ^ex:hasIssue [ my:Product1 my:Product2 ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://a.example/#status",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                { "type": "IriStemRange",
                  "stem": "http://a.example/codes#" },
                { "type": "IriStemRange",
                  "stem": "http://aux.example/terms#" }
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://a.example/#mood",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                {
                  "type": "LanguageStemRange",
                  "stem": { "value": "en" },
                  "exclusions": [
                    { "value": "en-fr" }
                  ] }
              ] } },
          { "type": "TripleConstraint",
            "inverse": true,
            "predicate": "http://a.example/#hasIssue",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://my.example/#Product1",
                "http://my.example/#Product2"
              ] } }
        ] } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue1 ex:status   excodes:resolved ;
            ex:mood     "hungry"@en-gb .
my:Product2 ex:hasIssue inst:Issue1 .
try it: js | scala
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status   ex:done ;
            ex:mood     "angry"@en-fr .
my:Product1 ex:hasIssue inst:Issue2 .

inst:Issue3 ex:status  auxterms:done.
my:Product3 ex:hasIssue inst:Issue3 .
try it: js | scala
            
          
              
                NodeShapeResultReason
                inst:Issue1my:IssueShapepass
                inst:Issue2my:IssueShapefailex:done not in range of ex:status.Excluded language tag for ex:mood.
                inst:Issue3my:IssueShapefailmy:Product3 not in range of ex:hasIssue.\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status   [ excodes:~ auxterms:~ ];
  ex:mood     [ @en~ - @en-fr ];
 ^ex:hasIssue [ my:Product1 my:Product2 ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "TripleConstraint",
            "predicate": "http://a.example/#status",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                { "type": "IriStemRange",
                  "stem": "http://a.example/codes#" },
                { "type": "IriStemRange",
                  "stem": "http://aux.example/terms#" }
              ] } },
          { "type": "TripleConstraint",
            "predicate": "http://a.example/#mood",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                {
                  "type": "LanguageStemRange",
                  "stem": { "value": "en" },
                  "exclusions": [
                    { "value": "en-fr" }
                  ] }
              ] } },
          { "type": "TripleConstraint",
            "inverse": true,
            "predicate": "http://a.example/#hasIssue",
            "valueExpr": {
              "type": "NodeConstraint",
              "values": [
                "http://my.example/#Product1",
                "http://my.example/#Product2"
              ] } }
        ] } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue1 ex:status   excodes:resolved ;
            ex:mood     "hungry"@en-gb .
my:Product2 ex:hasIssue inst:Issue1 .
try it: js | scala
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status   ex:done ;
            ex:mood     "angry"@en-fr .
my:Product1 ex:hasIssue inst:Issue2 .

inst:Issue3 ex:status  auxterms:done.
my:Product3 ex:hasIssue inst:Issue3 .
try it: js | scala\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n[ excodes:~ auxterms:~ ]\n[ my:Product1 my:Product2 ]\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n<http://inst.example/#>\nmy:Product2 ex:hasIssue inst:Issue1\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n<http://inst.example/#>\ninst:Issue2 ex:status   ex:done\nmy:Product1 ex:hasIssue inst:Issue2\nmy:Product1 ex:hasIssue inst:Issue2\ninst:Issue3 ex:status  auxterms:done\nmy:Product3 ex:hasIssue inst:Issue3\nmy:Product3 ex:hasIssue inst:Issue3\nex:done not in range of ex:status.Excluded language tag for ex:mood.\nmy:Product3 not in range of ex:hasIssue.\nWhile IRI, string and language tag stems match any terms starting with the stem, one may wish to exclude specific terms or term stems.
            Stem exclusions are expressed by following a stem with one or more exclusions.
            An exclusion consists of a minus ("-") followed by an IRI, IRI stem, string, string stem, language tag, or language tag stem.
          

          
          
            
            PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status [
      excodes:~ - excodes:unassigned - excodes:assigned
      auxterms:~ - <http://aux.example/terms#med_>~
  ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://a.example/#status",
        "valueExpr": {
          "type": "NodeConstraint",
          "values": [
            { "type": "IriStemRange",
              "stem": "http://a.example/codes#",
              "exclusions": [
                "http://a.example/codes#unassigned",
                "http://a.example/codes#assigned"
              ] },
            { "type": "IriStemRange",
              "stem": "http://aux.example/terms#",
              "exclusions": [
                { "type": "IriStem",
                  "stem": "http://aux.example/terms#med_" }
              ] }
          ] } } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status  excodes:resolved .
                                         
inst:Issue3 ex:status  excodes:assigned.
                                         
inst:Issue4 ex:status  auxterms:med_sniffles.
                                         
inst:Issue5 ex:status  ex:done.
try it: js | scala
            
          
              
                NodeShapeResultReason
                inst:Issue2my:IssueShapepass
                inst:Issue3my:IssueShapefailexcodes:assigned excluded.
                inst:Issue4my:IssueShapefailauxterms:med_… terms excluded.
                inst:Issue5my:IssueShapefailex:done not in range of ex:status.
              
            
          

          
            A period (.) can be used with exclusions to say that any term is permitted except the exclusions.
          

          
          
            
            PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status [
    . - excodes:retracted - excodes:assigned
  ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://a.example/#status",
        "valueExpr": {
          "type": "NodeConstraint",
          "values": [
            { "type": "IriStemRange",
              "stem": {
                "type": "Wildcard" },
              "exclusions": [
                "http://a.example/codes#retracted",
                "http://a.example/codes#assigned"
              ] }
          ] } } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue1 ex:status  ex:random .
try it: js | scala
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status  excodes:assigned.
try it: js | scala
            
          
            
              NodeShapeResultReason
              inst:Issue1my:IssueShapepass
              inst:Issue2my:IssueShapefailexcodes:assigned is excluded.\nWhile IRI, string and language tag stems match any terms starting with the stem, one may wish to exclude specific terms or term stems.
            Stem exclusions are expressed by following a stem with one or more exclusions.
            An exclusion consists of a minus ("-") followed by an IRI, IRI stem, string, string stem, language tag, or language tag stem.\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status [
      excodes:~ - excodes:unassigned - excodes:assigned
      auxterms:~ - <http://aux.example/terms#med_>~
  ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://a.example/#status",
        "valueExpr": {
          "type": "NodeConstraint",
          "values": [
            { "type": "IriStemRange",
              "stem": "http://a.example/codes#",
              "exclusions": [
                "http://a.example/codes#unassigned",
                "http://a.example/codes#assigned"
              ] },
            { "type": "IriStemRange",
              "stem": "http://aux.example/terms#",
              "exclusions": [
                { "type": "IriStem",
                  "stem": "http://aux.example/terms#med_" }
              ] }
          ] } } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status  excodes:resolved .
                                         
inst:Issue3 ex:status  excodes:assigned.
                                         
inst:Issue4 ex:status  auxterms:med_sniffles.
                                         
inst:Issue5 ex:status  ex:done.
try it: js | scala
            
          
              
                NodeShapeResultReason
                inst:Issue2my:IssueShapepass
                inst:Issue3my:IssueShapefailexcodes:assigned excluded.
                inst:Issue4my:IssueShapefailauxterms:med_… terms excluded.
                inst:Issue5my:IssueShapefailex:done not in range of ex:status.\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status [
      excodes:~ - excodes:unassigned - excodes:assigned
      auxterms:~ - <http://aux.example/terms#med_>~
  ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://a.example/#status",
        "valueExpr": {
          "type": "NodeConstraint",
          "values": [
            { "type": "IriStemRange",
              "stem": "http://a.example/codes#",
              "exclusions": [
                "http://a.example/codes#unassigned",
                "http://a.example/codes#assigned"
              ] },
            { "type": "IriStemRange",
              "stem": "http://aux.example/terms#",
              "exclusions": [
                { "type": "IriStem",
                  "stem": "http://aux.example/terms#med_" }
              ] }
          ] } } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status  excodes:resolved .
                                         
inst:Issue3 ex:status  excodes:assigned.
                                         
inst:Issue4 ex:status  auxterms:med_sniffles.
                                         
inst:Issue5 ex:status  ex:done.
try it: js | scala\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n[
      excodes:~ - excodes:unassigned - excodes:assigned
      auxterms:~ - <http://aux.example/terms#med_>~
  ]\n<http://aux.example/terms#med_>~\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n<http://inst.example/#>\ninst:Issue2 ex:status  excodes:resolved\ninst:Issue3 ex:status  excodes:assigned\ninst:Issue4 ex:status  auxterms:med_sniffles\nauxterms:med_sniffles\nauxterms:med_sniffles\ninst:Issue5 ex:status  ex:done\nexcodes:assigned excluded.\nauxterms:med_… terms excluded.\nex:done not in range of ex:status.\nA period (.) can be used with exclusions to say that any term is permitted except the exclusions.\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status [
    . - excodes:retracted - excodes:assigned
  ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://a.example/#status",
        "valueExpr": {
          "type": "NodeConstraint",
          "values": [
            { "type": "IriStemRange",
              "stem": {
                "type": "Wildcard" },
              "exclusions": [
                "http://a.example/codes#retracted",
                "http://a.example/codes#assigned"
              ] }
          ] } } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue1 ex:status  ex:random .
try it: js | scala
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status  excodes:assigned.
try it: js | scala
            
          
            
              NodeShapeResultReason
              inst:Issue1my:IssueShapepass
              inst:Issue2my:IssueShapefailexcodes:assigned is excluded.\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>

my:IssueShape {
  ex:status [
    . - excodes:retracted - excodes:assigned
  ]
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "shapes": [
    { "id": "http://my.example/#IssueShape",
      "type": "Shape",
      "expression": {
        "type": "TripleConstraint",
        "predicate": "http://a.example/#status",
        "valueExpr": {
          "type": "NodeConstraint",
          "values": [
            { "type": "IriStemRange",
              "stem": {
                "type": "Wildcard" },
              "exclusions": [
                "http://a.example/codes#retracted",
                "http://a.example/codes#assigned"
              ] }
          ] } } }
  ] }
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue1 ex:status  ex:random .
try it: js | scala
              PREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>

inst:Issue2 ex:status  excodes:assigned.
try it: js | scala\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n[
    . - excodes:retracted - excodes:assigned
  ]\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n<http://inst.example/#>\ninst:Issue1 ex:status  ex:random\nPREFIX ex: <http://a.example/#>
PREFIX my: <http://my.example/#>
PREFIX excodes: <http://a.example/codes#>
PREFIX auxterms: <http://aux.example/terms#>
PREFIX inst: <http://inst.example/#>\n<http://my.example/#>\n<http://a.example/codes#>\n<http://aux.example/terms#>\n<http://inst.example/#>\ninst:Issue2 ex:status  excodes:assigned\nexcodes:assigned is excluded.\n4.1 Inverse Triple Constraints\nPlacing a regular triple constraint on predicate ex:reportedIssue into my:UserShape effectively requires all users to have reported an issue.
          

          
            
            PREFIX my: <http://my.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned]
}

my:UserShape {
  foaf:name LITERAL;
  foaf:mbox IRI+;
  ex:reportedIssue @my:IssueShape
}

            
            { "type": "Schema",
  "shapes": {
    "my:IssueShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "ex:state",                      
            "value": { "type": "NodeConstraint",              
              "values": [ "ex:unassigned", "ex:assigned" ]
            }                                             
          }
        ]
      }
    },
    "my:UserShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                
              "type": "NodeConstraint",   
              "datatype": "xsd:string"
            }                         
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",              
              "nodeKind": "iri"                           
            },                              
            "min": 1, "max": -1
          },                                              
          { "type": "TripleConstraint",                      
            "predicate": "ex:reportedIssue", "inverse": false,
            "value": "my:IssueShape"                   
          }                                                  
        ]
      }
    }
  }
}
            inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned .

inst:User2 a foaf:Person ;                     
    foaf:name       "Bob Smith" ;              
    foaf:mbox       <mailto:bob@example.org> ; 
    foaf:mbox       <mailto:rs@example.org> .  

inst:User3 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    ex:reportedIssue inst:Issue1 ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
            
          
            
              NodeShapeResultReason
              inst:Issue1my:IssueShapepass
              inst:User2my:UserShapefailExpected ex:reportedIssue property.
              inst:User3my:UserShapepass\nPlacing a regular triple constraint on predicate ex:reportedIssue into my:UserShape effectively requires all users to have reported an issue.\nPREFIX my: <http://my.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

my:IssueShape {
  ex:state [ex:unassigned ex:assigned]
}

my:UserShape {
  foaf:name LITERAL;
  foaf:mbox IRI+;
  ex:reportedIssue @my:IssueShape
}

            
            { "type": "Schema",
  "shapes": {
    "my:IssueShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "ex:state",                      
            "value": { "type": "NodeConstraint",              
              "values": [ "ex:unassigned", "ex:assigned" ]
            }                                             
          }
        ]
      }
    },
    "my:UserShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                
              "type": "NodeConstraint",   
              "datatype": "xsd:string"
            }                         
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",              
              "nodeKind": "iri"                           
            },                              
            "min": 1, "max": -1
          },                                              
          { "type": "TripleConstraint",                      
            "predicate": "ex:reportedIssue", "inverse": false,
            "value": "my:IssueShape"                   
          }                                                  
        ]
      }
    }
  }
}
            inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned .

inst:User2 a foaf:Person ;                     
    foaf:name       "Bob Smith" ;              
    foaf:mbox       <mailto:bob@example.org> ; 
    foaf:mbox       <mailto:rs@example.org> .  

inst:User3 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    ex:reportedIssue inst:Issue1 ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .\nPREFIX my: <http://my.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n<http://my.example/#>\n<http://example.com/users/>\n<http://xmlns.com/foaf/0.1/>\n<http://www.w3.org/2001/XMLSchema#>\n[ex:unassigned ex:assigned]\nex:reportedIssue @my:IssueShape\n"predicate": "ex:state"\n"value": { "type": "NodeConstraint",\n"values": [ "ex:unassigned", "ex:assigned" ]\n"predicate": "foaf:name"\n"type": "NodeConstraint",\n"datatype": "xsd:string"\n"predicate": "foaf:mbox"\n"value": { "type": "NodeConstraint",\n{ "type": "TripleConstraint",\n"predicate": "ex:reportedIssue", "inverse": false,\n"predicate": "ex:reportedIssue"\n"value": "my:IssueShape"\n"value": "my:IssueShape"\nex:state        ex:unassigned\ninst:User2 a foaf:Person ;\nfoaf:name       "Bob Smith" ;\nfoaf:name       "Bob Smith"\nfoaf:mbox       <mailto:bob@example.org> ;\nfoaf:mbox       <mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox       <mailto:rs@example.org> .\nfoaf:mbox       <mailto:rs@example.org>\n<mailto:rs@example.org>\nfoaf:name       "Bob Smith"\nex:reportedIssue inst:Issue1\nfoaf:mbox       <mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox       <mailto:rs@example.org>\n<mailto:rs@example.org>\nExpected ex:reportedIssue property.\nHowever, it may be more precise to require that for every issue, there is some user who reported it.
            This could be expressed in the data by describing every issue as being reported by (ex:reportedBy) a user.
            Alternatively, an issue could be described as the object of a triple with predicate ex:reportedIssue.
            A triple constraint for such an incoming arc may expressed in the ShExC syntax by prefixing the constraint with a caret (^) and in the ShExJ syntax with "inverse": true.
          

          
            
            my:IssueShape {
  ex:state [ex:unassigned ex:assigned];
 ^ex:reportedIssue @my:UserShape
}

my:UserShape {
  foaf:name LITERAL;
  foaf:mbox IRI+
}

            
            { "type": "Schema",
  "shapes": {
    "my:IssueShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "ex:state",                      
            "value": { "type": "NodeConstraint",              
              "values": [ "ex:unassigned", "ex:assigned" ]
            }                                             
          },                                              
          { "type": "TripleConstraint",                      
            "predicate": "ex:reportedIssue", "inverse": true,
            "value": "my:IssueShape"                   
          }                                                  
        ]
      }
    },
    "my:UserShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                
              "type": "NodeConstraint",   
              "datatype": "xsd:string"
            }                         
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",              
              "nodeKind": "iri"                           
            },                              
            "min": 1, "max": -1            
          }                                               
        ]
      }
    }
  }
}
            
            
            inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned .
inst:User1 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    ex:reportedIssue inst:Issue1 ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
            inst:Issue2 a ex:Issue ;
    ex:state         ex:unassigned ;
    ex:reportedBy    inst:User2 .
inst:User2 a foaf:Person ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    foaf:mbox        <mailto:rs@example.org> .

inst:Issue3 a ex:Issue ;
    ex:state         ex:unassigned ;
    ex:reportedIssue inst:User3 .
inst:User3 a foaf:Person ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    foaf:mbox        <mailto:rs@example.org> .

inst:Issue4 a ex:Issue ;
    ex:state         ex:unassigned .
inst:User4 a foaf:Person ;
    foaf:name        "Robert" ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    ex:reportedIssue inst:Issue4 .
  
            
          
            
              NodeShapeResultReason
              inst:Issue1my:IssueShapepass
              inst:Issue2my:IssueShapefailMissing incoming ex:reportedIssue property.
              inst:Issue3my:IssueShapefailex:reportedIssue is in the wrong direction.
              inst:Issue4my:IssueShapefailSubject of ex:reportedIssue does not match my:UserShape;
              inst:User4my:UserShapefailMax cardinality of foaf:name exceeded.\nHowever, it may be more precise to require that for every issue, there is some user who reported it.
            This could be expressed in the data by describing every issue as being reported by (ex:reportedBy) a user.
            Alternatively, an issue could be described as the object of a triple with predicate ex:reportedIssue.
            A triple constraint for such an incoming arc may expressed in the ShExC syntax by prefixing the constraint with a caret (^) and in the ShExJ syntax with "inverse": true.\nmy:IssueShape {
  ex:state [ex:unassigned ex:assigned];
 ^ex:reportedIssue @my:UserShape
}

my:UserShape {
  foaf:name LITERAL;
  foaf:mbox IRI+
}

            
            { "type": "Schema",
  "shapes": {
    "my:IssueShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "ex:state",                      
            "value": { "type": "NodeConstraint",              
              "values": [ "ex:unassigned", "ex:assigned" ]
            }                                             
          },                                              
          { "type": "TripleConstraint",                      
            "predicate": "ex:reportedIssue", "inverse": true,
            "value": "my:IssueShape"                   
          }                                                  
        ]
      }
    },
    "my:UserShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                
              "type": "NodeConstraint",   
              "datatype": "xsd:string"
            }                         
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",              
              "nodeKind": "iri"                           
            },                              
            "min": 1, "max": -1            
          }                                               
        ]
      }
    }
  }
}
            
            
            inst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned .
inst:User1 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    ex:reportedIssue inst:Issue1 ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
            inst:Issue2 a ex:Issue ;
    ex:state         ex:unassigned ;
    ex:reportedBy    inst:User2 .
inst:User2 a foaf:Person ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    foaf:mbox        <mailto:rs@example.org> .

inst:Issue3 a ex:Issue ;
    ex:state         ex:unassigned ;
    ex:reportedIssue inst:User3 .
inst:User3 a foaf:Person ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    foaf:mbox        <mailto:rs@example.org> .

inst:Issue4 a ex:Issue ;
    ex:state         ex:unassigned .
inst:User4 a foaf:Person ;
    foaf:name        "Robert" ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    ex:reportedIssue inst:Issue4 .\n[ex:unassigned ex:assigned]\nex:reportedIssue @my:UserShape\n"predicate": "ex:state"\n"value": { "type": "NodeConstraint",\n"values": [ "ex:unassigned", "ex:assigned" ]\n{ "type": "TripleConstraint",\n"predicate": "ex:reportedIssue", "inverse": true,\n"predicate": "ex:reportedIssue"\n"value": "my:IssueShape"\n"value": "my:IssueShape"\n"predicate": "foaf:name"\n"type": "NodeConstraint",\n"datatype": "xsd:string"\n"predicate": "foaf:mbox"\n"value": { "type": "NodeConstraint",\ninst:Issue1 a ex:Issue ;
    ex:state        ex:unassigned .
inst:User1 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    ex:reportedIssue inst:Issue1 ;
    foaf:mbox       <mailto:bob@example.org> ;
    foaf:mbox       <mailto:rs@example.org> .
            inst:Issue2 a ex:Issue ;
    ex:state         ex:unassigned ;
    ex:reportedBy    inst:User2 .
inst:User2 a foaf:Person ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    foaf:mbox        <mailto:rs@example.org> .

inst:Issue3 a ex:Issue ;
    ex:state         ex:unassigned ;
    ex:reportedIssue inst:User3 .
inst:User3 a foaf:Person ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    foaf:mbox        <mailto:rs@example.org> .

inst:Issue4 a ex:Issue ;
    ex:state         ex:unassigned .
inst:User4 a foaf:Person ;
    foaf:name        "Robert" ;
    foaf:name        "Bob Smith" ;
    foaf:mbox        <mailto:bob@example.org> ;
    ex:reportedIssue inst:Issue4 .\nex:state        ex:unassigned\nfoaf:name       "Bob Smith"\nex:reportedIssue inst:Issue1\nfoaf:mbox       <mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox       <mailto:rs@example.org>\n<mailto:rs@example.org>\nex:state         ex:unassigned\nex:reportedBy    inst:User2\nfoaf:name        "Bob Smith"\nfoaf:mbox        <mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox        <mailto:rs@example.org>\n<mailto:rs@example.org>\nex:state         ex:unassigned\nex:reportedIssue inst:User3\nfoaf:name        "Bob Smith"\nfoaf:mbox        <mailto:bob@example.org>\n<mailto:bob@example.org>\nfoaf:mbox        <mailto:rs@example.org>\n<mailto:rs@example.org>\nex:state         ex:unassigned\nfoaf:name        "Robert"\nfoaf:name        "Bob Smith"\nfoaf:mbox        <mailto:bob@example.org>\n<mailto:bob@example.org>\nex:reportedIssue inst:Issue4\nMissing incoming ex:reportedIssue property.\nex:reportedIssue is in the wrong direction.\nSubject of ex:reportedIssue does not match my:UserShape;\nMax cardinality of foaf:name exceeded.\n4.2 Negative Triple Constraints\nA schema may specify triples that must not appear in the data.
              For example, suppose there were a need for free-standing issues -- issues having no ex:component relationships, incoming or outgoing, with any other issues.
              This can be expressed by setting the cardinality of triple constraints on the predicate ex:component to zero, meaning that they should match zero triples in the data.
              That the shape must also not be the target of incoming triples with the predicate ex:component is expressed by prefixing the triple constraint with a caret (^).
            
  
            
              
              my:SolitaryIssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:component . {0} ;
 ^ex:component . {0}
}

              
              TODO
              
              
              inst:Issue1 a ex:Issue ;                 
    rdfs:label      "smokes too much" ;  
    ex:state        ex:unassigned .      

inst:Issue2 a ex:Issue ;                 
    dc:creator      "Alice" ;            
    ex:state        ex:unassigned ;      
    ex:component    inst:Issue3 .        
                                         
inst:Issue3 a ex:Issue ;                 
    rdfs:label      "smokes too little" ;
    ex:state        ex:unassigned .      
              
              
            
              
                NodeShapeResultReason
                inst:Issue1my:SolitaryIssueShapepass
                inst:Issue2my:SolitaryIssueShapefailExpected zero outgoing ex:component arcs.
                inst:Issue3my:SolitaryIssueShapefailExpected zero incoming ex:component arcs.\nA schema may specify triples that must not appear in the data.
              For example, suppose there were a need for free-standing issues -- issues having no ex:component relationships, incoming or outgoing, with any other issues.
              This can be expressed by setting the cardinality of triple constraints on the predicate ex:component to zero, meaning that they should match zero triples in the data.
              That the shape must also not be the target of incoming triples with the predicate ex:component is expressed by prefixing the triple constraint with a caret (^).\nmy:SolitaryIssueShape {
  ex:state [ex:unassigned ex:assigned];
  ex:component . {0} ;
 ^ex:component . {0}
}

              
              TODO
              
              
              inst:Issue1 a ex:Issue ;                 
    rdfs:label      "smokes too much" ;  
    ex:state        ex:unassigned .      

inst:Issue2 a ex:Issue ;                 
    dc:creator      "Alice" ;            
    ex:state        ex:unassigned ;      
    ex:component    inst:Issue3 .        
                                         
inst:Issue3 a ex:Issue ;                 
    rdfs:label      "smokes too little" ;
    ex:state        ex:unassigned .\nmy:SolitaryIssueShape\n[ex:unassigned ex:assigned]\ninst:Issue1 a ex:Issue ;                 
    rdfs:label      "smokes too much" ;  
    ex:state        ex:unassigned .      

inst:Issue2 a ex:Issue ;                 
    dc:creator      "Alice" ;            
    ex:state        ex:unassigned ;      
    ex:component    inst:Issue3 .        
                                         
inst:Issue3 a ex:Issue ;                 
    rdfs:label      "smokes too little" ;
    ex:state        ex:unassigned .\ninst:Issue1 a ex:Issue ;\nrdfs:label      "smokes too much" ;\nrdfs:label      "smokes too much"\nex:state        ex:unassigned .\ninst:Issue2 a ex:Issue ;\ndc:creator      "Alice" ;\ndc:creator      "Alice"\nex:state        ex:unassigned ;\nex:component    inst:Issue3 .\ninst:Issue3 a ex:Issue ;\nrdfs:label      "smokes too little" ;\nrdfs:label      "smokes too little"\nex:state        ex:unassigned .\nex:state        ex:unassigned\nmy:SolitaryIssueShape\nmy:SolitaryIssueShape\nExpected zero outgoing ex:component arcs.\nmy:SolitaryIssueShape\nExpected zero incoming ex:component arcs.\nServices backed by an RDF triple store may simply accept and store any triples not described in the schema;
            in such a case, the schema may only identify triples that the service understands and manipulates.
            At the other extreme are services or databases that accept or emit only the data structures described in a schema.
            In a ShEx schema, a shape may be defined to match only RDF data nodes that have outgoing triples matching the given set of triple constraints and no other outgoing triples.
            A shape declaration can be qualified to mean "this set of outgoing triples and no others" by using the keyword CLOSED.
          

        
          
          my:OpenUserShape {
  foaf:name xsd:string;
  foaf:mbox IRI
}

my:ClosedUserShape CLOSED {
  foaf:name xsd:string;
  foaf:mbox IRI
}

          
          { "type": "Schema",
  "shapes": [
    { "type": "Shape", "id": "my:OpenUserShape"
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                                    
              "type": "NodeConstraint",                   
              "datatype": "xsd:string"                    
            }                                             
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",          
              "nodeKind": "iri"                           
            }                                             
          }                                               
        ]
      }
    },
    { "type": "Shape", "id": "my:ClosedUserShape",
      "closed": "true",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                                    
              "type": "NodeConstraint",                   
              "datatype": "xsd:string"                    
            }                                             
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",          
              "nodeKind": "iri"                           
            }                                             
          }                                               
        ]
      }
    }
  ]
}
          
          
          inst:User1
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:rs@example.org> .

inst:User2 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:bob@example.org> .

inst:User2 foaf:knows inst:User1 .
  
          
      
       
      
        NodeShapeResultReason
        inst:User1my:OpenUserShapepass
        inst:User2my:OpenUserShapepass
        inst:User1my:ClosedUserShapepass
        inst:User2my:ClosedUserShapefailUnexpected rdf:type and foaf:knows arcs.
      
      
        The triple inst:User2  foaf:knows inst:User1 makes inst:User2 non-conformant with my:ClosedUserShape, but it does not make inst:User1 non-conformant because CLOSED applies only to outgoing arcs.\nServices backed by an RDF triple store may simply accept and store any triples not described in the schema;
            in such a case, the schema may only identify triples that the service understands and manipulates.
            At the other extreme are services or databases that accept or emit only the data structures described in a schema.
            In a ShEx schema, a shape may be defined to match only RDF data nodes that have outgoing triples matching the given set of triple constraints and no other outgoing triples.
            A shape declaration can be qualified to mean "this set of outgoing triples and no others" by using the keyword CLOSED.\nmy:OpenUserShape {
  foaf:name xsd:string;
  foaf:mbox IRI
}

my:ClosedUserShape CLOSED {
  foaf:name xsd:string;
  foaf:mbox IRI
}

          
          { "type": "Schema",
  "shapes": [
    { "type": "Shape", "id": "my:OpenUserShape"
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                                    
              "type": "NodeConstraint",                   
              "datatype": "xsd:string"                    
            }                                             
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",          
              "nodeKind": "iri"                           
            }                                             
          }                                               
        ]
      }
    },
    { "type": "Shape", "id": "my:ClosedUserShape",
      "closed": "true",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "foaf:name",                     
            "value": {                                    
              "type": "NodeConstraint",                   
              "datatype": "xsd:string"                    
            }                                             
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "foaf:mbox",                     
            "value": { "type": "NodeConstraint",          
              "nodeKind": "iri"                           
            }                                             
          }                                               
        ]
      }
    }
  ]
}
          
          
          inst:User1
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:rs@example.org> .

inst:User2 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:bob@example.org> .

inst:User2 foaf:knows inst:User1 .\n{ "type": "TripleConstraint",\n"predicate": "foaf:name",\n"predicate": "foaf:name"\n"type": "NodeConstraint",\n"type": "NodeConstraint",\n"datatype": "xsd:string"\n"datatype": "xsd:string"\n{ "type": "TripleConstraint",\n"predicate": "foaf:mbox",\n"predicate": "foaf:mbox"\n"value": { "type": "NodeConstraint",\n"value": { "type": "NodeConstraint",\n{ "type": "TripleConstraint",\n"predicate": "foaf:name",\n"predicate": "foaf:name"\n"type": "NodeConstraint",\n"type": "NodeConstraint",\n"datatype": "xsd:string"\n"datatype": "xsd:string"\n{ "type": "TripleConstraint",\n"predicate": "foaf:mbox",\n"predicate": "foaf:mbox"\n"value": { "type": "NodeConstraint",\n"value": { "type": "NodeConstraint",\ninst:User1
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:rs@example.org> .

inst:User2 a foaf:Person ;
    foaf:name       "Bob Smith" ;
    foaf:mbox       <mailto:bob@example.org> .

inst:User2 foaf:knows inst:User1 .\nfoaf:name       "Bob Smith"\nfoaf:mbox       <mailto:rs@example.org>\n<mailto:rs@example.org>\ninst:User2 a foaf:Person\n<mailto:bob@example.org>\ninst:User2 foaf:knows\nUnexpected rdf:type and foaf:knows arcs.\nThe triple inst:User2  foaf:knows inst:User1 makes inst:User2 non-conformant with my:ClosedUserShape, but it does not make inst:User1 non-conformant because CLOSED applies only to outgoing arcs.\nfoaf:knows inst:User1\n4.4 Permitting Extra Properties\nIf a shape contains a triple constraint with predicate P, the shape is said to "mention" P.  By default, for an RDF data node to match that shape, every outgoing arc from that node that uses a mentioned predicate must match a triple constraint in the shape.  This is called "closing a property". The following example asserts that every my:UserShape must have two rdf:types: ex:Employee  and foaf:Person. The example data fails validation because ex:Manager is not a permitted object.\nmy:UserShape {
  a [ex:Employee];
  a [foaf:Person]
}

          
          { "type": "Schema",
  "shapes": {
    "my:IssueShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "rdf:type",                      
            "value": { "type": "NodeConstraint",              
              "values": [ "ex:Employee" ]
            }                                             
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "ex:reportedBy",                 
            "value": { "type": "NodeConstraint",              
              "values": [ "foaf:Person" ]
            }                                             
          }                                               
        ]
      }
    }
  }
}
          
          
          inst:User4 a foaf:Person, ex:Employee, ex:Manager.\n{ "type": "TripleConstraint",\n"predicate": "rdf:type",\n"predicate": "rdf:type"\n"value": { "type": "NodeConstraint",\n"value": { "type": "NodeConstraint",\n"values": [ "ex:Employee" ]\n"values": [ "ex:Employee" ]\n{ "type": "TripleConstraint",\n"predicate": "ex:reportedBy",\n"predicate": "ex:reportedBy"\n"value": { "type": "NodeConstraint",\n"value": { "type": "NodeConstraint",\n"values": [ "foaf:Person" ]\n"values": [ "foaf:Person" ]\ninst:User4 a foaf:Person, ex:Employee, ex:Manager.\nThe shape my:UserShape can be modified to accept any number of additional arcs with the predicate rdf:type by using the keyword EXTRA followed by the permitted predicate (here: a).\nmy:UserShape EXTRA a {
  a [ex:Employee];
  a [foaf:Person]
}

          
          { "type": "Schema",
  "shapes": {
    "my:UserShape": { "type": "Shape",
      "expression": { "type": "group",
        "expressions": [
          { "type": "TripleConstraint",                   
            "predicate": "rdf:type",                      
            "value": { "type": "NodeConstraint",              
              "values": [ "ex:Employee" ]
            }                                             
          },                                              
          { "type": "TripleConstraint",                   
            "predicate": "ex:reportedBy",                 
            "value": { "type": "NodeConstraint",              
              "values": [ "foaf:Person" ]
            }                                             
          }                                               
        ]
      }
    }
  }
}
          
          
          inst:User4 a foaf:Person, ex:Employee, ex:Manager.\n{ "type": "TripleConstraint",\n"predicate": "rdf:type",\n"predicate": "rdf:type"\n"value": { "type": "NodeConstraint",\n"value": { "type": "NodeConstraint",\n"values": [ "ex:Employee" ]\n"values": [ "ex:Employee" ]\n{ "type": "TripleConstraint",\n"predicate": "ex:reportedBy",\n"predicate": "ex:reportedBy"\n"value": { "type": "NodeConstraint",\n"value": { "type": "NodeConstraint",\n"values": [ "foaf:Person" ]\n"values": [ "foaf:Person" ]\ninst:User4 a foaf:Person, ex:Employee, ex:Manager.\n4.5 Repeated Properties\nThe use of generic predicates sometimes leads to their being used multiple times in the same shape.
              In the following example, we want to make sure that an issue that is ex:accepted or ex:resolved has been reproduced both by a tester and by a programmer.
            

            
              
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ex:reproducedBy @my:TesterShape;
  ex:reproducedBy @my:ProgrammerShape
}

my:TesterShape {          
  foaf:name xsd:string;   
  ex:role [ex:testingRole]
}                         

my:ProgrammerShape {                      
  foaf:name xsd:string;                   
  ex:department [ex:ProgrammingDepartment]
}                                         

              
              {
  "my:IssueShape": { "type": "Shape",
    "expression": { "type": "group",
      "expressions": [
        { "type": "TripleConstraint", "predicate": "ex:state",
          "value": { "type": "NodeConstraint", "values": [ "ex:accepted", "ex:resolved" ] }
        },
        { "type": "TripleConstraint", "predicate": "ex:reproducedBy",
          "value": "reference": "my:TesterShape"
        },
        { "type": "TripleConstraint", "predicate": "ex:reproducedBy",
          "value": "my:ProgrammerShape"
        }
      ]
    }
  },
  "my:TesterShape": { "type": "Shape",                                     
    "expression": { "type": "group",                                       
      "expressions": [                                                     
        { "type": "TripleConstraint", "predicate": "foaf:name",            
          "value": { "type": "NodeConstraint", "datatype": "xsd:string" }      
        },                                                                 
        { "type": "TripleConstraint", "predicate": "ex:role",              
          "value": { "type": "NodeConstraint", "values": [ "ex:testingRole" ] }
        }                                                                  
      ]                                                                    
    }                                                                      
  },                                                                       
  "my:ProgrammerShape": { "type": "Shape",                                 
    "expression": { "type": "group",                                       
      "expressions": [                                                     
        { "type": "TripleConstraint", "predicate": "foaf:name",            
          "value": { "type": "NodeConstraint", "datatype": "xsd:string" }      
        },                                                                 
        { "type": "TripleConstraint", "predicate": "ex:department",        
          "value": { "type": "NodeConstraint", "values": [ "ex:Programming" ] }
        }                                                                  
      ]                                                                    
    }                                                                      
  }                                                                        
}
              
              
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Programmer3 .

inst:Tester2              
  foaf:name "Uldis" ;     
  ex:role ex:testingRole .

inst:Programmer3                          
  foaf:name "Liga" ;                      
  ex:department ex:ProgrammingDepartment .
              
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Tester4 .

inst:Tester2              
  foaf:name "Uldis" ;     
  ex:role ex:testingRole .

inst:Tester4              
  foaf:name "Liene" ;     
  ex:role ex:testingRole .\nThe use of generic predicates sometimes leads to their being used multiple times in the same shape.
              In the following example, we want to make sure that an issue that is ex:accepted or ex:resolved has been reproduced both by a tester and by a programmer.\nmy:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ex:reproducedBy @my:TesterShape;
  ex:reproducedBy @my:ProgrammerShape
}

my:TesterShape {          
  foaf:name xsd:string;   
  ex:role [ex:testingRole]
}                         

my:ProgrammerShape {                      
  foaf:name xsd:string;                   
  ex:department [ex:ProgrammingDepartment]
}                                         

              
              {
  "my:IssueShape": { "type": "Shape",
    "expression": { "type": "group",
      "expressions": [
        { "type": "TripleConstraint", "predicate": "ex:state",
          "value": { "type": "NodeConstraint", "values": [ "ex:accepted", "ex:resolved" ] }
        },
        { "type": "TripleConstraint", "predicate": "ex:reproducedBy",
          "value": "reference": "my:TesterShape"
        },
        { "type": "TripleConstraint", "predicate": "ex:reproducedBy",
          "value": "my:ProgrammerShape"
        }
      ]
    }
  },
  "my:TesterShape": { "type": "Shape",                                     
    "expression": { "type": "group",                                       
      "expressions": [                                                     
        { "type": "TripleConstraint", "predicate": "foaf:name",            
          "value": { "type": "NodeConstraint", "datatype": "xsd:string" }      
        },                                                                 
        { "type": "TripleConstraint", "predicate": "ex:role",              
          "value": { "type": "NodeConstraint", "values": [ "ex:testingRole" ] }
        }                                                                  
      ]                                                                    
    }                                                                      
  },                                                                       
  "my:ProgrammerShape": { "type": "Shape",                                 
    "expression": { "type": "group",                                       
      "expressions": [                                                     
        { "type": "TripleConstraint", "predicate": "foaf:name",            
          "value": { "type": "NodeConstraint", "datatype": "xsd:string" }      
        },                                                                 
        { "type": "TripleConstraint", "predicate": "ex:department",        
          "value": { "type": "NodeConstraint", "values": [ "ex:Programming" ] }
        }                                                                  
      ]                                                                    
    }                                                                      
  }                                                                        
}
              
              
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Programmer3 .

inst:Tester2              
  foaf:name "Uldis" ;     
  ex:role ex:testingRole .

inst:Programmer3                          
  foaf:name "Liga" ;                      
  ex:department ex:ProgrammingDepartment .
              
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Tester4 .

inst:Tester2              
  foaf:name "Uldis" ;     
  ex:role ex:testingRole .

inst:Tester4              
  foaf:name "Liene" ;     
  ex:role ex:testingRole .\n[ex:accepted ex:resolved]\nfoaf:name xsd:string;\nex:role [ex:testingRole]\nfoaf:name xsd:string;\nex:department [ex:ProgrammingDepartment]\n[ex:ProgrammingDepartment]\nProgrammingDepartment\n"predicate": "ex:state"\n"value": { "type": "NodeConstraint", "values": [ "ex:accepted", "ex:resolved" ]\n"predicate": "ex:reproducedBy"\n"value": "reference": "my:TesterShape"\n"reference": "my:TesterShape"\n"predicate": "ex:reproducedBy"\n"value": "my:ProgrammerShape"\n"my:TesterShape": { "type": "Shape",\n"expression": { "type": "group",\n{ "type": "TripleConstraint", "predicate": "foaf:name",\n"predicate": "foaf:name"\n"value": { "type": "NodeConstraint", "datatype": "xsd:string" }\n"value": { "type": "NodeConstraint", "datatype": "xsd:string" }\n{ "type": "TripleConstraint", "predicate": "ex:role",\n"predicate": "ex:role"\n"value": { "type": "NodeConstraint", "values": [ "ex:testingRole" ] }\n"value": { "type": "NodeConstraint", "values": [ "ex:testingRole" ] }\n"my:ProgrammerShape": { "type": "Shape",\n"expression": { "type": "group",\n{ "type": "TripleConstraint", "predicate": "foaf:name",\n"predicate": "foaf:name"\n"value": { "type": "NodeConstraint", "datatype": "xsd:string" }\n"value": { "type": "NodeConstraint", "datatype": "xsd:string" }\n{ "type": "TripleConstraint", "predicate": "ex:department",\n"predicate": "ex:department"\n"value": { "type": "NodeConstraint", "values": [ "ex:Programming" ] }\n"value": { "type": "NodeConstraint", "values": [ "ex:Programming" ] }\ninst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Programmer3 .

inst:Tester2              
  foaf:name "Uldis" ;     
  ex:role ex:testingRole .

inst:Programmer3                          
  foaf:name "Liga" ;                      
  ex:department ex:ProgrammingDepartment .
              
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Tester4 .

inst:Tester2              
  foaf:name "Uldis" ;     
  ex:role ex:testingRole .

inst:Tester4              
  foaf:name "Liene" ;     
  ex:role ex:testingRole .\nex:role ex:testingRole .\nex:department ex:ProgrammingDepartment .\nex:ProgrammingDepartment\nProgrammingDepartment\nex:role ex:testingRole .\nex:role ex:testingRole .\nNote that ShEx uses a partitioning strategy to find a solution whereby triples in the data are assigned to triple constraints in the schema.
              It is possible to construct schemas for which it is quite expensive to find a mapping from RDF data triple to ShEx triple constraint that satisfies the schema.
              In practical schemas, this is rarely a concern as the search space is quite small, however, certain mistakes in a schema can create a large search space.\nAccidentally duplicating many triple constraints in a shape causes the search space to explode.
                If you notice a validation process taking a long time or a lot of memory, look for duplicated chunks of the schema.\nFor shapes with multiple triple constraints for the same predicate, try to minimize the overlap between the value expressions.
                For instance, if three types of inspection are necessary on a manufacturing checklist, use three different constraints for each of the inspection proprerties rather than requiring three different inspection properties with a value expression which is a union of all three types.
                This will make the validation process more efficient and will more effectively capture the business logic in the schema.\nIssue 1
              
                There are two proposed strategies for validation:
              
              
                
                  partition - no triple can be used to satisfy more than one constraint.
                
                
                  conjunction - triples are allowed to satisfy more than one constraint.
                
              
              
                These two strategies are equivalent when no triple satisfies more than one constraint.
    In the example above, depending on the strategy being used, someone acting as both a programmer and a tester might or might not allow to satisfy the schema.
              

              
                Below are three variants of the example above.
                These each fail when evaluated by one of the strategies.
                Below each example is a workaround which works for the failing validation strategy.
              
              
                One individual acting as both tester and programmer.
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails partition, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  )
}
              
              TODO
              
              
                
                  One individual acts can be both a tester and a programmer, another is only a tester.
                
              # one tester and one combination 
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Tester2              
  foaf:name xsd:string ;  
  ex:role ex:testingRole .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
            AND NOT @my:ProgrammerShape
    ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  | ex:reproducedBy @my:ProgrammerShape
            AND NOT @my:TesterShape    
    ex:reproducedBy @my:ProgrammerShape
                AND @my:TesterShape    
  )
}
              
              TODO
              
              
                
                  Two individuals can act as both a tester and a programmer.
                
              # two combinations
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 ;
  ex:reproducedBy inst:Testgrammer45 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .

inst:Testgrammer45                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape       
                AND @my:ProgrammerShape{2}
  )
}
              

              
                The behavior in these cases currently uses the partition strategy. 
                Please send feedback to public-shex@w3.org with advice and use cases, if the conjunction strategy is better suited for your use cases.\nIssue 1
              
                There are two proposed strategies for validation:
              
              
                
                  partition - no triple can be used to satisfy more than one constraint.
                
                
                  conjunction - triples are allowed to satisfy more than one constraint.
                
              
              
                These two strategies are equivalent when no triple satisfies more than one constraint.
    In the example above, depending on the strategy being used, someone acting as both a programmer and a tester might or might not allow to satisfy the schema.
              

              
                Below are three variants of the example above.
                These each fail when evaluated by one of the strategies.
                Below each example is a workaround which works for the failing validation strategy.
              
              
                One individual acting as both tester and programmer.
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails partition, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  )
}
              
              TODO
              
              
                
                  One individual acts can be both a tester and a programmer, another is only a tester.
                
              # one tester and one combination 
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Tester2              
  foaf:name xsd:string ;  
  ex:role ex:testingRole .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
            AND NOT @my:ProgrammerShape
    ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  | ex:reproducedBy @my:ProgrammerShape
            AND NOT @my:TesterShape    
    ex:reproducedBy @my:ProgrammerShape
                AND @my:TesterShape    
  )
}
              
              TODO
              
              
                
                  Two individuals can act as both a tester and a programmer.
                
              # two combinations
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 ;
  ex:reproducedBy inst:Testgrammer45 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .

inst:Testgrammer45                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape       
                AND @my:ProgrammerShape{2}
  )
}
              

              
                The behavior in these cases currently uses the partition strategy. 
                Please send feedback to public-shex@w3.org with advice and use cases, if the conjunction strategy is better suited for your use cases.\nThere are two proposed strategies for validation:
              
              
                
                  partition - no triple can be used to satisfy more than one constraint.
                
                
                  conjunction - triples are allowed to satisfy more than one constraint.
                
              
              
                These two strategies are equivalent when no triple satisfies more than one constraint.
    In the example above, depending on the strategy being used, someone acting as both a programmer and a tester might or might not allow to satisfy the schema.
              

              
                Below are three variants of the example above.
                These each fail when evaluated by one of the strategies.
                Below each example is a workaround which works for the failing validation strategy.
              
              
                One individual acting as both tester and programmer.
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails partition, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  )
}
              
              TODO
              
              
                
                  One individual acts can be both a tester and a programmer, another is only a tester.
                
              # one tester and one combination 
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Tester2              
  foaf:name xsd:string ;  
  ex:role ex:testingRole .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
            AND NOT @my:ProgrammerShape
    ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  | ex:reproducedBy @my:ProgrammerShape
            AND NOT @my:TesterShape    
    ex:reproducedBy @my:ProgrammerShape
                AND @my:TesterShape    
  )
}
              
              TODO
              
              
                
                  Two individuals can act as both a tester and a programmer.
                
              # two combinations
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 ;
  ex:reproducedBy inst:Testgrammer45 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .

inst:Testgrammer45                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape       
                AND @my:ProgrammerShape{2}
  )
}
              

              
                The behavior in these cases currently uses the partition strategy. 
                Please send feedback to public-shex@w3.org with advice and use cases, if the conjunction strategy is better suited for your use cases.\nThere are two proposed strategies for validation:\npartition - no triple can be used to satisfy more than one constraint.\nconjunction - triples are allowed to satisfy more than one constraint.\nThese two strategies are equivalent when no triple satisfies more than one constraint.
    In the example above, depending on the strategy being used, someone acting as both a programmer and a tester might or might not allow to satisfy the schema.\nboth a programmer and a tester\nBelow are three variants of the example above.
                These each fail when evaluated by one of the strategies.
                Below each example is a workaround which works for the failing validation strategy.\nOne individual acting as both tester and programmer.
              inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails partition, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  )
}
              
              TODO\nOne individual acting as both tester and programmer.\nfoaf:name xsd:string ;\nex:role ex:testingRole ;\nex:department ex:ProgrammingDepartment .\nex:ProgrammingDepartment\nProgrammingDepartment\nfails partition, workaround is:\nex:accepted ex:resolved\n| ex:reproducedBy @my:TesterShape\nAND @my:ProgrammerShape\nAND @my:ProgrammerShape\nOne individual acts can be both a tester and a programmer, another is only a tester.
                
              # one tester and one combination 
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Tester2 ;
  ex:reproducedBy inst:Testgrammer23 .

inst:Tester2              
  foaf:name xsd:string ;  
  ex:role ex:testingRole .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape    
            AND NOT @my:ProgrammerShape
    ex:reproducedBy @my:TesterShape    
                AND @my:ProgrammerShape
  | ex:reproducedBy @my:ProgrammerShape
            AND NOT @my:TesterShape    
    ex:reproducedBy @my:ProgrammerShape
                AND @my:TesterShape    
  )
}
              
              TODO\nOne individual acts can be both a tester and a programmer, another is only a tester.\n# one tester and one combination\nfoaf:name xsd:string ;\nex:role ex:testingRole ;\nex:department ex:ProgrammingDepartment .\nex:ProgrammingDepartment\nProgrammingDepartment\nfails conjunction, workaround is:\nex:accepted ex:resolved\n| ex:reproducedBy @my:TesterShape\nAND NOT @my:ProgrammerShape\nAND NOT @my:ProgrammerShape\nex:reproducedBy @my:TesterShape\nAND @my:ProgrammerShape\nAND @my:ProgrammerShape\n| ex:reproducedBy @my:ProgrammerShape\nAND NOT @my:TesterShape\nAND NOT @my:TesterShape\nex:reproducedBy @my:ProgrammerShape\nTwo individuals can act as both a tester and a programmer.
                
              # two combinations
inst:Issue1
  ex:state ex:accepted ;
  ex:reproducedBy inst:Testgrammer23 ;
  ex:reproducedBy inst:Testgrammer45 .

inst:Testgrammer23                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .

inst:Testgrammer45                        
  foaf:name xsd:string ;                  
  ex:role ex:testingRole ;                
  ex:department ex:ProgrammingDepartment .
              fails conjunction, workaround is:
              my:IssueShape {
  ex:state [ex:accepted ex:resolved];
  ( ex:reproducedBy @my:TesterShape;
    ex:reproducedBy @my:ProgrammerShape
  | ex:reproducedBy @my:TesterShape       
                AND @my:ProgrammerShape{2}
  )
}\nTwo individuals can act as both a tester and a programmer.\nex:ProgrammingDepartment\nProgrammingDepartment\nfoaf:name xsd:string ;\nex:role ex:testingRole ;\nex:department ex:ProgrammingDepartment .\nex:ProgrammingDepartment\nProgrammingDepartment\nfails conjunction, workaround is:\nex:accepted ex:resolved\n| ex:reproducedBy @my:TesterShape\nAND @my:ProgrammerShape{2}\nAND @my:ProgrammerShape{2}\nThe behavior in these cases currently uses the partition strategy. 
                Please send feedback to public-shex@w3.org with advice and use cases, if the conjunction strategy is better suited for your use cases.\nIn good programming spirit, ShEx provides mechanisms to factor and re-use shapes or schemas.\n5.1 Reusing Triple Expressions\nWhen multiple shapes share common triple expressions, the triple expressions can be defined and labeled just once and referenced multiple times.
            In the example below, both users and employees are expected to have a foaf:name and foaf:mbox.
            my:UserShape declares my:entity (with a dollar-sign prefix) and my:EmployeeShape includes it (with an ampersand prefix).
          

          
            
            PREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

my:UserShape {
  $my:entity (
    foaf:name LITERAL ;
    foaf:mbox IRI+
  ) ;
  ex:userID LITERAL
}

my:EmployeeShape {
  &my:entity ;
  ex:employeeID LITERAL
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema", "shapes": [
    { "id": "http://my.example/#UserShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "EachOf", "expressions": [
              { "type": "TripleConstraint",
                "predicate": "http://xmlns.com/foaf/0.1/name",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "literal" } },
              { "type": "TripleConstraint", "min": 1, "max": -1,
                "predicate": "http://xmlns.com/foaf/0.1/mbox",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "iri" } }
            ],
            "id": "http://my.example/#entity"
          },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#userID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] }
    },
    { "id": "http://my.example/#EmployeeShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          "http://my.example/#entity",
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#employeeID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] } }
  ] }
              PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Employee2 foaf:name "Bob" ;
  foaf:mbox <mailto:bob@example.com> ;
  ex:employeeID "e02" .

inst:Employee3 ex:employeeID "e03" .    

inst:User1 foaf:name "Alice" ;
  foaf:mbox <mailto:alice@example.com> ;
  ex:userID "u01" .
try it: js | scala
             
          
            
              NodeShapeResultReason
              inst:Employee2my:EmployeeShapepass
              inst:Employee3my:EmployeeShapefailExpected foaf:name and foaf:mbox arcs.
              inst:User1my:UserShapepass\nWhen multiple shapes share common triple expressions, the triple expressions can be defined and labeled just once and referenced multiple times.
            In the example below, both users and employees are expected to have a foaf:name and foaf:mbox.
            my:UserShape declares my:entity (with a dollar-sign prefix) and my:EmployeeShape includes it (with an ampersand prefix).\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

my:UserShape {
  $my:entity (
    foaf:name LITERAL ;
    foaf:mbox IRI+
  ) ;
  ex:userID LITERAL
}

my:EmployeeShape {
  &my:entity ;
  ex:employeeID LITERAL
}

            
            { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema", "shapes": [
    { "id": "http://my.example/#UserShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          { "type": "EachOf", "expressions": [
              { "type": "TripleConstraint",
                "predicate": "http://xmlns.com/foaf/0.1/name",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "literal" } },
              { "type": "TripleConstraint", "min": 1, "max": -1,
                "predicate": "http://xmlns.com/foaf/0.1/mbox",
                "valueExpr": {
                  "type": "NodeConstraint",
                  "nodeKind": "iri" } }
            ],
            "id": "http://my.example/#entity"
          },
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#userID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] }
    },
    { "id": "http://my.example/#EmployeeShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          "http://my.example/#entity",
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#employeeID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] } }
  ] }
              PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Employee2 foaf:name "Bob" ;
  foaf:mbox <mailto:bob@example.com> ;
  ex:employeeID "e02" .

inst:Employee3 ex:employeeID "e03" .    

inst:User1 foaf:name "Alice" ;
  foaf:mbox <mailto:alice@example.com> ;
  ex:userID "u01" .
try it: js | scala\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\n"http://my.example/#entity"\n"http://my.example/#entity"\nPREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n<http://example.com/users/>\n<http://xmlns.com/foaf/0.1/>\n<mailto:bob@example.com>\ninst:Employee3 ex:employeeID "e03" .\n<mailto:alice@example.com>\nExpected foaf:name and foaf:mbox arcs.\n5.2 Importing schemas\nThe IMPORT directive allows the importing schema to reference shape and triple expressions in imported schemas.
          In the schema above, my:EmployeeShape references a triple expression (my:entity) in my:UserShape.
          If my:UserShape were defined in another schema, the schema containing my:EmployeeShape could import it and still reference my:UserShape and my:entity.
          In the example below, my:UserShape is defined in a schema referenced by the URL <https://shex.io/examples/import/UserSchema>.
          Relative URLs are resolved against the base URL of their containing document, which may be set by a BASE directive.
          Redunant imports are ignored which means that circular imports are not a problem.
        

        
          
          PREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
BASE <https://shex.io/examples/import/>
IMPORT <UserSchema>

<EmployeeSchema#EmployeeShape> {
  &<UserSchema#entity> ;
  ex:employeeID LITERAL
}

            
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "imports": ["https://shex.io/examples/import/UserSchema"],
  "shapes": [
    { "id": "https://shex.io/examples/import/EmployeeSchema#EmployeeShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          "https://shex.io/examples/import/UserSchema#entity",
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#employeeID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] } }
  ] }
          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Employee2 foaf:name "Bob" ;
  foaf:mbox <mailto:bob@example.com> ;
  ex:employeeID "e02" .

inst:Employee3 ex:employeeID "e03" .    

inst:User1 foaf:name "Alice" ;
  foaf:mbox <mailto:alice@example.com> ;
  ex:userID "u01" .
try it: js | scala
           
        
        
          This import above loads the schema below.
          The
          &<UserSchema#entity>
          "expressions": ["https://shex.io/examples/import/UserSchema#entity", ...]
          references the <#entity> triple expression in this schema:
        
        
          
          PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

<#UserShape> {
  &<UserSchema#entity> (
    foaf:name LITERAL ;
    foaf:mbox IRI+
  ) ;
  ex:userId LITERAL
}

            
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "imports": ["https://shex.io/examples/import/UserSchema"],
  "shapes": [
    { "id": "https://shex.io/examples/import/EmployeeSchema#EmployeeShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          "https://shex.io/examples/import/UserSchema#entity",
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#employeeID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] } }
  ] }
        
        
          The results are the same as if both documents were combined in one schema:
        
        
          NodeShapeResultReason
          inst:Employee2my:EmployeeShapepass
          inst:Employee3my:EmployeeShapefailExpected foaf:name and foaf:mbox arcs.
          inst:User1my:UserShapepass\nThe IMPORT directive allows the importing schema to reference shape and triple expressions in imported schemas.
          In the schema above, my:EmployeeShape references a triple expression (my:entity) in my:UserShape.
          If my:UserShape were defined in another schema, the schema containing my:EmployeeShape could import it and still reference my:UserShape and my:entity.
          In the example below, my:UserShape is defined in a schema referenced by the URL <https://shex.io/examples/import/UserSchema>.
          Relative URLs are resolved against the base URL of their containing document, which may be set by a BASE directive.
          Redunant imports are ignored which means that circular imports are not a problem.\n<https://shex.io/examples/import/UserSchema>\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
BASE <https://shex.io/examples/import/>
IMPORT <UserSchema>

<EmployeeSchema#EmployeeShape> {
  &<UserSchema#entity> ;
  ex:employeeID LITERAL
}

            
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "imports": ["https://shex.io/examples/import/UserSchema"],
  "shapes": [
    { "id": "https://shex.io/examples/import/EmployeeSchema#EmployeeShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          "https://shex.io/examples/import/UserSchema#entity",
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#employeeID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] } }
  ] }
          PREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

inst:Employee2 foaf:name "Bob" ;
  foaf:mbox <mailto:bob@example.com> ;
  ex:employeeID "e02" .

inst:Employee3 ex:employeeID "e03" .    

inst:User1 foaf:name "Alice" ;
  foaf:mbox <mailto:alice@example.com> ;
  ex:userID "u01" .
try it: js | scala\nPREFIX ex: <http://ex.example/#>
PREFIX my: <http://my.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n<http://my.example/#>\n<http://xmlns.com/foaf/0.1/>\n<https://shex.io/examples/import/>\n<EmployeeSchema#EmployeeShape>\n"https://shex.io/examples/import/UserSchema"\nPREFIX ex: <http://ex.example/#>
PREFIX inst: <http://example.com/users/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n<http://example.com/users/>\n<http://xmlns.com/foaf/0.1/>\n<mailto:bob@example.com>\ninst:Employee3 ex:employeeID "e03" .\n<mailto:alice@example.com>\nThis import above loads the schema below.
          The
          &<UserSchema#entity>
          "expressions": ["https://shex.io/examples/import/UserSchema#entity", ...]
          references the <#entity> triple expression in this schema:\n"expressions": ["https://shex.io/examples/import/UserSchema#entity", ...]\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

<#UserShape> {
  &<UserSchema#entity> (
    foaf:name LITERAL ;
    foaf:mbox IRI+
  ) ;
  ex:userId LITERAL
}

            
          { "@context": "http://www.w3.org/ns/shex.jsonld",
  "type": "Schema",
  "imports": ["https://shex.io/examples/import/UserSchema"],
  "shapes": [
    { "id": "https://shex.io/examples/import/EmployeeSchema#EmployeeShape",
      "type": "Shape", "expression": {
        "type": "EachOf",
        "expressions": [
          "https://shex.io/examples/import/UserSchema#entity",
          { "type": "TripleConstraint",
            "predicate": "http://ex.example/#employeeID",
            "valueExpr": {
              "type": "NodeConstraint",
              "nodeKind": "literal" } }
        ] } }
  ] }\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n<http://ex.example/#>\n<http://xmlns.com/foaf/0.1/>\n"https://shex.io/examples/import/UserSchema"\nThe results are the same as if both documents were combined in one schema:\nExpected foaf:name and foaf:mbox arcs.\n6. Relationship of ShEx to RDF and OWL\nShEx is designed to fill a long-recognized gap in Semantic Web technology.
        The Resource Description Framework language (RDF), and the more expressive Web Ontology Language (OWL), were designed for making statements about things "in the world" or, more precisely, about things in a conceptual caricature of the world.
        Things in that caricature may include anything from people, books, abstract ideas, and Web pages to planets or refrigerators.
        By design, RDF and OWL were optimized for aggregating information from multiple sources and for processing incomplete information.
        If a model in OWL says that a person has two biological parents, and only one parent is described in a given graph, an OWL processor will not report a mismatch between the model and the graph because the second parent is assumed to exist even if it is not described in the data.
        In other words, the graph could describe the second parent if more triples were supplied.
        In logic, this is called the "open world assumption".\nIn contrast, real-world data applications must often test the integrity of their data by flagging such omissions as non-conformant, and the ShEx language was designed for use in making such conformance tests.
        Where an RDF graph describes things in the caricature of the world, a ShEx schema describes things that are actually "in the data" of RDF data graphs.
        A shape expression refers to an RDF graph as a collection of abstract-syntactic entities: IRIs, blank nodes, literals, and triples, seen either as incoming arcs or outgoing arcs, with subjects, predicates, and objects.
        Inasmuch as a ShEx schema is tested against a given RDF data graph, and does not consider potential but unknown data outside of that graph, the ShEx model of conformance testing follows the "closed world assumption".
        That said, a ShEx schema can specify a "closed" interpretation, meaning that data can conform only if it includes only triples specified in the schema, or an "open" interpretation, meaning that data triples not specified in the schema are simply ignored.\nIt should be noted that a ShEx schema is valid as an RDF expression in an open-world sense.
        A ShEx schema describes something in the world, where that "something" happens to be the set of abstract-syntactic components that comprise an RDF graph.
        However, such an interpretation is of no use in practical terms.
        The utility of a ShEx schema derives from its use for testing against the abstract-syntactic components "in the data" of an RDF graph to yield a conformance test result.
        It should also be noted that a ShEx schema is not an RDF schema, even though both describe RDF data.
        For historical reasons, "RDF Schema" is the name of a language for defining RDF vocabularies and for specifying semantic relationships between terms that can be used to infer relationships between RDF resources [rdf-schema].  A ShEx schema, in contrast, defines structural constraints, analogously to relational or XML schemas.\nA. Namespaces in this Document\nhttp://www.w3.org/1999/02/22-rdf-syntax-ns#\nhttp://www.w3.org/2001/XMLSchema#\nhttp://xmlns.com/foaf/0.1/\nFriend Of A Friend vocabulary\nhttp://ex.example/ns#\nrandom application ontology\nhttp://my.example/ns#\nhttp://inst.example/ns#\nselect validator: Close
        
        js - shex.jshttp://rawgit.com/shexSpec/shex.js/extends/doc/shex-simple.html?scala - rdfshapehttp://rdfshape.weso.es/validate?triggerMode=ShapeMap&
        
        Contol click to return to this form.
      UpdateCancel\nselect validator: Close\nContol click to return to this form.\nB.1 Informative references\nhttps://www.w3.org/TR/json-ld/\nhttps://www.w3.org/TR/rdf-schema/\nhttps://www.w3.org/TR/rdf11-primer/\nShape Expressions Language 2.0\nhttp://shex.io/shex-semantics/\nhttps://www.w3.org/TR/turtle/\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\nThe ShEx Test extension is a very simple extension intended for testing ShEx extension frameworks.
        Test participates in validate and has side-effects.\nThe ShEx Test extension is a very simple extension intended for testing ShEx extension frameworks.
        Test participates in validate and has side-effects.\nThe Test extension has two functions:\nprint(msg) - emit some mesage\nfail(msg) - fail validation\nTake a sample input schema with ShEx Test directives and input data:\nPREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX test: <http://shex.io/extensions/Test/>

%test:{  %}

start = <IssueShape>

<IssueShape> {
    ex:reportedBy @<UserShape>
        %test:{ fail("some message") %},
}

<UserShape> {
    foaf:name xsd:string
        %test:{ print(o) %}
}
          
        PREFIX ex: <http://ex.example/#>
PREFIX foaf: <http://xmlns.com/foaf/>

<Issue1> ex:reportedBy <User2> .
<User2> foaf:name "Bob" .

          
        
      
        In the ShEx Demo we see a failure:
      
        <Issue1> matches <IssueShape>:PASS {
  ex:reportedBy @<UserShape> %<http://shexspec.github.io/extensions/Test/>{ fail("some message") %} matched by <Issue1> ex:reportedBy <User2> .
    PASS {
Errors:
 ☹           eval of {"some message"} rejected [[
    <http://xmlns.com/foaf/name> <http://www.w3.org/2001/XMLSchema#string> %<http://shexspec.github.io/extensions/Test/>{ print(o) %} matched by <User2> <http://xmlns.com/foaf/name> "Bob".
    ]]
Matches:
      foaf:name xsd:string %<http://shexspec.github.io/extensions/Test/>{ print(o) %} matched by <User2> foaf:name "Bob" .
    }
}No remaining triples.
      
        Examining the output (look for Popup or link in validation messages) we see:
      
      {
  "prints": [
    "Bob"
  ]
}\n<http://ex.example/#>\n<http://xmlns.com/foaf/>\n<http://www.w3.org/2001/XMLSchema#>\n<http://shex.io/extensions/Test/>\n%test:{ fail("some message") %}\nIn the ShEx Demo we see a failure:\n<Issue1> matches <IssueShape>:PASS {
  ex:reportedBy @<UserShape> %<http://shexspec.github.io/extensions/Test/>{ fail("some message") %} matched by <Issue1> ex:reportedBy <User2> .
    PASS {
Errors:
 ☹           eval of {"some message"} rejected [[
    <http://xmlns.com/foaf/name> <http://www.w3.org/2001/XMLSchema#string> %<http://shexspec.github.io/extensions/Test/>{ print(o) %} matched by <User2> <http://xmlns.com/foaf/name> "Bob".
    ]]
Matches:
      foaf:name xsd:string %<http://shexspec.github.io/extensions/Test/>{ print(o) %} matched by <User2> foaf:name "Bob" .
    }
}No remaining triples.\n<Issue1> matches <IssueShape>:\nex:reportedBy @<UserShape> %<http://shexspec.github.io/extensions/Test/>{ fail("some message") %} matched by <Issue1> ex:reportedBy <User2> .\nex:reportedBy @<UserShape> %<http://shexspec.github.io/extensions/Test/>{ fail("some message") %}\n<Issue1> ex:reportedBy <User2> .\neval of {"some message"} rejected [[
    <http://xmlns.com/foaf/name> <http://www.w3.org/2001/XMLSchema#string> %<http://shexspec.github.io/extensions/Test/>{ print(o) %} matched by <User2> <http://xmlns.com/foaf/name> "Bob".
    ]]\nfoaf:name xsd:string %<http://shexspec.github.io/extensions/Test/>{ print(o) %} matched by <User2> foaf:name "Bob" .\nfoaf:name xsd:string %<http://shexspec.github.io/extensions/Test/>{ print(o) %}\n<User2> foaf:name "Bob" .\nExamining the output (look for Popup or link in validation messages) we see:\nTest has a defined behavior when attached to a triple constraint.
        Other behaviors of Test are unspecified.
        There are two function in the Test extension:\nprint(msg) - emit some mesage\nfail(msg) - fail validation\nEach takes an argument, which is one of these four particles: s, p or o, or a literal delimited with "s and potentially containing "s and \s escaped by preceding \s.\nFor all SemActs, string literals are stripped of their delimiters, unescaped, and treated as a literal.\nFor SemActs on TripleExpressions, s, p and o correspond to the subject, predicate and object of the matching triple.\nFor SemActs on ShapeExpressions, s corresponds to focus node; the rest not defined.\nFor Start SemActs, no variable references are defined.\nTest directives can be parsed with the regular expression /^ *(fail|print) *\( *(?:("(?:[^\\"]|\\\\|\\")*")|([spo])) *\) *$/.
        The first capture group will be either "fail" or "print".
        The second will capture quoted strings, including their quotation marks.
        The third will captures the particles "s", "p", "o".\nTest is not a practical extension (apart perhaps from debugging).
            It has side effects as well as participating in validation.
            The output when there is a failure is undefined.
            Some implementations, as the example above, may include the output even if validation failed.
            For these systems, print provides a print-debugging.\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\ndirective* ((notStartAction | startActions) statement*)?baseDecl | prefixDecl | importDecl"BASE" IRIREF"PREFIX" PNAME_NS IRIREF"IMPORT" IRIREFstart | shapeExprDecl"start" '=' inlineShapeExpressioncodeDecl+directive | notStartActionshapeExprLabel (shapeExpression | "EXTERNAL")shapeOrinlineShapeOrshapeAnd ("OR" shapeAnd)*inlineShapeAnd ("OR" inlineShapeAnd)*shapeNot ("AND" shapeNot)*inlineShapeNot ("AND" inlineShapeNot)*"NOT"? shapeAtom"NOT"? inlineShapeAtomnonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint shapeOrRef?
                                | litNodeConstraint
                                | shapeDefinition nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'nonLitNodeConstraint inlineShapeOrRef?
                                | litNodeConstraint
                                | inlineShapeOrRef nonLitNodeConstraint?
                                | '(' shapeExpression ')'
                                | '.'shapeDefinition | shapeRef
inlineShapeDefinition | shapeRef
ATPNAME_LN | ATPNAME_NS | '@' shapeExprLabel"LITERAL" xsFacet*
                                | datatype xsFacet*
                                | valueSet xsFacet*
                                | numericFacet+nonLiteralKind stringFacet*
                                | stringFacet+"IRI" | "BNODE" | "NONLITERAL"stringFacet | numericFacetstringLength INTEGER
| REGEXP"LENGTH" | "MINLENGTH" | "MAXLENGTH"numericRange numericLiteral
| numericLength INTEGER"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE""TOTALDIGITS" | "FRACTIONDIGITS"(extraPropertySet | "CLOSED")* '{' tripleExpression? '}' annotation* semanticActions(extraPropertySet | "CLOSED")* '{' tripleExpression? '}'"EXTRA" predicate+oneOfTripleExprgroupTripleExpr | multiElementOneOfgroupTripleExpr ('|' groupTripleExpr)+singleElementGroup | multiElementGroupunaryTripleExpr ';'?unaryTripleExpr (';' unaryTripleExpr)+ ';'?('$' tripleExprLabel)? (tripleConstraint | bracketedTripleExpr)
| include'(' tripleExpression ')' cardinality? annotation* semanticActionssenseFlags? predicate inlineShapeExpression cardinality? annotation* semanticActions'*' | '+' | '?' | REPEAT_RANGE'^''[' valueSetValue* ']'iriRange | literalRange | languageRange
| exclusion+'.' '-' (iri | literal | LANGTAG) '~'?iri ('~' exclusion*)?'-' iri '~'?literal ('~' literalExclusion*)?'-' literal '~'?LANGTAG ('~' languageExclusion*)?
| '@' '~' languageExclusion*'-' LANGTAG '~'?'&' tripleExprLabel"//" predicate (iri | literal)codeDecl*'%' iri (CODE | '%')rdfLiteral | numericLiteral | booleanLiteraliri | RDF_TYPEiriiri | blankNodeiri | blankNodeINTEGER | DECIMAL | DOUBLElangString | string ("^^" datatype)?"true" | "false"STRING_LITERAL1 | STRING_LITERAL_LONG1
| STRING_LITERAL2 | STRING_LITERAL_LONG2LANG_STRING_LITERAL1 | LANG_STRING_LITERAL_LONG1
| LANG_STRING_LITERAL2 | LANG_STRING_LITERAL_LONG2IRIREF | prefixedNamePNAME_LN | PNAME_NSBLANK_NODE_LABEL"{" ([^%\\] | "\\" [%\\] | UCHAR)* "%" "}""{" INTEGER ( "," (INTEGER | "*")? )? "}""a""<" ([^#0000- <>\"{}|^`\\] | UCHAR)* ">"PN_PREFIX? ":"PNAME_NS PN_LOCAL"@" PNAME_NS"@" PNAME_LN'/' ([^/\\\n\r]
     | '\\' [nrt\\|.?*+(){}$-\[\]^/]
     | UCHAR
    )+ '/' [smix]*"_:" (PN_CHARS_U | [0-9]) ((PN_CHARS | ".")* PN_CHARS)?"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*[+-]? [0-9]+[+-]? [0-9]* "." [0-9]+[+-]? ([0-9]+ "." [0-9]* EXPONENT | "."? [0-9]+ EXPONENT)[eE] [+-]? [0-9]+"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'"'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"'"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''"'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""'"'" ([^'\\\n\r] | ECHAR | UCHAR)* "'" LANGTAG'"' ([^\"\\\n\r] | ECHAR | UCHAR)* '"' LANGTAG"'''" ( ("'" | "''")? ([^\\'\\] | ECHAR | UCHAR) )* "'''" LANGTAG'"""' ( ('"' | '""')? ([^\"\\] | ECHAR | UCHAR) )* '"""' LANGTAG"\\u" HEX HEX HEX HEX
| "\\U" HEX HEX HEX HEX HEX HEX HEX HEX"\\" [tbnrf\\\"\\'][A-Z] | [a-z]
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]
| [#0370-#037D] | [#037F-#1FFF]
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]
| [#10000-#EFFFF]PN_CHARS_BASE | "_"PN_CHARS_U | "-" | [0-9]
| [#00B7] | [#0300-#036F] | [#203F-#2040]PN_CHARS_BASE ( (PN_CHARS | ".")* PN_CHARS )?(PN_CHARS_U | ":" | [0-9] | PLX) (PN_CHARS | "." | ":" | PLX)* PERCENT | PN_LOCAL_ESC"%" HEX HEX[0-9] | [A-F] | [a-f]"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )[ \t\r\n]+
| "#" [^\r\n]*
| "/*" ([^*] | '*' ([^/] | '\\/'))* "*/"\n\n\n\n